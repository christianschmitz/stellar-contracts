module specializedMintDelegate

//! provides a basic version, not yet specialized,
// of the "specializedMintDelegate" interface, which simply
// exports a DelegateDatum enum and DelegateActivities (redeemer enum).  

//! these specializations MAY include additional enum variants, and 
//  ... they MUST include the same enum variants found in this
//  ... unspecialized version.   If you're specializing and you get a Helios 
//  ... compiler error, these are the first things you should check!

// The MintDelegateActivity (redeemer) enum reserves the first 10
// ... variants for use-cases inside the script, with the remaining
// ... available for authorizing application-specific use-cases.

// The mintingUuts activity

// The MintDelegateDatum enum reserves the first variant for the
// ... "IsDelegation" datum, which can contain any delegate-specific 
// ... configuration.  Its CustomConfig field is specified as a String 
// ... in the unspecialized version, but may be redefined to use different
// ... type in your specialization.  The Modifying activity may be used for
// ... applying updates to that datum, with validation of that activity
// ... provided by your specialization.

//! Your specialization MAY include any 
// ... additional functions, imports or methods

import {
     DelegationDetail,
     mustReturnValueToScript,
     tvAuthorityToken,
     unmodifiedDelegation
} from CapoDelegateHelpers

import {
    validateUutMinting,
    mkUutTnFactory
} from CapoMintHelpers

enum MintDelegateDatum {
    IsDelegation {
        dd: DelegationDetail
        // provides structural space for (non-string) configuration data.
        // the string case is degenerate (expect empty string always)
        CustomConfig: String
    }
    ScriptReference
    
    func validateCDConfig(self, updated: MintDelegateDatum::IsDelegation) -> Bool {
        self.switch {
            ddd: IsDelegation => {
                (ddd.CustomConfig == "") &&
                (updated == self)
            },
            _ => error("unreachable")
        }
    }
}

enum MintDelegateActivity {
    // Authorizing  - obsolete
    Reassigning
    Retiring
    Modifying
    _reserved3
    _reserved4
    _reserved5
    _reserved6
    _reserved7
    _reserved8
    _reserved9
    // note: all activities at index > 9 are reserved for application-specific use-cases

    // NOTE: prefer application-specific use-cases with particular minting validations,
    // ... rather than generic mintingUuts
    mintingUuts {
        seedTxn: TxId
        seedIndex: Int
        purposes: []String
    }

    //prefer application-specific use-cases with particular minting validations,
    // ... rather than generic mintingUuts
    //xxx //??? have the charter know about the UUT purposes, 
    //xxx // ... so we can limit the mint/burns to match the known list??
    //xxx burningUuts {
    // xxx    tns: []String
    //xxx }

    func usesGenericUutMinting(self) -> Bool {
        // use this error to completely disable the uutMinting activity in
        // favor of app-specific activities with more directed validations:
        //   error("no generic UUT minting in this delegate");

        self == self
        && true
    }

    // this function gives a general-purpose implementation of checking for 
    // valid uut mints. A specialization might modify it use different policies
    // or enforce additional requirements
    func genericUutMinting(self, 
        mdd: MintDelegateDatum,
        ctx: ScriptContext
    ) -> Bool {
        MintDelegateActivity::mintingUuts{sTxId, sIdx, purposes} = self;
        MintDelegateDatum::IsDelegation{dd, _} = mdd;
        returnsAuthzToken : Bool = mustReturnValueToScript(tvAuthorityToken(dd), ctx);

        assert(self.usesGenericUutMinting(), "no genericUutMinting");
        o : []TxOutput = ctx.get_cont_outputs();
        if (o.length != 1) { error("single utxo only") };


        isOk : Bool = returnsAuthzToken && 
        // A project that wants to evolve the Datum's isDelegation.CustomConfig 
        // should enforce that requirement instead of this "not modified" check.
        unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize(), ctx) &&

        // This call can serve as a template for enforcing expected mints 
        // of uuts (and additional token values) in validation of application-
        // specific activities.
        validateUutMinting(
            ctx: ctx, 
            mph: dd.mph,
            seedTxId: sTxId, 
            seedIdx: sIdx, 
            purposes: purposes,
            // additionalValues: ()
            mkTokenName: mkUutTnFactory(sTxId, sIdx)
        );

        isOk
    }

    //! used only for validating IsDelegation datum, that is,
    //   ... to approve minting requests or any customize spending modes 
    //   ... of that datum.  In this unspecialized version, 
    //   ... the "Modifying" activity is an unsupported stand-in for that use-case, always rejecting.
    //! in a real-life customization case, additional custom IsDelegation config can be
    //   ... enforced in "Modifying" event the second field of IsDelegation (the "CDConfig" stand-in here)
    //   ... the BasicMintDelegate allows for that field's presence, without any assumptions
    //   ... about its type.
    //  Note that the basic mint delegate already enforces some basic
    //    administrative expectations for Reassigning, Retiring, Modifying activites, 
    //    so a specialization doesn't need to re-implement those checks.
    func additionalDelegateValidation( self,
        priorMddd: MintDelegateDatum::IsDelegation, 
        ctx: ScriptContext
    ) -> Bool {
        // print("  ----- checking additional delegate validation");
        self.switch {
            // Authorizing => {
            //     unmodifiedDelegation(priorMddd.serialize(), ctx) && 
            //     true
            // },
            mintingUuts => self.genericUutMinting(priorMddd, ctx),
            // Modifying => false,
            // Reassigning => false,
            // Retiring => false,
            _ => false
        } || ctx.tx.serialize() != priorMddd.serialize()
    }

    //! used only for validating non-IsDelegation datum types.
    //   if you have any admininstrative data structures that inform 
    //   your minting policy, this might be useful
    func otherDatumValidation( self,
        priorMdd: MintDelegateDatum, 
        ctx: ScriptContext
    ) -> Bool {
        neverTriggered = () -> {  error("never called") };
        self.switch{
            // Authorizing => neverTriggered(),
            Reassigning => neverTriggered(),
            Retiring => neverTriggered(),
            Modifying => neverTriggered(),
            _ => false
        } && (priorMdd.serialize() != ctx.serialize())
    }
}

struct types {
    redeemers: MintDelegateActivity
    datum : MintDelegateDatum
}
