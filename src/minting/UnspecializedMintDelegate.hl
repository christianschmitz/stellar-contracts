module specializedMintDelegate

//! provides a basic version, not yet specialized,
// of the "specializedMintDelegate" interface, which simply
// exports a DelegateDatum enum and DelegateActivities (redeemer enum).  

//! Your specialization MUST include the enum variants found in this
//  ... unspecialized version.  It MAY include additional Datum variants.
// Any additional Redeemer/Activity variants should be added underneath 
// the SpendingActivity / MintingActivity top-level enum variants, instead 
// of adding new top-level enum variants to MintDelegateActivity.

// The MintDelegateActivity (redeemer) enum conforms to the 
// Delegate Redeemer protocol, in which enum 0 is reserved for
// lifecycle activities, enum 1 is used for spend-related activities 
// (if the delegate is used as a spend delegate), and enum 2 is called
// for authorizing minting.  Enum 3 and beyond are reserved for
// extensions to the Delegate Redeemer protocol.

// Within the minting and spending activities, the specialization can 
// indicate a nested activity enum to support various dApp-specific
// activities.  

// Activities that validate minting of UUTs should contain enum fields 
// to identify the seed-transaction details needed for properly validating 
// UUT mints fitting the use-case.

//! Your specialization MAY include any additional functions, imports or 
//  methods defined on any of the types in this file.


import {
    DelegationDetail,
    mustReturnValueToScript,
    tvAuthorityToken,
    DelegateLifecycleActivity,
    unmodifiedDelegation
} from CapoDelegateHelpers

import {
    validateUutMinting,
    mkUutTnFactory
} from CapoMintHelpers

import {
    capoSettings
} from CustomCapoSettings

enum MintDelegateDatum {
    IsDelegation {
        dd: DelegationDetail
    }
    ScriptReference

    func validateSettings(self, ctx: ScriptContext, settings: capoSettings) -> Bool{
        assert(false, "not valid (stubbed)");
        settings.serialize() != self.serialize() &&
        ctx.tx.serialize() != self.serialize() &&        
        true
    }

}

enum MintingActivity {
    // application can replace the placeholder, which is only here to 
    // avoid a syntax error in the unspecialized version
    _placeholder  
}

//! The minting delegate can also be used as a general spending 
// delegate (this is the default arrangement during the Capo 
// charter mint).  These activities are required by the Capo when
// spending 
enum SpendingActivity {
    // application can replace the placeholder, which is only here to 
    // avoid a syntax error in the unspecialized version
    _placeholder  
}

enum MintDelegateActivity {
    // must ALWAYS be at Enum position 0
    DelegateLifecycleActivities {
        // administrative activities for the delegate lifecycle, enforced
        //  by the basic mint delegate code.  Specializations can add more 
        //  restrictions, but in many/most cases they will not need to.
        activity: DelegateLifecycleActivity
    }

    // application-specific spending activities, ALWAYS at Enum position 1
    SpendingActivities {
        activity: SpendingActivity
    }

    // application-specific minting activities, ALWAYS at Enum position 2
    MintingActivities {
        activity: MintingActivity
    }

    // this function gives a general-purpose implementation of checking for 
    // valid uut mints. A specialization might modify it use different policies
    // or enforce additional requirements
    // func genericUutMinting(self, 
    //     mdd: MintDelegateDatum,
    //     ctx: ScriptContext
    // ) -> Bool {
    //     //!!! replace with an activity using the same seed-txn pattern:
    //     // MintDelegateActivity::mintingUuts{sTxId, sIdx, purposes} = self;
    //     MintDelegateDatum::IsDelegation{dd} = mdd;
    //     returnsAuthzToken : Bool = mustReturnValueToScript(tvAuthorityToken(dd), ctx);

    //     o : []TxOutput = ctx.get_cont_outputs();
    //     if (o.length != 1) { error("single utxo only") };

    //     print ("in unsp_MD");
    //     isOk : Bool = returnsAuthzToken && 

    //     unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize(), ctx) &&

    //     // This call can serve as a template for enforcing expected mints 
    //     // of uuts (and additional token values) in validation of application-
    //     // specific activities, given (mph, sTxId, sIdx, purposes)
    //     validateUutMinting(
    //         ctx: ctx, 
    //         mph: dd.mph,
    //         seedTxId: sTxId, 
    //         seedIdx: sIdx, 
    //         purposes: purposes,
    //         // additionalValues: ()
    //         mkTokenName: mkUutTnFactory(sTxId, sIdx)
    //     );

    //     isOk
    // }

    //! used only for validating IsDelegation datum, that is,
    //   ... to approve minting requests or any customize spending modes 
    //   ... of that datum.  
    
    //  Note that the basic mint delegate already enforces some basic
    //    administrative expectations for Reassigning, Retiring activites, 
    //    so a specialization doesn't need to re-implement those checks.
    func additionalDelegateValidation( self,
        priorMddd: MintDelegateDatum::IsDelegation, 
        ctx: ScriptContext
    ) -> Bool {
        // print("  ----- checking additional delegate validation");
        self.switch {
            // generic DelegateLifecycleActivities is already validated, but 
            //  ... you can add more constraints here if needed
            DelegateLifecycleActivities => true,

            _ => false
        } || ctx.tx.serialize() != priorMddd.serialize()
    }

    //! Used only for validating non-IsDelegation datum types and activities.
    // if you have any special admininstrative data structures that inform 
    // ...  your minting policy, this might be useful.  Otherwise, and typically,
    // ... you should look to Activity validations above in additionalDelegateValidation,
    // ...  in which the isDelegation token is being spent with an application-specific
    // ...  activity/redeemer
    func otherDatumValidation( self,
        priorMdd: MintDelegateDatum, 
        ctx: ScriptContext
    ) -> Bool {
        neverTriggered = () -> {  error("never called") };
        self.switch{
            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.
            //  Using it on any other Datum type will always fail and execution will never arrive here.
            DelegateLifecycleActivities => neverTriggered(),
            
            // ------------------- application-specific activities can be added here

            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls
        } && (priorMdd.serialize() != ctx.serialize())
    }
}

