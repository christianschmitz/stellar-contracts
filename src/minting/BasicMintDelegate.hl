spending BasicMintDelegate

const rev : Int = 1
const instance : ByteArray = #67656e6572616c

import {
    DelegationDetail,
    acAuthorityToken,
    tvAuthorityToken
} from CapoDelegateHelpers

import {
    returnsValueToScript
} from StellarHeliosHelpers

import {
    MintDelegateActivity,
    MintDelegateDatum
} from specializedMintDelegate

// import { 
//     preventCharterChange
// } from MultiSigAuthority
// func main(datum: Datum,_,ctx: ScriptContext) -> Bool {
//     preventCharterChange(ctx, datum) 
// }

func mustReturnValueToScript(value : Value, ctx : ScriptContext) -> Bool {
    if (!returnsValueToScript( value, ctx)) {
         error("the authZor token MUST be returned")
    };
    true
}

func main(mdd: MintDelegateDatum, activity: MintDelegateActivity, ctx: ScriptContext) -> Bool {
    // input = ctx.get_current_input();
    mdd.switch{
        //! performs essential checks of policy for spending the minting delegate's authority token "mintDgt-*"
        //! It also calls any additionalDelegateValidation() defined in a specialized minting delegate.
        isD : IsDelegation{dd, _} => {
            // MintDelegateDatum::IsDelegation{dd, cfg} = isD;
            activity.switch {        
                // authorizing minting of a new token or burning an existing token:
                //   guards that the authority token is returned to this script.
                // specialized minting delegates should likely perform additional checks.
                Authorizing => {
                    ok : Bool = mustReturnValueToScript(tvAuthorityToken(dd), ctx);

                    o : []TxOutput = ctx.get_cont_outputs();
                    if (o.length != 1) { error("only one utxo allowed in return to mint delegate") };

                    // Note: unspecialized delegate requires unchanged datum
                    // ... in additionalDelegateValidation.  ...like this:
                    //      unmodifiedDelegation( /*isD, same as*/ ddd.serialize(), ctx) &&

                    ok
                },
                // reassigning the authority token to a new minting delegate
                Reassigning => {
                    // the token isn't burned, and it isn't returned back to this script
                    ctx.tx.minted.get_safe( acAuthorityToken(dd) ) == 0 &&
                    !returnsValueToScript( tvAuthorityToken(dd), ctx)
                },
                // the token is being burned, retiring the authority token for this minting delegate
                // as a result, this minting delegate will no longer be consulted.  This could be combined
                // with the creation of a new minting delegate with a new authority token, registered
                // with the Capo in place of this one (or Reassigning could be used for such a case).
                // If there is no replacement minting delegate, then the Capo will not be able to perform 
                // any further minting activities.
                //
                // Retiring is not suitable for authorizing token-burning.
                Retiring => {
                    ctx.tx.minted.get(acAuthorityToken(dd)) == -1
                },
                // adjusting any configuration details for this mint delegate:
                // guards that the authority token is returned to this script, 
                // ... and calls additional validateCDConfig() defined in a specialized minting delegate.
                // specialized minting delegates can perform additional checks, but
                // ... if they only need to validate custom mint-delegate configuration, 
                // ... they can simply implement a validateCDConfig() method.
                Modifying => {
                    authorityValue : Value = tvAuthorityToken(dd);
                    ok : Bool = mustReturnValueToScript(authorityValue, ctx);
                    dlgt : TxOutput = ctx.get_cont_outputs().find(
                        (o :TxOutput) -> Bool {
                            o.value.contains(authorityValue)
                        }
                    );
                            
                    ddNew : MintDelegateDatum::IsDelegation = 
                    MintDelegateDatum::from_data( 
                        dlgt.datum.get_inline_data() 
                    );

                    mdd.validateCDConfig(ddNew) && ok
                },
                _ => true
            } && activity.additionalDelegateValidation(isD, ctx)
        },
        _ => {
            invalidRedeemer = () -> {  error("custom datum must not use Activities reserved for IsDelegation datum.") };
            activity.switch{
                Authorizing => invalidRedeemer(),
                Reassigning => invalidRedeemer(),
                Retiring => invalidRedeemer(),
                Modifying => invalidRedeemer(),
                _ => activity.otherDatumValidation(mdd, ctx)
            }
        }
    }
}
