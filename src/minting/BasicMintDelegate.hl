spending BasicMintDelegate

const rev : Int = 1
const instance : ByteArray = #67656e6572616c
const devGen : Int = 0
const isDev: Bool = false

import {
    DelegationDetail,
    acAuthorityToken,
    tvAuthorityToken,
    unmodifiedDelegation,
    mustReturnValueToScript
} from CapoDelegateHelpers

import {
    mkUutTnFactory,
    validateUutMinting,
    mintsUutForCharterUsingRedeemerIndex
} from CapoMintHelpers

import {
    returnsValueToScript,
    mkTv,
    tvCharter
} from StellarHeliosHelpers

import {
    MintDelegateActivity,
    MintDelegateDatum
} from specializedMintDelegate


// import { 
//     preventCharterChange
// } from MultiSigAuthority
// func main(datum: Datum,_,ctx: ScriptContext) -> Bool {
//     preventCharterChange(ctx, datum) 
// }



func main(mdd: MintDelegateDatum, activity: MintDelegateActivity, ctx: ScriptContext) -> Bool {
    print("hi from mint delegate");
    if (isDev) {
        print("is dev @gen " + devGen.show() )
    };

    // input = ctx.get_current_input();
    mdd.switch{
        //! performs essential checks of policy for spending the minting delegate's authority token "mintDgt-*"
        //! It also calls any additionalDelegateValidation() defined in a specialized minting delegate.
        isD : IsDelegation{dd, _} => {
            // MintDelegateDatum::IsDelegation{dd, cfg} = isD;
            activity.switch {
                // authorizing minting of a new token or burning an existing token:
                //   guards that the authority token is returned to this script.
                // specialized minting delegates should likely perform additional checks.

                // obsoleted by application-specific minting activities
                //  //  Authorizing => {
                //  //     assert(activity.usesGenericAuthorization(), "no generic authz");
                //  //     ok : Bool = mustReturnValueToScript(tvAuthorityToken(dd), ctx);

                //  //     o : []TxOutput = ctx.get_cont_outputs();
                //  //     if (o.length != 1) { error("single utxo only") };

                //  //     // Note: unspecialized delegate requires unchanged datum
                //  //     // ... in additionalDelegateValidation.  ...like this:
                //  //     //      unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize(), ctx) &&

                //  //     ok
                //  //  },

                // mintingUuts => {
                //     error("obsolete activity index 9 (was mintingUuts).  Use application-specific minting activities instead")

                //     // if (!activity.usesGenericUutMinting()) { // this may throw an error when this entire actviity is disabled by the specialization
                //     //     // if we arrive here, then the minting delegate should handle validation
                //     //     // of this activity in additionalDelegateValidation().
                //     //     true                                    
                //     // } else {
                //     //      activity.genericUutMinting(mdd, ctx)
                //     // }
                // },

                // reassigning the authority token to a new minting delegate
                ReplacingMe{seedTxId, seedIdx, purpose} => {
                    // should burn the old UUT, mint the new UUT, and update the Charter
                    // with the new mint authority

                    //xxx -   ctx.tx.minted.get_safe( acAuthorityToken(dd) ) == 0 &&
                    //xxx -   !returnsValueToScript( tvAuthorityToken(dd), ctx)

                    updatingCharter: Int = 1;
                    BURNED: Int = -1;
                    otherMintedValue: Value = Value::new(
                        AssetClass::new(dd.mph, dd.tn), 
                        BURNED
                    );

                    print("checking ReplacingMe on "+purpose+": "+dd.tn.decode_utf8());
                    mintsUutForCharterUsingRedeemerIndex(
                        ctx: ctx, 
                        mph: dd.mph,
                        purpose: purpose,
                        seedTxId: seedTxId,
                        seedIdx: seedIdx,
                        charterRedeemerIndex: updatingCharter,
                        otherMintedValue: otherMintedValue,
                        needsMintDelegateApproval: false,
                        extraMintDelegateRedeemerCheck: false
                    )
                },
                // the token is being burned, retiring the authority token for this minting delegate
                // as a result, this minting delegate will no longer be consulted.  This could be combined
                // with the creation of a new minting delegate with a new authority token, registered
                // with the Capo in place of this one (or Reassigning could be used for such a case).
                // If there is no replacement minting delegate, then the Capo will not be able to perform 
                // any further minting activities.
                //
                // Retiring is not suitable for authorizing token-burning.
                Retiring => {
                    ctx.tx.minted.get(acAuthorityToken(dd)) == -1
                },
                // adjusting any configuration details for this mint delegate:
                // guards that the authority token is returned to this script, 
                // ... and calls additional validateCDConfig() defined in a specialized minting delegate.
                // specialized minting delegates can perform additional checks, but
                // ... if they only need to validate custom mint-delegate configuration, 
                // ... they can simply implement a validateCDConfig() method.
                Modifying => {
                    authorityValue : Value = tvAuthorityToken(dd);
                    ok : Bool = mustReturnValueToScript(authorityValue, ctx);
                    dlgt : TxOutput = ctx.get_cont_outputs().find(
                        (o :TxOutput) -> Bool {
                            o.value.contains(authorityValue)
                        }
                    );
                            
                    ddNew : MintDelegateDatum::IsDelegation = 
                    MintDelegateDatum::from_data( 
                        dlgt.datum.get_inline_data() 
                    );

                    mdd.validateCDConfig(ddNew) && ok
                },
                _ => true
            } && activity.additionalDelegateValidation(isD, ctx)
        },
        _ => {
            invalidRedeemer = () -> {  error("wrong Actvy/dtm") }; ///Activity custom datum must not use Activities reserved for IsDelegation datum.") };
            activity.switch{
                // Authorizing => invalidRedeemer(),
                ReplacingMe => invalidRedeemer(),
                Retiring => invalidRedeemer(),
                Modifying => invalidRedeemer(),
                _ => activity.otherDatumValidation(mdd, ctx)
            }
        }
    }
}
