spending BasicMintDelegate

const rev : Int = 1
const instance : ByteArray = #67656e6572616c
const devGen : Int = 0
const isDev: Bool = false

import {
    DelegationDetail,
    acAuthorityToken,
    tvAuthorityToken,
    unmodifiedDelegation,
    mustReturnValueToScript
} from CapoDelegateHelpers

import {
    capoSettings
} from CustomCapoSettings

import {
    getTxCharterDatum,
    CapoDatum,
    CapoActivity
} from CapoHelpers

import {
    mkUutTnFactory,
    validateUutMinting,
    mintsUutForCharterUsingRedeemerIndex
} from CapoMintHelpers

import {
    returnsValueToScript,
    mkTv,
    outputAndDatum,
    tvCharter
} from StellarHeliosHelpers

import {
    MintDelegateActivity,
    MintDelegateDatum
} from specializedMintDelegate


// import { 
//     preventCharterChange
// } from MultiSigAuthority
// func main(datum: Datum,_,ctx: ScriptContext) -> Bool {
//     preventCharterChange(ctx, datum) 
// }



func main(mdd: MintDelegateDatum, activity: MintDelegateActivity, ctx: ScriptContext) -> Bool {
    print("hi from mint delegate");
    if (isDev) {
        print("is dev @gen " + devGen.show() )
    };

    // input = ctx.get_current_input();
    mdd.switch{
        //! performs essential checks of policy for spending the minting delegate's authority token "mintDgt-*"
        //! It also calls any additionalDelegateValidation() defined in a specialized minting delegate.
        isD : IsDelegation{dd} => {
            // MintDelegateDatum::IsDelegation{dd, cfg} = isD;
            activity.switch {
                // authorizing minting of a new token or burning an existing token:
                //   guards that the authority token is returned to this script.
                // specialized minting delegates should likely perform additional checks.

                DelegateLifecycleActivities{innerActvity} => innerActvity.switch {
                    // reassigning the authority token to a new minting delegate
                    ReplacingMe{seedTxId, seedIdx, purpose} => {
                        // should burn the old UUT, mint the new UUT, and update the Charter
                        // with the new mint authority

                        //xxx -   ctx.tx.minted.get_safe( acAuthorityToken(dd) ) == 0 &&
                        //xxx -   !returnsValueToScript( tvAuthorityToken(dd), ctx)

                        BURNED: Int = -1;
                        otherMintedValue: Value = Value::new(
                            AssetClass::new(dd.mph, dd.tn), 
                            BURNED
                        );
                    
                        print("checking ReplacingMe on "+purpose+": "+dd.tn.decode_utf8());
                        // the charter update itself will check that there's a valid delegate output for the new delegate
                        updatingCharter: Int = 1;
                        mintsUutForCharterUsingRedeemerIndex(
                            charterRedeemerIndex: updatingCharter,
                            ctx: ctx, 
                            mph: dd.mph,
                            purpose: purpose,
                            seedTxId: seedTxId,
                            seedIdx: seedIdx,
                            otherMintedValue: otherMintedValue,
                            needsMintDelegateApproval: false,
                            extraMintDelegateRedeemerCheck: false
                        )
                    },

                    // the token is being burned, retiring the authority token for this minting delegate
                    // as a result, this minting delegate will no longer be consulted.  This could be combined
                    // with the creation of a new minting delegate with a new authority token, registered
                    // with the Capo in place of this one (or Reassigning could be used for such a case).
                    // If there is no replacement minting delegate, then the Capo will not be able to perform 
                    // any further minting activities.
                    //
                    // Retiring is not suitable for authorizing token-burning.
                    Retiring => {
                        ctx.tx.minted.get(acAuthorityToken(dd)) == -1
                    },

                    ValidatingSettings => {
                        //!!! todo: verify if any cost diff between this vs direct-field-access.
                        // CapoDatum::CharterToken {
                        //     /*spendDgt*/ _,  
                        //     /* spendInvariants */ _,
                        //     settingsUut,
                        //     /* namedDelegates */ _,
                        //     /* mintDgt */ _, 
                        //     /* mintInvariants */ _, 
                        //     /* govAuthority */ _
                    // } = getTxCharterDatum(ctx, dd.mph);
                    charter : CapoDatum::CharterToken = getTxCharterDatum(ctx, dd.mph);
                    foundSettings : outputAndDatum[CapoDatum::SettingsData] = 
                        charter.mustFindSettingsOutput(ctx, dd.mph, dd.capoAddr);
                    customSettings = capoSettings::from_data(foundSettings.rawData);

                    print("MINT DELEGATE TRYING TO VALIDATE SETTINGS");
                    validated : Bool = customSettings.validate();
                     print("HURRAY");
                    validated && 
                        // isValid : Bool = 
                        //     ((isTest && throwIfBadSettings(ctx, mdd, settings)) || true) &&
                        //     mdd.validateSettings(settings, ctx);
                        // isValid
                        true
                    }
                },
                _ => true
            } && activity.additionalDelegateValidation(isD, ctx)
        },
        _ => {
            invalidRedeemer = () -> {  error("wrong Actvy/dtm") }; ///Activity custom datum must not use Activities reserved for IsDelegation datum.") };
            activity.switch{
                DelegateLifecycleActivities => invalidRedeemer(), 
                _ => activity.otherDatumValidation(mdd, ctx)
            }
        }
    }
}
