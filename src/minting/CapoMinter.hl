minting CapoMinter

import {
    tx, 
    get_current_input,
    get_current_validator_hash,
    get_current_minting_policy_hash,
    get_cont_outputs
} from ScriptContext

import { 
    hasSeedUtxo, 
    mkUutTnFactory,
    requiresMintDelegateApproval,
    validateUutMinting, 
    mintsUutForCharterUsingRedeemerIndex,
    MinterActivity
} from CapoMintHelpers

import {
    CapoDatum,
    CapoActivity,
    getRefCharterUtxo
} from CapoHelpers
import {
    DgTknDisposition as DgTkn
} from CapoDelegateHelpers

import {
    mustFindInputRedeemer,
    mkTv,
    outputAndDatum,
    tvCharter
} from StellarHeliosHelpers

const seedTxn : TxId = TxId::new(#1234)
const seedIndex : Int = 42
const rev : Int = 1

func hasContractSeedUtxo(tx: Tx) -> Bool {
    hasSeedUtxo(tx, TxOutputId::new(seedTxn, seedIndex))
}

// this is a simple example showing how a tagged struct
//   ... can be cast from a generic Map[String]Data
// struct Foo {
//     // the "meaning" field can be an Int, and this makes it "just work" as a Real.
//     m: Real "meaning"
//     // the struct can have the "happy" field, and we don't have to interpret it!
//     // h: Int "happy"
//     func info(self) ->() {
//         print(
//             // "happy? "+self.h.show()+
//             "; the answer is " + self.m.show()
//         )
//     }
// }


func main(r : MinterActivity) -> Bool {
    mph: MintingPolicyHash = get_current_minting_policy_hash();
    value_minted: Value = tx.minted;
    assert(true || (/* never evaluated */ rev.serialize() == rev.serialize()), "no");
    print(" 🚥❓ Capo minter: ");
    print( get_current_minting_policy_hash().show());
    print("\n");

    ok : Bool = r.switch {
        charter: mintingCharter => {
            charterVal : Value = mkTv(mph, "charter");

            // these must be sorted by length first, then lexicographically
            //   (actually byte-wise, but ~same diff)
            settingsTnBase: String = "set";
            authTnBase : String = "capoGov";
            mintDgtTnBase : String = "mintDgt";  
            spendDgtTnBase: String = "spendDgt";
            purposes = []String{
                settingsTnBase,
                authTnBase, 
                mintDgtTnBase, 
                spendDgtTnBase
            };

            assert(value_minted >= charterVal,
                "charter token not minted");
            print("  -- creating charter");

            hasSeed: Bool = hasContractSeedUtxo(tx);
            minterSeed: TxOutputId = TxOutputId::new(seedTxn, seedIndex);
            mkUutName: (String) -> String = mkUutTnFactory(
                minterSeed  
            );
            mintsUuts: Bool = validateUutMinting(
                mph: mph,
                seed: minterSeed,
                purposes: purposes, 
                mkTokenName: mkUutName,
                bootstrapCharter: charterVal
            );
            charterOutput: TxOutput = tx.outputs.find( (output: TxOutput) -> Bool {
                output.address == charter.owner &&
                    output.value.contains(charterVal)
            });
            // ^^ fails if there's no charter output to the right address

            // print("defaultMinter @C");
            charterData : Data = charterOutput.datum.inline;
            charterDatum = CapoDatum::CharterToken::from_data(charterData);
            CharterToken{
                spendDgt, 
                spendInvariants,
                // _settingsUut,
                namedDelegates,
                mintDgt, 
                mintInvariants, 
                authDgt
                // _typeMapUut
            } = charterDatum;
            // settings are not essential to a Capo.
            // ... some Capos could use settings, and it would be
            // ... up to its mint/spend delegate to enforce their presence.
            // Also, their verification by other delegates, in case of updating
            // the settings.  This gives settings a slightly special role,
            // but much less than the special status they had when Settings
            // were a separate datum type.

            // foundSettings : outputAndDatum[CapoDatum::SettingsData] = 
            //     charterDatum.mustFindSettingsOutput(mph: mph, inAddr: charter.owner);
            // assert(foundSettings == foundSettings, "no way");

            // once we have burned down the test backlog a bit, we can add these in:
            assert(mintInvariants.length == 0, "no mint invariants allowed at charter creation");
            assert(spendInvariants.length == 0, "no spend invariants allowed at charter creation");
            assert(namedDelegates.length ==0, "no named delegates allowed at charter creation");
            
            print("  -- checking for required delegates\n");
            hasGoodDelegates : Bool = true &&
                authDgt.hasValidOutput(mph, true, DgTkn::Created) &&
                mintDgt.hasValidOutput(mph, true, DgTkn::Created) &&
                spendDgt.hasValidOutput(mph, true, DgTkn::Created);

            print("\n  -- hasSeed: " + hasSeed.show());
            print("\n  -- mintsUuts: " + mintsUuts.show());
            print("\n  -- hasGoodDelegates: " + hasGoodDelegates.show());
            hasGoodDelegates && mintsUuts && hasSeed
        },

        // ------------------------- MOST MINTING ACTIVITIES USE THIS CODE PATH --------------------
        mintWithDelegateAuthorizing => {
            print("mintWithDelegateAuthorizing\n");
            requiresMintDelegateApproval(mph)
            // -------------------------  ^^^ deferring to the Capo's current minting delegate --------------------
        },

        addingMintInvariant{seed} => {
            addMintInvariant : Int = 3;

            // XXXXXXXXXXXXXXXXXXX should be failing
            print("checking for addingMintInvariant\n");
                                    //!todo change this one
            mintsUutForCharterUsingRedeemerIndex(
                charterRedeemerIndex: addMintInvariant,
                mph: mph, 
                purpose: "mintInvar", 
                seed: seed
            )
        },

        addingSpendInvariant{seed} => {
            addSpendInvariant : Int = 4;
            // XXXXXXXXXXXXXXXXXXX should be failing
                        //!todo change this one
                        print("checking for addingSpendInvariant\n");
            mintsUutForCharterUsingRedeemerIndex(
                charterRedeemerIndex: addSpendInvariant,
                mph: mph, 
                purpose: "spendInvar", 
                seed: seed
            )
        },

        ForcingNewMintDelegate{seed} => {
            updatingCharter : Int = 1; // general update to charter
            print("checking for ForcingNewMintDelegate\n");
                                    //!todo change this one
            mintsUutForCharterUsingRedeemerIndex(
                charterRedeemerIndex: updatingCharter,
                mph: mph, 
                purpose: "mintDgt",
                seed: seed, 
                needsMintDelegateApproval: false
            )
        },

        CreatingNewSpendDelegate{seed, replaceExisting} => {
            print("checking for CreatingNewSpendDelegate\n");

            otherMintedValue : Value = replaceExisting.switch {
                Some{oldTokenName} => {
                    BURNED: Int = -1;
                    Value::new(
                        AssetClass::new(mph, oldTokenName), 
                        BURNED
                    )
                },
                None => Value::ZERO
            };

            updatingCharter : Int = 1; // general update to charter

                        //!todo change this one
            mintsUutForCharterUsingRedeemerIndex(
                charterRedeemerIndex: updatingCharter,
                mph: mph,
                purpose: "spendDgt",
                seed: seed,
                needsMintDelegateApproval: false,
                otherMintedValue: otherMintedValue
            )
        }        
        // _ => true
    };

    // print("defaultMinter: minting value: " + value_minted.show());
    print("\n\n🚥🟢 Capo minter: ok!\n");
    // assert(false, "barfola");
    ok
}

