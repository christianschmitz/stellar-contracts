minting CapoMinter

import {
    tx, 
    get_current_input,
    get_current_validator_hash,
    get_current_minting_policy_hash,
    get_cont_outputs
} from ScriptContext

import { 
    hasSeedUtxo, 
    mkUutTnFactory,
    requiresMintDelegateApproval,
    validateUutMinting, 
    MinterActivity
} from CapoMintHelpers

import {
    CapoDatum,
    CapoActivity,
    getRefCharterUtxo,
    mkCapoCtx
} from CapoHelpers

import {
    DgTknDisposition as DgTkn
} from CapoDelegateHelpers

import {
    mustFindInputRedeemer,
    mkTv,
    outputAndDatum,
    tvCharter
} from StellarHeliosHelpers

const seedTxn : TxId = TxId::new(#1234)
const seedIndex : Int = 42
const rev : Int = 1

func hasContractSeedUtxo(tx: Tx) -> Bool {
    hasSeedUtxo(tx, TxOutputId::new(seedTxn, seedIndex))
}

func main(r : MinterActivity) -> Bool {
    mph: MintingPolicyHash = get_current_minting_policy_hash();
    value_minted: Value = tx.minted;
    assert(true || (/* never evaluated */ rev.serialize() == rev.serialize()), "no");
    print(" 🚥❓ Capo minter: ");
    print( get_current_minting_policy_hash().show());
    print("\n");

    ok : Bool = r.switch {
        charter: mintingCharter => {
            charterVal : Value = mkTv(mph, "charter");

            // these must be sorted by length first, then lexicographically
            //   (actually byte-wise, but ~same diff)
            // settingsTnBase: String = "set";
            authTnBase : String = "capoGov";
            mintDgtTnBase : String = "mintDgt";  
            spendDgtTnBase: String = "spendDgt";
            purposes = []String{
                // settingsTnBase,
                authTnBase, 
                mintDgtTnBase, 
                spendDgtTnBase
            };
            // settingsDgtTnBase: String = "settingsDgt"
            // if (charter.withSettings) purposes = purposes + []String{ settingsDgtTnBase, "settings" }

            assert(value_minted >= charterVal,
                "charter token not minted");
            print("  -- creating charter");

            hasSeed: Bool = hasContractSeedUtxo(tx);
            minterSeed: TxOutputId = TxOutputId::new(seedTxn, seedIndex);
            mkUutName: (String) -> String = mkUutTnFactory(
                minterSeed  
            );
            mintsUuts: Bool = validateUutMinting(
                mph: mph,
                seed: minterSeed,
                purposes: purposes, 
                mkTokenName: mkUutName,
                bootstrapCharter: charterVal
            );
            charterOutput: TxOutput = tx.outputs.find( (output: TxOutput) -> Bool {
                output.address == charter.owner &&
                    output.value.contains(charterVal)
            });
            // ^^ fails if there's no charter output to the right address

            // print("defaultMinter @C");
            charterData : Data = charterOutput.datum.inline;
            charterDatum = CapoDatum::CharterToken::from_data(charterData);
            CharterToken{
                spendDgt, 
                spendInvariants,
                namedDelegates,
                mintDgt, 
                mintInvariants, 
                authDgt,
                manifest,
                pendingDelegates
            } = charterDatum;
            // settings are not essential to a Capo.
            // ... some Capos could use settings, and it would be
            // ... up to its mint/spend delegate to enforce their presence.
            // Also, their verification by other delegates, in case of updating
            // the settings.  This gives settings a slightly special role,
            // but much less than the special status they had when Settings
            // were a separate datum type.

            // once we have burned down the test backlog a bit, we can add these in:
            assert(mintInvariants.length == 0, "no mint invariants allowed at charter creation");
            assert(spendInvariants.length == 0, "no spend invariants allowed at charter creation");
            assert(manifest.length == 0, "no UUTs allowed at charter creation");
            assert(pendingDelegates.length == 0, "no pending delegates allowed at charter creation");

            print("  -- checking for required delegates\n");
            hasGoodDelegates : Bool = true &&
                authDgt.hasValidOutput(mph, true, DgTkn::Created) &&
                mintDgt.hasValidOutput(mph, true, DgTkn::Created) &&
                spendDgt.hasValidOutput(mph, true, DgTkn::Created) &&
                true;

                // if (charter.withSettings) {
                //     REQT("when 'withSettings' is true, there must be a settings-policy delegate created");
                //     assert(namedDelegates.length == 1, "only settingsDgt allowed at charter creation");
                    
                //     settingsDgt = namedDelegates.get_safe("settingsPolicy").switch {
                //         None => error("missing required named delegate 'settingsPolicy'"),
                //         Some{dgt} => dgt
                //     };
                //     settingsDgt.hasValidOutput(mph, true, DgTkn::Created)

                //     REQT("with settings, there must be a settings datum stored in the Capo");
                //     cctx = mkCapoCtx(mph).nowMinting(charter.owner, charterOutput);
                //     foundSettingsOutput : TxOutput = cctx.delegatedOutputData(
                //         mkUutName(settingsTnBase)
                //     );
                
                //     // tx.outputs.find_safe( (output: TxOutput) -> Bool {
                //     //     output.address == charter.owner &&
                //     //         output.value.contains(mkTv(mph, mkUutName(settingsTnBase))
                //     // }).switch {
                //     //     None => error("missing required settings data"),
                //     //     Some{output} => output
                //     // };
                                    
                //     outputAndDatum[CapoDatum::DelegatedData] = 
                //         charterDatum.mustFindSettingsOutput(mph: mph, inAddr: charter.owner);
                //     assert(foundSettings == foundSettings, "no way");

                //     true
                // } else { 
                //     assert(namedDelegates.length == 0, "no named delegates allowed at charter creation");
                //     true
                //  };

            assert(namedDelegates.length == 0, "no named delegates allowed at charter creation");


            print("\n  -- hasSeed: " + hasSeed.show());
            print("\n  -- mintsUuts: " + mintsUuts.show());
            print("\n  -- hasGoodDelegates: " + hasGoodDelegates.show());
            hasGoodDelegates && mintsUuts && hasSeed
        },

        // ------------------------- MOST MINTING ACTIVITIES USE THIS CODE PATH --------------------
        mintWithDelegateAuthorizing => {
            print("mintWithDelegateAuthorizing\n");
            requiresMintDelegateApproval(mph)
            // -------------------------  ^^^ deferring to the Capo's current minting delegate --------------------
        },
        _ => {
            cctx = mkCapoCtx(mph).withCharterInput();
            r.switch {
                mintingCharter => error("unreachable"),
                mintWithDelegateAuthorizing => error("unreachable"),
                addingMintInvariant{_seed} => {
                    print("checking for addingMintInvariant\n");
                    assert(false, "should be handled by the mintDelegate!");
                    false
                },

                addingSpendInvariant{_seed} => {
                    print("checking for addingSpendInvariant\n");
                    assert(false, "should be handled by the mintDelegate!");
                    false
                },

                forcingNewMintDelegate{seed} => {
                    print("checking for forcingNewMintDelegate\n");
                    badCharterActivity = "when forcingNewMintDelegate, capo charter must be spent with its capoLifecycleActivity.forcingNewMintDelegate activity";
                    cctx.getCharterRedeemer().switch {
                        capoLifecycleActivity{activity} => activity.switch {
                            forcingNewMintDelegate{seedToCapo, purpose} => {
                                print("WARNING: capo lifecycle activity is forcing a new mint-delegate with its Escape-hatch activity");
                                print("NOTE: the normal lifecycle is to use minter:mintWithDelegateAuthorizing, \n"+
                                    "  ... which defers to the Capo's current minting delegate and allows \n"+
                                    "  ... queuePendingDgtChange(role: MintDgt) to queue the new mint delegate for installation"
                                );
                                assert(seed == seedToCapo, "seed mismatch:"+
                                    "\n  - Capo activity seed: "+seedToCapo.show()+
                                    "\n  - Minter seed: "+seed.show()
                                );
                                assert("mintDgt" == purpose, "wrong Capo purpose '"+purpose+"'; should be 'mintDgt'");

                                validateUutMinting(
                                    mph: mph,
                                    seed: seed,
                                    purposes: []String{purpose}
                                )
                            }, 
                            _ => error(badCharterActivity)
                            
                            // queuePendingDgtChange{capoActivitySeed, purpose, role, name} => {
                            //     assert(purpose == "mintDgt", "wrong purpose");
                            //     role.switch {
                            //         MintDgt => {
                            //             print("ok: capo lifecycle activity is adding a (pending) mint-delegate");
                            //             true
                            //         }, 
                            //         _ => error("wrong role in capo lifecycle activity")
                            //     }
                            // }
                        },
                        _ => error(badCharterActivity)
                    }
                },

                forcingNewSpendDelegate{seed, replaceExisting} => {
                    print("checking for forcingNewSpendDelegate\n");

                    otherMintedValue : Value = replaceExisting.switch {
                        Some{oldTokenName} => {
                            BURNED: Int = -1;
                            Value::new(
                                AssetClass::new(mph, oldTokenName), 
                                BURNED
                            )
                        },
                        None => Value::ZERO
                    };

                    badCharterActivity = "when forcingNewSpendDelegate, capo charter must be spent with its capoLifecycleActivity.forcingNewSpendDelegate activity";

                    cctx.getCharterRedeemer().switch {
                        capoLifecycleActivity{activity} => activity.switch {
                            forcingNewSpendDelegate{seedToCapo, purpose} => {
                                print("WARNING: capo lifecycle activity is forcing a spend-delegate with its Escape-hatch activity");
                                print("NOTE: the normal lifecycle is to use minter:mintWithDelegateAuthorizing, \n"+
                                    "  ... which defers to the Capo's current minting delegate and allows \n"+
                                    "  ... queuePendingDgtChange(role: SpendDgt) to queue the new spend delegate for installation"
                                );

                                assert(seed == seedToCapo, "seed mismatch: "
                                    + "\n  - Capo activity seed: " + seedToCapo.show()
                                    + "\n  - Minter seed: " + seed.show()
                                );
                                assert("spendDgt" == purpose, "wrong Capo purpose '"+purpose+"'; should be 'spendDgt'");

                                validateUutMinting(
                                    mph: mph,
                                    seed: seed,
                                    purposes: []String{ purpose },
                                    otherMintedValue: otherMintedValue
                                )
                            },
                            // queuePendingDgtChange{capoActivitySeed, purpose, role, name} => {
                            //     assert(!replaceExisting, "queuePendingDgtChange can't use replaceExisting option");

                            //     assert(purpose == "spendDgt", "wrong purpose");
                            //     role.switch {
                            //         SpendDgt => {
                            //             print("ok: capo lifecycle activity is adding a (pending) spend-delegate");
                            //             true
                            //         }, 
                            //         _ => error("wrong role in capo lifecycle activity")
                            //     }
                            // },
                            _ => error(badCharterActivity)
                        },
                        _ => error(
                            badCharterActivity
                        )
                    }
                }        
            }
            // _ => true // don't catch other variants, for complete coverage above.
        }
    };

    // print("defaultMinter: minting value: " + value_minted.show());
    print("\n\n🚥🟢 Capo minter: ok!\n");
    // assert(false, "barfola");
    ok
}

