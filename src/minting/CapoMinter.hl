minting CapoMinter

import { 
    hasSeedUtxo, 
    mkUutTnFactory,
    requiresMintDelegateApproval,
    validateUutMinting, 
    mintsUutForCharterUsingRedeemerIndex,
    MinterActivity
} from CapoMintHelpers

import {
    CapoDatum,
    CapoActivity,
    getRefCharterUtxo
} from CapoHelpers

import {
    mustFindInputRedeemer,
    mkTv,
    outputAndDatum,
    tvCharter
} from StellarHeliosHelpers

//!!!! todo: change to TxOutputId, rolling up these two things:
const seedTxn : TxId = TxId::new(#1234)
const seedIndex : Int = 42
const rev : Int = 1
//!!! todo propagate isDev from Capo
const isDev : Bool = false

func hasContractSeedUtxo(tx: Tx) -> Bool {
    hasSeedUtxo(tx, seedTxn, seedIndex
        // , "charter"
    )
}

// this is a simple example showing how a tagged struct
//   ... can be cast from a generic Map[String]Data
// struct Foo {
//     // the "meaning" field can be an Int, and this makes it "just work" as a Real.
//     m: Real "meaning"
//     // the struct can have the "happy" field, and we don't have to interpret it!
//     // h: Int "happy"
//     func info(self) ->() {
//         print(
//             // "happy? "+self.h.show()+
//             "; the answer is " + self.m.show()
//         )
//     }
// }


func main(r : MinterActivity, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    mph: MintingPolicyHash = ctx.get_current_minting_policy_hash();
    value_minted: Value = tx.minted;
    assert(rev.serialize() == rev.serialize(), "impossible!");
    print(" 🚥❓ Capo minter: " + ctx.get_current_minting_policy_hash().show());

    ok : Bool = r.switch {
        charter: mintingCharter => {
            charterVal : Value = mkTv(mph, "charter");

            // these must be sorted by length first, then lexicographically
            //   (actually byte-wise, but ~same diff)
            settingsTnBase: String = "set";
            authTnBase : String = "capoGov";
            mintDgtTnBase : String = "mintDgt";  
            spendDgtTnBase: String = "spendDgt";
            purposes = []String{
                settingsTnBase,
                authTnBase, 
                mintDgtTnBase, 
                spendDgtTnBase
            };

            assert(value_minted >= charterVal,
                "charter token not minted");

            hasSeed: Bool = hasContractSeedUtxo(tx);
            mkUutName: (String) -> String = mkUutTnFactory(seedTxn, seedIndex);
            print("defaultMinter @B");
            mintsUuts: Bool = validateUutMinting(
                ctx: ctx, 
                mph: mph,
                seedTxId: seedTxn, 
                seedIdx: seedIndex, 
                purposes: purposes, 
                mkTokenName: mkUutName,
                bootstrapCharter: charterVal
            );
            charterOutput: TxOutput = tx.outputs.find( (output: TxOutput) -> Bool {
                output.address == charter.owner &&
                    output.value.contains(charterVal)
            });
            // ^^ fails if there's no charter output to the right address

            print("defaultMinter @C");
            charterData : Data = charterOutput.datum.get_inline_data();
            charterDatum = CapoDatum::CharterToken::from_data(charterData);
            CapoDatum::CharterToken{
                spendDgt, 
                spendInvariants,
                /* settingsUut */ _, 
                namedDelegates,
                mintDgt, 
                mintInvariants, 
                authDgt,
                /* typeMapUut */ _
            } = charterDatum;
            foundSettings : outputAndDatum[CapoDatum::SettingsData] = 
                charterDatum.mustFindSettingsOutput(ctx: ctx, mph: mph, inAddr: charter.owner);
            assert(foundSettings == foundSettings, "no way");

                // charterData.switch{
            //         // c: Datum => c.switch{ 
            //         // c:CharterToken => c, _ => error("unexpected datum type") },
            //     (index: Int, fields: []Data) => {
            //         assert(index==0, "charter token must be at index 0");
            //         assert(fields.length == 7, "charter token must have 7 fields");
            //         // {authDgt, mintDgt, spendDgt, mintInvariants, spendInvariants}
            //         print("defaultMinter @D");
            //         settingsIndex : Int = 2;

            //         t : Data = fields.get(settingsIndex);
            //         print("ok: "+ t.serialize().show());

            //         CapoDatum::CharterToken::from_data(charterData)
            //     },
            //     _ => error("unexpected datum type")  
            // };
            // settingsValue : Value = mkTv(
            //     mph: mph, 
            //     tnBytes: settingsUut
            // );
            // assert(settingsOutput.value.contains(settingsValue), "settings output must contain settings UUT");

            print("defaultMinter @E");
            // print("" + settingsMap.tag.show());
            // settingsMap.switch {

            // };
            // print(settingsMap.show());
            // assert(settings.id == "set", "must have settings.id='set'");
            // assert(settingsMap.length == 1, "no settings fields allowed at charter creation");

            // once we have burned down the test backlog a bit, we can add these in:
            assert(mintInvariants.length == 0, "no mint invariants allowed at charter creation");
            assert(spendInvariants.length == 0, "no spend invariants allowed at charter creation");
            assert(namedDelegates.length ==0, "no named delegates allowed at charter creation");
            
            hasGoodDelegates : Bool = authDgt.hasValidOutput(mph, ctx) &&
                mintDgt.hasValidOutput(mph, ctx) &&
                spendDgt.hasValidOutput(mph, ctx);

            print("     -- hasSeed: " + hasSeed.show());
            print("     -- mintsUuts: " + mintsUuts.show());
            print("     -- hasGoodDelegates: " + hasGoodDelegates.show());
            hasGoodDelegates && mintsUuts && hasSeed
        },

        mintWithDelegateAuthorizing => {
            requiresMintDelegateApproval(ctx, mph)
        },

        addingMintInvariant{sTxId, sIdx} => {
            addMintInvariant : Int = 3;

            // XXXXXXXXXXXXXXXXXXX should be failing
            print("checking for addingMintInvariant");
                                    //!todo change this one
            mintsUutForCharterUsingRedeemerIndex(
                charterRedeemerIndex: addMintInvariant,
                ctx : ctx, 
                mph: mph, 
                purpose: "mintInvar", 
                seedTxId: sTxId, 
                seedIdx: sIdx
            )
        },

        addingSpendInvariant{sTxId, sIdx} => {
            addSpendInvariant : Int = 4;
            // XXXXXXXXXXXXXXXXXXX should be failing
                        //!todo change this one
                        print("checking for addingSpendInvariant");
            mintsUutForCharterUsingRedeemerIndex(
                charterRedeemerIndex: addSpendInvariant,
                ctx : ctx, 
                mph: mph, 
                purpose: "spendInvar", 
                seedTxId: sTxId, 
                seedIdx: sIdx 
            )
        },

        ForcingNewMintDelegate{sTxId, sIdx} => {
            updatingCharter : Int = 1; // general update to charter
            print("checking for ForcingNewMintDelegate");
                                    //!todo change this one
            mintsUutForCharterUsingRedeemerIndex(
                charterRedeemerIndex: updatingCharter,
                ctx : ctx, 
                mph: mph, 
                purpose: "mintDgt", 
                seedTxId: sTxId, 
                seedIdx: sIdx, 
                needsMintDelegateApproval: false
            )
        },

        CreatingNewSpendDelegate{seedTxId, seedIdx, replaceExisting} => {
            print("checking for CreatingNewSpendDelegate");

            otherMintedValue : Value = replaceExisting.switch {
                Some{oldTokenName} => {
                    BURNED: Int = -1;
                    Value::new(
                        AssetClass::new(mph, oldTokenName), 
                        BURNED
                    )
                },
                None => Value::ZERO
            };

            updatingCharter : Int = 1; // general update to charter

                        //!todo change this one
            mintsUutForCharterUsingRedeemerIndex(
                charterRedeemerIndex: updatingCharter,
                ctx : ctx,
                mph: mph,
                purpose: "spendDgt",
                seedTxId: seedTxId,
                seedIdx: seedIdx,
                needsMintDelegateApproval: false,
                otherMintedValue: otherMintedValue
            )
        },
        _ => true
    };

    // print("defaultMinter: minting value: " + value_minted.show());
    print("🚥🟢 Capo minter: ok!");
    ok
}

