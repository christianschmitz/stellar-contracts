minting DefaultMinter 

import { 
    hasSeedUtxo, 
    mkUutTnFactory,
    requiresMintDelegateApproval,
    validateUutMinting, 
    validateUutBurning,
    mintsUutForCharterUsingRedeemerIndex,
    MinterActivity
} from CapoMintHelpers

import { Datum } from specializedCapo

import {
    getRefCharterUtxo,
    mustFindInputRedeemer
} from CapoHelpers

import {
    mkTv,
    tvCharter
} from StellarHeliosHelpers

import {
    requiresValidDelegateOutput
} from CapoDelegateHelpers

//!!!! todo: change to TxOutputId, rolling up these two things:
const seedTxn : TxId = TxId::new(#1234)
const seedIndex : Int = 42
const rev : Int = 1

func hasContractSeedUtxo(tx: Tx) -> Bool {
    hasSeedUtxo(tx, seedTxn, seedIndex
        // , "charter"
    )
}


func main(r : MinterActivity, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    mph: MintingPolicyHash = ctx.get_current_minting_policy_hash();
    value_minted: Value = tx.minted;
    assert(rev.serialize() == rev.serialize(), "impossible!");
    print("hi from minter");

    ok : Bool = r.switch {
        charter: mintingCharter => {       
            charterVal : Value = mkTv(mph, "charter");
            authTnBase : String = "capoGov";
            mintDgtTnBase : String = "mintDgt";  
            spendDgtTnBase: String = "spendDgt";
            assert(value_minted >= charterVal,
                "charter token not minted");

            hasSeed: Bool = hasContractSeedUtxo(tx);
            print("defaultMinter @B");
            mintsUuts : Bool = validateUutMinting(
                ctx: ctx, 
                mph: mph,
                seedTxId: seedTxn, 
                seedIdx: seedIndex, 
                purposes: []String{authTnBase, mintDgtTnBase, spendDgtTnBase}, 
                mkTokenName: mkUutTnFactory(seedTxn, seedIndex),
                bootstrapCharter: charterVal
            );
            charterOutput: TxOutput = tx.outputs.find( (output: TxOutput) -> Bool {
                output.address == charter.owner &&
                    output.value.contains(charterVal)
            });
            // ^^ fails if there's no charter output to the right address

            print("defaultMinter @C");
            charterData : Data = charterOutput.datum.get_inline_data();
            Datum::CharterToken{
                spendDgt, 
                spendInvariants,
                _, // config, 
                mintDgt, 
                mintInvariants, 
                authDgt
            } = charterData.switch{
                    // c: Datum => c.switch{ 
                    // c:CharterToken => c, _ => error("unexpected datum type") },
                (index: Int, fields: []Data) => {
                    assert(index==0, "charter token must be at index 0");
                    assert(fields.length == 6, "charter token must have 6 fields");
                    // {authDgt, mintDgt, spendDgt, mintInvariants, spendInvariants}
                    print("defaultMinter @D");
                    configIndex : Int = 2;
                    t : Data = fields.get(configIndex);
                    print("ok: "+ t.serialize().show());
                    ( 
                        Datum::CharterToken::from_data(charterData), 
                        fields.get(configIndex)
                    )
                },
                _ => error("unexpected datum type")  
            };
            print("defaultMinter @E");
            print("" + configMap.tag.show());
            // configMap.switch {

            // };
            // print(configMap.show());
            // assert(config.id == "cfg", "must have config.id='cfg'");
            // assert(configMap.length == 1, "no config fields allowed at charter creation");

            // once we have burned down the test backlog a bit, we can add these in:
            assert(mintInvariants.length == 0, "no mint invariants allowed at charter creation");
            assert(spendInvariants.length == 0, "no spend invariants allowed at charter creation");

            hasGoodDelegates : Bool = requiresValidDelegateOutput(authDgt, mph, ctx) &&
                requiresValidDelegateOutput(mintDgt, mph, ctx) &&
                requiresValidDelegateOutput(spendDgt, mph, ctx);

            print("     -- hasSeed: " + hasSeed.show());
            print("     -- mintsUuts: " + mintsUuts.show());
            print("     -- hasGoodDelegates: " + hasGoodDelegates.show());
            hasGoodDelegates && mintsUuts && hasSeed
        },

        mintWithDelegateAuthorizing => {
            if (true) {
                // todo: enforces minting invariants.
                print("------- TODO: must enforce minting invariants")
            }; 
            requiresMintDelegateApproval(ctx, mph)
        },

        addingMintInvariant{sTxId, sIdx} => {
            addMintInvariant : Int = 3;
            print("checking for addingMintInvariant");

            mintsUutForCharterUsingRedeemerIndex(
                ctx : ctx, 
                mph: mph, 
                purpose: "mintInvar", 
                seedTxId: sTxId, 
                seedIdx: sIdx, 
                charterRedeemerIndex: addMintInvariant                
            )
        },

        addingSpendInvariant{sTxId, sIdx} => {
            addSpendInvariant : Int = 4;
            print("checking for addingSpendInvariant");
            mintsUutForCharterUsingRedeemerIndex(
                ctx : ctx, 
                mph: mph, 
                purpose: "spendInvar", 
                seedTxId: sTxId, 
                seedIdx: sIdx, 
                charterRedeemerIndex: addSpendInvariant
            )
        },

        ForcingNewMintDelegate{sTxId, sIdx} => {
            updateCharter : Int = 1; // general update to charter
            print("checking for ForcingNewMintDelegate");
            mintsUutForCharterUsingRedeemerIndex(
                ctx : ctx, 
                mph: mph, 
                purpose: "mintDgt", 
                seedTxId: sTxId, 
                seedIdx: sIdx, 
                charterRedeemerIndex: updateCharter,
                needsMintDelegateApproval: false
            )
        },

        CreatingNewSpendDelegate{seedTxId, seedIdx, replaceExisting} => {
            updateCharter : Int = 1; // general update to charter
            print("checking for CreatingNewSpendDelegate");

            otherMintedValue : Value = replaceExisting.switch {
                Some{oldTokenName} => {
                    BURNED: Int = -1;
                    Value::new(
                        AssetClass::new(mph, oldTokenName), 
                        BURNED
                    )
                },
                None => Value::ZERO
            };

            mintsUutForCharterUsingRedeemerIndex(
                ctx : ctx,
                mph: mph,
                purpose: "spendDgt",
                seedTxId: seedTxId,
                seedIdx: seedIdx,
                charterRedeemerIndex: updateCharter,
                needsMintDelegateApproval: false,
                otherMintedValue: otherMintedValue
            )
        },

        mintingUuts => { // {sTxId, sIdx, purposes} => {
            error("minter:mintingUuts obsolete; use minter:followingDelegate with delegate:mintingUuts or a more application-specific activity")
            // validateUutMinting(
            //     ctx: ctx, 
            //     seedTxId: sTxId, 
            //     seedIdx: sIdx, 
            //     purposes: purposes,
            //     mkTokenName: r.uutTnFactory()
            // )
        },
        burningUuts => { // {tns} => {
            error("minter:burningUuts obslete; use minter:followingDelegate with delegate:burningUuts or a more application-specific activity")
            // validateUutBurning(
            //     ctx: ctx,
            //     tns: tns
            // ) 
        },
        _ => true
    };

    // print("defaultMinter: minting value: " + value_minted.show());

    ok
}

