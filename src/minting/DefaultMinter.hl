minting DefaultMinter 

import { 
    hasSeedUtxo, 
    mkUutTnFactory,
    requiresMintDelegateApproval,
    validateUutMinting, 
    validateUutBurning,
    mintsUutForCharterUsingRedeemerIndex,
    MinterActivity
} from CapoMintHelpers

import { Datum } from specializedCapo

import {
    getRefCharterUtxo,
    mustFindInputRedeemer
} from CapoHelpers

import {
    mkTv,
    tvCharter
} from StellarHeliosHelpers

import {
    requiresValidDelegateOutput
} from CapoDelegateHelpers

//!!!! todo: change to TxOutputId, rolling up these two things:
const seedTxn : TxId = TxId::new(#1234)
const seedIndex : Int = 42
const rev : Int = 1
//!!! todo propagate isDev from Capo
const isDev : Bool = false

func hasContractSeedUtxo(tx: Tx) -> Bool {
    hasSeedUtxo(tx, seedTxn, seedIndex
        // , "charter"
    )
}

struct Foo {
    // the "meaning" field can be an Int, and this makes it "just work" as a Real.
    m: Real "meaning"
    // the struct can have the "happy" field, and we don't have to interpret it!
    // h: Int "happy"
    func info(self) ->() {
        print(
            // "happy? "+self.h.show()+
            "; the answer is " + self.m.show()
        )
    }
}


func main(r : MinterActivity, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    mph: MintingPolicyHash = ctx.get_current_minting_policy_hash();
    value_minted: Value = tx.minted;
    assert(rev.serialize() == rev.serialize(), "impossible!");
    print("hi from minter");

    ok : Bool = r.switch {
        charter: mintingCharter => {       
            charterVal : Value = mkTv(mph, "charter");

            // these must be sorted by length first, then lexicographically
            //   (actually byte-wise, but ~same diff)
            settingsTnBase: String = "set";
            authTnBase : String = "capoGov";
            mintDgtTnBase : String = "mintDgt";  
            spendDgtTnBase: String = "spendDgt";
            purposes = []String{
                settingsTnBase,
                authTnBase, 
                mintDgtTnBase, 
                spendDgtTnBase
            };

            assert(value_minted >= charterVal,
                "charter token not minted");

            hasSeed: Bool = hasContractSeedUtxo(tx);
            mkUutName: (String) -> String = mkUutTnFactory(seedTxn, seedIndex);
            print("defaultMinter @B");
            mintsUuts: Bool = validateUutMinting(
                ctx: ctx, 
                mph: mph,
                seedTxId: seedTxn, 
                seedIdx: seedIndex, 
                purposes: purposes, 
                mkTokenName: mkUutName,
                bootstrapCharter: charterVal
            );
            charterOutput: TxOutput = tx.outputs.find( (output: TxOutput) -> Bool {
                output.address == charter.owner &&
                    output.value.contains(charterVal)
            });
            // ^^ fails if there's no charter output to the right address

            settingsVal : Value = mkTv(mph, mkUutName(settingsTnBase));
            print( "finding settings output" );
            settingsOutput: TxOutput = tx.outputs.find_safe( (output: TxOutput) -> Bool {
                output.address == charter.owner &&
                    output.value.contains(settingsVal)
            }).switch {
                Some{output} => {
                    assert(settingsVal.contains(output.value.get_assets()), 
                    "excess value in settings output: "+(output.value - settingsVal).show()
                    );
                    t : Foo = Foo::from_data(
                        output.datum.get_inline_data()
                    );
                    t.info();

                    output
                },
                None => error("missing settings output to contract")
            };

            // ^^ fails if there's no settings output to the right address
            // the settings output should be empty.
            assert(settingsOutput.serialize() == settingsOutput.serialize(), "no way");
            print("settingsOutput: ");
            // print(settingsOutput.serialize().show());
            // print(settingsOutput.serialize().show());

            print("defaultMinter @C");
            charterData : Data = charterOutput.datum.get_inline_data();
            Datum::CharterToken{
                spendDgt, 
                spendInvariants,
                /* settings */ _, 
                namedDelegates,
                mintDgt, 
                mintInvariants, 
                authDgt
            } = charterData.switch{
                    // c: Datum => c.switch{ 
                    // c:CharterToken => c, _ => error("unexpected datum type") },
                (index: Int, fields: []Data) => {
                    assert(index==0, "charter token must be at index 0");
                    assert(fields.length == 7, "charter token must have 7 fields");
                    // {authDgt, mintDgt, spendDgt, mintInvariants, spendInvariants}
                    print("defaultMinter @D");
                    settingsIndex : Int = 2;

                    t : Data = fields.get(settingsIndex);
                    print("ok: "+ t.serialize().show());

                    Datum::CharterToken::from_data(charterData)
                },
                _ => error("unexpected datum type")  
            };
            print("defaultMinter @E");
            // print("" + settingsMap.tag.show());
            // settingsMap.switch {

            // };
            // print(settingsMap.show());
            // assert(settings.id == "set", "must have settings.id='set'");
            // assert(settingsMap.length == 1, "no settings fields allowed at charter creation");

            // once we have burned down the test backlog a bit, we can add these in:
            assert(mintInvariants.length == 0, "no mint invariants allowed at charter creation");
            assert(spendInvariants.length == 0, "no spend invariants allowed at charter creation");
            assert(namedDelegates.length ==0, "no named delegates allowed at charter creation");
            
            hasGoodDelegates : Bool = requiresValidDelegateOutput(authDgt, mph, ctx) &&
                requiresValidDelegateOutput(mintDgt, mph, ctx) &&
                requiresValidDelegateOutput(spendDgt, mph, ctx);

            print("     -- hasSeed: " + hasSeed.show());
            print("     -- mintsUuts: " + mintsUuts.show());
            print("     -- hasGoodDelegates: " + hasGoodDelegates.show());
            hasGoodDelegates && mintsUuts && hasSeed
        },

        mintWithDelegateAuthorizing => {
            if (true) {
                // todo: enforces minting invariants.
                print("------- TODO: must enforce minting invariants")
            }; 
            requiresMintDelegateApproval(ctx, mph)
        },

        addingMintInvariant{sTxId, sIdx} => {
            addMintInvariant : Int = 3;
            print("checking for addingMintInvariant");

            mintsUutForCharterUsingRedeemerIndex(
                ctx : ctx, 
                mph: mph, 
                purpose: "mintInvar", 
                seedTxId: sTxId, 
                seedIdx: sIdx, 
                charterRedeemerIndex: addMintInvariant                
            )
        },

        addingSpendInvariant{sTxId, sIdx} => {
            addSpendInvariant : Int = 4;
            print("checking for addingSpendInvariant");
            mintsUutForCharterUsingRedeemerIndex(
                ctx : ctx, 
                mph: mph, 
                purpose: "spendInvar", 
                seedTxId: sTxId, 
                seedIdx: sIdx, 
                charterRedeemerIndex: addSpendInvariant
            )
        },

        ForcingNewMintDelegate{sTxId, sIdx} => {
            updateCharter : Int = 1; // general update to charter
            print("checking for ForcingNewMintDelegate");
            mintsUutForCharterUsingRedeemerIndex(
                ctx : ctx, 
                mph: mph, 
                purpose: "mintDgt", 
                seedTxId: sTxId, 
                seedIdx: sIdx, 
                charterRedeemerIndex: updateCharter,
                needsMintDelegateApproval: false
            )
        },

        CreatingNewSpendDelegate{seedTxId, seedIdx, replaceExisting} => {
            updateCharter : Int = 1; // general update to charter
            print("checking for CreatingNewSpendDelegate");

            otherMintedValue : Value = replaceExisting.switch {
                Some{oldTokenName} => {
                    BURNED: Int = -1;
                    Value::new(
                        AssetClass::new(mph, oldTokenName), 
                        BURNED
                    )
                },
                None => Value::ZERO
            };

            mintsUutForCharterUsingRedeemerIndex(
                ctx : ctx,
                mph: mph,
                purpose: "spendDgt",
                seedTxId: seedTxId,
                seedIdx: seedIdx,
                charterRedeemerIndex: updateCharter,
                needsMintDelegateApproval: false,
                otherMintedValue: otherMintedValue
            )
        },

        mintingUuts => { // {sTxId, sIdx, purposes} => {
            error("minter:mintingUuts obsolete; use minter:followingDelegate with delegate:mintingUuts or a more application-specific activity")
            // validateUutMinting(
            //     ctx: ctx, 
            //     seedTxId: sTxId, 
            //     seedIdx: sIdx, 
            //     purposes: purposes,
            //     mkTokenName: r.uutTnFactory()
            // )
        },
        burningUuts => { // {tns} => {
            error("minter:burningUuts obslete; use minter:followingDelegate with delegate:burningUuts or a more application-specific activity")
            // validateUutBurning(
            //     ctx: ctx,
            //     tns: tns
            // ) 
        },
        _ => true
    };

    // print("defaultMinter: minting value: " + value_minted.show());

    ok
}

