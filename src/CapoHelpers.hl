module CapoHelpers

import {
    mkTv,
    tvCharter,
    mustFindInputRedeemer,
    outputAndDatum
} from StellarHeliosHelpers

import {
    TypeMap
} from TypeMapMetadata

import { 
    RelativeDelegateLink,
    AbstractDelegateActivitiesEnum
} from CapoDelegateHelpers

// field-names style of struct, arbitrary & extensible
// field list, can be interpreted by any script that defines a 
// field-names style of struct with its own fields & data types.
struct AnyData {
    id: String "@id"  // same as the UUT name for this data
    type: String "tpe"

    // can have other fields; receiver will interpret their target types.
}

enum CapoDatum {
    CharterToken {
        spendDelegateLink: RelativeDelegateLink
        spendInvariants: []RelativeDelegateLink
        settingsUut: ByteArray          // UUT-name links to SettingsData
        namedDelegates: Map[String]RelativeDelegateLink
        mintDelegateLink: RelativeDelegateLink
        mintInvariants: []RelativeDelegateLink
        govAuthorityLink: RelativeDelegateLink
        typeMapUut: Option[ByteArray]   // optional reference to a UUT having TypeMapInfo datum
    }
    ScriptReference
    SettingsData {
        data:  Map[String]Data
    }
    DelegatedData {  // the Capo redirects control of these to the spend delegate
        data: AnyData // the spend delegate may redirect control further, depending on what it sees in there
        //xxx delegateLink: RelativeDelegateLink  // such link info would be unnormalized
    }
    TypeMapInfo {
        typeMapInfoFlag: String // = "{{}}" 
        data: TypeMap
    }

    // this needs to be a method on the CapoDatum enum,
    // ... because it's called by other methods here, AND
    // ... it depends on the CapoDatum's own enum variants.
    func hasCharterRefInput(
        self,
        ctx: ScriptContext, 
        mph : MintingPolicyHash
    ) -> Option[CapoDatum::CharterToken] {
        assert( // avoid "unused variable self" error
            self.serialize() != ctx.serialize() &&
            self.serialize() != mph.serialize(), "never thrown"
        );
        assert(false, "unused?"); // see standalone getRefCharterDatum()
        
        chVal : Value = tvCharter(mph);
        hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };

        ctx.tx.ref_inputs.find_safe(hasCharter).switch{
            Some{txin} => Option[CapoDatum::CharterToken]::Some{
                CapoDatum::from_data( 
                    txin.datum.get_inline_data() 
                ).switch{
                    c : CharterToken => c,
                    _ => error("wrong enum")
                }
            },
            None => Option[CapoDatum::CharterToken]::None
        }
    }

    func mustFindSettingsOutput(self, ctx: ScriptContext, mph: MintingPolicyHash, inAddr: Address) -> outputAndDatum[CapoDatum::SettingsData] {
        settingsVal : Value = mkTv(mph: mph, tnBytes: self.switch {
            ct: CharterToken => ct.settingsUut,
            _ => error("mustFindSettings - only valid on CharterToken datum")
        });
        print( "finding settings output" );
        tx : Tx = ctx.tx;
        notFound = Option[outputAndDatum[CapoDatum::SettingsData]]::None;
        foundSettings: []outputAndDatum[CapoDatum::SettingsData] = 
            tx.outputs.map_option[
                outputAndDatum[CapoDatum::SettingsData]
            ](
                 (output: TxOutput) -> Option[outputAndDatum[CapoDatum::SettingsData]] {
                    print("defaultMinter finding settings output");
                    if ( output.address != inAddr ) {
                        // print("not the right address");
                        notFound
                    } else {
                        rawDatum : Data = output.datum.get_inline_data();
                        CapoDatum::from_data(
                            rawDatum
                        ).switch {
                            settings: SettingsData => {
                                print("found CapoDatum::SettingsData");
                                Option[
                                    outputAndDatum[CapoDatum::SettingsData]
                                ]::Some{
                                    outputAndDatum[CapoDatum::SettingsData] {
                                        output, settings, rawDatum
                                    }
                                }
                            },
                            _ => {
                                // print("found non-SettingsData");
                                notFound
                            }
                        }
                    }
                }
            );

        // if (isDev) { 
        assert(foundSettings.length < 2, "too many settings outputs") ;
        assert(foundSettings.length == 1, "no settings output");

        settingsOutput : TxOutput = foundSettings.head.output;
        assert(
            // already checked above.
            // settingsOutput.address == charter.owner &&
            settingsOutput.value.contains(settingsVal),
                "settings output not found in contract with expected UUT"
        );
        assert(settingsVal.contains(settingsOutput.value.get_assets()), 
            "excess value in settings output: "+(settingsOutput.value - settingsVal).show()
        );
        foundSettings.head
        // ^^ fails if there's no settings output to the right address

    }
}

enum CapoActivity {
    usingAuthority // variant 0
    updatingCharter // variant 1
    retiringRefScript // variant 2
    addingSpendInvariant // variant 3
    spendingDelegatedDatum // variant 4
    updatingSettings // variant 5
    retiringSettings // variant 6
    updatingTypeMap // variant 7
}

func getRefCharterUtxo(ctx: ScriptContext, mph : MintingPolicyHash) -> TxInput {
    chVal : Value = tvCharter(mph);
    hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };
    print("getting ref_input for charter");
    charterUtxo : TxInput = ctx.tx.ref_inputs.find_safe(hasCharter).switch{
        Some{ch} => ch,
        //!!! todo adjust this message: Missing required charter in ref_inputs
        None => error("Missing charter in required ref_inputs (use txnMustUseCharterUtxo(tcx, 'refInput') in txn builder)")
    };

    charterUtxo
}

func getRefCharterDatum(ctx: ScriptContext, mph : MintingPolicyHash) -> CapoDatum::CharterToken {
    charterUtxo : TxInput = getRefCharterUtxo(ctx, mph);
    ctd : CapoDatum::CharterToken = CapoDatum::from_data( 
        charterUtxo.datum.get_inline_data() 
    );

    ctd
}

//! retrieves a required Charter atum for the indicated policy - 
// ... either from the txn's reference inputs  or inputs.
func getTxCharterDatum(
    ctx: ScriptContext, 
    mph : MintingPolicyHash,
    refInputs : []TxInput = ctx.tx.ref_inputs
) -> CapoDatum::CharterToken {
    chVal : Value = tvCharter(mph);
    hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };

    charterUtxo : TxInput = refInputs.find_safe(hasCharter).switch{
        Some{ch} => ch,
        None => ctx.tx.inputs.find_safe(hasCharter).switch{
            Some{ch} => ch,
            None => error("Missing charter inputs / ref_inputs")
        }
    };
    ctd : CapoDatum::CharterToken = CapoDatum::CharterToken::from_data( 
        charterUtxo.datum.get_inline_data() 
    );

    ctd
}

func mustHaveGovAuthority(
    ctx: ScriptContext, 
    mph : MintingPolicyHash,
    charterDatum : CapoDatum::CharterToken = getTxCharterDatum(ctx, mph)
) -> Bool {
    charterDatum.govAuthorityLink.hasValidOutput(mph, ctx)
}

struct DelegateInput {
    link: RelativeDelegateLink
    input: TxInput
    ctx: ScriptContext
    mph: MintingPolicyHash

    func genericDelegateActivity(self) -> AbstractDelegateActivitiesEnum {
        AbstractDelegateActivitiesEnum::from_data(
            mustFindInputRedeemer(self.ctx, self.input)
        )
    }
    func requiresValidOutput(self) -> Bool {
        self.link.hasValidOutput(
            mph: self.mph, 
            ctx: self.ctx,
            required: true
          )
    }

    func getActivity[ACTIVITY](self) -> ACTIVITY {
        ACTIVITY::from_data(
            mustFindInputRedeemer(self.ctx, self.input)
        )
    }

    func getDatum[DATUM](self) -> DATUM {
        DATUM::from_data(
            self.input.datum.get_inline_data()
        )
    }
}

// func genericDelegateActivity(
//     link: RelativeDelegateLink,
//     input: TxInput
// ) -> DelegateActivity[AbstractDelegateActivitiesEnum] {
//     DelegateActivity[AbstractDelegateActivitiesEnum]::new{
//         link,
//         input,
//         // datum: Option[DATUM]::None,
//         activity: Option[AbstractDelegateActivitiesEnum]::None
//     }
// }

enum CapoCharter {
    Unk
    Ref { datum: CapoDatum::CharterToken }
    Input { 
        utxo: TxInput 
        datum: CapoDatum::CharterToken 
    }
}    

struct CapoCtx {
    ctx: ScriptContext
    mph: MintingPolicyHash
    charter: CapoCharter

    func requiresNamedDelegateInput(self, dgtName: String) -> DelegateInput {
        self.resolveCharterDatum().namedDelegates.get_safe(dgtName).switch{
            None => error("missing required delegate with name: " + dgtName),

            Some{dgtLink} => {
                self.requiresDelegateInput(dgtLink)
            }
        }
    }

    func requiresMintDelegateInput(self) -> DelegateInput {
        dgtLink : RelativeDelegateLink = self.resolveCharterDatum().mintDelegateLink;
        self.requiresDelegateInput(dgtLink)
    }

    func requiresSpendDelegateInput(self) -> DelegateInput {
        dgtLink : RelativeDelegateLink = self.resolveCharterDatum().spendDelegateLink;
        self.requiresDelegateInput(dgtLink)
    }

    // internal / low-level function
    func resolveCharterDatum(self) -> CapoDatum::CharterToken {
        self.charter.switch {
            Ref{datum} => datum,
            Input{_, datum} => datum,
            _ => error("CapoCtx.resolveCharterDatum(): unknown charter strategy; use result of withCharterInput(), withCharterRef(), or needsCharter() to resolve charter datum first")
        }
    }

    // internal / low-level function
    func requiresDelegateInput(self, dgtLink: RelativeDelegateLink) -> DelegateInput {
        dgtLink.hasDelegateInput(
            inputs: self.ctx.tx.inputs, 
            mph: self.mph,
            required: true
        ).switch {
            None => error("unreachable"),
            Some{input} => {
                DelegateInput{
                    dgtLink,
                    input,
                    self.ctx,
                    self.mph
                }
            }
        }
    }
    
    // doesn't care where the charter info comes from - refinput or input, both OK
    func needsCharter(self) -> CapoCtx {
        charter : CapoCharter = self.charter;
        charter.switch {
            Ref => self,
            Input => self,
            Unk => {
                CapoCtx{ctx, mph, _} = self;
                chVal : Value = tvCharter(mph);
                hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };

                ctx.tx.ref_inputs.find_safe(hasCharter).switch{
                    None => {
                        print("CapoCtx needsCharter(): no charter ref; must be in inputs...");

                        self.withCharterInput()
                    },
                    Some{charterUtxo} => {
                        print("CapoCtx needsCharter(): found charter ref");

                        datum : CapoDatum::CharterToken = CapoDatum::CharterToken::from_data( 
                            charterUtxo.datum.get_inline_data() 
                        );
                        CapoCtx{ctx, mph, CapoCharter::Ref{datum}}
                    }
                }
                // _ => self
            }
        }
    }

    func withCharterInput(self) -> CapoCtx {
        charter : CapoCharter = self.charter;

        charter.switch {
            Input => self,
            Ref => error("CapoCtx.withCharterInput(): charter is from ref!"),
            Unk => {
                CapoCtx{ctx, mph, _} = self;

                chVal : Value = tvCharter(mph);
                hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };
        
                print("CapoCtx finding charter in inputs");
                charterUtxo: TxInput = ctx.tx.inputs.find_safe(hasCharter).switch{
                    Some{ch} => ch,
                    None => error("Missing required charter input")
                };
                datum : CapoDatum::CharterToken = CapoDatum::CharterToken::from_data( 
                    charterUtxo.datum.get_inline_data() 
                );
                // datum : CapoDatum::CharterToken = getTxCharterDatum(self.ctx, self.mph);
                CapoCtx{ctx, mph, CapoCharter::Input{charterUtxo, datum}}
                // self.copy(charter: CapoCharter::Input{charterUtxo, datum})
            }
        }
    }

    func withCharterRef(self) -> CapoCtx {
        charter : CapoCharter = self.charter;
        charter.switch {
            Ref => self,
            Input => error("CapoCtx.withCharterRef(): charter is from inputs!"),
            Unk => {
                CapoCtx{ctx, mph, _} = self;
                datum : CapoDatum::CharterToken = getRefCharterDatum(self.ctx, self.mph);

                CapoCtx{ctx, mph, CapoCharter::Ref{datum}}

                // self.copy(charter: CapoCharter::Ref{datum})
            }
        }
    }
}

func mkCapoCtx(ctx: ScriptContext, mph: MintingPolicyHash) -> CapoCtx {
    CapoCtx{
        ctx, mph, CapoCharter::Unk
    }
}


