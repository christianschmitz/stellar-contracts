module CapoHelpers

import {
    mkTv,
    tvCharter,
    mustFindInputRedeemer,
    outputAndDatum,
    AnyData,
    REQT,
    TODO
} from StellarHeliosHelpers

import {
    TypeMap
} from TypeMapMetadata

import { 
    RelativeDelegateLink,
    AbstractDelegateActivitiesEnum
} from CapoDelegateHelpers

enum CapoDatum {
    CharterToken {
        spendDelegateLink: RelativeDelegateLink
        spendInvariants: []RelativeDelegateLink
        settingsUut: ByteArray          // UUT-name links to SettingsData
        namedDelegates: Map[String]RelativeDelegateLink
        mintDelegateLink: RelativeDelegateLink
        mintInvariants: []RelativeDelegateLink
        govAuthorityLink: RelativeDelegateLink
        typeMapUut: Option[ByteArray]   // optional reference to a UUT having TypeMapInfo datum
    }
    ScriptReference
    SettingsData {
        data:  Map[String]Data
    }
    DelegatedData {  // the Capo redirects control of these to the spend delegate
        data: AnyData // the spend delegate may redirect control further, depending on what it sees in there
        version: Int // for CIP-68 compatibility
        otherDetails: Data // abstract additional info
        //xxx delegateLink: RelativeDelegateLink  // such link info would be unnormalized
    }
    
    TypeMapInfo {
        typeMapInfoFlag: String // = "{{}}" 
        data: TypeMap
    }

    // this needs to be a method on the CapoDatum enum,
    // ... because it's called by other methods here, AND
    // ... it depends on the CapoDatum's own enum variants.
    func hasCharterRefInput(
        self,
        ctx: ScriptContext, 
        mph : MintingPolicyHash
    ) -> Option[CapoDatum::CharterToken] {
        assert( // avoid "unused variable self" error
            self.serialize() != ctx.serialize() &&
            self.serialize() != mph.serialize(), "never thrown"
        );
        assert(false, "unused?"); // see standalone getRefCharterDatum()
        
        chVal : Value = tvCharter(mph);
        hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };

        ctx.tx.ref_inputs.find_safe(hasCharter).switch{
            Some{txin} => Option[CapoDatum::CharterToken]::Some{
                CapoDatum::from_data( 
                    txin.datum.get_inline_data() 
                ).switch{
                    c : CharterToken => c,
                    _ => error("wrong enum")
                }
            },
            None => Option[CapoDatum::CharterToken]::None
        }
    }

    func mustFindSettingsOutput(self, ctx: ScriptContext, mph: MintingPolicyHash, inAddr: Address) -> outputAndDatum[CapoDatum::SettingsData] {
        settingsVal : Value = mkTv(mph: mph, tnBytes: self.switch {
            ct: CharterToken => ct.settingsUut,
            _ => error("mustFindSettings - only valid on CharterToken datum")
        });
        print( "finding settings output" );
        tx : Tx = ctx.tx;
        notFound = Option[outputAndDatum[CapoDatum::SettingsData]]::None;
        foundSettings: []outputAndDatum[CapoDatum::SettingsData] = 
            tx.outputs.map_option[
                outputAndDatum[CapoDatum::SettingsData]
            ](
                 (output: TxOutput) -> Option[outputAndDatum[CapoDatum::SettingsData]] {
                    print("defaultMinter finding settings output");
                    if ( output.address != inAddr ) {
                        // print("not the right address");
                        notFound
                    } else {
                        rawDatum : Data = output.datum.get_inline_data();
                        CapoDatum::from_data(
                            rawDatum
                        ).switch {
                            settings: SettingsData => {
                                print("found CapoDatum::SettingsData");
                                Option[
                                    outputAndDatum[CapoDatum::SettingsData]
                                ]::Some{
                                    outputAndDatum[CapoDatum::SettingsData] {
                                        output, settings, rawDatum
                                    }
                                }
                            },
                            _ => {
                                // print("found non-SettingsData");
                                notFound
                            }
                        }
                    }
                }
            );

        // if (isDev) { 
        assert(foundSettings.length < 2, "too many settings outputs") ;
        assert(foundSettings.length == 1, "no settings output");

        settingsOutput : TxOutput = foundSettings.head.output;
        assert(
            // already checked above.
            // settingsOutput.address == charter.owner &&
            settingsOutput.value.contains(settingsVal),
                "settings output not found in contract with expected UUT"
        );
        assert(settingsVal.contains(settingsOutput.value.get_assets()), 
            "excess value in settings output: "+(settingsOutput.value - settingsVal).show()
        );
        foundSettings.head
        // ^^ fails if there's no settings output to the right address

    }
}

enum CapoActivity {
    usingAuthority // variant 0
    updatingCharter // variant 1
    retiringRefScript // variant 2
    addingSpendInvariant // variant 3
    spendingDelegatedDatum // variant 4
    updatingSettings // variant 5
    retiringSettings // variant 6
    updatingTypeMap // variant 7
}

func getRefCharterUtxo(ctx: ScriptContext, mph : MintingPolicyHash) -> TxInput {
    chVal : Value = tvCharter(mph);
    hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };
    print("getting ref_input for charter");
    charterUtxo : TxInput = ctx.tx.ref_inputs.find_safe(hasCharter).switch{
        Some{ch} => ch,
        //!!! todo adjust this message: Missing required charter in ref_inputs
        None => {
            print("expected charter value" + chVal.show());
            error("Missing charter in required ref_inputs (use txnAddCharterRef(tcx) in txn builder)")
        }
    };

    charterUtxo
}

func getRefCharterDatum(ctx: ScriptContext, mph : MintingPolicyHash) -> CapoDatum::CharterToken {
    charterUtxo : TxInput = getRefCharterUtxo(ctx, mph);
    ctd : CapoDatum::CharterToken = CapoDatum::from_data( 
        charterUtxo.datum.get_inline_data() 
    );

    ctd
}

//! retrieves a required Charter atum for the indicated policy - 
// ... either from the txn's reference inputs  or inputs.
func getTxCharterDatum(
    ctx: ScriptContext, 
    mph : MintingPolicyHash,
    refInputs : []TxInput = ctx.tx.ref_inputs
) -> CapoDatum::CharterToken {
    chVal : Value = tvCharter(mph);
    hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };

    charterUtxo : TxInput = refInputs.find_safe(hasCharter).switch{
        Some{ch} => ch,
        None => ctx.tx.inputs.find_safe(hasCharter).switch{
            Some{ch} => ch,
            None => error("Missing charter inputs / ref_inputs")
        }
    };
    ctd : CapoDatum::CharterToken = CapoDatum::CharterToken::from_data( 
        charterUtxo.datum.get_inline_data() 
    );

    ctd
}

func mustHaveGovAuthority(
    ctx: ScriptContext, 
    mph : MintingPolicyHash,
    charterDatum : CapoDatum::CharterToken = getTxCharterDatum(ctx, mph)
) -> Bool {
    charterDatum.govAuthorityLink.hasValidOutput(mph, ctx)
}

struct DelegateInput {
    link: RelativeDelegateLink
    input: Option[TxInput]
    ctx: ScriptContext
    mph: MintingPolicyHash

    func genericDelegateActivity(self) -> AbstractDelegateActivitiesEnum {
        AbstractDelegateActivitiesEnum::from_data(
            mustFindInputRedeemer(self.ctx, self.input.unwrap())
        )
    }

    func withSpendingActivity(self) -> DelegateInput {
        self.genericDelegateActivity().switch {
            SpendingActivities => self,
            _ => error("dgtTkn: non-spend activity!")
        }
    }

    func withMintingActivity(self) -> DelegateInput {
        self.genericDelegateActivity().switch {
            MintingActivities => self,
            _ => error("dgtTkn: non-mint activity!")
        }
    }
    func withSeededMintingActivity(self, seedTxn : TxId, seedIdx : Int) -> DelegateInput {
        // tnFactory : (String) -> String = mkUutTnFactory(seedTxn, seedIdx);

        self.genericDelegateActivity().switch {
            MintingActivities{ma} => {
                ma.switch {
                    (index: Int, fields: []Data) => {
                        assert(index==index, "no way"); // unused field can't be _
                        assert(seedTxn == TxId::from_data(fields.get(0)), "seedTxn mismatch");
                        assert(seedIdx == Int::from_data(fields.get(1)), "seedIdx mismatch")
                    },
                    _ => error("no way")
                };
                self
            },
            MultipleDelegateActivities{activities} => {
                // can do one or more minting activities, but each one needs to be bound to a separate seed
                assert(activities.length > 0, "no minting activities found");
                foundWithThisSeed : []Data = activities.filter( (a : Data) -> Bool {
                    AbstractDelegateActivitiesEnum::from_data(a).switch {
                        MintingActivities{ma} => {
                            ma.switch {
                                (index: Int, fields: []Data) => {
                                    assert(index==index, "no way"); // unused field can't be _ in switch
                                    seedTxn == TxId::from_data(fields.head) &&
                                    seedIdx == Int::from_data(fields.get(1)) &&
                                    true
                                },
                                _ => error("no way")
                            }
                        },
                        _ => false
                    }
                });
                REQT("one of the delegate multi-activities must be minting with this seed");
                assert(foundWithThisSeed.length > 0, "no minting activity found for seed");
                REQT("only one of a multi-activity for a given seed is allowed");
                assert(foundWithThisSeed.length == 1, "multiple minting activities found for seed");
                self
            },
            _ => error("dgtTkn: non-mint activity!")
        }
    }

    func withDDSpendingActivity(self, recId: ByteArray) -> DelegateInput {
        REQT("withDDSpendingActivity: checks presence of delegated-data controller's spending activity for recId");
        strId : String = recId.decode_utf8();
        print("    -- recId: "+strId);
        self.genericDelegateActivity().switch {
            SpendingActivities{sa} => {
                sa.switch {
                    (index: Int, fields: []Data) => {
                        assert(index==index, "no way"); // unused field can't be _
                        foundRecId: ByteArray = ByteArray::from_data(fields.head);
                        print("expected: Spending:"+strId);
                        if(recId != foundRecId) {
                            print("actual: Spending:"+foundRecId.show());
                            error("recId mismatch")
                        };
                        print ("  -- ok: DD controller using spending activity")
                    },
                    _ => error("no way")
                };
                self
            },
            MultipleDelegateActivities{activities} => {
                print( "    -- multiple activities found" );
                assert(activities.length > 0, "no spending activities found");
                // can do one or more spending activities, but each one needs to be bound to a separate recId
                actsOnThisRecord : []Data = activities.filter( (a : Data) -> Bool {
                    AbstractDelegateActivitiesEnum::from_data(a).switch {
                        CreatingDelegatedData => error(
                            "dgInput: withSpendingActivity: CreatingDelegatedData invalid"
                        ),
                        UpdatingDelegatedData => error(
                            "dgInput: withSpendingActivity: UpdatingDgData invalid; use a Spending variant in the delegated-data policy"
                            // " not the delegate controller's activities (use SpendingDelegatedData for that)"
                        ),
                        DeletingDelegatedData => error(
                            "dgInput: withSpendingActivity: DeletingDelegatedData invalid" 
                            // is only valid in context of a mintDgt- when destroying a data record
                        ),
                        SpendingActivities{sa} => {
                            // assert(false && sa.serialize() == sa.serialize(), "no way");
                            // false
                            sa.switch {
                                (index: Int, fields: []Data) => {
                                    assert(index==index, "no way"); // unused field can't be _
                                    foundRecId: ByteArray = ByteArray::from_data(fields.head);
                                    print("expected: Spending: "+strId);
                                    if(recId != foundRecId) {
                                        print("actual: Spending:"+foundRecId.show());
                                        error("recId mismatch")
                                    };
                                    true
                                },
                                _ => error("wrong structure for spending activity")
                            }
                        },
                        
                        _ => false
                    }
                });
                REQT("one of the delegate data-controller multi-activities must treat this recId");
                assert(
                    (actsOnThisRecord.length > 0).trace("dgt acting on this recId? ")
                    , "no spending activity found for recId: "+strId
                );
                REQT("only one of a multi-activity for a given recId is allowed");
                assert(
                    (actsOnThisRecord.length == 1).trace("exactly one activity? ")
                    , "multiple spending activities found for recId: "+strId
                );
                self
            },
            _ => error("dgtTkn: non-spend activity!")
        }
    }


    func requiresValidOutput(self) -> Bool {
        self.link.hasValidOutput(
            mph: self.mph, 
            ctx: self.ctx,
            required: true
          )
    }

    func getActivity[ACTIVITY](self) -> ACTIVITY {
        ACTIVITY::from_data(
            mustFindInputRedeemer(self.ctx, self.input.unwrap())
        )
    }

    func getDatum[DATUM](self) -> DATUM {
        DATUM::from_data(
            self.input.unwrap().datum.get_inline_data()
        )
    }

    func delegateUnchanged(self) -> DelegateInput {
        DelegateInput{link, input, ctx, mph} = self;
        RelativeDelegateLink{
            uut,
             _ /* strategy */,
            validatorHash,
            _ /* configJson */
        } = link;
        targetValue : Value = mkTv(mph, uut);
        returnedUnchanged : Bool = validatorHash.switch {
            Some{vh} => {
                // print(" ⬅️ 🔎 💁 expect dgTkn "+uut + " sent to vh " + vh.show());
                assert(
                    ctx.tx.value_locked_by(vh)   .
                    contains(
                        targetValue
                    ), 
                    "dgTkn not returned: "+ uut
                );
                ctx.tx.outputs.find_safe((o : TxOutput) -> Bool {
                    o.datum.serialize() == input.unwrap().datum.serialize()
                }).switch {
                    Some => true, 
                    None => error("dgt modified")
                }
            },
            None => {
                error("unchOut - no vh") // this method not valid on non-contract delegate tokens
                // todo maybe make it valid by enforcing return to the input address?
            }
        };
        assert(returnedUnchanged, "no"); // already thrown
        assert(link.hasValidOutput(mph, ctx), "no"); // thrown inside the method

        self
    }
    // syntax sugar.  Implied is that that any other function calls will trip errors,
    func orFail(self) -> Bool {
        assert(true || /* never executed */ self.serialize() == self.serialize(), "no way");
        true
    }
}

// func genericDelegateActivity(
//     link: RelativeDelegateLink,
//     input: TxInput
// ) -> DelegateActivity[AbstractDelegateActivitiesEnum] {
//     DelegateActivity[AbstractDelegateActivitiesEnum]::new{
//         link,
//         input,
//         // datum: Option[DATUM]::None,
//         activity: Option[AbstractDelegateActivitiesEnum]::None
//     }
// }

enum CapoCharterInputType {
    Unk
    Ref { 
        datum: CapoDatum::CharterToken
        utxo: TxInput
    }
    Input { 
        datum: CapoDatum::CharterToken 
        utxo: TxInput 
    }
}    

enum ddDataSrc {
    Unk
    Input { utxo: TxInput }
    Output { txo: TxOutput }
    Both {
        utxo: TxInput
        txo: TxOutput
    }
}

struct DgDataDetails {
    dataSrc: ddDataSrc
    // filteredInputs: []TxInput
    id: ByteArray
    type: String
    mph: MintingPolicyHash
    // inputs: []TxInput

    // see CapoCtx::updatingDgData(id)
    func updating(id : ByteArray, input: TxInput, output : TxOutput, mph : MintingPolicyHash) -> DgDataDetails {
        DgDataDetails{
            dataSrc: ddDataSrc::Both{input, output},
            id: id,
            type: "",
            mph: mph
        }
    }
    
    // see CapoCtx::creatingDgData(id)
    func creating(id : ByteArray, output : TxOutput, mph : MintingPolicyHash
    ) -> DgDataDetails {
        DgDataDetails{
            dataSrc: ddDataSrc::Output{output},
            id: id,
            type: "",
            mph: mph
        }
    }

    func uutValue(self) -> Value {
        Value::new(
            AssetClass::new(self.mph, self.id), 
            1
        )
    }

    // func withOutput(id : ByteArray, input: []TxInput, output : TxOutput) -> DgDataDetails {
    //     DgDataDetails{
    //         dataSrc: ddDataSrc::Output{output},
    //         // filteredInputs: []TxInput{},
    //         id: id,
    //         type: ""
    //         // inputs: inputs
    //     }
    // }

    // func withInput(self) -> DgDataDetails {
    //     assert(self.id.length > 0, "no id; try cctx.updatingDgDat (id)");
    //     self.dataSrc.switch {
    //         Input => self,
    //         Both => self,
    //         _ => {
    //             oneInput: []TxInput = self.filterInputs();
    //             assert(1 == oneInput.length, "yikes! too many inputs");
    //             dataSrc : ddDataSrc = self.dataSrc.switch {
    //                 Unk => ddDataSrc::Input{oneInput.head},
    //                 Output{txo} => ddDataSrc::Both{oneInput.head, txo},
    //                 _ => error("no way") // already returned self
    //             };

    //             DgDataDetails{
    //                 dataSrc: dataSrc,
    //                    // filteredInputs: oneInput,
    //                 id: self.id,
    //                 type: self.type,
    //                 inputs: self.inputs
    //             }
    //         }
    //     }
    // }

    func input(self) -> TxInput {
        // assert(1 == self.filteredInputs.length, "use withId(id)");
        // assert(self.id.length > 0, "use withId(id) or cctx.updatingDgData(id).withInput()");

        // self.inputs.head
        self.dataSrc.switch {
            Input{utxo} => utxo,
            Both{utxo, _} => utxo,
            _ => error("no input data; use findInput() first")
        }
    }

    func output(self) -> TxOutput {
        self.dataSrc.switch {
            Output{txo} => txo,
            Both{_, txo} => txo,
            _ => error("no output data")
        }
    }

    // doesn't work - something about the way the IR is generated?
    //   - seems like it might be the list operations, 
    //   - or scoping of the fields of type []TxInput?
    //
    // func findInput(self) -> DgDataDetails {
    //     self.dataSrc.switch {
    //         Input => self,
    //         Both => self,
    //         _ => {
    //             targetId : ByteArray = self.id;
    //             isEmpty : Bool = targetId.length == 0;
    //             print("finding input dgData id: "+self.id.decode_utf8());
    //             utxo: TxInput = self.inputs.find_safe( (txin : TxInput) -> Bool {
    //                 rec : AnyData = AnyData::from_data(
    //                     txin.datum.get_inline_data()
    //                 );
    //                 rec.type.starts_with(self.type)
    //                 && (isEmpty || rec.id == targetId)
    //             }).switch {
    //                 Some{x} => x,
    //                 None => error("❌ no input dgData")
    //             };
    //             newSrc: ddDataSrc = self.dataSrc.switch {
    //                 Output{txo} => ddDataSrc::Both{utxo, txo},
    //                 Unk => ddDataSrc::Input{utxo},
    //                 _ => error("no way") // unreachable
    //             };

    //             DgDataDetails{
    //                 dataSrc: newSrc,
    //                 // filteredInputs: [utxo],
    //                 id: self.id,
    //                 type: self.type,
    //                 inputs: self.inputs
    //             }
    //         }
    //     }
    // }


    // func filterInputs(self) -> []TxInput {
    //     self.inputs
    //     // targetId : ByteArray = self.id;
    //     // isEmpty : Bool = targetId.length == 0;
    //     // self.inputs.filter( (txin : TxInput) -> Bool {
    //     //     rec : AnyData = AnyData::from_data(
    //     //         txin.datum.get_inline_data()
    //     //     );

    //     //     rec.type.starts_with(self.type)
    //     //     && (isEmpty || rec.id == targetId)
    //     // })
    // }

    // func withFilteredInputs(self) -> DgDataDetails {
    //     //!!! causes IR assertion error
    //     // if (self.filteredInputs.is_empty()) {
    //     // if (self.filteredInputs.length == 0) {
    //     if(true) {
    //             self
    //         // DgDataDetails {
    //         //     dataSrc: self.dataSrc,
    //         //     filteredInputs: self.filterInputs(),
    //         //     id: self.id,
    //         //     type: self.type,
    //         //     inputs: self.inputs
    //         // }

    //     // dataSrc: ddDataSrc
    //     // filteredInputs: []TxInput
    //     // id: ByteArray
    //     // type: String
    //     // inputs: []TxInput
    
    //     } else {
    //         self
    //     }
    // }

    func inputData(self) -> Data {
        self.input().datum.get_inline_data()
        // self.dataSrc.switch {
        //     Input{utxo} => utxo.datum.get_inline_data(),
        //     Both{utxo, _} => utxo.datum.get_inline_data(),
        //     _ => error("no input data")
        // }
    }

    func outputData(self) -> Data {
        self.output().datum.get_inline_data()
        // self.dataSrc.switch {
        //     Output{txo} => txo.datum.get_inline_data(),
        //     Both{_, txo} => txo.datum.get_inline_data(),
        //     _ => error("no output data")
        // }
    }
    
    // func mustHaveUut(self, uut: String) -> Bool {
    //     // todo
    //     false
    // }
}

struct CapoCtx {
    ctx: ScriptContext
    mph: MintingPolicyHash
    charter: CapoCharterInputType

    func mkTv(self,
        tn: ByteArray,
        count : Int = 1
    ) -> Value {
        assert(tn.length > 0, "missing reqd tn");
        Value::new(
            AssetClass::new(self.mph, tn), 
            count
        )
    }

    // use this or updatingDgData() instead of getDDOutput()
    func creatingDgData(
        self,
        recId : String="", 
        recIdBytes : ByteArray = recId.encode_utf8()
    ) -> DgDataDetails {
        output : TxOutput = self.delegatedTxOutput(recIdBytes);
        DgDataDetails::creating(recIdBytes, output, self.mph)
    }

    func updatingDgData(
        self,
        recId : String="", 
        recIdBytes : ByteArray = recId.encode_utf8()
    ) -> DgDataDetails {
        output : TxOutput = self.delegatedTxOutput(recIdBytes);
        input : TxInput = self.delegatedDataTxInput(recIdBytes: recIdBytes);
        DgDataDetails::updating(recIdBytes, input, output, self.mph)
    }

    func now(self, granularity: Duration = Duration::HOUR) -> Time {
        validity : TimeRange = self.ctx.tx.time_range;
        assert(
            validity.end - validity.start 
                <= granularity,
            "txn duration err"
        );
        validity.start
    }
    
    func getCharterRedeemer(self) -> CapoActivity {
        e : String = "requires charter as input";
        self.charter.switch {
            Unk => error(e),
            Ref => error(e),
            Input{_, utxo} => {
                activity : CapoActivity = CapoActivity::from_data(
                    mustFindInputRedeemer(self.ctx, utxo)
                );
                wrongActivity = () -> CapoActivity { 
                    if (true) { error("non-CharterToken activity") } else { 
                        // unreachable
                        CapoActivity::usingAuthority
                    } 
                };
                activity.switch {
                    retiringRefScript => wrongActivity(),
                    updatingSettings => wrongActivity(),
                    retiringSettings => wrongActivity(),
                    updatingTypeMap => wrongActivity(),
                    spendingDelegatedDatum => wrongActivity(),

                    usingAuthority => activity,
                    updatingCharter => activity,
                    addingSpendInvariant => activity

                    // _ => // leaving other potential variants out to generate compile errors if they're added
                }
            }
        }
    }

    func getRefSettingsUtxo(self) -> TxInput {
        charterDatum : CapoDatum::CharterToken = self.resolveCharterDatum();
        settingsValue : Value = mkTv(mph: self.mph, tnBytes: charterDatum.settingsUut);
        hasSettings = (txin : TxInput) -> Bool { txin.value.contains(settingsValue) };

        print("getting ref_input for settings");
        settingsUtxo : TxInput =  self.ctx.tx.ref_inputs.find_safe(hasSettings).switch{
            Some{s} => s,
            //!!! todo adjust this message: Missing required charter in ref_inputs
            None => error("Missing settings in required ref_inputs (use capo.addSettingsRef(tcx, 'refInput') in txn builder)")
        };
    
        settingsUtxo
    }

    func requiresGovAuthority(self) -> Bool {
        self.resolveCharterDatum().govAuthorityLink.hasValidOutput(
            mph: self.mph, 
            ctx: self.ctx
        )
    }

    func getSettings[SettingsTYPE](self) -> SettingsTYPE {
        settings : TxInput = self.getRefSettingsUtxo();

        SettingsTYPE::from_data(settings.datum.get_inline_data())
    }

    func requiresNamedDelegateInput(self, dgtName: String) -> DelegateInput {
        self.resolveCharterDatum().namedDelegates.get_safe(dgtName).switch{
            None => error("missing required delegate with name: " + dgtName),

            Some{dgtLink} => {
                self.requiresDelegateInput(dgtLink)
            }
        }
    }

    func actingAsMintDgt(self, required: Bool = true) -> Bool {
        input : TxInput = self.ctx.get_current_input();
        isMintDgt : Bool = (
            self.requiresMintDelegateInput(required: required).input.switch {
                Some{i} => i == input,
                None => false
            }
        ).trace("acting on mintDgt-* right now? ");
        assert(
            isMintDgt || !required
            , "not acting as mint delegate"
        );
        isMintDgt
    }

    func actingAsSpendDgt(self, required: Bool = true) -> Bool {
        input : TxInput = self.ctx.get_current_input();
        isSpendDgt : Bool = (
            self.requiresSpendDelegateInput(required: required).input.switch {
                Some{i} => i == input,
                None => false
            }
        ).trace("acting on spendDgt-* right now? ");
        assert(
             isSpendDgt || !required
            , "not acting as spend delegate"
        );
        isSpendDgt
    }

    func requiresMintDelegateInput(self, required: Bool = true) -> DelegateInput {
        dgtLink : RelativeDelegateLink = self.resolveCharterDatum().mintDelegateLink;
        self.requiresDelegateInput(dgtLink: dgtLink, required: required)
    }

    func requiresSpendDelegateInput(self, required: Bool = true) -> DelegateInput {
        dgtLink : RelativeDelegateLink = self.resolveCharterDatum().spendDelegateLink;
        self.requiresDelegateInput(dgtLink: dgtLink, required: required)
    }

    // internal / low-level function
    func resolveCharterDatum(self) -> CapoDatum::CharterToken {
        self.charter.switch {
            Ref{datum, _} => datum,
            Input{datum, _} => datum,
            _ => error("CapoCtx.resolveCharterDatum(): unknown charter strategy; use result of withCharterInput(), withCharterRef(), or needsCharter() to resolve charter datum first")
        }
    }

    func resolveCharterUtxo(self) -> TxInput {
        self.charter.switch {
            Ref{_, utxo} => utxo,
            Input{_, utxo} => utxo,
            _ => error("CapoCtx.resolveCharterUtxo(): unknown charter strategy; use result of withCharterInput(), withCharterRef(), or needsCharter() to resolve charter utxo first")
        }
    }

    // internal / low-level function
    func requiresDelegateInput(self, dgtLink: RelativeDelegateLink, required: Bool = true) -> DelegateInput {
        DelegateInput{
            dgtLink,
            dgtLink.hasDelegateInput(
                inputs: self.ctx.tx.inputs, 
                mph: self.mph,
                required: required
            ),
            self.ctx,
            self.mph
        }
    }

    func address(self) -> Address {
        addr : Address = self.resolveCharterUtxo().address;
        // print("Capo addr: " + addr.show());
        addr
    }

    func delegatedDataTxInput(self, 
        recId: String="",
        recIdBytes: ByteArray=recId.encode_utf8()
    ) -> TxInput {
        hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(
            id: recIdBytes
        );

        print(recIdBytes.decode_utf8());
        self.ctx.tx.inputs.find_safe(hasDD).switch {
            None => {
                error("❌ 📎 ^ inDD: not found")
            },
            Some{txin} => {
                print("✅ 📎 ^ inDD: ok");

                txin
            }
        }
    }
                
    func mkDelegatedDataPredicate(self, typeName: String="", id: ByteArray=#) -> (TxInput) -> Bool {
        capoAddr : Address = self.address();
        assert( 
            id.length > 0 
            || typeName.serialize().length > 0, 
            "data predicate must have id or typeName"
        );
        (txin : TxInput) -> Bool {
            if(txin.address == capoAddr) {
                data : Data = txin.datum.get_inline_data();

                CapoDatum::from_data(data).switch {
                    DelegatedData => {
                        x : AnyData = AnyData::from_data(data);
                        true 
                        && (typeName == "" || x.type == typeName) 
                        && (id == # || x.id == id)
                    },
                    _ => false
                }
            } else { false }
        }
    }

    func mkDelegatedDataOutputPredicate(self, typeName: String, id: ByteArray=#) -> (TxOutput) -> Bool {
        capoAddr : Address = self.address();
        // print("capoAddr: "+ capoAddr.show());
        // print("seeking type "+ typeName);
        // print("seeking id "+ id.decode_utf8());
        (txo : TxOutput) -> Bool {
            // print("txo.address: "+ txo.address.show());
            if(txo.address == capoAddr) {
                data : Data = txo.datum.get_inline_data();
                CapoDatum::from_data(data).switch {
                    DelegatedData => {
                        x : AnyData = AnyData::from_data(data);
                        // print( "found type " + x.type );
                        // print( "found id " + x.id.decode_utf8() );
                        // isMatch : Bool = 
                        x.type == typeName && (id == # || x.id == id)
                        // print( "isMatch: " + isMatch.show() );
                        // isMatch
                    },
                    _ => {
                        // print ("not DelegatedData");
                        false
                    }
                }
            } else { 
                // print ("not in capoAddr");
                false
             }
        }
    }


    // func toDelegatedData(self, typeName: String) -> (TxInput) -> Option[Data] {
    //     capoAddr : Address = self.resolveCharterUtxo().address;
    //     none : Option[Data]::None = Option[Data]::None;
    //     (txin : TxInput) -> Option[Data] {
    //         if(txin.address == capoAddr) {
    //             data : Data = txin.datum.get_inline_data();
    //             CapoDatum::from_data(data).switch {
    //                 DelegatedData => {
    //                     x : AnyData = AnyData::from_data(data);
    //                     if (x.type == typeName) {
    //                         Option[Data]::Some{data}
    //                     } else {
    //                         none
    //                     }
    //                 },
    //                 _ => none
    //             }
    //         } else { none }
    //     }
    // }

    // func foldDelegatedData_lazy[RT]( self, 
    //     typeName: String, 
    //     reducer: (
    //         Data, () -> RT
    //     ) -> RT, 
    //     final: RT
    // ) -> RT {
    //     // filter : (TxInput) -> Bool = self.delegatedDataFilter(typeName);
    //     hasDD : (TxInput) -> Option[Data] = self.toDelegatedData(typeName);
    //     // capoAddr : Address = self.resolveCharterUtxo().address;
    //     self.ctx.tx.inputs.fold_lazy[RT](
    //         (txin : TxInput, myNext: () -> RT) -> RT {
    //             hasDD(txin).switch {
    //                 Some{data} => reducer(data, myNext),
    //                 None => myNext()
    //             }
    //         }, final
    //     )
    // }

    // func filterDelegatedData(self, type: String, filter: (Data) -> Bool) -> []TxInput {
    //     //NOT: hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);
    //     // use toDelegatedData:
        
    //     hasDD : (TxInput) -> Option[Data] = self.mkDelegatedDataPredicate(type);
    //     self.ctx.tx.inputs.filter( (txin : TxInput) -> Bool {
    //         hasDD(txin).switch { 
    //             Some{data} => filter(data),
    //             None => false
    //         }
    //     })
    // }

    // func findDelegatedData[T](self, 
    //     type: String, 
    //     transform: (Data) -> Option[T],
    //     optional: Bool = false
    // ) -> []T {
    //     //not hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);
    //     // use toDelegatedData:
    //     hasDD : (TxInput) -> Option[Data] = self.toDelegatedData(type);
    //     none : Option[T]::None = Option[T]::None;
    //     result : []T = self.ctx.tx.inputs.map_option[T]( (txin : TxInput) -> Option[T] {
    //         hasDD(txin).switch { 
    //             Some{data} => {
    //                 transform(data)
    //             },
    //             None => none
    //         }
    //     });
    //     if (!optional && (result.length == 0)) {
    //         error(type + ": no match")
    //     };

    //     result
    // }

    // func findDelegatedDataUtxos(self, 
    //     type: String, 
    //     filter: (Data, TxInput) -> Bool,
    //     id: ByteArray=#,
    //     optional: Bool = false
    // ) -> []TxInput {
    //     //not hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);
    //     // use toDelegatedData:
    //     hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(type, id);
    //     none : Option[TxInput]::None = Option[TxInput]::None;
    //     result : []TxInput = self.ctx.tx.inputs.map_option[TxInput]( (txin : TxInput) -> Option[TxInput]{
    //         if (hasDD(txin)
    //             Some{data} => {
    //                 if (filter(data, txin)) {
    //                     Option[TxInput]::Some{txin}
    //                 } else {
    //                     none
    //                 }
    //             },
    //             None => none
    //         }
    //     });
    //     if (!optional && (result.length == 0)) {
    //         error(type + ": no match")
    //     };

    //     result
    // }


    func delegatedOutputData(self, 
        recId: ByteArray
    ) -> Data {
        self.internalHasDelegatedDataOutput(
            mkTv(mph: self.mph, tnBytes: recId)
        ).datum.get_inline_data()
    }
    func mustOutputDelegatedData(self, newDataId : ByteArray, dataTypePurpose : String) -> Bool{
        dgData : Data = self.internalHasDelegatedDataOutput(
            mkTv(mph: self.mph, tnBytes: newDataId)
        ).datum.get_inline_data();
        dgDatum : CapoDatum = CapoDatum::from_data(dgData);
        // ndid: ByteArray = newDataId.encode_utf8();
        dgDatum.switch {
            DelegatedData => {
                data : AnyData = AnyData::from_data(dgData);
                if (data.id != newDataId) {
                    print("need id: "+newDataId.decode_utf8());
                    error("❌ 📎 outDD: wrong id: "+data.id.decode_utf8())
                };
                if (data.type != dataTypePurpose) {
                    print("need type: "+ dataTypePurpose);
                    error("❌ 📎 outDD: bad type: "+data.type)
                }
            },
            _ => {
                error("output not delegated data")
            }
        };
        print(newDataId.decode_utf8());
        print(" ⬅️ ✅ 📎 ok: ^ outDD to Capo");
        true
    }

    func delegatedTxOutput(self, 
        recId: ByteArray
    ) -> TxOutput {
        print("seeking delegated-data output for "+recId.decode_utf8());
        result : TxOutput = self.internalHasDelegatedDataOutput(
            mkTv(mph: self.mph, tnBytes: recId)
        );
        print("✅ 📎 ^ outDD: found");
        result
    }

    func internalHasDelegatedDataOutput(self, v : Value) -> TxOutput {
        capoAddr : Address = self.address();

        // print("seek txOutput" + v.show());
        // print("@addr" + capoAddr.show());

        self.ctx.tx.outputs.find_safe(
            (txout : TxOutput) -> Bool {
                // print("?? txOut" + txout.value.show());
                // print("@addr" + txout.address.show());
                true
                && txout.address == capoAddr
                && txout.value.contains(v)
            }
        ).switch{
            None => {
                // print( "   ... expected value: ");
                print( v.show() );
                error("^ no req'd delegated-data out")
            },
            Some{txout} => {
                txout
            }
        }
    }
    
    // doesn't care where the charter info comes from - refinput or input, both OK
    func needsCharter(self) -> CapoCtx {
        charter : CapoCharterInputType = self.charter;
        charter.switch {
            Ref => self,
            Input => self,
            Unk => {
                CapoCtx{ctx, mph, _} = self;
                chVal : Value = tvCharter(mph);
                hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };

                ctx.tx.ref_inputs.find_safe(hasCharter).switch{
                    None => {
                        print("CapoCtx needsCharter(): no charter ref; must be in inputs...");

                        self.withCharterInput()
                    },
                    Some{charterUtxo} => {
                        print("CapoCtx needsCharter(): found charter ref");

                        datum : CapoDatum::CharterToken = CapoDatum::CharterToken::from_data( 
                            charterUtxo.datum.get_inline_data() 
                        );
                        CapoCtx{ctx, mph, CapoCharterInputType::Ref{datum, charterUtxo}}
                    }
                }
                // _ => self
            }
        }
    }

    func withCharterInput(self) -> CapoCtx {
        charter : CapoCharterInputType = self.charter;

        charter.switch {
            Input => self,
            Ref => error("CapoCtx.withCharterInput(): charter is from ref!"),
            Unk => {
                CapoCtx{ctx, mph, _} = self;

                chVal : Value = tvCharter(mph);
                hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };
        
                print("CapoCtx finding charter in inputs");
                charterUtxo: TxInput = ctx.tx.inputs.find_safe(hasCharter).switch{
                    Some{ch} => ch,
                    None => error("Missing required charter input")
                };
                datum : CapoDatum::CharterToken = CapoDatum::CharterToken::from_data( 
                    charterUtxo.datum.get_inline_data() 
                );
                // datum : CapoDatum::CharterToken = getTxCharterDatum(self.ctx, self.mph);
                CapoCtx{ctx, mph, CapoCharterInputType::Input{datum, charterUtxo}}
                // self.copy(charter: CapoCharterInputType::Input{charterUtxo, datum})
            }
        }
    }

    func withCharterRef(self) -> CapoCtx {
        charter : CapoCharterInputType = self.charter;
        charter.switch {
            Ref => self,
            Input => error("CapoCtx.withCharterRef(): charter is from inputs!"),
            Unk => {
                CapoCtx{ctx, mph, _} = self;
                utxo : TxInput = getRefCharterUtxo(ctx, mph);
                datum : CapoDatum::CharterToken = CapoDatum::from_data( 
                    utxo.datum.get_inline_data() 
                );
            
                CapoCtx{ctx, mph, CapoCharterInputType::Ref{datum, utxo}}

                // self.copy(charter: CapoCharterInputType::Ref{datum})
            }
        }
    }
}

func mkCapoCtx(ctx: ScriptContext, mph: MintingPolicyHash) -> CapoCtx {
    CapoCtx{
        ctx, mph, CapoCharterInputType::Unk
    }
}

func mkTokenShow(mph: MintingPolicyHash) -> (Value) -> String {
    (v: Value) -> String {
        others : String = Value::from_map(
                v.get_assets().to_map().filter( (someMph: MintingPolicyHash, _) -> Bool {
                mph != someMph
            })
        ).show();
        ada : String = (
            (
                (0.0 + v.get_lovelace()) / 1_000.0
            ).round() / 1_000.0
        ).show() + " ADA";
        mine : String = v.get_policy(mph).fold[[]String]( (previous: []String, tokenName: ByteArray, c: Int) -> []String {
            []String{
                c.show() + "×💴 " + tokenName.decode_utf8()
            } + previous
        }, []String{}).join(" + ");
        // v.assets()

        mine + " + " + ada  + others
    }
}

