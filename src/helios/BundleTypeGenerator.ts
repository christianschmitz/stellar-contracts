import { genTypes, type TypeSchema } from "@helios-lang/contract-utils";
import type {
    anyTypeDetails,
    EnumId,
    EnumTypeMeta,
    enumTypeDetails,
    HeliosBundleTypeDetails,
    HeliosBundleTypes,
    HeliosScriptBundle,
    makesUplcActivityEnumData,
    singleEnumVariantMeta,
    typeDetails,
    variantTypeDetails,
} from "./HeliosScriptBundle.js";
import type {
    EnumTypeSchema,
    VariantTypeSchema,
} from "@helios-lang/type-utils";
import type { DataType } from "@helios-lang/compiler/src/index.js";
import type { EnumMemberType } from "@helios-lang/compiler/src/typecheck/common.js";
import { BundleTypes } from "./BundleTypes.js";

/**
 * Gathers any number of types expressible for an on-chain Helios script,
 * and generates types and type aliases for the off-chain TypeScript context.
 *
 * Each struct type is directly expressed as its name
 * Each enum type is expressed as a proxy type, unioned with the possible raw enum variants for that type
 * As each type is encountered (as a **nested field** within a datum or redeemer), any named types encountered
 * are added to the context, with any recursive expansions generated and added to the context, depth-first,
 * ... then the named type is used for the **nested field** where it was encountered.
 */
export class BundleTypeGenerator {
    bundle: HeliosScriptBundle;
    typeBundle: BundleTypes

    constructor(bundle: HeliosScriptBundle, typeBundle?: BundleTypes) {
        this.bundle = bundle;
        if (typeBundle) {
            this. typeBundle = typeBundle;
        } else {
            this.typeBundle = new BundleTypes(bundle);
        }
    }

    get namedTypes() {
        return this.typeBundle.namedTypes;
    }
    
    get topLevelTypeDetails() {
        return this.typeBundle.topLevelTypeDetails;
    }
    get activityTypeDetails() {
        return this.typeBundle.activityTypeDetails;
    }
    get datumTypeDetails() {
        return this.typeBundle.datumTypeDetails;
    }
    
    createAllTypesSource(className: string, parentClassName: string) {
        return (
            "" +
            `// generated by StellarHeliosProject using Stellar heliosRollupTypeGen()
/// <reference types="@helios-lang/uplc" />
/// <reference types="@helios-lang/ledger" />
/// <reference types="@helios-lang/contract-utils" />
/// <reference types="../delegation/CapoDelegateBundle.ts">;  // development
/// <reference types="./CapoHeliosBundle.ts">
/// <reference types="./HeliosScriptBundle.ts">
/// <reference types="@donecollectively/stellar-contracts" /> // production



/** ------------ BEGIN hlbundle imports --------- */
/** if you want to maintain these in a .ts file, you can use the following imports there */
// import type { UplcData } from "@helios-lang/uplc";
// import type {
//     Address,
//     AssetClass,
//     DatumHash,
//     MintingPolicyHash,
//     PubKey,
//     PubKeyHash,
//     ScriptHash,
//     SpendingCredential,
//     StakingCredential,
//     StakingHash,
//     StakingValidatorHash,
//     TimeRange,
//     TxId,
//     TxInput,
//     TxOutput,
//     TxOutputId,
//     TxOutputDatum,
//     ValidatorHash,
//     Value,
// } from "@helios-lang/ledger";
// import type { Cast } from "@helios-lang/contract-utils";
// import type { 
//     IntLike,
//     ByteArrayLike,
//  } from "@helios-lang/codec-utils";

// import type {CapoHeliosBundle} from "@donecollectively/stellar-contracts"
// import type {CapoDelegateBundle} from "@donecollectively/stellar-contracts"
// import type {
//     HeliosScriptBundle,
//     mkEnum,
//     type EnumTypeMeta,
//     type singleEnumVariantMeta,
//     type tagOnly
// } from "@donecollectively/stellar-contracts"

/** ------------ BEGIN hlbundle types ------------ */
${this.generateNamedDependencyTypes()}
/** ------------- hlbundle types END ------------- */

export default
class ${className} 
extends ${parentClassName} {
${this.generateDatumApiTypes()}
${this.generateRedeemerApiTypes()}
}
`
        );
    }
    
    generateNamedDependencyTypes() {
        return Object.entries(this.namedTypes)
            .map(([name, typeInfo]) => {
                if (typeInfo.typeSchema.kind === "enum") {
                    return this.generateEnumTypeSource(
                        name,
                        typeInfo as enumTypeDetails
                    );
                } else {
                    return this.generateOtherNamedTypeSource(
                        name,
                        typeInfo as typeDetails
                    );
                }
            })
            .join("\n");
    }

    generateEnumTypeSource(name: string, typeInfo: enumTypeDetails) {
        return (
            `export type ${name}Meta = ${typeInfo.canonicalMetaType}\n`+
            `export type ${name} = ${typeInfo.canonicalType}\n` +
            `export type ${name}Like = ${typeInfo.permissiveType}\n`+
            ""
        );
    }

    generateOtherNamedTypeSource(name: string, typeInfo: typeDetails) {
        return (
            `export type ${name} = ${typeInfo.canonicalType}\n` +
            `export type ${name}Like = ${typeInfo.permissiveType}\n`
        );
    }

    // redeemer is write-only
    generateRedeemerApiTypes() {
        return this.generateWriteApiTypes(
            this.topLevelTypeDetails.redeemer,
            "Activity"
        );
    }

    // datums are read/write, when present
    generateDatumApiTypes() {
        // datum: HeliosTypeInfo | HeliosEnumInfo) {
        if (!this.topLevelTypeDetails.datum) {
            return `// no datum types in this script`;
        }

        return (
            this.generateWriteApiTypes(
                this.topLevelTypeDetails.datum,
                "mkDatum"
            ) +
            this.generateReadApiTypes(
                this.topLevelTypeDetails.datum,
                "readDatum"
            )
        );

        // mkDatum: {
        //     placeholder: "generate proxy types here";
        // }
        // readDatum: {
        //     placeholder: "show proxy types here";
        // }
    }

    generateWriteApiTypes(typeInfo: anyTypeDetails, accessorName?: string) {
        if (!accessorName) {
            //@ts-expect-error - name not always present
            if (!typeInfo.typeSchema.name) {
                throw new Error("typeName must be provided for unnamed types");
            }
            //@ts-expect-error - name already guarded above
            accessorName = `mk${typeInfo.typeSchema.name}`;
        }
        const isActivity = "Activity" == accessorName ? "Activity" : "";
        if (typeInfo.typeSchema.kind === "enum") {
            return `    ${accessorName}: makesUplc${isActivity}EnumData<${typeInfo.typeSchema.name}Like>;\n`;
        }

        //@ts-expect-error - name not always present
        if (typeInfo.typeSchema.name) {
            //@ts-expect-error - name already guarded above
            return `    ${accessorName}: uplcDataMaker<${typeInfo.typeSchema.name}Like>;\n`;
        } else {
            console.log(
                " ????????? is non-named uplcDataMaker ever used?\nyes:" +
                    new Error("").stack!.split("\n").splice(2).join("\n")
            );
            return `    ${accessorName}: uplcDataMaker<${typeInfo.permissiveType}>;\n`;
        }
    }

    generateReadApiTypes(typeInfo: anyTypeDetails, accessorName?: string) {
        if (!accessorName) {
            //@ts-expect-error - name not always present
            if (!typeInfo.typeSchema.name) {
                throw new Error("typeName must be provided for unnamed types");
            }
            //@ts-expect-error - name already guarded above
            accessorName = `read${typeInfo.typeSchema.name}`;
        }
        if (typeInfo.typeSchema.kind === "enum") {
            return `    ${accessorName}: readsUplcEnumData<${typeInfo.typeSchema.name}>;\n`;
        }
        //@ts-expect-error - name not always present
        if (typeInfo.typeSchema.name) {
            //@ts-expect-error - name already guarded above
            return `    ${accessorName}: readsUplcData<${typeInfo.typeSchema.name}>;\n`;
        }
        return `    ${accessorName}: readsUplcData<${typeInfo.canonicalType}>;\n`;
    }
}
