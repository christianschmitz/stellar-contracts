import { existsSync, readFileSync, writeFileSync } from "fs";
import path from "path";
import type { HeliosScriptBundle } from "./HeliosScriptBundle.js";
import { type TypeSchema, genTypes } from "@helios-lang/contract-utils";
// import CapoBundle from "../CapoHeliosBundle.js";

type HeliosTypeInfo = {
    kind: TypeSchema["kind"];
    canonicalType: string;
    permissiveType: string;
};
type HeliosVariantInfo = {
    fields: Record<string, HeliosTypeInfo>;
};

type HeliosEnumInfo = {
    kind: "enum";
    variants: Record<string, HeliosVariantInfo>;
};

type HeliosBundleTypes = {
    datum: HeliosTypeInfo | HeliosEnumInfo;
    redeemer: HeliosTypeInfo | HeliosEnumInfo;
};

type bundleWithStatus = {
    filename: string;
    bundle?: Option<HeliosScriptBundle>;
    types?: Option<HeliosBundleTypes>;
};
/**
 * Gathers `*.hlbundle.js` files along with their status and attributes.
 * @public
 * @remarks
 * For script bundles that have previously been loaded, the project will
 * have access to the bundle's type information, and  be able to
 * instantiate the bundle, given a CapoBundle that typically provides
 * library dependencies.
 *
 * For script bundles that are being loaded for the first time, the project
 * can generate a "placeholder" type-definition, to be updated once the
 * bundle has been transformed by the helios rollup loader to be able to
 * do the above.
 */
export class StellarHeliosProject {
    static root: string
    static loadExistingProject() : Promise<StellarHeliosProject> | undefined {

        const root = StellarHeliosProject.findProjectRoot();
        if (existsSync(`${root}/hlproject.mjs`)) {
            return  import(`${root}/hlproject.mjs`).then((projectPackage) => {
                if (!projectPackage.project) {
                    throw new Error(`hlproject.mjs must export a \`project\``);
                }
                return  projectPackage.project;
            })
        }
    }

    bundles: Map<string, bundleWithStatus>;
    capoBundle: HeliosScriptBundle | null = null;
    projectRoot: string;
    constructor() {
        this.bundles = new Map();
        this.projectRoot = StellarHeliosProject.findProjectRoot();
    }

    // call from code-generated hlproject.mjs with instantiated bundle
    // call from rollup plugin with bundle filename
    addBundle(filename: string, bundleClass?: typeof HeliosScriptBundle) {
        if (bundleClass) {
            let bundle: HeliosScriptBundle | undefined;
            // if the bundle has a CapoBundle, use it
            const isCapoBundle = false
            debugger
            if (isCapoBundle) { //bundleClass.prototype instanceof CapoBundle) {
                if (this.bundles.size > 0) {
                    if (this.capoBundle) {
                        throw new Error(
                            `only one CapoBundle is currently supported`
                        );
                    } else {
                        throw new Error(
                            `the CapoBundle must be registered before any other bundles (at ${filename}`
                        );
                    }
                }
                this.capoBundle = new (bundleClass as any)();
            } else {
                if (!this.capoBundle) {
                    throw new Error(
                        `the CapoBundle must be registered before any other bundles (at ${filename}`
                    );
                }
                bundle = new (bundleClass as any)(this.capoBundle);
            }
            const types = bundle ? this.genTypes(bundle) : undefined;
            this.bundles.set(filename, { filename, bundle, types });
        } else {
            this.bundles.set(filename, { filename });
        }
    }

    hasBundleClass(filename: string) {
        if (this.bundles.has(filename)) {
            return this.bundles.get(filename)?.bundle !== undefined;
        }
    }

    writeTypeInfo(filename: string) {
        const bundle = this.bundles.get(filename);
        if (!bundle) {
            throw new Error(`bundle not found: ${filename}`);
        } else if( !bundle.bundle ) {
            throw new Error(`cannot write type info for ${filename} for newly-added bundle (check for hasBundleClass first)`);
        }
        const types = this.genTypes(bundle.bundle);
        const typeFilename = filename.replace(/\.hlbundle\.js$/, ".hlbundle.d.ts");
        const className = bundle.bundle.constructor.name;

        const parentClass = "Placehodler"// bundle.bundle?.constructor.name || "HeliosScriptBundle";
        debugger
        throw new Error(`todo: write type info to ${typeFilename}`);
        writeFileSync(typeFilename, `// generated by StellarHeliosProject using Stellar Helios Rollup type-generator
import type {CapoBundle} from "src/CapoHeliosBundle.ts"   // todo import  from @stellar-contracts
import type {HeliosScriptBundle} from "src/helios/HeliosScriptBundle.ts" // todo import from @stellar-contracts

export default class ${className} extends ${parentClass} {
    mkDatum: {
        placeholder: "generate proxy types here";
    }
    mkRedeemer: {
        placeholder: "make proxy types here";
    }
    readDatum: {
        placeholder: "show proxy types here";
    }
}
           `);
    }

    genTypes(bundle: HeliosScriptBundle): HeliosBundleTypes {
        throw new Error(
            `todo: detect enums, generate enum-variant types for each`
        );

        // const [canonicalType, permissiveType] = genTypes(bundle)
    }

    generateProject() {
        // creates or updates hlproject.mjs in the project root
        // makes a backup of the existing hlproject.mjs
        // writes the new hlproject.mjs

        if (existsSync(`${this.projectRoot}/hlproject.mjs`)) {
            writeFileSync(
                `${this.projectRoot}/hlproject.mjs.bk`,
                readFileSync(`${this.projectRoot}/hlproject.mjs`)
            );
        }
        let content = `// generated by StellarHeliosProject using Stellar Helios Rollup type-generator

import { HeliosScriptBundle } from "src/helios/HeliosScriptBundle.ts"
import { CapoHeliosBundle } from "src/CapoHeliosBundle.ts"
import { StellarHeliosProject } from "src/helios/StellarHeliosProject.ts"
`;
        for (const [filename, bundle] of this.bundles) {
            content += `import ${
                bundle.bundle?.program.name || "unk"
            } from "${filename}";\n`;
        }
        content += `\nexport const project = new StellarHeliosProject();\n\n`;
        for (const [filename, bundle] of this.bundles) {
            content += `project.addBundle("${filename}", ${
                bundle.bundle?.program.name || "unk"
            });\n`;
        }
        writeFileSync(`${this.projectRoot}/hlproject.mjs`, content);
        console.log(
            `ðŸ“¦ StellarHeliosProject: wrote hlproject.mjs to ${this.projectRoot}`
        );
    }

    static findProjectRoot() {
        // starting in the current working directory,
        // look for package.json
        // if not found, go up a directory and try again
        // repeat until found or at root
        // throw error if not found
        // returns the full path to the project root

        if (this.root) return this.root;

        const cwd = process.cwd();
        let dir = cwd;
        let found = false;
        while (!found) {
            if (existsSync(path.join(dir, "package.json"))) {
                found = true;
            } else {
                const parent = path.dirname(dir);
                if (parent === dir) {
                    throw new Error(
                        `could not find package.json in ${cwd} or any parent directories`
                    );
                }
                dir = parent;
            }
        }
        console.log(`ðŸ“¦ StellarHeliosProject: found project root at ${dir}`);
        this.root = dir
        return dir;
    }
}
