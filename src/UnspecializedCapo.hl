module specializedCapo

// SPECIALIZING Capo is now DEPRECATED.
// 

import { 
    RelativeDelegateLink
} from CapoDelegateHelpers

import {
    capoSettings
} from CustomCapoSettings

import {
    outputAndDatum,
    mkTv,
    tvCharter
} from StellarHeliosHelpers

// field-names style of struct, arbitrary & extensible
// field list, can be interpreted by any script that defines a 
// field-names style of struct with its own fields & data types.
struct AnyData {
    id: String "@id"  // same as the UUT name for this data
    // can have other fields; receiver will interpret their target types.
}

//! provides a basic version of Datum in default specializedCapo module
enum Datum {
    CharterToken {
        spendDelegateLink: RelativeDelegateLink
        spendInvariants: []RelativeDelegateLink
        settingsUut: ByteArray // UUT-name links to SettingsData
        namedDelegates: Map[String]RelativeDelegateLink
        mintDelegateLink: RelativeDelegateLink
        mintInvariants: []RelativeDelegateLink
        govAuthorityLink: RelativeDelegateLink
    }
    ScriptReference
    SettingsData {
        data:  Map[String]Data
    }
    DelegatedData {
        data: AnyData
        delegateLink: RelativeDelegateLink
    }

    //! datum-validation only supports checks of absolute spendability, 
    //  ... and can't check details of the Activity ("redeemer") being used.
    func validateSpend(self, ctx: ScriptContext, mph: MintingPolicyHash) -> Bool {
        //! Note: an overridden Datum's impl of validateSpend() 
        // ... is never called with the CharterToken variant
        assert(false, "can't happen");
        self.switch{
            CharterToken => true,
            _ => error("can't happen")
        } || (
            ctx.tx.serialize() /* never */ == self.serialize() ||
            mph.serialize() /* never */ == self.serialize()
        )
    }

    // this needs to be a method on the Datum enum,
    // ... because it's called by other methods here, AND
    // ... it depends on the Datum's own enum variants.
    func hasCharterRefInput(
        self,
        ctx: ScriptContext, 
        mph : MintingPolicyHash
    ) -> Option[Datum::CharterToken] {
        assert( // avoid "unused variable self" error
            self.serialize() != ctx.serialize() &&
            self.serialize() != mph.serialize(), "never thrown"
        );
        
        chVal : Value = tvCharter(mph);
        hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };

        ctx.tx.ref_inputs.find_safe(hasCharter).switch{
            Some{txin} => Option[Datum::CharterToken]::Some{
                Datum::from_data( 
                    txin.datum.get_inline_data() 
                ).switch{
                    c : CharterToken => c,
                    _ => error("wrong enum")
                }
            },
            None => Option[Datum::CharterToken]::None
        }
    }

    func mustFindSettingsOutput(self, ctx: ScriptContext, mph: MintingPolicyHash, inAddr: Address) -> outputAndDatum[Datum::SettingsData] {
        settingsVal : Value = mkTv(mph: mph, tnBytes: self.switch {
            ct: CharterToken => ct.settingsUut,
            _ => error("mustFindSettings - only valid on CharterToken datum")
        });
        print( "finding settings output" );
        tx : Tx = ctx.tx;
        notFound = Option[outputAndDatum[Datum::SettingsData]]::None;
        foundSettings: []outputAndDatum[Datum::SettingsData] = 
            tx.outputs.map_option[
                outputAndDatum[Datum::SettingsData]
            ](
                 (output: TxOutput) -> Option[outputAndDatum[Datum::SettingsData]] {
                    print("defaultMinter finding settings output");
                    if ( output.address != inAddr ) {
                        // print("not the right address");
                        notFound
                    } else {
                        rawDatum : Data = output.datum.get_inline_data();
                        Datum::from_data(
                            rawDatum
                        ).switch {
                            settings: SettingsData => {
                                print("found Datum::SettingsData");
                                Option[
                                    outputAndDatum[Datum::SettingsData]
                                ]::Some{
                                    outputAndDatum[Datum::SettingsData] {
                                        output, settings, rawDatum
                                        // .switch { 
                                        //     (index:Int, fields: []Data) => {
                                        //         // work around issue where index can't be made unused with _
                                        //         assert(index == index, "no way");
                                        //         fields.head
                                        //     },
                                        //     _ => error("no way")
                                        // }
                                    }
                                }
                            },
                            _ => {
                                // print("found non-SettingsData");
                                notFound
                            }
                        }
                    }
                }
            );

        // if (isDev) { 
        assert(foundSettings.length < 2, "too many settings outputs") ;
        assert(foundSettings.length == 1, "no settings output");

        settingsOutput : TxOutput = foundSettings.head.output;
        assert(
            // already checked above.
            // settingsOutput.address == charter.owner &&
            settingsOutput.value.contains(settingsVal),
                "settings output not found in contract with expected UUT"
        );
        assert(settingsVal.contains(settingsOutput.value.get_assets()), 
            "excess value in settings output: "+(settingsOutput.value - settingsVal).show()
        );
        foundSettings.head
        // ^^ fails if there's no settings output to the right address

        // the settings output should be empty?
        // assert(foundSettings.head.datum.data.length == 0,
        //     "temp: settings must be empty during charter"
        // );

        // assert(settingsOutput.serialize() == settingsOutput.serialize(), "no way");

    }

}

//! provides a basic version of Activity ("redeemer" type) in default specializedCapo module
enum Activity {
    usingAuthority // variant 0
    updatingCharter // variant 1
    retiringRefScript // variant 2
    addingSpendInvariant // variant 3
    spendingDelegatedDatum // variant 4
    updatingSettings // variant 5
    retiringSettings // variant 6

}

struct types {
    redeemers: Activity
    datum : Datum
}
