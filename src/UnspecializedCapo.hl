module specializedCapo

//! provides a basic version, not actually specialized,
// of the "specializedCapo" interface, which simply
// exports Datum and Activity ('redemeer") enum types.  
//! the Datum and Activity of specializations
//  MUST include the same enum variants as in this
//  unspecialized version.  if you're specializing 
//  ... and you get a Helios compiler error,
// ... these are the first things you should check!
//! Your specialization MAY include any 
// ... additional functions, imports or methods

import { 
    RelativeDelegateLink
} from CapoDelegateHelpers
import {
    tvCharter
} from StellarHeliosHelpers

//! provides a basic version of Datum in default specializedCapo module
enum Datum {
    CharterToken {
        spendDelegateLink: RelativeDelegateLink
        spendInvariants: []RelativeDelegateLink
        mintDelegateLink: RelativeDelegateLink
        mintInvariants: []RelativeDelegateLink 
        govAuthorityLink: RelativeDelegateLink
    }
    ScriptReference

    //! datum-validation only supports checks of absolute spendability, 
    //  ... and can't check details of the Activity ("redeemer") being used.
    func validateSpend(self, ctx: ScriptContext, mph: MintingPolicyHash) -> Bool {
        //! Note: an overridden Datum's impl of validateSpend() 
        // ... is never called with the CharterToken variant
        assert(false, "can't happen");
        self.switch{
            CharterToken => true,
            _ => error("can't happen")
        } || (
            ctx.tx.serialize() /* never */ == self.serialize() ||
            mph.serialize() /* never */ == self.serialize()
        )
    }   

    // this needs to be a method on the Datum enum,
    // ... because it's called by other methods here, AND
    // ... it depends on the Datum's own enum variants.
    // If you're specializing, you'll need to copy this.  
    // But you probably don't need to specialize.  Use delegates instead.
    func hasCharterRefInput(
        self,
        ctx: ScriptContext, 
        mph : MintingPolicyHash
    ) -> Option[Datum::CharterToken] {
        assert( // avoid "unused variable self" error
            self.serialize() != ctx.serialize() &&
            self.serialize() != mph.serialize(), "never thrown"
        );
        
        chVal : Value = tvCharter(mph);
        hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };

        ctx.tx.ref_inputs.find_safe(hasCharter).switch{
            Some{txin} => Option[Datum::CharterToken]::Some{
                Datum::from_data( 
                    txin.datum.get_inline_data() 
                ).switch{
                    c : CharterToken => c,
                    _ => error("wrong enum")
                }
            },
            None => Option[Datum::CharterToken]::None
        }
    }

}

//! provides a basic version of Activity ("redeemer" type) in default specializedCapo module
enum Activity {
    usingAuthority // variant 0
    updatingCharter // variant 1
    retiringRefScript // variant 2
    addingSpendInvariant // variant 3
    spendingDelegatedDatum // variant 4

    func allowActivity(self, datum: Datum, ctx: ScriptContext, mph: MintingPolicyHash) -> Bool {
        self.switch{
            //! Note: an overridden Reedeemer def doesn't have to replicate the checks
            // ... for the baseline enum variants; it's not called in those cases.
            updatingCharter => true,
            usingAuthority => true,
            _ => error("unreachable code")
            // not executed, but prevents the args from showing up as unused:
        } || (
            ctx.tx.serialize() /* never */ == datum.serialize() ||
            mph.serialize() /* never */ == datum.serialize()
        )
    }    
}

struct types {
    redeemers: Activity
    datum : Datum
}
