

module CapoMintHelpers
import {
    mustFindInputRedeemer,
    mkTv,
    TODO,
    tvCharter
} from StellarHeliosHelpers

import {
    getTxCharterDatum,
    CapoCtx,
    mkCapoCtx,
    DelegateInput,
    CapoDatum, 
    CapoActivity
} from CapoHelpers


import {
    RelativeDelegateLink,
    AbstractDelegateActivitiesEnum,
    DelegateLifecycleActivity
} from CapoDelegateHelpers

func hasSeedUtxo(tx: Tx, seedTxId : TxId, seedIdx: Int
    // , reason: String
) -> Bool {
    seedUtxo: TxOutputId = TxOutputId::new(
        seedTxId,
        seedIdx
    );
    assert(tx.inputs.any( (input: TxInput) -> Bool {
        input.output_id == seedUtxo
    }),  "seed utxo required for minting "
        // +reason 
        // + "\n"+seedTxId.show() + " : " + seedIdx.show()
    );
    print( "  -- has seed -> ok");
    true
}

func requiresDelegateAuthorizingMint(
    delegateLink: RelativeDelegateLink, 
    mph: MintingPolicyHash, 
    ctx : ScriptContext,
    extraMintDelegateRedeemerCheck: Bool = true
) -> Bool {
    authzVal : Value = Value::new(AssetClass::new(mph, delegateLink.uutName.encode_utf8()), 1);
    print( delegateLink.uutName);
    print("finding ^ my inp");
    targetId: TxOutputId = ctx.tx.inputs.find_safe((i: TxInput) -> {
        // print("   ?  in "+i.value.show());
        i.value.contains(authzVal) // find my authority token
    }).switch{
        Some{x} => x.output_id,
        None => error("missing dgTkn "+delegateLink.uutName)
    };
    print ("     found ^");
    spendsAuthorityUut : ScriptPurpose = ctx.tx.redeemers.find_key( 
        (purpose : ScriptPurpose) -> { purpose.switch{ 
            sp: Spending => {
                // print ("oid: " + sp.output_id.show());
                sp.output_id == targetId
            }, 
            _ => false 
        } }
    );

    // r : Data = ctx.tx.redeemers.get(  // index redeemers by...
    //     ScriptPurpose::new_spending(  // [spending, plus ...
    //     );
        //!!! Todo replace this with a return of Option[delegate-redeemer}?
    err : String = "dgTkn "+delegateLink.uutName+" not being spent as expected"; // "not spent with an authorizing activity!")
    maybeCheckedMintDelegateAuthority : Bool = ctx.tx.redeemers.get_safe(
        spendsAuthorityUut
    ).switch {
        None => {
            error(err)
        },
        Some{x} => x.switch {
            (index: Int, fields: []Data) => {

                /* avoids unused-variable warning: */ fields == fields && 
                if (!extraMintDelegateRedeemerCheck) {
                    print("  -- ok, dgTkn spent");
                    print("  -- skip redeemer check");
                    true
                } else { 
                    if (0 == index) {
                        dgtActivity : DelegateLifecycleActivity = DelegateLifecycleActivity::from_data(fields.head);
                        dgtActivity.switch {
                            ReplacingMe => {
                                print("  -- ok, dgTkn spent");
                                true
                            },
                            Retiring => error("DLA::Retiring can't mint!"),
                            ValidatingSettings => error("DLA::ValidatingSettings can't mint!")
                        }
                    } else { true }
                }
            },
            _ => {
                error(err)
            }
        }
    };
    delegateDidAuthorize = true; // otherwise, we'd have failed above.

    // NOTE: DOESN'T CHECK that the AUTHORIZING DELEGATE is returned anywhere specific.
    //    - it's not generally a minting responsibility (however, as an exception the bootstrap charter event DOES 
    //      actually check for valid delegate outputs).  All other cases should have the correct
    //      delegate outputs checked (e.g. in the Capo's CharterDatum spend checker).
    // print("no no no");
    // maybeCheckDelegateOutput : Bool = if (!checkDelegateOutput) {
    //     print("  -- skipping check for expected delegate output ");
    //     true
    // } else {
    //     delegateLink.hasValidOutput(mph, ctx)        
    // };
    delegateDidAuthorize && maybeCheckedMintDelegateAuthority
}

func requiresMintDelegateApproval(
    ctx: ScriptContext, 
    mph: MintingPolicyHash
) -> Bool {
    cctx : CapoCtx = mkCapoCtx(ctx, mph).withCharterRef();
    print("Minter needs mintDgt + mint activity");

    if (true) {
        // todo: enforces minting invariants.
        TODO("must enforce minting invariants")
    }; 

    mintDgtInput : DelegateInput = cctx.requiresMintDelegateInput();
    activity : AbstractDelegateActivitiesEnum = mintDgtInput.genericDelegateActivity();


    // TODO restore this: mintDgtInput.requiresValidOutput() && 
    activity.switch {
        SpendingActivities => error("DelegateInput::SpendingActivity can't mint!"),
        CapoLifecycleActivities{CLA} => CLA.switch {
            CreatingDelegate => {
                print("  -- minter wants mintDgt + CapoLifecycle (delegate-creation)");

                mintDgtInput.requiresValidOutput() && 
                true
            }
            // _ => // ---- left as a compile-time error if any further variants are added 
        },
        DelegateLifecycleActivities{DLA} => {
            DLA.switch {
                ReplacingMe => {
                    TODO( "relay delegate installation sequence" 
                        // "the new delegate should be minted under CapoLifecycleActivities::CreatingDelegate, then installed \n  ...without the minter's involvement, using its DelegateLifecycle::Installing activity"
                    );
                    print("  -- TEMPORARY: the mint delegate is being replaced");
                    true
                },
                Retiring => error("DLA::Retiring can't mint!"),
                ValidatingSettings => error("DLA::ValidatingSettings can't mint!")
            }
        },
        MintingActivities => {
            print("  -- app-specific minting; trust mintDgt");
            mintDgtInput.requiresValidOutput() && 
                        true
        }
    }

    // CapoDatum::CharterToken {
    //     /*spendDgt*/ _,  
    //     /* spendInvariants */ _,
    //     /* settings */ _,
    //     /* namedDelegates */ _,
    //     mintDgt, 
    //     /* mintInvariants */ _, 
    //     /* govAuthority */ _
    // } = getRefCharterDatum(ctx, mph);



    // requiresDelegateAuthorizingMint(
    //     delegateLink: mintDgt, 
    //     mph: mph,
    //     ctx: ctx
    // )
}

//! pre-computes the hash-based suffix for a token name, returning
//  a function that cheaply makes Uut names with any given purpose, 
// given the initial seed-txn details
func mkUutTnFactory(
    seedTxId : TxId, seedIdx : Int
) -> (String) -> String {
   
    idxBytes : ByteArray = seedIdx.serialize();
    // assert(idxBytes.length == 1, "surprise!");

    //! yuck: un-CBOR...
    rawTxId : ByteArray = seedTxId.serialize().slice(5,37);

    txoInfo : ByteArray = if (idxBytes.length > 9) { 
        // allows 9 bytes to ensure we can support 
        // the largest possible cbor encoding of txo-index integers, 
        // even though we only expect integers < 256 currently
        assert(false, 
            //"expected cbor(txo index) to be at most 9 bytes, got cbor( index=
            //  + seedIdx.show() + " ).hex = " + idxBytes.show()
            "cbor(txoId) len > 9 !!"  
        );
        idxBytes // never used
    } else {
       ( rawTxId + "@".encode_utf8() )+ idxBytes
    };
    // assert(txoId.length == 34, "txId + @ + int should be length 34");
    // print( "******** txoId " + txoId.show());

    miniHash : ByteArray = txoInfo.blake2b().slice(0,6);
    // assert(miniHash.length == 6, "urgh.  slice 5? expected 12, got "+ miniHash.length.show());

    mhs: String = miniHash.show();

    // returns a function computing a lightweight prefix + miniHash
    (p: String) -> String {
        p + "-" + mhs
    }
}

func tnCip68nft222(tn : String) -> ByteArray{
    #000de140 + tn.encode_utf8()
}

func tnCip68ref100(tn : String) -> ByteArray {
    #000643b0 + tn.encode_utf8()
}

// checks all of the following:
//  - there's an approving delegate (or we're bootstrapping)
//  - the mint includes the seed UTXO
//  - the mint matches the UUTs indicated by the list of purposes
func validateUutMinting(
    ctx: ScriptContext, 
    mph: MintingPolicyHash,
    seedTxId : TxId, seedIdx : Int, 
    purposes: []String,     
    mkTokenName: (String) -> String = mkUutTnFactory(seedTxId, seedIdx),
    bootstrapCharter:Value = Value::ZERO,
    otherMintedValue: Value = Value::ZERO,
    needsMintDelegateApproval: Bool = true,
    extraMintDelegateRedeemerCheck: Bool = true
) -> Bool {
    tx: Tx = ctx.tx;

    isBootstrapping : Bool = !( bootstrapCharter.is_zero() );
    delegateApproval : Bool = if ( isBootstrapping ) { 
        true 
    } else {
        // not bootstrapping; must honor the mintDelegate's authority
        CapoDatum::CharterToken {
            /*spendDgt*/ _,  
            /* spendInvariants */ _,
            /* settings */ _,
            /* namedDelegates */ _,
            mintDgt, 
            /* mintInvariants */ _, 
            /* govAuthority */ _,
            /* typeInfo */ _
        } = getTxCharterDatum(ctx, mph);

        if (needsMintDelegateApproval) {
            //!!! todo: add explicit activity details in authorization
                                    //!todo change this one
            requiresDelegateAuthorizingMint(
                delegateLink: mintDgt, 
                mph: mph, 
                ctx: ctx,
                extraMintDelegateRedeemerCheck: extraMintDelegateRedeemerCheck
            )
        } else {
            true
        }
    };

    valueMinted: Value = tx.minted;

    // idxBytes : ByteArray = seedIdx.bound_max(255).serialize();
    // // assert(idxBytes.length == 1, "surprise!");

    // //! yuck: un-CBOR...
    // rawTxId : ByteArray = seedTxId.serialize().slice(5,37);

    // txoId : ByteArray = (rawTxId + "@".encode_utf8() + idxBytes);
    // assert(txoId.length == 34, "txId + @ + int should be length 34");
    // // print( "******** txoId " + txoId.show());

    // miniHash : ByteArray = txoId.blake2b().slice(0,6);
    // // assert(miniHash.length == 6, "urgh.  slice 5? expected 12, got "+ miniHash.length.show());

    // tokenName1 = purpose + "." + miniHash.show();

    // print(" purposes: " + purposes.join(", "));
    expectedValue : Value = bootstrapCharter + otherMintedValue + Value::sum(
        purposes.sort((a:String, b:String) -> Bool { a != b }).map(
            (purpose: String) -> Value {
                // print("purpose: " + purpose);
                mkTv(mph, mkTokenName(purpose))
            }
        )
    );
    if (! valueMinted.contains_policy(mph) ) {
        print( "  -- no mint from our policy at (mph, valueMinted): ( ");
        print( mph.show() );
        print(valueMinted.show() );
        error(") - validateUutMinting(): no mint")
    };

    actualMint : Map[ByteArray]Int = valueMinted.get_policy(mph);
    // expectedMint : Map[ByteArray]Int = expectedValue.get_policy(mph);
    if (true) {
        actualMint.for_each( (b : ByteArray, i: Int) -> {
            print( "    ℹ️ 🐞 actual: " );
            print( i.show() + "x " + b.decode_utf8())
        });
        print(Value::from_map(valueMinted.to_map().filter( (b:MintingPolicyHash, _ /* Map[ByteArray]Int */ ) -> Bool {
            b != mph
        })).show());
        
        print("uut-minting seed: ");
        print( seedTxId.show() );
        print("🔹#" + seedIdx.show());
        expectedValue.get_policy(mph).for_each( (b : ByteArray, i: Int) -> {
            print( "    ℹ️ 🐞 expected: ");
            print( i.show() + "x " + b.decode_utf8())
        })
    };

    temp : []ByteArray = actualMint.fold( (l: []ByteArray, b : ByteArray, i: Int) -> {
        l.find_safe((x : ByteArray) -> Bool { x == b }).switch{
            None => l.prepend(b),
            Some /*{x}*/ => error("UUT duplicate purpose "
                // +  x.decode_utf8()
            )
        }
    }, []ByteArray{});
    assert(true || (temp == temp), "prevent unused var");


    expectationsMet : Bool = valueMinted  == expectedValue;

    assert(expectationsMet, "mismatch in UUT mint"
        // +";\n   ... expected "+ expectedValue.show()+
        // "   ... actual "+ valueMinted.show()+
        // "   ... diff = \n" + (expectedValue - valueMinted).show()
    );
    print(" ✅ validateUutMinting:  ok!");

    delegateApproval && expectationsMet &&
    hasSeedUtxo(tx, seedTxId, seedIdx
        //, "UUT "+purposes.join("+")
    )
}

func mintsUutForCharterUsingRedeemerIndex(
    ctx: ScriptContext,
    mph: MintingPolicyHash,
    purpose: String,
    seedTxId: TxId,
    seedIdx: Int,
    charterRedeemerIndex: Int,
    otherMintedValue: Value = Value::new(AssetClass::ADA, 0),
    needsMintDelegateApproval: Bool = true,
    extraMintDelegateRedeemerCheck: Bool = true
) -> Bool {
            // only has to check that a) it's minting all-and-only the expected uut,
            // and b) the contract charter is BEING SPENT WITH THE ACTIVITY at the indicated index.
            // ------> The charter-spend policy for that activity checks all the other necessaries
            //     given that activity.

            // NOT needed; the charter-spend policy ensures the expected 
            //   ... delegate output is created when adding a spend invariant.
            // hasRightDestination : Bool = output.value == value_minted &&
            //     output.address == charterUtxo.address;

    chVal : Value = tvCharter(mph);
    hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };
    print("  --- finding required charter input ");
    charterInput : TxInput = ctx.tx.inputs.find(hasCharter);
    print ("  <-- found charter input");
    charterRedeemer : Data  = mustFindInputRedeemer(ctx, charterInput);
    // print("defaultMinter @A");

    charterRedeemer.switch{
        (index: Int, _fields: []Data) => {
            /* avoids unused-variable warning: */ _fields == _fields && 

            if (index == charterRedeemerIndex) { 
                // ok, good charter-redeemer as expected; print("ok here");
                // the charter update itself will check that there's a valid delegate output for the new delegate
                true 
            } else {  
                error("wrong charter Activity for adding spend invariant; expected redeemer #"+ 
                    charterRedeemerIndex.show()+
                     ", got "+index.show()
                )
            }
        },
        _ => error("incontheeivable!")
    } &&
    validateUutMinting(
        ctx: ctx, 
        mph: mph,
        seedTxId: seedTxId, 
        seedIdx: seedIdx, 
        purposes: []String{purpose}, 
        mkTokenName: mkUutTnFactory(seedTxId, seedIdx),
        otherMintedValue: otherMintedValue,
        needsMintDelegateApproval: needsMintDelegateApproval,
        extraMintDelegateRedeemerCheck: extraMintDelegateRedeemerCheck
    ) && if (/* more debug info? */ true) {
        print ("  -- CMH: mint UUT "+purpose+" w/ charter redeemer #"+charterRedeemerIndex.show());
        true
    } else { true } 
}

enum MinterActivity { 
    mintingCharter //0
     {
        owner: Address
        // we don't have a responsiblity to enforce delivery to the right location
        // govAuthority: RelativeDelegateLink   // not needed 
    }
    mintWithDelegateAuthorizing // 1 - delegate is handling all mints

    addingMintInvariant { //2 
        seedTxn: TxId
        seedIndex: Int
    }

    addingSpendInvariant { //3
        seedTxn: TxId
        seedIndex: Int
    }

    ForcingNewMintDelegate { //4
        seedTxn: TxId
        seedIndex: Int
    }

    CreatingNewSpendDelegate { //5
        seedTxn: TxId
        seedIndex: Int
        replacingUut: Option[ByteArray]
    }

}

