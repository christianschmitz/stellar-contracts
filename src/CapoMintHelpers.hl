module CapoMintHelpers
import {
    mkTv,
    tvCharter
} from StellarHeliosHelpers

import {
    getRefCharterDatum
} from CapoHelpers

import {
    Datum, Activity as CapoActivity
} from specializedCapo

import {
    RelativeDelegateLink,
    requiresDelegateAuthorizing
} from CapoDelegateHelpers

func hasSeedUtxo(tx: Tx, seedTxId : TxId, seedIdx: Int
    // , reason: String
) -> Bool {
    seedUtxo: TxOutputId = TxOutputId::new(
        seedTxId,
        seedIdx
    );
    assert(tx.inputs.any( (input: TxInput) -> Bool {
        input.output_id == seedUtxo
    }),  "seed utxo required for minting "
        // +reason 
        // + "\n"+seedTxId.show() + " : " + seedIdx.show()
    );

    true
}

func requiresDelegateApproval(
    ctx: ScriptContext, 
    mph: MintingPolicyHash
) -> Bool {
    Datum::CharterToken {
        _, mintDgt
    } = getRefCharterDatum(ctx, mph);

    requiresDelegateAuthorizing(
        mintDgt, 
        mph, 
        ctx
    )
}

//! pre-computes the hash-based suffix for a token name, returning
//  a function that makes Uut names with any given purpose, given the seed-txn details
func mkUutTnFactory(
    seedTxId : TxId, seedIdx : Int
) -> (String) -> String {
   
    idxBytes : ByteArray = seedIdx.serialize();
    // assert(idxBytes.length == 1, "surprise!");

    //! yuck: un-CBOR...
    rawTxId : ByteArray = seedTxId.serialize().slice(5,37);

    txoInfo : ByteArray = if (idxBytes.length > 9) { 
        // allows 9 bytes to ensure we can support 
        // the largest possible cbor encoding of txo-index integers, 
        // even though we only expect integers < 256 currently
        assert(false, 
            "expected cbor(txo index) to be at most 9 bytes, got cbor( index="+ 
             seedIdx.show() + " ).hex = " + idxBytes.show()
        );
        idxBytes // never used
    } else {
       ( rawTxId + "@".encode_utf8() )+ idxBytes
    };
    // assert(txoId.length == 34, "txId + @ + int should be length 34");
    // print( "******** txoId " + txoId.show());

    miniHash : ByteArray = txoInfo.blake2b().slice(0,6);
    // assert(miniHash.length == 6, "urgh.  slice 5? expected 12, got "+ miniHash.length.show());

    mhs: String = miniHash.show();

    // returns a function computing a lightweight prefix + miniHash
    (p: String) -> String {
        p + "-" + mhs
    }
}

func validateUutBurning(
    ctx: ScriptContext, 
    tns: []String
) -> Bool {
    tx: Tx = ctx.tx;
    mph: MintingPolicyHash = ctx.get_current_minting_policy_hash();
    Datum::CharterToken {
        _, mintDgt
    } = getRefCharterDatum(ctx, mph);

    valueBurned: Value = tx.minted;

    expectedBurn : Value = Value::sum(tns.map(
        (tn: String) -> Value {
            mkTv(mph, tn, -1)
        }
    ));
    actualBurn : Map[ByteArray]Int = valueBurned.get_policy(mph);
    hasExpectedBurn : Bool = actualBurn == expectedBurn.get_policy(mph);
    if (!hasExpectedBurn)  {
        // actualBurn.for_each( (b : ByteArray, i: Int) -> {
        //     print( "actual: " + b.show() + " " + i.show() )
        // });
        // expectedBurn.get_policy(mph).for_each( (b : ByteArray, i: Int) -> {
        //     print( "expected: " + b.show() + " " + i.show() )
        // });
        assert(false, "mismatch in UUT burn with diff:\n"
            + (expectedBurn - valueBurned).show()
        )
    };

    hasExpectedBurn && requiresDelegateAuthorizing(
        mintDgt, 
        mph, 
        ctx
    )

}

func validateUutMinting(
    ctx: ScriptContext, 
    mph: MintingPolicyHash,
    seedTxId : TxId, seedIdx : Int, 
    purposes: []String, 
    mkTokenName: (String) -> String,
    bootstrapCharter:Value = Value::new(AssetClass::ADA, 0)
) -> Bool {
    tx: Tx = ctx.tx;

    isBootstrapping : Bool = !( bootstrapCharter.is_zero() );
    delegateApproval : Bool = if ( isBootstrapping ) { 
        true 
    } else {
        // not bootstrapping; must honor the mintDelegate's authority
        Datum::CharterToken {
            _, mintDgt
        } = getRefCharterDatum(ctx, mph);

        //!!! todo: add explicit activity details in authorization
        requiresDelegateAuthorizing(
            mintDgt, 
            mph, 
            ctx
        )
    };

    valueMinted: Value = tx.minted;

    // idxBytes : ByteArray = seedIdx.bound_max(255).serialize();
    // // assert(idxBytes.length == 1, "surprise!");

    // //! yuck: un-CBOR...
    // rawTxId : ByteArray = seedTxId.serialize().slice(5,37);

    // txoId : ByteArray = (rawTxId + "@".encode_utf8() + idxBytes);
    // assert(txoId.length == 34, "txId + @ + int should be length 34");
    // // print( "******** txoId " + txoId.show());

    // miniHash : ByteArray = txoId.blake2b().slice(0,6);
    // // assert(miniHash.length == 6, "urgh.  slice 5? expected 12, got "+ miniHash.length.show());

    // tokenName1 = purpose + "." + miniHash.show();

    expectedValue : Value = Value::sum(purposes.sort((a:String, b:String) -> Bool { a == b }).map(
        (purpose: String) -> Value {
            mkTv(mph, mkTokenName(purpose))
        }
    )) + bootstrapCharter;
    // expectedMint : Map[ByteArray]Int = expectedValue.get_policy(mph);
    actualMint : Map[ByteArray]Int = valueMinted.get_policy(mph);
    // actualMint.for_each( (b : ByteArray, i: Int) -> {
    //     print( "actual: " + b.show() + " " + i.show() )
    // });

    // print("activity" + seedTxId.show() + " " + seedIdx.show() + " asset " + assetName.show());
    // expectedMint.for_each( (b : ByteArray, i: Int) -> {
    //     print( "expected: " + b.show() + " " + i.show() )
    // });
    temp : []ByteArray = actualMint.fold( (l: []ByteArray, b : ByteArray, i: Int) -> {
        l.find_safe((x : ByteArray) -> Bool { x == b }).switch{
            None => l.prepend(b),
            Some /*{x}*/ => error("UUT duplicate purpose "
                // +  x.decode_utf8()
            )
        }
    }, []ByteArray{});
    assert(temp == temp, "prevent unused var");


    expectationsMet : Bool = valueMinted  == expectedValue;

    assert(expectationsMet, "mismatch in UUT mint"
        // +";\n   ... expected "+ expectedValue.show()+
        // "   ... actual "+ valueMinted.show()+
        // "   ... diff = \n" + (expectedValue - valueMinted).show()
    );

    delegateApproval && expectationsMet &&
    hasSeedUtxo(tx, seedTxId, seedIdx
        //, "UUT "+purposes.join("+")
    )
}

enum Activity { 
    mintingCharter
     {
        owner: Address

        // we don't have a responsiblity to enforce delivery to the right location
        // govAuthority: RelativeDelegateLink   // not needed 
    }
    mintWithDelegateAuthorizing // delegate is handling all mints

    mintingUuts {
        seedTxn: TxId
        seedIndex: Int
        purposes: []String
    }

    //??? have the charter know about the UUT purposes, 
    // ... so we can limit the mint/burns to match the known list??
    burningUuts {
        tns: []String
    }

    func tvForPurpose(self, ctx: ScriptContext, purpose: String) -> Value {
        mph : MintingPolicyHash = ctx.get_current_minting_policy_hash();
        
        mkTv(mph, self.uutTnFactory()(purpose))
    }

    func uutTnFactory(self) -> (String) -> String {
        self.switch{
            mintingUuts{MUseedTxn, MUseedIndex, _} => {
                mkUutTnFactory(MUseedTxn, MUseedIndex)
            },
            // mintingCharter => {
            //     mkUutTnFactory(seedTxn, seedIndex)
            // },
            _ => error("uutTnFactory: not mintingUuts!")
        } 
    }
}
