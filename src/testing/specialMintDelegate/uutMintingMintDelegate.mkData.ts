// generated by Stellar Contracts mkDataBridgeGenerator
// based on types defined in BasicDelegate (src/delegation/BasicDelegate.hl)

import { Cast } from "@helios-lang/contract-utils"
import type { UplcData } from "@helios-lang/uplc";
import type { 
    IntLike,
    ByteArrayLike,
 } from "@helios-lang/codec-utils";
import type {
    Address,
    AssetClass,
    DatumHash,
    MintingPolicyHash,
    PubKey,
    PubKeyHash,
    ScriptHash,
    SpendingCredential,
    StakingCredential,
    StakingHash,
    StakingValidatorHash,
    TimeRange,
    TxId,
    TxInput,
    TxOutput,
    TxOutputId,
    TxOutputDatum,
    ValidatorHash,
    Value,
} from "@helios-lang/ledger";

import {
    DelegationDetail,
    SampleStruct,
    SomeEnum$hasNestedFields,
    SomeEnum$hasRecursiveFields,
    SomeEnum,
    DelegateDatum$MultiFieldVariant,
    DelegateDatum$MultiFieldNestedThings,
    DelegateDatum,
    CapoLifecycleActivity$CreatingDelegate,
    CapoLifecycleActivity,
    DelegateLifecycleActivity$ReplacingMe,
    DelegateLifecycleActivity,
    SpendingActivity,
    MintingActivity$mintingUuts,
    MintingActivity,
    BurningActivity,
    DelegateActivity$CreatingDelegatedData,
    DelegateActivity$UpdatingDelegatedData,
    DelegateActivity$DeletingDelegatedData,
    DelegateActivity
} from "./uutMintingMintDelegate.hlbundle.js"
import { someDataMaker } from "../../helios/dataBridge/someDataMaker.js"
import { tagOnly } from "../../helios/HeliosScriptBundle.js"
import {hasSeed} from "../../StellarContract.js"

export default class mkDatumBridgeBasicDelegate extends someDataMaker {
    
    datum: DelegateDatumHelper = new DelegateDatumHelper(this.bundle)   // datumAccessor
    DelegateDatum: DelegateDatumHelper = this.datum;


}

class SomeEnumHelper extends someDataMaker {
    enumCast = new Cast<
       
        | { justATag: /*minEnumVariant*/ tagOnly }
        | { justAnInt: /*minEnumVariant*/ bigint /*singleVariantField*/  }
        | { oneNestedStruct: /*minEnumVariant*/ SampleStruct /*singleVariantField*/  }
        | { hasNestedFields: /*minEnumVariant*/ SomeEnum$hasNestedFields }
        | { hasRecursiveFields: /*minEnumVariant*/ SomeEnum$hasRecursiveFields }, 
       
        | { justATag: /*minEnumVariant*/ tagOnly }
        | { justAnInt: /*minEnumVariant*/ IntLike /*singleVariantField*/  }
        | { oneNestedStruct: /*minEnumVariant*/ SampleStructLike /*singleVariantField*/  }
        | { hasNestedFields: /*minEnumVariant*/ SomeEnum$hasNestedFieldsLike }
        | { hasRecursiveFields: /*minEnumVariant*/ SomeEnum$hasRecursiveFieldsLike }
   >(SomeEnumSchema, { isMainnet: true });
    get justATag() {
        return this.enumCast.toUplcData({ justATag: {} });
    }

    justAnInt(
        value: IntLike
    ) {
        return this.enumCast.toUplcData({ 
           justAnInt: { m: value } 
        });
    }

    oneNestedStruct(
        value: {
    a: /*minStructField*/ IntLike
    b: /*minStructField*/ Map<string, number[]>
    c: /*minStructField*/ Array<boolean>
    d: /*minStructField*/ Option<UplcData>
}

    ) {
        return this.enumCast.toUplcData({ 
           oneNestedStruct: { m: value } 
        });
    }

    hasNestedFields(fields: { 
        m: {
    a: /*minStructField*/ IntLike
    b: /*minStructField*/ Map<string, number[]>
    c: /*minStructField*/ Array<boolean>
    d: /*minStructField*/ Option<UplcData>
},
        n: IntLike
    }) {
        return this.enumCast.toUplcData({
            hasNestedFields: fields 
        });
    }

    hasRecursiveFields(fields: { 
        placeholder: IntLike,
        ph2: string
    }) {
        return this.enumCast.toUplcData({
            hasRecursiveFields: fields 
        });
    }
}


class DelegateDatumHelper extends someDataMaker {
    enumCast = new Cast<
       
        | { IsDelegation: /*minEnumVariant*/ DelegationDetail /*singleVariantField*/  }
        | { ScriptReference: /*minEnumVariant*/ tagOnly }
        | { SingleDataElement: /*minEnumVariant*/ string /*singleVariantField*/  }
        | { SingleNestedStruct: /*minEnumVariant*/ SampleStruct /*singleVariantField*/  }
        | { HasNestedEnum: /*minEnumVariant*/ SomeEnum /*singleVariantField*/  }
        | { MultiFieldVariant: /*minEnumVariant*/ DelegateDatum$MultiFieldVariant }
        | { MultiFieldNestedThings: /*minEnumVariant*/ DelegateDatum$MultiFieldNestedThings }, 
       
        | { IsDelegation: /*minEnumVariant*/ DelegationDetailLike /*singleVariantField*/  }
        | { ScriptReference: /*minEnumVariant*/ tagOnly }
        | { SingleDataElement: /*minEnumVariant*/ string /*singleVariantField*/  }
        | { SingleNestedStruct: /*minEnumVariant*/ SampleStructLike /*singleVariantField*/  }
        | { HasNestedEnum: /*minEnumVariant*/ SomeEnumLike /*singleVariantField*/  }
        | { MultiFieldVariant: /*minEnumVariant*/ DelegateDatum$MultiFieldVariantLike }
        | { MultiFieldNestedThings: /*minEnumVariant*/ DelegateDatum$MultiFieldNestedThingsLike }
   >(DelegateDatumSchema, { isMainnet: true });
    IsDelegation(
        value: {
    capoAddr: /*minStructField*/ Address | string
    mph: /*minStructField*/ MintingPolicyHash | string | number[]
    tn: /*minStructField*/ number[]
}

    ) {
        return this.enumCast.toUplcData({ 
           IsDelegation: { dd: value } 
        });
    }

    get ScriptReference() {
        return this.enumCast.toUplcData({ ScriptReference: {} });
    }

    SingleDataElement(
        value: string
    ) {
        return this.enumCast.toUplcData({ 
           SingleDataElement: { aString: value } 
        });
    }

    SingleNestedStruct(
        value: {
    a: /*minStructField*/ IntLike
    b: /*minStructField*/ Map<string, number[]>
    c: /*minStructField*/ Array<boolean>
    d: /*minStructField*/ Option<UplcData>
}

    ) {
        return this.enumCast.toUplcData({ 
           SingleNestedStruct: { aStruct: value } 
        });
    }

    HasNestedEnum(
        value: 
        | { justATag: /*minEnumVariant*/ tagOnly }
        | { justAnInt: /*minEnumVariant*/ IntLike /*singleVariantField*/  }
        | { oneNestedStruct: /*minEnumVariant*/ SampleStructLike /*singleVariantField*/  }
        | { hasNestedFields: /*minEnumVariant*/ SomeEnum$hasNestedFieldsLike }
        | { hasRecursiveFields: /*minEnumVariant*/ SomeEnum$hasRecursiveFieldsLike }
    ) {
        return this.enumCast.toUplcData({ 
           HasNestedEnum: { nested: value } 
        });
    }

    MultiFieldVariant(fields: { 
        field1: IntLike,
        field2: string
    }) {
        return this.enumCast.toUplcData({
            MultiFieldVariant: fields 
        });
    }

    MultiFieldNestedThings(fields: { 
        nestedStruct: {
    a: /*minStructField*/ IntLike
    b: /*minStructField*/ Map<string, number[]>
    c: /*minStructField*/ Array<boolean>
    d: /*minStructField*/ Option<UplcData>
},
        nestedEnumMaybe: Option<
        | { justATag: /*minEnumVariant*/ tagOnly }
        | { justAnInt: /*minEnumVariant*/ IntLike /*singleVariantField*/  }
        | { oneNestedStruct: /*minEnumVariant*/ SampleStructLike /*singleVariantField*/  }
        | { hasNestedFields: /*minEnumVariant*/ SomeEnum$hasNestedFieldsLike }
        | { hasRecursiveFields: /*minEnumVariant*/ SomeEnum$hasRecursiveFieldsLike }>
    }) {
        return this.enumCast.toUplcData({
            MultiFieldNestedThings: fields 
        });
    }
}


class CapoLifecycleActivityHelper extends someDataMaker {
    enumCast = new Cast<
       
        | { CreatingDelegate: /*minEnumVariant*/ CapoLifecycleActivity$CreatingDelegate }, 
       
        | { CreatingDelegate: /*minEnumVariant*/ CapoLifecycleActivity$CreatingDelegateLike }
   >(CapoLifecycleActivitySchema, { isMainnet: true });
    /**
     * generates UplcData, given a transaction-context with a seed utxo and other field details
     * @remarks
     * See the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.     */
    CreatingDelegate(value: hasSeed, fields: { 
        purpose: string 
    } ) : UplcData
    /**
    * generates UplcData with raw seed details included in fields.
    */
    CreatingDelegate(fields: {
        seed: TxOutputId | string,
        purpose: string 
    } ) : UplcData
    CreatingDelegate(
        seedOrUf: hasSeed | { 
            seed: TxOutputId | string,
            purpose: string
        }, 
        filteredFields?: { 
            purpose: string
    }) : UplcData {
        if (filteredFields) {
            const seedTxOutputId = this.getSeed(seedOrUf as hasSeed);
            return this.enumCast.toUplcData({
                CreatingDelegate: { seed: seedTxOutputId, ...filteredFields } 
            });
        } else {
            const fields = seedOrUf; 
            return this.enumCast.toUplcData({
                CreatingDelegate: fields 
            });
        }
    }

}


class DelegateLifecycleActivityHelper extends someDataMaker {
    enumCast = new Cast<
       
        | { ReplacingMe: /*minEnumVariant*/ DelegateLifecycleActivity$ReplacingMe }
        | { Retiring: /*minEnumVariant*/ tagOnly }
        | { ValidatingSettings: /*minEnumVariant*/ tagOnly }, 
       
        | { ReplacingMe: /*minEnumVariant*/ DelegateLifecycleActivity$ReplacingMeLike }
        | { Retiring: /*minEnumVariant*/ tagOnly }
        | { ValidatingSettings: /*minEnumVariant*/ tagOnly }
   >(DelegateLifecycleActivitySchema, { isMainnet: true });
    /**
     * generates UplcData, given a transaction-context with a seed utxo and other field details
     * @remarks
     * See the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.     */
    ReplacingMe(value: hasSeed, fields: { 
        purpose: string 
    } ) : UplcData
    /**
    * generates UplcData with raw seed details included in fields.
    */
    ReplacingMe(fields: {
        seed: TxOutputId | string,
        purpose: string 
    } ) : UplcData
    ReplacingMe(
        seedOrUf: hasSeed | { 
            seed: TxOutputId | string,
            purpose: string
        }, 
        filteredFields?: { 
            purpose: string
    }) : UplcData {
        if (filteredFields) {
            const seedTxOutputId = this.getSeed(seedOrUf as hasSeed);
            return this.enumCast.toUplcData({
                ReplacingMe: { seed: seedTxOutputId, ...filteredFields } 
            });
        } else {
            const fields = seedOrUf; 
            return this.enumCast.toUplcData({
                ReplacingMe: fields 
            });
        }
    }


    get Retiring() {
        return this.enumCast.toUplcData({ Retiring: {} });
    }

    get ValidatingSettings() {
        return this.enumCast.toUplcData({ ValidatingSettings: {} });
    }
}


class SpendingActivityHelper extends someDataMaker {
    enumCast = new Cast<
       
        | { _placeholder2SA: /*minEnumVariant*/ number[] /*singleVariantField*/  }
        | { mockWorkingSpendActivity: /*minEnumVariant*/ number[] /*singleVariantField*/  }, 
       
        | { _placeholder2SA: /*minEnumVariant*/ number[] /*singleVariantField*/  }
        | { mockWorkingSpendActivity: /*minEnumVariant*/ number[] /*singleVariantField*/  }
   >(SpendingActivitySchema, { isMainnet: true });
    _placeholder2SA(
        value: number[]
    ) {
        return this.enumCast.toUplcData({ 
           _placeholder2SA: { id: value } 
        });
    }

    mockWorkingSpendActivity(
        value: number[]
    ) {
        return this.enumCast.toUplcData({ 
           mockWorkingSpendActivity: { id: value } 
        });
    }
}


class MintingActivityHelper extends someDataMaker {
    enumCast = new Cast<
       
        | { mintingUuts: /*minEnumVariant*/ MintingActivity$mintingUuts }
        | { mockOtherActivity: /*minEnumVariant*/ tagOnly }, 
       
        | { mintingUuts: /*minEnumVariant*/ MintingActivity$mintingUutsLike }
        | { mockOtherActivity: /*minEnumVariant*/ tagOnly }
   >(MintingActivitySchema, { isMainnet: true });
    /**
     * generates UplcData, given a transaction-context with a seed utxo and other field details
     * @remarks
     * See the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.     */
    mintingUuts(value: hasSeed, fields: { 
        purposes: Array<string> 
    } ) : UplcData
    /**
    * generates UplcData with raw seed details included in fields.
    */
    mintingUuts(fields: {
        seed: TxOutputId | string,
        purposes: Array<string> 
    } ) : UplcData
    mintingUuts(
        seedOrUf: hasSeed | { 
            seed: TxOutputId | string,
            purposes: Array<string>
        }, 
        filteredFields?: { 
            purposes: Array<string>
    }) : UplcData {
        if (filteredFields) {
            const seedTxOutputId = this.getSeed(seedOrUf as hasSeed);
            return this.enumCast.toUplcData({
                mintingUuts: { seed: seedTxOutputId, ...filteredFields } 
            });
        } else {
            const fields = seedOrUf; 
            return this.enumCast.toUplcData({
                mintingUuts: fields 
            });
        }
    }


    get mockOtherActivity() {
        return this.enumCast.toUplcData({ mockOtherActivity: {} });
    }
}


class BurningActivityHelper extends someDataMaker {
    enumCast = new Cast<
       
        | { _placeholder2BA: /*minEnumVariant*/ number[] /*singleVariantField*/  }, 
       
        | { _placeholder2BA: /*minEnumVariant*/ number[] /*singleVariantField*/  }
   >(BurningActivitySchema, { isMainnet: true });
    _placeholder2BA(
        value: number[]
    ) {
        return this.enumCast.toUplcData({ 
           _placeholder2BA: { recId: value } 
        });
    }
}


class DelegateActivityHelper extends someDataMaker {
    enumCast = new Cast<
       
        | { CapoLifecycleActivities: /*minEnumVariant*/ CapoLifecycleActivity /*singleVariantField*/  }
        | { DelegateLifecycleActivities: /*minEnumVariant*/ DelegateLifecycleActivity /*singleVariantField*/  }
        | { SpendingActivities: /*minEnumVariant*/ SpendingActivity /*singleVariantField*/  }
        | { MintingActivities: /*minEnumVariant*/ MintingActivity /*singleVariantField*/  }
        | { BurningActivities: /*minEnumVariant*/ BurningActivity /*singleVariantField*/  }
        | { CreatingDelegatedData: /*minEnumVariant*/ DelegateActivity$CreatingDelegatedData }
        | { UpdatingDelegatedData: /*minEnumVariant*/ DelegateActivity$UpdatingDelegatedData }
        | { DeletingDelegatedData: /*minEnumVariant*/ DelegateActivity$DeletingDelegatedData }
        | { MultipleDelegateActivities: /*minEnumVariant*/ Array<UplcData> /*singleVariantField*/  }, 
       
        | { CapoLifecycleActivities: /*minEnumVariant*/ CapoLifecycleActivityLike /*singleVariantField*/  }
        | { DelegateLifecycleActivities: /*minEnumVariant*/ DelegateLifecycleActivityLike /*singleVariantField*/  }
        | { SpendingActivities: /*minEnumVariant*/ SpendingActivityLike /*singleVariantField*/  }
        | { MintingActivities: /*minEnumVariant*/ MintingActivityLike /*singleVariantField*/  }
        | { BurningActivities: /*minEnumVariant*/ BurningActivityLike /*singleVariantField*/  }
        | { CreatingDelegatedData: /*minEnumVariant*/ DelegateActivity$CreatingDelegatedDataLike }
        | { UpdatingDelegatedData: /*minEnumVariant*/ DelegateActivity$UpdatingDelegatedDataLike }
        | { DeletingDelegatedData: /*minEnumVariant*/ DelegateActivity$DeletingDelegatedDataLike }
        | { MultipleDelegateActivities: /*minEnumVariant*/ Array<UplcData> /*singleVariantField*/  }
   >(DelegateActivitySchema, { isMainnet: true });
    CapoLifecycleActivities(
        value: 
        | { CreatingDelegate: /*minEnumVariant*/ CapoLifecycleActivity$CreatingDelegateLike }
    ) {
        return this.enumCast.toUplcData({ 
           CapoLifecycleActivities: { activity: value } 
        });
    }

    DelegateLifecycleActivities(
        value: 
        | { ReplacingMe: /*minEnumVariant*/ DelegateLifecycleActivity$ReplacingMeLike }
        | { Retiring: /*minEnumVariant*/ tagOnly }
        | { ValidatingSettings: /*minEnumVariant*/ tagOnly }
    ) {
        return this.enumCast.toUplcData({ 
           DelegateLifecycleActivities: { activity: value } 
        });
    }

    SpendingActivities(
        value: 
        | { _placeholder2SA: /*minEnumVariant*/ number[] /*singleVariantField*/  }
        | { mockWorkingSpendActivity: /*minEnumVariant*/ number[] /*singleVariantField*/  }
    ) {
        return this.enumCast.toUplcData({ 
           SpendingActivities: { activity: value } 
        });
    }

    MintingActivities(
        value: 
        | { mintingUuts: /*minEnumVariant*/ MintingActivity$mintingUutsLike }
        | { mockOtherActivity: /*minEnumVariant*/ tagOnly }
    ) {
        return this.enumCast.toUplcData({ 
           MintingActivities: { activity: value } 
        });
    }

    BurningActivities(
        value: 
        | { _placeholder2BA: /*minEnumVariant*/ number[] /*singleVariantField*/  }
    ) {
        return this.enumCast.toUplcData({ 
           BurningActivities: { activity: value } 
        });
    }

    /**
     * generates UplcData, given a transaction-context with a seed utxo and other field details
     * @remarks
     * See the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.     */
    CreatingDelegatedData(value: hasSeed, fields: { 
        dataType: string 
    } ) : UplcData
    /**
    * generates UplcData with raw seed details included in fields.
    */
    CreatingDelegatedData(fields: {
        seed: TxOutputId | string,
        dataType: string 
    } ) : UplcData
    CreatingDelegatedData(
        seedOrUf: hasSeed | { 
            seed: TxOutputId | string,
            dataType: string
        }, 
        filteredFields?: { 
            dataType: string
    }) : UplcData {
        if (filteredFields) {
            const seedTxOutputId = this.getSeed(seedOrUf as hasSeed);
            return this.enumCast.toUplcData({
                CreatingDelegatedData: { seed: seedTxOutputId, ...filteredFields } 
            });
        } else {
            const fields = seedOrUf; 
            return this.enumCast.toUplcData({
                CreatingDelegatedData: fields 
            });
        }
    }


    UpdatingDelegatedData(fields: { 
        dataType: string,
        recId: number[]
    }) {
        return this.enumCast.toUplcData({
            UpdatingDelegatedData: fields 
        });
    }

    DeletingDelegatedData(fields: { 
        dataType: string,
        recId: number[]
    }) {
        return this.enumCast.toUplcData({
            DeletingDelegatedData: fields 
        });
    }

    MultipleDelegateActivities(
        value: Array<UplcData>
    ) {
        return this.enumCast.toUplcData({ 
           MultipleDelegateActivities: { activities: value } 
        });
    }
}



