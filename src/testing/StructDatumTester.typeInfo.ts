// generated by StellarHeliosProject using Stellar heliosRollupTypeGen()
// recommended: CHECK THIS FILE INTO YOUR VERSION CONTROL SYSTEM
//   ... and keep checking in the changes as your on-chain types evolve.
//
// NOTE: this file is auto-generated; do not edit directly

import type { UplcData } from "@helios-lang/uplc";
import type {
    Address,
    AssetClass,
    DatumHash,
    MintingPolicyHash,
    PubKey,
    PubKeyHash,
    ScriptHash,
    SpendingCredential,
    StakingCredential,
    StakingValidatorHash,
    TimeRange,
    TxId,
    TxInput,
    TxOutput,
    TxOutputId,
    InlineTxOutputDatum,
    ValidatorHash,
    Value,
} from "@helios-lang/ledger";
import type { Cast } from "@helios-lang/contract-utils";
import type { 
    IntLike,
    // BytesLike,
 } from "@helios-lang/codec-utils";

 type TimeLike = IntLike;
 
        
import type {
    CapoHeliosBundle,
    CapoDelegateBundle,
    minimalData,
    HeliosScriptBundle,
    EnumTypeMeta,
    singleEnumVariantMeta,
    tagOnly,
    IntersectedEnum
} from "@donecollectively/stellar-contracts"


export type struct3 = {
    thirdLevelF1: /*minStructField*/ bigint
}

export type Ergostruct3 = struct3/*like canon-other*/
export type struct3Like = {
    thirdLevelF1: /*minStructField*/ IntLike
}


export type OtherStruct = {
    secondLevelF1: /*minStructField*/ bigint
    secondLevelF2: /*minStructField*/ struct3
}

export type ErgoOtherStruct = {
    secondLevelF1: /*minStructField*/ bigint
    secondLevelF2: /*minStructField*/ Ergostruct3
}

export type OtherStructLike = {
    secondLevelF1: /*minStructField*/ IntLike
    secondLevelF2: /*minStructField*/ struct3Like
}


export type SomeKindaEnumMeta = EnumTypeMeta<
    {module: "StructDatumTester", enumName: "SomeKindaEnum"}, {
        case1: singleEnumVariantMeta<SomeKindaEnumMeta, "case1",
            "Constr#0", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        case2: singleEnumVariantMeta<SomeKindaEnumMeta, "case2",
            "Constr#1", "singletonField", /* implied wrapper { f1: ... } for singleVariantField */ 
			bigint   , "noSpecialFlags"
        >
    }
>;


/**
 * SomeKindaEnum enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **2 variant(s)** of the SomeKindaEnum enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `SomeKindaEnumHelper` class
 *     for generating UPLC data for this enum type
 */
export type SomeKindaEnum = 
        | { case1: tagOnly /*minEnumVariant*/ }
        | { case2: /* implied wrapper { f1: ... } for singleVariantField */ 
			bigint    /*minEnumVariant*/ }

export type ErgoSomeKindaEnum = IntersectedEnum<SomeKindaEnum/*like canon enum*/>

/**
 * SomeKindaEnum enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **2 variant(s)** of the SomeKindaEnum enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `SomeKindaEnumHelper` class
 *     for generating UPLC data for this enum type
 *
 * ### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 */
export type SomeKindaEnumLike = IntersectedEnum<
        | { case1: tagOnly /*minEnumVariant*/ }
        | { case2: /* implied wrapper { f1: ... } for singleVariantField */ 
			IntLike    /*minEnumVariant*/ }
>

export type DatumStruct = {
    field1: /*minStructField*/ bigint
    field2: /*minStructField*/ string
    field3: /*minStructField*/ Map<string, OtherStruct>
    field4: /*minStructField*/ SomeKindaEnum
}

export type ErgoDatumStruct = {
    field1: /*minStructField*/ bigint
    field2: /*minStructField*/ string
    field3: /*minStructField*/ Map<string, ErgoOtherStruct>
    field4: /*minStructField*/ ErgoSomeKindaEnum
}

export type DatumStructLike = {
    field1: /*minStructField*/ IntLike
    field2: /*minStructField*/ string
    field3: /*minStructField*/ Map<string, OtherStructLike>
    field4: /*minStructField*/ SomeKindaEnumLike
}


