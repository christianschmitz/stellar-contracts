spending BaselineCapo

// needed in helios 0.13: defaults
const mph : MintingPolicyHash = MintingPolicyHash::new(#1234)
const rev : Int = 1

import { 
    RelativeDelegateLink,
    requiresValidDelegate
} from CapoDelegateHelpers

import {
    mkTv,
    txHasOutput,
    didSign,
    didSignInCtx
} from StellarHeliosHelpers

import { Datum, Redeemer } from specializedCapo


func requiresAuthorization(ctx: ScriptContext, datum: Datum) -> Bool {
    Datum::CharterToken{
        RelativeDelegateLink{uutName, _, _, _}
    } = datum;

    assert(txHasOutput(ctx.tx,  mkTv(mph, uutName)),
        "missing required authZor token "+uutName
    );
    true
}

func getCharterOutput(tx: Tx) -> TxOutput {
    charterTokenValue : Value = Value::new(
        AssetClass::new(mph, "charter".encode_utf8()), 
        1
    );
    tx.outputs.find_safe(
        (txo : TxOutput) -> Bool {
            txo.value >= charterTokenValue
        }
    ).switch{
        None => error("this could only happen if the charter token is burned."),
        Some{o} => o
    }
}

func notUpdatingCharter(redeemer: Redeemer) -> Bool { redeemer.switch {
    updatingCharter => false,  
    _ => true
}}

func preventCharterChange(ctx: ScriptContext, datum: Datum::CharterToken) -> Bool {
    tx: Tx = ctx.tx;

    charterOutput : TxOutput = getCharterOutput(tx);

    cvh : ValidatorHash = ctx.get_current_validator_hash();
    myself : Credential = Credential::new_validator(cvh);
    if (charterOutput.address.credential != myself) {
        actual : String = charterOutput.address.credential.switch{
            PubKey{pkh} => "pkh:ðŸ”‘#" + pkh.show(),
            Validator{vh} => "val:ðŸ“œ#:" + vh.show()
        };
        error(
            "charter token must be returned to the contract " + cvh.show() +
            "... but was sent to " +actual
        )
    };

    Datum::CharterToken{
        RelativeDelegateLink{uut, strategy, reqdAddress, addressesHint}
    } = datum;
    Datum::CharterToken{
        RelativeDelegateLink{newUut, newStrategy, newReqdAddress, newAddressesHint}
    } = Datum::from_data( 
        charterOutput.datum.get_inline_data() 
    );
    if ( !(
        newUut  == uut &&
        newStrategy == strategy  &&
        newReqdAddress == reqdAddress &&
        newAddressesHint == addressesHint
    )) { 
        error("invalid update to charter settings") 
    };

    true
}

func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    // now: Time = tx.time_range.start;
    
    allDatumSpecificChecks: Bool = datum.switch {
        ctd : CharterToken => {
            // throws if bad
            if(notUpdatingCharter(redeemer)) { 
                preventCharterChange(ctx, ctd)
            } else {
                true // "maybe", really
            }
        },
        _ => {
            redeemer.switch {
                spendingDatum => datum.validateSpend(ctx),
                _ => true
            }
        }            
    };
    allRedeemerSpecificChecks : Bool = redeemer.switch {
        updatingCharter => {             
            charterOutput : TxOutput = getCharterOutput(tx);
            newDatum = Datum::from_data( 
                charterOutput.datum.get_inline_data() 
            );
            Datum::CharterToken{delegate} = newDatum;

            requiresValidDelegate(delegate, mph, ctx) &&
            requiresAuthorization(ctx, datum)
        },
        usingAuthority => {
            // by definition, we're truly notUpdatingCharter(redeemer) 
            datum.switch {
                 // throws if bad
                ctd : CharterToken => requiresAuthorization(ctx, ctd),
                _ => error("wrong use of usingAuthority action for non-CharterToken datum")
            }
        },
        _ => redeemer.allowActivity(datum, ctx)
    };

    assert(allDatumSpecificChecks, "datum-check fail");
    assert(allRedeemerSpecificChecks, "redeeemer-check fail");

    //! retains mph in parameterization
    assert(
        ( allDatumSpecificChecks && allRedeemerSpecificChecks ) ||
            // this should never execute (much less fail), yet it also shouldn't be optimized out.
             mph.serialize() != datum.serialize(), 
        "unreachable"
    ); 

    allDatumSpecificChecks && 
    allRedeemerSpecificChecks &&
    tx.serialize() != datum.serialize()
}
