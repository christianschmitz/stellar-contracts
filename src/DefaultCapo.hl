spending Capo

// needed in helios 0.13: defaults
const mph : MintingPolicyHash = MintingPolicyHash::new(#1234)
const rev : Int = 1
const devGen : Int = 0
const isDev: Bool = false

// import {
//     tvCharter
// } from CapoHelpers

import { 
    RelativeDelegateLink,
    requiresValidDelegateOutput,
    requiresNoDelegateInput
} from CapoDelegateHelpers

import {
    tvCharter,
    mkTv,
    didSign,
    didSignInCtx
} from StellarHeliosHelpers

import { 
    Datum, 
    Activity
 } from specializedCapo

/**
 * 
 */
func requiresAuthorization(ctx: ScriptContext, datum: Datum) -> Bool {
    Datum::CharterToken{
            /*spendDgt*/ _,  
            /* spendInvariants */ _,
            /* mintDgt */ _, 
            /* mintInvariants */ _, 
        govDelegateLink
    } = datum;

    requiresValidDelegateOutput(govDelegateLink, mph, ctx)
}

func getCharterOutput(tx: Tx) -> TxOutput {
    charterTokenValue : Value = Value::new(
        AssetClass::new(mph, "charter".encode_utf8()), 
        1
    );
    tx.outputs.find_safe(
        (txo : TxOutput) -> Bool {
            txo.value >= charterTokenValue
        }
    ).switch{
        None => error("this could only happen if the charter token is burned."),
        Some{o} => o
    }
}

func notUpdatingCharter(activity: Activity) -> Bool { activity.switch {
    updatingCharter => false,  
    _ => true
}}

func preventCharterChange(ctx: ScriptContext, datum: Datum::CharterToken) -> Bool {
    tx: Tx = ctx.tx;

    charterOutput : TxOutput = getCharterOutput(tx);

    cvh : ValidatorHash = ctx.get_current_validator_hash();
    myself : Credential = Credential::new_validator(cvh);
    if (charterOutput.address.credential != myself) {
        error("charter token must be returned to the contract ")
        // actual : String = charterOutput.address.credential.switch{
        //     PubKey{pkh} => "pkh:ðŸ”‘#" + pkh.show(),
        //     Validator{vh} => "val:ðŸ“œ#:" + vh.show()
        // };
        // error(
        //     "charter token must be returned to the contract " + cvh.show() +
        //     "... but was sent to " +actual
        // )
    };

    Datum::CharterToken{
        spendDelegate,
        spendInvariants,
        mintDelegate,
        mintInvariants,
        govDelegate
    } = datum;
    Datum::CharterToken{
        newSpendDelegate,
        newSpendInvariants,
        newMintDelegate,
        newMintInvariants,
        newGovDelegate
    } = Datum::from_data( 
        charterOutput.datum.get_inline_data() 
    );
    if ( !(
        newGovDelegate == govDelegate &&
        newMintDelegate == mintDelegate &&
        newSpendDelegate == spendDelegate &&
        newMintInvariants == mintInvariants &&
        newSpendInvariants == spendInvariants
    )) { 
        error("invalid update to charter settings") 
    };

    true
}

func checkpoint(s: String) -> Bool {
    print("checkpoint: " + s);
    true
}

func main(datum: Datum, activity: Activity, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    // now: Time = tx.time_range.start;
    print("hi from capo");

    if (isDev) {
        print("is dev @gen " + devGen.show() )
    };
    
    allDatumSpecificChecks: Bool = datum.switch {
        ctd : CharterToken => {
            // throws if bad
            if (notUpdatingCharter(activity)) { 
                preventCharterChange(ctx, ctd)
            } else {
                true // "maybe", really
            }
        },

        scriptRef : ScriptReference => {
            // only here to ensure specializations are properly arranged
            assert(true || (scriptRef == scriptRef), "never");
            true
        },

        _ => { // delegates to specialization's Datum::validateSpend() method.
            datum.validateSpend(ctx, mph)
        }
    };

    // the normal case for validation is to use Datum-specific checks.  
    // however, this section allows activity-specific checks to be included, so extensions aren't painted into a corner.
    allActivitySpecificChecks : Bool = activity.switch {
        updatingCharter => {
            // print("hi from updatingCharter");

            charterOutput : TxOutput = getCharterOutput(tx);
            newDatum = Datum::from_data( 
                charterOutput.datum.get_inline_data() 
            );
            Datum::CharterToken{                
                spendDelegate, 
                spendInvariants,
                mintDelegate, 
                mintInvariants,
                govDelegate
            } = newDatum;

            Datum::CharterToken{
                oldSpendDelegate, 
                oldSpendInvariants, 
                oldMintDelegate, 
                oldMintInvariants,
                /* _oldGovDelegate */ _ 
            } = datum;

            mustNotModifyMintInvariants : Bool =  ( mintInvariants == oldMintInvariants );
            mustNotModifySpendInvariants : Bool = ( spendInvariants == oldSpendInvariants );

            unchangedSpendDgt : Bool = ( spendDelegate.serialize() == oldSpendDelegate.serialize() );
            unchangedMintDgt : Bool = ( mintDelegate.serialize() == oldMintDelegate.serialize() );

            print("is spendDgt unchanged? " + unchangedSpendDgt.show() +
                "\n  - old: "+ oldSpendDelegate.uutName + " = " + oldSpendDelegate.strategyName +
                " => "+  oldSpendDelegate.delegateValidatorHash.switch{Some{v} => v.show(), None => " (any addr)"} +
               "\n  - new: "+ spendDelegate.uutName + " = " + spendDelegate.strategyName +
                " => "+ spendDelegate.delegateValidatorHash.switch{Some{v} => v.show(), None => " (any addr)"} 
            );
            print("is mintDgt unchanged?  " + unchangedMintDgt.show() + 
                "\n  - old: "+ oldMintDelegate.uutName + " = " + oldMintDelegate.strategyName +
                " => "+  oldMintDelegate.delegateValidatorHash.switch{Some{v} => v.show(), None => " (any addr)"} +
                "\n  - new: "+ mintDelegate.uutName + " = " + mintDelegate.strategyName +
                " => "+ mintDelegate.delegateValidatorHash.switch{Some{v} => v.show(), None => " (any addr)"}
             );

            // govDelegate is always spent, so we always check its destination is kosher.
            requiresValidDelegateOutput(govDelegate, mph, ctx) &&
            checkpoint("1") &&
            if (unchangedMintDgt) {
                // unchanged mintDgt must not be included in the tx
                checkpoint("2b") &&
                requiresNoDelegateInput(mintDelegate, mph, ctx)
            } else {
                //  the new one has to go to the right place
                checkpoint("2a") &&
                 requiresValidDelegateOutput(mintDelegate, mph, ctx)
            } && 
            checkpoint("3") &&
            if ( unchangedSpendDgt) {
                // unchanged spendDgt must not be included in the tx
                checkpoint("4b") &&
                requiresNoDelegateInput(spendDelegate, mph, ctx)
            } else {
                //  the new one has to go to the right place
                checkpoint("4a") &&
                requiresValidDelegateOutput(spendDelegate, mph, ctx)
            } &&
            checkpoint("5") &&
            mustNotModifyMintInvariants &&
            mustNotModifySpendInvariants &&
            requiresAuthorization(ctx, datum) &&
            checkpoint("6")
        },

        retiringRefScript => {
            // the ref script is being spent:
            isSpendingRefScript : Bool = datum.switch{
                ScriptReference => true,
                _ => error("wrong use of retiringRefScript action for non-ScriptRef datum")
            };

            hasGovAuthority : Bool = datum.hasCharterRefInput(
                ctx, mph
            ).switch{
                None => error("no reqd charter ref"),
                Some {Datum::CharterToken{
                    /*spendDgt*/ _,  
                    /* spendInvariants */ _,
                    /* mintDgt */ _, 
                    /* mintInvariants */ _, 
                    govAuthority
                }} => requiresValidDelegateOutput(govAuthority, mph, ctx)
             };

             isSpendingRefScript && 
             hasGovAuthority &&
             true
             // no other constraints; the ref script could be re-created or
             // replaced with a new one, or simply destroyed.
        },

        usingAuthority => {
            // by definition, we're truly notUpdatingCharter(activity) 
            datum.switch {
                 // throws if bad
                ctd : CharterToken => requiresAuthorization(ctx, ctd),
                _ => error("wrong use of usingAuthority action for non-CharterToken datum")
            }
        },
        // defers to the specialization's Activity::allowActivity() method for checking other activities
        _ => activity.allowActivity(datum, ctx, mph)
    };

    assert(allDatumSpecificChecks, "some datum-check failed");
    assert(allActivitySpecificChecks, "some redeeemer-check failed");

    //! retains mph in parameterization
    assert(
        ( allDatumSpecificChecks && allActivitySpecificChecks ) ||
            // this should never execute (much less fail), yet it also shouldn't be optimized out.
             mph.serialize() /* never */ == datum.serialize(), 
        "unreachable"
    ); 

    allDatumSpecificChecks && 
    allActivitySpecificChecks &&
    tx.serialize() != datum.serialize()
}
