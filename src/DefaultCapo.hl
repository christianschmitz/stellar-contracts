spending Capo

// needed in helios 0.13: defaults
const mph : MintingPolicyHash = MintingPolicyHash::new(#1234)
const rev : Int = 1
const devGen : Int = 0
const isDev: Bool = false

// import {
//     tvCharter
// } from CapoHelpers

import { 
    AbstractDelegateActivitiesEnum,
    requiresNoDelegateInput,
    requiresValidDelegateOutput,
    RelativeDelegateLink
} from CapoDelegateHelpers

import {
    TODO,
    mustFindInputRedeemer,
    outputAndDatum,
    tvCharter,
    mkTv,
    didSign,
    didSignInCtx
} from StellarHeliosHelpers

import {
    getTxCharterDatum,
    mustHaveGovAuthority,
    CapoDatum,
    CapoActivity
} from CapoHelpers

import {
    capoSettings
} from CustomCapoSettings

func requiresAuthorization(ctx: ScriptContext, ctd: CapoDatum::CharterToken) -> Bool {
    govDelegate : RelativeDelegateLink = ctd.govAuthorityLink;

    govDelegate.hasValidOutput(mph, ctx)
}

func getCharterOutput(tx: Tx) -> TxOutput {
    charterTokenValue : Value = Value::new(
        AssetClass::new(mph, "charter".encode_utf8()), 
        1
    );
    tx.outputs.find_safe(
        (txo : TxOutput) -> Bool {
            txo.value >= charterTokenValue
        }
    ).switch {
        None => error("this could only happen if the charter token is burned."),
        Some{o} => o
    }
}

func preventCharterChange(ctx: ScriptContext, datum: CapoDatum::CharterToken) -> Bool {
    tx: Tx = ctx.tx;

    charterOutput : TxOutput = getCharterOutput(tx);

    cvh : ValidatorHash = ctx.get_current_validator_hash();
    myself : Credential = Credential::new_validator(cvh);
    if (charterOutput.address.credential != myself) {
        error("charter token must be returned to the contract ")
        // actual : String = charterOutput.address.credential.switch{
        //     PubKey{pkh} => "pkh:🔑#" + pkh.show(),
        //     Validator{vh} => "val:📜#:" + vh.show()
        // };
        // error(
        //     "charter token must be returned to the contract " + cvh.show() +
        //     "... but was sent to " +actual
        // )
    };

    newDatum : CapoDatum = CapoDatum::from_data( 
        charterOutput.datum.get_inline_data() 
    );
    if (datum.serialize() != newDatum.serialize()) {
        error("invalid update to charter settings") 
    };

    true
}

func checkpoint(s: String) -> Bool {
    print("checkpoint: " + s);
    true
}

func showMyTokens(v: Value) -> String{
    others : String = Value::from_map(
            v.get_assets().to_map().filter( (someMph: MintingPolicyHash, _) -> Bool {
            mph != someMph
        })
    ).show();
    ada : String = (
        (
            (0.0 + v.get_lovelace()) / 1_000.0
        ).round() / 1_000.0
    ).show() + " ADA";
    mine : String = v.get_policy(mph).fold[[]String]( (previous: []String, tokenName: ByteArray, c: Int) -> []String {
         []String{
            c.show() + "×💴 " + tokenName.decode_utf8()
        } + previous
    }, []String{}).join(" + ");
    // v.assets()

    mine + " + " + ada  + others
}

func main(datum: CapoDatum, activity: CapoActivity, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    // now: Time = tx.time_range.start;
    print("🚥❓Capo" + if (isDev) {
            " - isDev @gen " + devGen.show()
        } else { "" }
    );
    print("  -- checking spend of "+ showMyTokens(ctx.get_current_input().value ));
    TODO("implement activity updatingTypeMap");
    
    allDatumSpecificChecks: Bool = datum.switch {
        // checks that unsupported activities for a datum are rejected promptly 
        // +special things we want to always guard against for specific Datum types:
        ctd : CharterToken => {
            invalid : String = "invalid activity on CharterToken";
            activity.switch {
                updatingCharter => true,  // more activity-checks happen below.
                addingSpendInvariant => error("todo"),
                updatingSettings => error(invalid),
                retiringSettings => error(invalid),
                spendingDelegatedDatum => error(invalid),
                _ => {
                    preventCharterChange(ctx, ctd)  // throws if bad                
                    // ... plus activity-specific checks below.
                }
            }
        },
        SettingsData => activity.switch {
            updatingSettings => true,  // more checks below.
            retiringSettings => error("there is no use case for this activity, unless it's part of a complete teardown"),
            _ => error("invalid activity on SettingsData")
        },
        ScriptReference => activity.switch {
            retiringRefScript => true,
            _ => error("invalid activity on ScriptReference")            
        },
        DelegatedData => activity.switch {
            spendingDelegatedDatum => true,
            _ => error("invalid activity on DelegateData")
        },
        TypeMapInfo => activity.switch {
            updatingTypeMap => true,
            _ => error("invalid activity on TypeMapInfo")
        },
        _ => true
    };

    // the normal case for validation is to use CapoDatum-specific checks.  
    // however, this section allows activity-specific checks to be included, so extensions aren't painted into a corner.
    allActivitySpecificChecks : Bool = activity.switch {
        // checks for higher-frequency cases first
        spendingDelegatedDatum => {
            print( "  ...with activity spendingDelegatedDatum\n");
            // check that the datum is a DelegatedData variant
            isRightDatum : Bool = datum.switch{
                DelegatedData => true,
                _ => {
                    error(
                        "activity spendingDelegatedDatum used on mismatched datum type"
                    )
                }
            };
            charterDatum : CapoDatum::CharterToken = getTxCharterDatum(
                ctx: ctx,
                mph: mph
            );
            spendDelegate: RelativeDelegateLink = charterDatum.spendDelegateLink;
            delegateReturned: Bool = spendDelegate.hasValidOutput(mph, ctx);
            // consider allowing this as a refInput, with other stuff to enable more parallelism for populations
            spendDelegateInput: TxInput = spendDelegate.hasDelegateInput(
                inputs: ctx.tx.inputs,
                mph: mph
            ).unwrap();
            usingSpendingActivity : Bool = AbstractDelegateActivitiesEnum::from_data(
                mustFindInputRedeemer(ctx, spendDelegateInput)
            ).switch {
                SpendingActivities => true,
                _ => error("spend delegate not triggered with a Spending activity")
            };
            usingSpendingActivity && 
                delegateReturned && isRightDatum            
        },
        updatingCharter => {
            print( "  ...with activity updatingCharter\n");

            charterOutput : TxOutput = getCharterOutput(tx);
            newCtDatum = CapoDatum::CharterToken::from_data( 
                charterOutput.datum.get_inline_data() 
            );
            oldCtDatum : CapoDatum::CharterToken = datum.switch {
                octd: CharterToken => octd,
                _ => error("wrong use of updatingCharter action for non-CharterToken datum")
            };
            CapoDatum::CharterToken{                
                spendDelegate, 
                spendInvariants,
                settingsUut,
                namedDelegates,
                mintDelegate, 
                mintInvariants,
                govDelegate,
                oldTypeMapUut
            } = newCtDatum;

            CapoDatum::CharterToken{
                oldSpendDelegate, 
                oldSpendInvariants, 
                oldSettingsUut,
                oldNamedDelegates,
                oldMintDelegate, 
                oldMintInvariants,
                /* _oldGovDelegate */ _ 
                typeMapUut
            } = oldCtDatum;

            mustNotModifyMintInvariants : Bool =  ( mintInvariants == oldMintInvariants );
            mustNotModifySpendInvariants : Bool = ( spendInvariants == oldSpendInvariants );

            unchangedSpendDgt : Bool = ( spendDelegate.serialize() == oldSpendDelegate.serialize() );
            unchangedMintDgt : Bool = ( mintDelegate.serialize() == oldMintDelegate.serialize() );
            changedAnyNamedDelegate : Bool = ( namedDelegates.serialize() != oldNamedDelegates.serialize() );
            mustNotModifySettings : Bool = ( settingsUut == oldSettingsUut );
            mustNotModifyTypeInfo : Bool = ( typeMapUut == oldTypeMapUut );

            if (isDev) {
                print("is spendDgt unchanged? " + unchangedSpendDgt.show() +
                    "\n  - old: "+ oldSpendDelegate.uutName + " = " + oldSpendDelegate.strategyName +
                    " => "+  oldSpendDelegate.delegateValidatorHash.switch{Some{v} => v.show(), None => " (any addr)"} +
                "\n  - new: "+ spendDelegate.uutName + " = " + spendDelegate.strategyName +
                    " => "+ spendDelegate.delegateValidatorHash.switch{Some{v} => v.show(), None => " (any addr)"} 
                );
                print("is mintDgt unchanged?  " + unchangedMintDgt.show() + 
                    "\n  - old: "+ oldMintDelegate.uutName + " = " + oldMintDelegate.strategyName +
                    " => "+  oldMintDelegate.delegateValidatorHash.switch{Some{v} => v.show(), None => " (any addr)"} +
                    "\n  - new: "+ mintDelegate.uutName + " = " + mintDelegate.strategyName +
                    " => "+ mintDelegate.delegateValidatorHash.switch{Some{v} => v.show(), None => " (any addr)"}
                );
                print("is config unchanged? " + mustNotModifySettings.show() +
                    "\n  - old: "+ oldSettingsUut.decode_utf8() +
                    "\n  - new: "+ settingsUut.decode_utf8()
                )
            };
            assert(mustNotModifySettings, "cannot change settings uut");
            assert(mustNotModifyTypeInfo, "cannot change typeInfo uut");

            // govDelegate is always spent, so we always check its destination is kosher.
            mustNotModifySettings &&
            mustNotModifyTypeInfo &&
            govDelegate.hasValidOutput(mph, ctx) &&
            checkpoint("1") &&
            if (unchangedMintDgt) {
                // unchanged mintDgt must not be included in the tx
                checkpoint("2b") &&
                mintDelegate.hasDelegateInput(
                    inputs: ctx.tx.inputs, 
                    mph: mph,
                    required: false
                ).switch {
                    None => {
                        // was requiresNoDelegateInput(mintDelegate, mph, ctx)
                        //  - it's ok to have it not included.
                        true
                    },
                    Some{input} => {
                        delegateActivity: AbstractDelegateActivitiesEnum = 
                            mintDelegate.getRedeemer(input, ctx);
                        print("mint delegate input found");
                        delegateActivity.switch {
                            CapoLifecycleActivities{CLA} => CLA.switch {
                                CreatingDelegate => {
                                    print("TEMPORARY: allowing delegate creation while **updatingCharter**");

                                    TODO("move delegate-creation to be separate from updatingCharter");
                                    TODO(" ?? use capo ActivatingXxxxDelegate activity when adopting delegate");

                                    mintDelegate.hasValidOutput(mph, ctx)
                                },
                                _ => error("invalid use of mint delegate during charter update")
                            },
                            _ => error("invalid use of mint delegate during charter update")
                        }
                    }
                }
            } else {
                //  the new one has to go to the right place
                checkpoint("2a") &&
                 mintDelegate.hasValidOutput(mph, ctx)
            } && 
            checkpoint("3") &&
            if ( unchangedSpendDgt) {
                // unchanged spendDgt must not be included in the tx
                checkpoint("4b") &&
                requiresNoDelegateInput(spendDelegate, mph, ctx)
            } else {
                //  the new one has to go to the right place
                checkpoint("4a") &&
                spendDelegate.hasValidOutput(mph, ctx)
            } &&
            checkpoint("5") &&
            if (!changedAnyNamedDelegate) { true } else {
                checkpoint("5b") && 
                namedDelegates.fold( (ok: Bool, name : String, dgt : RelativeDelegateLink) -> Bool {
                    ok && 
                    oldNamedDelegates.get_safe(name).switch {
                        None => {
                            print (" - adopting named delegate: " + name);

                            true
                        },
                        Some{oldDgt} => { 
                            if (oldDgt.serialize() == dgt.serialize()) {
                               // unchanged named delegate must not be included in the tx
                                requiresNoDelegateInput(dgt, mph, ctx)
                            } else {
                                TODO("the old named delegate must be retired, or be force-replaced (in a different activity?)");
                                //  the new one has to go to the right place
                                dgt.hasValidOutput(mph, ctx)
                            }
                        }
                    }
                }, true)
            } &&
            mustNotModifyMintInvariants &&
            mustNotModifySpendInvariants &&
            requiresAuthorization(ctx, oldCtDatum) &&
            checkpoint("6")
        },

        retiringRefScript => {
            print( "  ...with activity retiringRefScript\n");
            // the ref script is being spent:
            isSpendingRefScript : Bool = datum.switch{
                ScriptReference => true,
                _ => error("wrong use of retiringRefScript action for non-ScriptRef datum")
            };

            hasGovAuthority : Bool = mustHaveGovAuthority(ctx,mph);

            isSpendingRefScript && 
            hasGovAuthority &&
            true
            // no other constraints; the ref script could be re-created or
            // replaced with a new one, or simply destroyed.
        },

        usingAuthority => {
            print( "  ...with activity usingAuthority\n");
            datum.switch {
                 // throws if bad
                ctd : CharterToken => requiresAuthorization(ctx, ctd),
                _ => error("wrong use of usingAuthority action for non-CharterToken datum")
            }
        },

        updatingSettings => {
            print( "  ...with activity updatingSettings\n");
            isRelevantDatum : Bool = datum.switch {
                SettingsData => true,
                TypeMapInfo => true,
                _ => error("wrong use of updatingSettings action; must use only on Settings and TypeInfo")
            };
            if (isRelevantDatum) { // temporary to minimize commit diff
                if (isRelevantDatum) { // temporary to minimize commit diff
                    charterDatum : CapoDatum::CharterToken = getTxCharterDatum(
                        ctx: ctx,
                        mph: mph
                    );
                    // it requires the govAuthority to be present 
                    print( "❗ gov authority must be present");
                    hasGovAuthority : Bool = mustHaveGovAuthority(
                        ctx : ctx,
                        mph: mph,
                        charterDatum: charterDatum // already resolved
                   );
                   CapoDatum::CharterToken{
                        spendDelegate,
                        spendInvariants,
                        /* settingsUut */ _,
                        namedDelegates,
                        mintDelegate ,
                        mintInvariants,
                        govDelegate,
                        /* oldTypeMapUut */ _
                    } = charterDatum;
                    
                   // ?? can we iterate inputs along with delegates, to reduce the overhead
                   //    ... of multiple passes over the tx inputs?
                    //  option 1: pay for iterating N inputs, 
                    //    - times a switch{} for delegate-matching
                    //    -    ... and invariants-iteration
                    //    -    ... and namedDelegates-iteration
                    //    - Plus a "is-anything-missing" check over delegates/invariants/namedDelegates
                    // option 2: switch and iterate over delegates, invariants, namedDelegates
                    //    - times a switch for input-finding
                    //    - ... and no separate is-anything-missing checks.
                    // ^^^ option 2 has to be cheaper.

                    inputs: []TxInput = ctx.tx.inputs;

                    print( "❗ spend delegate must validate settings");
                    spendDelegateIsValidating : Bool = 
                        spendDelegate.validatesUpdatedSettings(
                            inputs: inputs,
                            mph: mph,
                            inputRequired: true,
                            ctx: ctx
                        ).unwrap();

                    print( "❗ mint delegate must validate settings");
                    mintDelegateIsValidating : Bool = 
                        mintDelegate.validatesUpdatedSettings(
                            inputs: inputs,
                            mph: mph,
                            inputRequired: true,
                            ctx: ctx
                        ).unwrap();

                    // govAuthority is checking the settings
                    print( "❗ govDelegate might need to validate settings");
                    govDelegateMaybeValidating : Bool = 
                        govDelegate.validatesUpdatedSettings(
                            inputs: inputs,
                            mph: mph,
                            inputRequired: false,
                            ctx: ctx
                        ).switch{
                            Some => true,
                            None => true
                        };
                    checkOneInvariant : (Bool, RelativeDelegateLink) -> Bool = 
                    (ok: Bool, oneDgt: RelativeDelegateLink) -> Bool {
                        print( "  ❗ invariant must validate settings");
                        ok && oneDgt.validatesUpdatedSettings(
                            inputs: inputs,
                            mph: mph,
                            inputRequired: true,
                            ctx: ctx
                        ).unwrap()
                    };
                    // spendInvariants are checking the settings
                    print( "❗ spend invariants must validate settings");
                    spendInvariantsAreValidating : Bool = spendInvariants.fold( 
                        checkOneInvariant, true
                    );
                    // mintInvariants are checking the settings
                    print( "❗ mint invariants must validate settings");
                    mintInvariantsAreValidating : Bool = mintInvariants.fold( 
                        checkOneInvariant, true
                    );
                    // namedDelegates are checking the settings
                    print( "❗ named delegates must validate settings");
                    namedDelegatesAreValidating : Bool = namedDelegates.fold( 
                        (ok: Bool, _, dgt: RelativeDelegateLink) -> Bool {
                            print( "    ❗ named delegate must validate settings");
                            ok && dgt.validatesUpdatedSettings(
                                inputs: inputs,
                                mph: mph,
                                inputRequired: true,
                                ctx: ctx
                            ).unwrap()
                        }, true
                    );

                    isRelevantDatum &&
                    spendDelegateIsValidating &&
                    mintDelegateIsValidating &&
                    govDelegateMaybeValidating &&
                    spendInvariantsAreValidating &&
                    mintInvariantsAreValidating &&
                    namedDelegatesAreValidating &&
                    hasGovAuthority
                } else { error("unreachable") }
            } else { error("unreachable") }
        },
        retiringSettings => {
            print( "  ...with activity retiringSettings\n");
            error("implement me")
        },
        updatingTypeMap => {
            print( "  ...with activity updatingTypeMap\n");
            error("implement me")            
        },
        _ => error("unhandled activity")
    };

    assert(allDatumSpecificChecks, "some datum-check failed");
    assert(allActivitySpecificChecks, "some redeeemer-check failed");

    //! retains mph in parameterization
    assert(
        ( allDatumSpecificChecks && allActivitySpecificChecks ) ||
            // this should never execute (much less fail), yet it also shouldn't be optimized out.
             mph.serialize() /* never */ == datum.serialize(), 
        "unreachable"
    ); 
    print("🚥🟢 Capo validator: ok!");

    allDatumSpecificChecks && 
    allActivitySpecificChecks
    // tx.serialize() != datum.serialize()
}
