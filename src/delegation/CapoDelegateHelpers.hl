module CapoDelegateHelpers

import {
    mustFindInputRedeemer,
    mkTv,
    returnsValueToScript
} from StellarHeliosHelpers

// Delegates can define addtional activities in their enum variants,
// but these 4 basic activities are essential.
enum BASE_DELEGATE_Activity {
    Authorizing
    Reassigning
    Retiring
    Modifying
}

// todo: add this to RelativeDelegateLink
enum stakingKeyRequirement {
    NoStakingKeyAllowed
    StakingKeyRequired
    SpecificStakeKeyRequired {
        stakeCredential: StakingCredential
    }
}

// use this activity at Redeemer zero, as enum Redeemer {
//   DelegateActivity { a: DelegateActivity }}
//   ...app-specific redeemer variants
// }
enum DelegateActivity {
    ReplacingMe { // replaces this mint delegate with a different one
        seedTxn: TxId
        seedIndex: Int
        purpose: String
    }
    Retiring
    Modifying
    ValidatingSettings
}

// use this enum to match any redeemer if you don't care about what other
// variants may be in that delegate, but you know it has to be a delegate with the 
// universal delegate activities at const#0
enum MustUseDelegateActivity {
    DelegateActivity {
        a: DelegateActivity
    }
    // _r1  // shouldn't need placeholder variants, hopefully.
    // _r2
    // _r3
    // _r4
}


// data stored in the Capo, representing basic delegate info
//   about the connection to a delegate.  
struct RelativeDelegateLink {
    uutName: String
    strategyName: String
    // delegate links without a validator hash are "arms-length" delegates,
    // which means they won't be checked for possible auto-upgrades 
    //  ... to new versions of their code.
    // it also means that they won't be able to participate 
    //   ... in validation of configuration changes in the Capo.
    delegateValidatorHash: Option[ValidatorHash]
    // !!! todo ???  - for namedDelegates particularly
    // stakingCred: stakingKeyRequirement

    func validatesUpdatedSettings(self,
        inputs: []TxInput,
        validatorHashRequired: Bool,
        mph: MintingPolicyHash,
        inputRequired: Bool,
        ctx: ScriptContext
    ) -> Option[Bool] {
        self.hasDelegateInput(
            inputs: inputs,
            mph: mph,
            validatorHashRequired: validatorHashRequired,
            inputRequired: inputRequired
        ).switch {
            // hasDelegateInput already failed if the input was required.
            None => Option[Bool]::None, // clean "not found but that's permitted"
            Some{spendDelegateInput} => {
                spendDelegateIsValid : Bool = MustUseDelegateActivity::from_data( 
                    mustFindInputRedeemer(ctx, spendDelegateInput)
                ).switch {
                    DelegateActivity{a} => {
                        a.switch {
                            ValidatingSettings => self.hasValidOutput(
                                 mph, ctx
                            ),
                            _ => error("delegate not ValidatingSettings: "+ self.uutName)
                        }
                    },
                    _ => error("no way") // throws if the redeemer isn't #0.
                };

                assert(spendDelegateIsValid, "no way"); // it threw any error already
                Option[Bool]::Some{spendDelegateIsValid}        
            }
        }
    }

    func hasDelegateInput(self, 
        inputs: []TxInput, 
        validatorHashRequired: Bool,
        mph: MintingPolicyHash,
        inputRequired: Bool
    ) -> Option[TxInput] {
        addrCredNeeded : Option[Credential] = self.delegateValidatorHash.switch{
            Some{vh} => Option[Credential]::Some{Credential::new_validator(vh)},
            None => if (validatorHashRequired) { 
                // this is a major conflict - this delegate type is EXPECTED to have a validator hash.
                error("missing required validator hash in delegate link " + self.uutName)
            } else { 
                Option[Credential]::None 
            }
        };

        addrCredNeeded.switch {
            None => {
                // when no special input is needed by the delegate, 
                // validatorHashRequired=true throws error above.
                assert(!validatorHashRequired, "no way");

                // when the delegate has no validator hash, then we shouldn't bother 
                // looking for a specific input.
                //  so we should quickly return None.  Caller should bail out if the input is needed
                if (inputRequired) {
                    error("missing required input for delegate link " + self.uutName)
                };
                Option[TxInput]::None
            },
            Some{needsAddrWithCred} => {
                // if we arrived here, then we have a delegate that's supposed to be at a specific address.
                // if we can't find an input with that address, it's an error condition.
                // we need an input with this address, having the expected UUT.
                expectedUut : Value = mkTv(mph, self.uutName);
                inputs.find_safe((i: TxInput) -> Bool {
                    i.address.credential == needsAddrWithCred &&
                    i.value.contains(expectedUut)
                }).switch {
                    foundGood: Some => foundGood,
                    /* notFound: */ None => {
                        error("missing required input for delegate link " + self.uutName)
                    }
                }
            }        
        }
    }

    // was requiresValidDelegateOutput 
    func hasValidOutput(
        self, // delegateLink: RelativeDelegateLink, 
        mph: MintingPolicyHash, 
        ctx : ScriptContext,
        required: Bool = true
    ) -> Bool {
        RelativeDelegateLink{
            uut, strategy,
            validatorHash
        } = self;
        if (strategy.encode_utf8().length < 4) {
            error("strategy too short")
            // error("strategy must be at least 4 bytes, got: '"+strategy +
            //     "' = "+ strategy.encode_utf8().length.show()
            // )
        };
    
        v : Value = mkTv(mph, uut);
        hasDelegate : Bool = validatorHash.switch{
            Some{vh} => {
                print(" - seek dgTkn in vh " + vh.show());
                ctx.tx.value_locked_by(vh).contains(v)
            },
            None => {
                print( " - seek dgTkn in any outputs; no special vhash requirement");
                ctx.tx.outputs.find_safe((o : TxOutput) -> Bool {
                    o.value.contains(v)
                }).switch{
                    Some => true, 
                    None => false
                }
            }
        };
    
        if (!hasDelegate && required) {
            error("missing dgTkn "+ uut )
        } else {
            if (hasDelegate) {
                print("has delegate: yes")
            } else {
                print("has delegate: returning false")
            }
        };
        hasDelegate
    }
    
    // config: Data
}

// data stored in isDelegate Datum (in the delegate's script)
// ... links back to the capo info
struct DelegationDetail {
    capoAddr: Address
    mph: MintingPolicyHash
    tn: ByteArray
}

// Delegates can define additional Datum in their enums,
// but this first Datum is essential
enum BASE_DELEGATE_Datum {
    IsDelegation {
        dd: DelegationDetail
    }
}

func mustReturnValueToScript(value : Value, ctx : ScriptContext) -> Bool {
    if (!returnsValueToScript( value, ctx)) {
        error("authZor not returned")
        // error("the authZor token MUST be returned")
    };
    true
}

//!!! call with existing delegate Datum.serialize()
func unmodifiedDelegation(oldDD : ByteArray, ctx: ScriptContext) -> Bool {
    o : []TxOutput = ctx.get_cont_outputs();
    //    print("::::::::::::::::::::::::::::::::: hi "+o.head.datum.get_inline_data().serialize().show());
    assert(o.head.datum.get_inline_data().serialize() == oldDD,
    // "delegation datum must not be modified"
    "modified dgtDtm"
);
    true
    // MintDelegateDatum::IsDelegation{
    //     ddNew, _
    // } = MintDelegateDatum::from_data( 
        
    // );

    //! the datum must be unchanged.
    // ddNew == dd 
}

/**
 * returns the AssetClass for the authority token found in the given DelegationDetail struct
 */
func acAuthorityToken(dd: DelegationDetail) -> AssetClass {
    AssetClass::new(dd.mph, dd.tn)
}

/**
 * returns a Value for the authority-token found in the given DelegationDetail struct
 */
 func tvAuthorityToken(dd: DelegationDetail) -> Value {
    Value::new(
        acAuthorityToken(dd), 1
    )
}

func requiresNoDelegateInput(
    delegateLink: RelativeDelegateLink, 
    mph: MintingPolicyHash, 
    ctx : ScriptContext
) -> Bool {
    v : Value = mkTv(mph, delegateLink.uutName);
    if (ctx.tx.inputs.any((i: TxInput) -> Bool {
        i.value.contains(v)
    })) {
        error("must not have dgTkn input: "+delegateLink.uutName)
    };
    print("ok: no dgTkn input: "+ delegateLink.uutName);
    true
}

// just some convenience stuff to lead people to the right place
struct delegateLink_hasValidOutput_asMethod {
    placeHolder: String 
}

func requiresValidDelegateOutput(
    delegateLink: delegateLink_hasValidOutput_asMethod,
    mph: MintingPolicyHash, 
    ctx : ScriptContext,
    required: Bool = true
) -> Bool {
    assert(false, "replaced by delegateLink.hasValidOutput(...)");
    assert(delegateLink==delegateLink, "no way");
    assert(mph==mph, "no way");
    assert(ctx==ctx, "no way");
    assert(required==required, "no way");
    true
}

// todo: move to Mint helpers, as that's it's only purpose.
func requiresDelegateAuthorizingMint(
    delegateLink: RelativeDelegateLink, 
    mph: MintingPolicyHash, 
    ctx : ScriptContext,
    extraMintDelegateRedeemerCheck: Bool = true
) -> Bool {
    authzVal : Value = Value::new(AssetClass::new(mph, delegateLink.uutName.encode_utf8()), 1);
    print("finding my inp "+ delegateLink.uutName);
    targetId: TxOutputId = ctx.tx.inputs.find_safe((i: TxInput) -> {
        // print("   ?  in "+i.value.show());
        i.value.contains(authzVal) // find my authority token
    }).switch{
        Some{x} => x.output_id,
        None => error("missing dgTkn "+delegateLink.uutName)
    };
    print ("     found ^");
    spendsAuthorityUut : ScriptPurpose = ctx.tx.redeemers.find_key( 
        (purpose : ScriptPurpose) -> { purpose.switch{ 
            sp: Spending => {
                // print ("oid: " + sp.output_id.show());
                sp.output_id == targetId
            }, 
            _ => false 
        } }
    );

    // r : Data = ctx.tx.redeemers.get(  // index redeemers by...
    //     ScriptPurpose::new_spending(  // [spending, plus ...
    //     );
        
    err : String = "dgTkn "+delegateLink.uutName+" not being spent as expected"; // "not spent with an authorizing activity!")
    maybeCheckedMintDelegateAuthority : Bool = ctx.tx.redeemers.get_safe(
        spendsAuthorityUut
    ).switch {
        None => {
            error(err)
        },
        Some{x} => x.switch {
            (index: Int, _fields: []Data) => {

                /* avoids unused-variable warning: */ _fields == _fields && 
                if (!extraMintDelegateRedeemerCheck) {
                    print("  -- okay, the delegate token was spent");
                    print("  -- skipping extra check for mint delegate's particular redeemer");
                    true
                } else { 
                    if (0 == index || index >= 9) {
                        print (" -- delegate is authorizing: ok redeemer #"+index.show());
                        true
                        } else {
                        print("expected mint-delegation activity with index = 0 or >= 9, not: "+index.show());
                        error(err)
                    }
                }
            },
            _ => {
                error(err)
            }
        }
    };
    delegateDidAuthorize = true; // otherwise, we'd have failed above.

    // NOTE: DOESN'T CHECK that the AUTHORIZING DELEGATE is returned anywhere specific.
    //    - it's not generally a minting responsibility (however, as an exception the bootstrap charter event DOES 
    //      actually check for valid delegate outputs).  All other cases should have the correct
    //      delegate outputs checked (e.g. in the Capo's CharterDatum spend checker).
    // print("no no no");
    // maybeCheckDelegateOutput : Bool = if (!checkDelegateOutput) {
    //     print("  -- skipping check for expected delegate output ");
    //     true
    // } else {
    //     delegateLink.hasValidOutput(mph, ctx)        
    // };
    delegateDidAuthorize && maybeCheckedMintDelegateAuthority
}
