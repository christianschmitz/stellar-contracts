module CapoDelegateHelpers

import {
    mkTv,
    returnsValueToScript
} from StellarHeliosHelpers

// Delegates can define addtional activities in their enum variants,
// but these 4 basic activities are essential.
enum BASE_DELEGATE_Activity {
    Authorizing
    Reassigning
    Retiring
    Modifying
}

struct RelativeDelegateLink {
    uutName: String
    strategyName: String
    delegateValidator: Option[ValidatorHash]

    // config: Data
}

struct DelegationDetail {
    capoAddr: Address
    mph: MintingPolicyHash
    tn: ByteArray
}

// Delegates can define additional Datum in their enums,
// but this first Datum is essential
enum BASE_DELEGATE_Datum {
    IsDelegation {
        dd: DelegationDetail
        CustomConfig: Data
    }
}

func mustReturnValueToScript(value : Value, ctx : ScriptContext) -> Bool {
    if (!returnsValueToScript( value, ctx)) {
         error("the authZor token MUST be returned")
    };
    true
}

//!!! call with existing delegate Datum.serialize()
func unmodifiedDelegation(oldDD : ByteArray, ctx: ScriptContext) -> Bool {
    o : []TxOutput = ctx.get_cont_outputs();
    //    print("::::::::::::::::::::::::::::::::: hi "+o.head.datum.get_inline_data().serialize().show());
    assert(o.head.datum.get_inline_data().serialize() == oldDD,
        "delegation datum must not be modified"
    );
    true
    // MintDelegateDatum::IsDelegation{
    //     ddNew, _
    // } = MintDelegateDatum::from_data( 
        
    // );

    //! the datum must be unchanged.
    // ddNew == dd 
}

/**
 * returns the AssetClass for the authority token found in the given DelegationDetail struct
 */
func acAuthorityToken(dd: DelegationDetail) -> AssetClass {
    AssetClass::new(dd.mph, dd.tn)
}

/**
 * returns a Value for the authority-token found in the given DelegationDetail struct
 */
 func tvAuthorityToken(dd: DelegationDetail) -> Value {
    Value::new(
        acAuthorityToken(dd), 1
    )
}

func requiresValidDelegateOutput(
    dd: RelativeDelegateLink, 
    mph: MintingPolicyHash, 
    ctx : ScriptContext,
    required: Bool = true
) -> Bool {
    RelativeDelegateLink{
        uut, strategy,
        validatorHash
    } = dd;
    if (strategy.encode_utf8().length < 4) {
        error("strategy too short")
        // error("strategy must be at least 4 bytes, got: '"+strategy +
        //     "' = "+ strategy.encode_utf8().length.show()
        // )
    };

    v : Value = mkTv(mph, uut);
    hasDelegate : Bool = validatorHash.switch{
        Some{vh} => {
            print(" - expecting delegation token in validator hash" + vh.show());
            ctx.tx.value_locked_by(vh).contains(v)
        },
        None => ctx.tx.outputs.find_safe((o : TxOutput) -> Bool {
            o.value.contains(v)
        }).switch{
            Some => true, 
            None => false
        }
    };

    if (!hasDelegate && required) {
        error("missing required delegation token: "+ uut )
    };
    hasDelegate
}


func requiresDelegateAuthorizing(
    dd: RelativeDelegateLink, 
    mph: MintingPolicyHash, 
    ctx : ScriptContext
) -> Bool {
    authzVal : Value = Value::new(AssetClass::new(mph, dd.uutName.encode_utf8()), 1);
    print("finding my "+ dd.uutName);
    targetId : TxOutputId = ctx.tx.inputs.find_safe((i: TxInput) -> {
        // print("   ?  in "+i.value.show());
        i.value.contains(authzVal) // find my authority token
    }).switch{
        Some{x} => x.output_id,
        None => error("missing required delegate UUT "+dd.uutName)
     };
    print ("     found ^");
    k : ScriptPurpose = ctx.tx.redeemers.find_key( 
        (purpose : ScriptPurpose) -> { purpose.switch{ 
            sp: Spending => {
                // print ("oid: " + sp.output_id.show());
                sp.output_id == targetId
            }, 
            _ => false 
        } }
    );
    // r : Data = ctx.tx.redeemers.get(  // index redeemers by...
    //     ScriptPurpose::new_spending(  // [spending, plus ...
    //     );
        
    isAuthorizing : Bool = ctx.tx.redeemers.get(k).switch {
        (index: Int, fields: []Data) => {
            // a: BASE_DELEGATE_Activity => a.switch {
            //     Authorizing => true,
            fields == fields && 
            if (index >= 10) { true } else {
                print("index: "+index.show());
                error("authz token "+dd.uutName+" not spent with an authorizing activity!")
            }
        },
        _ => error("authz token "+dd.uutName+"not spent with an authorizing activity!")
    };

    isAuthorizing && requiresValidDelegateOutput(dd, mph, ctx)
}
