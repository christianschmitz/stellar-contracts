import { makeSource, type Source } from "@helios-lang/compiler-utils";
import type { Capo } from "../Capo.js";
import { CapoHeliosBundle } from "../CapoHeliosBundle.js";
import {
    HeliosScriptBundle,
} from "../helios/HeliosScriptBundle.js";
import {
    type CapoBundleClass,
    type Constructor,
    type EmptyConstructor
} from "../helios/HeliosMetaTypes.js";
import type { stellarSubclass } from "../StellarContract.js";
import BasicDelegate from "./BasicDelegate.hl";

export type CapoDelegateBundleClass = new () => CapoDelegateBundle;

// this class expresses a "has dependences from the Capo" semantic,
// ... not because it expects any dynamic code dependencies from an
// ... application-specific Capo.  Also, this class being abstract, it never
// ... is used directly.  The direct requirements of its included code from
// ... BasicDelegate are easily satisfied by the unspecialized Capo bundle.
//
// Subclasses of this class MAY have application-specific dependencies
// ... to be provided by an application-specific Capo.

const USING_EXTENSION = Symbol("USING_EXTENSION");

type ConcreteCapoDelegateBundle = typeof CapoDelegateBundle &
    Constructor<CapoDelegateBundle> & 
    EmptyConstructor<CapoDelegateBundle> &

    {
        capoBundle: CapoHeliosBundle;
        isConcrete: true;
    };

/**
 * for any Capo delegate; combines the BasicDelegate with a
 *  concrete specialization
 * @public
 **/
//x@ts-expect-error "static using(): cannot assign abstract constructor type to non-abstract class"
export abstract class CapoDelegateBundle extends HeliosScriptBundle {
    abstract get specializedDelegateModule(): Source;
    declare capoBundle: CapoHeliosBundle;
    isConcrete = false;

    /**
     * Creates a CapoDelegateBundle subclass based on a specific CapoHeliosBundle class
     */
    static usingCapoBundleClass<
        THIS extends typeof CapoDelegateBundle,
        CB extends CapoBundleClass
    >(this: THIS, c: CB) : ConcreteCapoDelegateBundle {
        const cb = new c();
        //@ts-expect-error returning a subclass without concrete implementations
        // of the abstract members; hopefully the subclass will error if they're missing
        const newClass = class aCapoBoundBundle extends this {
            capoBundle = cb;
            constructor() {
                super(USING_EXTENSION);
            }
            isConcrete = true;
        } as ConcreteCapoDelegateBundle & typeof newClass
        // as typeof CapoDelegateBundle & CapoDelegateBundleClass // & CB

        return newClass
    }

    constructor(isUsingExtension: typeof USING_EXTENSION) {
        if (!isUsingExtension) {
            throw new Error(
                "CapoDelegateBundle is abstract; create your base class like this:\n" +
                    " class ‹YourBundle› extends CapoDelegateBundle.usingCapoBundleClass(‹some CapoHeliosBundleClass ›) {\n     ... \n}"
            );
        }

        super();
    }

    // constructor(public capoBundle: CapoHeliosBundle) {
    //     super();
    // }

    get main() {
        return BasicDelegate;
    }

    get moduleName() {
        const specialDgt = this.specializedDelegateModule;
        if (!specialDgt.moduleName) {
            throw new Error(
                "specializedDelegate module must have a moduleName"
            );
        }
        return specialDgt.moduleName;
    }

    getEffectiveModuleList() {
        const specialDgt = this.specializedDelegateModule;
        const delegateWrapper = this.mkDelegateWrapper(specialDgt.moduleName);

        return [
            ... super.getEffectiveModuleList(),
            delegateWrapper,
            this.specializedDelegateModule,
        ]
    }

    get modules(): Source[] {
        return []
    }

    mkDelegateWrapper(moduleName) {
        const indent = " ".repeat(8);
        const src = `module specializedDelegate
import {
    DelegateActivity,
    DelegateDatum,
    BurningActivity,
    MintingActivity,
    SpendingActivity
} from ${moduleName}\n`;
        // console.log("mkDelegateWrapper:", new Error( src));
        return makeSource(src, {
            name: `generatedSpecializedDelegateModule`,
            project: "stellar-contracts",
            moreInfo:
                `${indent}- wraps ${moduleName} provided by ${this.constructor.name}\n` +
                `${indent}  (generated by stellar-contracts:src/delegation/ContractBasedDelegate.ts:mkDelegateWrapper())`,
        });
    }
}
