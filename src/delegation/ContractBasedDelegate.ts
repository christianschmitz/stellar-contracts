import {
    Address,
    ByteArrayData,
    ConstrData,
    IntData,
    ListData,
    TxId,
    TxInput,
    TxOutput,
    TxOutputId,
    UplcData,
    Value,
    bytesToText,
    textToBytes,
} from "@hyperionbt/helios";
import type {
    Capo,
    DelegateSetupWithoutMintDelegate,
    MinimalDelegateLink,
    MintUutActivityArgs,
    NormalDelegateSetup,
    hasCharterRef,
    hasSettingsRef,
} from "../Capo.js";
import {
    Datum,
    type InlineDatum,
    type ValidatorHash,
} from "../HeliosPromotedTypes.js";
import {
    Activity,
    datum,
    type configBaseWithRev,
    type isActivity,
} from "../StellarContract.js";
import { StellarDelegate } from "./StellarDelegate.js";
import type {
    DelegationDetail,
    capoDelegateConfig,
} from "./RolesAndDelegates.js";
import { StellarTxnContext } from "../StellarTxnContext.js";
import { BasicDelegate } from "./BasicDelegate.js";
import { mkHeliosModule, type HeliosModuleSrc } from "../HeliosModuleSrc.js";
import { UnspecializedDelegate } from "./UnspecializedDelegate.js";
import { dumpAny } from "../diagnostics.js";

/**
 * Base class for delegates controlled by a smart contract, as opposed
 * to a simple delegate backed by an issued token, whose presence
 * grants delegated authority.
 * @public
 */
export class ContractBasedDelegate<
    CT extends capoDelegateConfig = capoDelegateConfig
> extends StellarDelegate<CT> {
    static currentRev = 1n;
    /**
     * Configures the matching parameter name in the on-chain script, indicating
     * that this delegate serves the Capo by enforcing policy for spending the Capo's utxos.
     * @remarks
     * Not used for any mint delegate.  Howeever, a mint delegate class can instead provide a true isMintAndSpendDelegate,
     *...  if a single script controls both the mintDgt-* and spendDgt-* tokens/delegation roles for your Capo.
     *
     * DO NOT enable this attribute for second-level delegates, such as named delegates or delegated-data controllers.
     * The base on-chain delegate script recognizes this conditional role and enforces that its generic delegated-data activities
     * are used only in the context the Capo's main spend delegate, re-delegating to the data-controller which
     * can't use those generic activities, but instead implements its user-facing txns as variants of its SpendingActivities enum.
     */
    get isSpendDelegate() {
        return false;
    }

    get delegateName(): string {
        throw new Error(
            `${this.constructor.name}: missing required get delegateName() : string`
        );
    }

    get capo(): Capo<any> {
        return this.configIn?.capo as unknown as Capo<any>;
    }

    contractSource() {
        return BasicDelegate;
    }

    get scriptDatumName() {
        return "DelegateDatum";
    }

    get scriptActivitiesName() {
        return "DelegateActivity";
    }

    mkDelegateWrapper(moduleName) {
        return mkHeliosModule(
            `
module specializedDelegate
import {
    DelegateActivity,
    DelegateDatum
} from ${moduleName}
`,
            ` [${this.constructor.name}:specializedDelegateModule()]\n       - wraps ${moduleName} (generated by stellar-contracts:src/delegation/ContractBasedDelegate.ts: ^^^ mkDelegateWrapper())`,
            "stellar-contracts"
        );
    }

    /**
     * Sets a list of Helios source modules to be available for import by the smart contract
     * indicated by `this.specializedDelegateModule()`
     * @remarks
     * The list of modules is used when compiling the smart contract.
     *
     * Note that the super class may provide import modules, so you should include the result
     * of `super.importModules()` in your return value.
     */
    importModules(): HeliosModuleSrc[] {
        if ("specializedDelegate" in this) {
            throw new Error(
                `${this.constructor.name}: specializedDelegate() - rename to specializedDelegateModule()`
            );
        }
        const specialDgt = this.specializedDelegateModule;
        if (specialDgt.moduleName == "specializedDelegate") {
            throw new Error(
                `${this.constructor.name}: specializedDelegateModule() module name must not be ` +
                    `'specializedDelegate'\n  ... in ${specialDgt.srcFile}\n  (we now provide a wrapper for your module)`
            );
        }
        const delegateWrapper = this.mkDelegateWrapper(specialDgt.moduleName);
        // console.log("specializedDelegate", specializedDelegate);
        // console.log("delegateWrapper", delegateWrapper);

        //@ts-expect-error
        const { capo } = this.configIn || this.partialConfig;

        if (!capo)
            throw new Error(
                `missing capo in config or partial-config for ${this.constructor.name}`
            );
        return [specialDgt, delegateWrapper, ...capo.importModules()];
    }

    static get defaultParams() {
        const params = {
            rev: this.currentRev,
            devGen: 0n,
            isSpendDelegate: this.prototype.isSpendDelegate,
        };
        return params;
    }
    static mkDelegateWithArgs(a: capoDelegateConfig) {}

    getContractScriptParams(config: CT) {
        //@ts-expect-error - spurious "could be instantiated with an unrelated type"
        const params: CT = {
            rev: config.rev,
            isDev: false,
            devGen: 0n,
            delegateName: this.delegateName,
        };

        const { capoAddr, mph, tn, capo, ...otherConfig } = config;
        otherConfig.delegateName = this.delegateName;

        if ("development" === process.env.NODE_ENV) {
            otherConfig.isDev = true;
            if (!otherConfig.devGen) {
                throw new Error(
                    `Missing expected devGen in config for ${this.constructor.name}`
                );
            }
        }
        return otherConfig as CT;
    }

    /**
     * specialized delegate module for customizing policies atop the basic delegate
     * ## REQUIRED: define it with a `get` accessor
     * like this: `get specializedDelegateModule() { return MySpecializedDelegate; }`
     * @remarks
     * The basic mint delegate contains an "unspecialized" implementation of this
     * customization, which doesn't have any special restrictions (or special capabilities)
     * @public
     **/
    get specializedDelegateModule(): HeliosModuleSrc {
        return UnspecializedDelegate;
    }

    tcxWithCharterRef<TCX extends StellarTxnContext | hasCharterRef>(tcx: TCX) {
        return this.capo.tcxWithCharterRef(tcx);
    }
    tcxWithSettingsRef<TCX extends StellarTxnContext | hasSettingsRef>(
        tcx: TCX
    ) {
        return this.capo.tcxWithSettingsRef(tcx);
    }

    /**
     * Adds a mint-delegate-specific authority token to the txn output
     * @remarks
     *
     * Implements {@link StellarDelegate.txnReceiveAuthorityToken | txnReceiveAuthorityToken() }.
     *
     * Uses {@link ContractBasedDelegate.mkDelegationDatum | mkDelegationDatum()} to make the inline Datum for the output.
     * @see {@link StellarDelegate.txnReceiveAuthorityToken | baseline txnReceiveAuthorityToken()'s doc }
     * @public
     **/
    async txnReceiveAuthorityToken<TCX extends StellarTxnContext>(
        tcx: TCX,
        tokenValue: Value,
        fromFoundUtxo?: TxInput
    ): Promise<TCX> {
        const datum = this.mkDelegationDatum(fromFoundUtxo);
        const newOutput = new TxOutput(this.address, tokenValue, datum);
        const separator = `     -----`;
        console.log(
            `${separator} delegate script receiving dgTkn\n${separator} ${dumpAny(
                newOutput
            )}` // ${dumpAny(tokenValue)} at ${dumpAny(addr)} = ${addr.toBech32()}`
        );
        // const ffu = fromFoundUtxo;
        // const v : Value = ffu?.value || this.mkMinAssetValue(this.configIn!.uut);
        return tcx.addOutput(newOutput);
    }

    mkDelegationDatum(txin?: TxInput) {
        if (txin) return txin.origOutput.datum!;
        const { capoAddr, mph, tn, ..._otherCfgSettings } = this.configIn!;

        return this.mkDatumIsDelegation({
            capoAddr,
            mph,
            tn,
        });
    }

    /**
     * redeemer for replacing the authority UUT with a new one
     * @remarks
     *
     * When replacing the delegate, the current UUT will be burned,
     * and a new one will be minted.  It can be deposited to any next delegate address.
     *
     * @param seedTxnDetails - seed details for the new UUT
     * @public
     **/
    @Activity.redeemer
    activityReplacingMe({
        // todo: add type for seedTxnDetails
        seed,
        purpose,
    }: Omit<MintUutActivityArgs, "purposes"> & { purpose: string }) {
        debugger
        return this.mkDelegateLifecycleActivity(
            "ReplacingMe", 
            seed._toUplcData(), 
            new ByteArrayData(textToBytes(purpose))
        );
    }

    mkDelegateLifecycleActivity(
        delegateActivityName: "ReplacingMe" | "Retiring" | "ValidatingSettings",
        ...args: any[]
    ): isActivity {
        const TopEnum = this.mustGetActivity("DelegateLifecycleActivities");
        const topVarSt = TopEnum.prototype._enumVariantStatement;
        const { DelegateLifecycleActivity } = this.onChainTypes;
        const NestedVariant = this.mustGetEnumVariant(
            DelegateLifecycleActivity,
            delegateActivityName
        );
        const nestedVarSt = NestedVariant.prototype._enumVariantStatement;
        if (args.every((x) => x instanceof UplcData)) {
            // the data is already encoded as UplcData, so we can simply
            // wrap it in a ConstrData with the correct index
            return {
                redeemer: new ConstrData(topVarSt.constrIndex, [
                    new ConstrData(nestedVarSt.constrIndex, [...args]),
                ]),
            };
        }
        try {
            return {
                redeemer: new TopEnum(new NestedVariant(...args))._toUplcData(),
            };
        } catch (e: any) {
            // warning emoji: "⚠️"
            e.message =
                "⚠️ ⚠️ ⚠️ error constructing delegate lifecycle activity.  You might need " +
                "to format the args as UplcData if the enum doesn't recognize a valid off-chain type.\nDelegate lifecycle activity: " +
                e.message;
            throw e;
        }
    }

    mkCapoLifecycleActivity(
        capoLifecycleActivityName: "CreatingDelegate" | "ActivatingDelegate",
        ...args: any[]
    ): isActivity {
        // for CreatingDelegate, the first arg is a seed

        const TopEnum = this.mustGetActivity("CapoLifecycleActivities");
        const { CapoLifecycleActivity } = this.onChainTypes;
        const NestedVariant = this.mustGetEnumVariant(
            CapoLifecycleActivity,
            capoLifecycleActivityName
        );
        const [seed, ...otherArgs] = "CreatingDelegate" == capoLifecycleActivityName ? args : [undefined, ... args];
        if (otherArgs.every((x) => x instanceof UplcData)) {
            console.log("using uplc data");
            // the data is already encoded as UplcData, so we can simply
            // wrap it in a ConstrData with the correct index
            const topVarSt = TopEnum.prototype._enumVariantStatement;
            const topVariantIndex = topVarSt.constrIndex;
            const nestedVarSt = NestedVariant.prototype._enumVariantStatement;
            const nestedVariantIndex = nestedVarSt.constrIndex;

            const finalArgs = seed ? [seed._toUplcData(), ...otherArgs] : otherArgs;
            return {
                redeemer: new ConstrData(topVariantIndex, [
                    new ConstrData(nestedVariantIndex, finalArgs),
                ]),
            };
        }
        debugger
        const enumInstance = new TopEnum(new NestedVariant(...args));
        const details = "tbd";
        return {
            redeemer: enumInstance._toUplcData(),
            details,
        };
    }

    /**
     * Creates a reedemer for the indicated spending activity name
     *
     * For delegated-data controllers, see the more explicit equivalent in DelegatedDataContract
     *
     * If you have any difficulty instantiating a complex activity object, you may
     * wish to provide all arguments with Uplc types.
     * This allows the activity to be formed without reference to on-chain Enum types,
     * which aren't all easily used from Javascript land.
     **/
    mkSpendingActivity(
        spendingActivityName: string,
        ...args: any[]
    ): isActivity {
        const TopEnum = this.mustGetActivity("SpendingActivities");
        const topVarSt = TopEnum.prototype._enumVariantStatement;
        const { SpendingActivity } = this.onChainTypes;
        const NestedVariant = this.mustGetEnumVariant(
            SpendingActivity,
            spendingActivityName
        );
        const nestedVarSt = NestedVariant.prototype._enumVariantStatement;

        let [id, ...otherActivityArgs] = args;
        if (otherActivityArgs.every((x) => x instanceof UplcData)) {
            // the data is already encoded as UplcData, so we can simply
            // wrap it in a ConstrData with the correct index
            if ("string" == typeof id) {
                id = new ByteArrayData(textToBytes(id));
            }
            if (Array.isArray(id)) {
                id = new ByteArrayData(id);
            }
            return {
                redeemer: new ConstrData(topVarSt.constrIndex, [
                    new ConstrData(nestedVarSt.constrIndex, [
                        id,
                        ...otherActivityArgs,
                    ]),
                ]),
            };
        }

        try {
            return {
                redeemer: new TopEnum(new NestedVariant(...args))._toUplcData(),
            };
        } catch (e: any) {
            // warning emoji: "⚠️"
            e.message =
                "⚠️ ⚠️ ⚠️ error constructing spending activity.  You might need " +
                "to format the args as UplcData, if the enum doesn't recognize a valid " +
                " off-chain type.\nSpending activity: " +
                e.message;
            throw e;
        }
    }

    mkSeedlessMintingActivity(
        mintingActivityName: string,
        ...args: any[]
    ): isActivity {
        const TopEnum = this.mustGetActivity("MintingActivities");
        const { MintingActivity } = this.onChainTypes;
        const NestedVariant = this.mustGetEnumVariant(
            MintingActivity,
            mintingActivityName
        );

        const varSt = TopEnum.prototype._enumVariantStatement;
        const nestedVarSt = NestedVariant.prototype._enumVariantStatement;
        // it ^^^ MUST NOT have a 'seed' arg
        const foundName = nestedVarSt.dataDefinition.fields[0].name.value;
        if ("seed" === foundName) {
            throw new Error(
                `${mintingActivityName}: found unexpected 'seed' field #1 in seedless(?) MintingActivity variant!  \n`+
                `\nIf this activity **does** need a unique seed, you should use:\n\n`+
                `   mkSeededMintingActivity() // for minting activities that require a seed\n\n`+
                `If this activity **doesn't** need guaranteed uniqueness for its minting use-case, \n`+
                `  ... then you would remove the 'seed' field from your on-chain variant definition. \n`+
                `^^^ Error in MintingActivity: ${mintingActivityName} ^^^ `
            )
        }

        if (args.every((x) => x instanceof UplcData)) {
            // the data is already encoded as UplcData, so we can simply
            // wrap it in a ConstrData with the correct index
            return {
                redeemer: new ConstrData(varSt.constrIndex, [
                    new ConstrData(nestedVarSt.constrIndex, [...args]),
                ]),
            };
        }

        try {
            return {
                redeemer: new TopEnum(new NestedVariant(...args))._toUplcData(),
            };
        } catch (e: any) {
            // warning emoji: "⚠️"
            e.message =
                "⚠️ ⚠️ ⚠️ error constructing minting activity.  You might need " +
                "to format the args as UplcData if the enum doesn't recognize a valid off-chain type.\nMinting activity: " +
                e.message;
            throw e;
        }
    }

    mkSeededMintingActivity(
        mintingActivityName: string,
        seed: TxOutputId,
        ...args: any[]
    ): isActivity {
        const TopEnum = this.mustGetActivity("MintingActivities");
        const { MintingActivity } = this.onChainTypes;
        const NestedVariant = this.mustGetEnumVariant(
            MintingActivity,
            mintingActivityName
        );

        const varSt = TopEnum.prototype._enumVariantStatement;
        const nestedVarSt = NestedVariant.prototype._enumVariantStatement;
        // it ^^^  MUST  have a 'seed' arg
        const foundName = nestedVarSt.dataDefinition.fields[0].name.value;
        if ("seed" !== foundName ) {
            throw new Error(
                `${mintingActivityName}: expected 'seed' field in position 1 of MintingActivity variant, \n`+
                `... but found field '${foundName}' instead.  \n`+
                `If this activity doesn't require a seed for guaranteed minting uniqueness, you should instead use:`+
                `   mkSeedlessMintingActivity() \n\n`+
                `^^^ Error in MintingActivity: ${mintingActivityName} ^^^ `
            )
        }

        if (args.every((x) => x instanceof UplcData)) {
            // the data is already encoded as UplcData, so we can simply
            // wrap it in a ConstrData with the correct index
            if (!seed._toUplcData) debugger;
            return {
                redeemer: new ConstrData(varSt.constrIndex, [
                    new ConstrData(nestedVarSt.constrIndex, [
                        seed._toUplcData(),
                        ...args,
                    ]),
                ]),
            };
        }

        try {
            return {
                redeemer: new TopEnum(
                    new NestedVariant(seed, ...args)
                )._toUplcData(),
            };
        } catch (e: any) {
            // warning emoji: "⚠️"
            e.message =
                "⚠️ ⚠️ ⚠️ error constructing minting activity.  You might need " +
                "to format the args as UplcData if the enum doesn't recognize a valid off-chain type.\nMinting activity: " +
                e.message;
            throw e;
        }
    }

    /**
     * redeemer for spending the authority UUT for burning it.
     * @public
     * @remarks
     *
     * The Retiring redeemer indicates that the delegate is being
     * removed.
     *
     **/
    @Activity.redeemer
    activityRetiring() {
        return this.mkDelegateLifecycleActivity("Retiring");
    }

    @Activity.redeemer
    activityValidatingSettings() {
        return this.mkDelegateLifecycleActivity("ValidatingSettings");
    }

    // @Activity.redeemer
    activityMultipleDelegateActivities(
        ...activities: isActivity[]
    ): isActivity {
        const MDA = this.mustGetActivity("MultipleDelegateActivities");
        const index = MDA.prototype._enumVariantStatement.constrIndex;

        return {
            redeemer: new ConstrData(index, [
                new ListData(activities.map((a) => a.redeemer as UplcData)),
            ]),
        };
    }

    /**
     * creates the essential datum for a delegate UTxO
     * @remarks
     *
     * Every delegate is expected to have a two-field 'IsDelegation' variant
     * in the first position of its on-chain Datum type.  This helper method
     * constructs a suitable UplcData structure, given appropriate inputs.
     * @param dd - Delegation details
     * @public
     **/
    @datum
    mkDatumIsDelegation(dd: DelegationDetail): InlineDatum {
        const { IsDelegation } = this.onChainDatumType;
        const { DelegationDetail } = this.onChainTypes;
        const t = new IsDelegation(new DelegationDetail(dd));
        return Datum.inline(t._toUplcData());
    }

    /**
     * returns the ValidatorHash of the delegate script, if relevant
     * @public
     * @remarks
     *
     * A delegate that doesn't use an on-chain validator should override this method and return undefined.
     **/
    get delegateValidatorHash(): ValidatorHash | undefined {
        if (!this.validatorHash) {
            throw new Error(
                `${this.constructor.name}: address doesn't use a validator hash!\n` +
                    `  ... if that's by design, you may wish to override 'get delegateValidatorHash()'`
            );
        }
        return this.validatorHash;
    }

    /**
     * {@inheritdoc AnyDelegate.DelegateMustFindAuthorityToken}
     **/
    async DelegateMustFindAuthorityToken(
        tcx: StellarTxnContext,
        label: string
    ): Promise<TxInput> {
        return this.mustFindMyUtxo(
            `${label}: ${bytesToText(this.configIn!.tn)}`,
            this.mkTokenPredicate(this.tvAuthorityToken()),
            "this delegate strategy might need to override txnMustFindAuthorityToken()"
        );
    }

    /**
     * Adds the delegate's authority token to a transaction
     * @public
     * @remarks
     * Given a delegate already configured by a Capo, this method implements
     * transaction-building logic needed to include the UUT into the `tcx`.
     * the `utxo` is discovered by {@link AnyDelegate.DelegateMustFindAuthorityToken | DelegateMustFindAuthorityToken() }
     *
     * The default implementation adds the `uutxo` to the transaction
     * using {@link ContractBasedDelegate.activityAuthorizing | activityAuthorizing() }.
     *
     * The off-chain code shouldn't need to check the details; it can simply
     * arrange the details properly and spend the delegate's authority token,
     * using this method.
     *
     * ### Reliance on this delegate
     *
     * Other contract scripts can rely on the delegate script to have validated its
     * on-chain policy and enforced its own "return to the delegate script" logic.
     *
     * ### Enforcing on-chain policy
     *
     * When spending the authority token in this way, the delegate's authority is typically
     * narrowly scoped, and it's expected that the delegate's on-chain script validates that
     * those parts of the transaction detail should be authorized, in accordance with the
     * delegate's core purpose/responsbility - i.e. that the txn does all of what the delegate
     * expects, and none of what it shouldn't do in that department.
     *
     * The on-chain code SHOULD typically enforce:
     *  * that the token is spent with an application-specific redeemer variant of its
     *     MintingActivity or SpendingActivitie.
     *
     *  * that the authority token is returned to the contract with its datum unchanged
     *  * that any other tokens it may also hold in the same UTxO do not become
     *     inaccessible as a result of the transactions - perhaps by requiring them to be
     *     returned together with the authority token.
     *
     * It MAY enforce additional requirements as well.
     *
     * @example
     * A minting delegate should check that all the expected tokens are
     * minted, AND that no other tokens are minted.
     *
     * @example
     * A role-based authentication/signature-checking delegate can
     * require an appropriate signature on the txn.
     *
     * @param tcx - the transaction context
     * @param utxo - the utxo having the authority UUT for this delegate
     * @reqt Adds the uutxo to the transaction inputs with appropriate redeemer.
     * @reqt Does not output the value; can EXPECT txnReceiveAuthorityToken to be called for that purpose.
     **/
    async DelegateAddsAuthorityToken<TCX extends StellarTxnContext>(
        tcx: TCX,
        uutxo: TxInput,
        redeemer: isActivity
    ): Promise<TCX> {
        const { capo } = this.configIn!;
        return capo.txnAttachScriptOrRefScript(
            tcx.addInput(uutxo, redeemer),
            this.compiledScript
        );

        // return this.txnKeepValue(
        //     tcx,
        //     uutxo.value,
        //     uutxo.origOutput.datum as InlineDatum
        // );
    }

    /**
     * {@inheritdoc AnyDelegate.DelegateAddsAuthorityToken}
     **/
    async DelegateRetiresAuthorityToken<TCX extends StellarTxnContext>(
        tcx: StellarTxnContext,
        fromFoundUtxo: TxInput
    ): Promise<TCX> {
        const utxo = fromFoundUtxo;

        return tcx.addInput(
            new TxInput(utxo.outputId, utxo.origOutput),
            this.activityRetiring()
        ) as TCX;
    }
}

/**
 * @public
 */
export type NamedDelegateCreationOptions<
    thisType extends Capo<any>,
    DT extends StellarDelegate
> = DelegateCreationOptions<
    string & keyof thisType["delegateRoles"]["namedDelegate"]["variants"],
    DT
> & {
    /**
     * Optional name for the UUT; uses the delegate name if not provided.
     **/
    uutName?: string;
};
// MinimalDelegateLink<DT> & {
//     uutOptions: UutCreationAttrs | ForcedUutReplacement
//     strategyName: string &
//     keyof thisType["delegateRoles"]["spendDelegate"]["variants"];
//     forcedUpdate?: true;
// };

export type DelegateCreationOptions<
    STRATEGIES extends string,
    DT extends StellarDelegate
> = MinimalDelegateLink<DT> & {
    /**
     * details for creating the delegate
     */
    mintSetup: NormalDelegateSetup | DelegateSetupWithoutMintDelegate;
    strategyName: string & STRATEGIES;
    /**
     * Installs the named delegate without burning the existing UUT for this delegate.
     * That UUT may become lost and inaccessible, along with any of its minUtxo.
     **/
    forcedUpdate?: true;
};
