module specializedDelegate

// specialized to ...
//   -   NOT YET SPECIALIZED (replace with your specialization notes here) - 
// original notes about (un)specialization follow:


//  //! provides a basic version, not yet specialized,
//  // of the "specializedDelegate" interface, which simply
//  // exports a DelegateDatum enum and DelegateActivities (redeemer enum).  

//  //! Your specialization MUST include the enum variants found in this
//  //  ... unspecialized version.  It MAY include additional Datum variants.
//  // Any additional Redeemer/Activity variants should be added underneath 
//  // the SpendingActivity / MintingActivity top-level enum variants, instead 
//  // of adding new top-level enum variants to DelegateActivity.

//  // The DelegateActivity (redeemer) enum conforms to the 
//  // Delegate Redeemer protocol, in which enum 0 is reserved for
//  // lifecycle activities, enum 1 is used for spend-related activities 
//  // (if the delegate is used as a spend delegate), and enum 2 is called
//  // for authorizing minting.  Enum 3 and beyond are reserved for
//  // extensions to the Delegate Redeemer protocol.

//  // Within the minting and spending activities, the specialization can 
//  // indicate a nested activity enum to support various dApp-specific
//  // activities.  

//  // Activities that validate minting of UUTs should contain enum fields 
//  // to identify the seed-transaction details needed for properly validating 
//  // UUT mints fitting the use-case.

//  //! Your specialization MAY include any additional functions, imports or 
//  //  methods defined on any of the types in this file.


import {
    DelegationDetail,
    mustReturnValueToScript,
    tvAuthorityToken,
    DelegateLifecycleActivity,
    CapoLifecycleActivity,
    unmodifiedDelegation
} from CapoDelegateHelpers

import {
    validateUutMinting,
    mkUutTnFactory
} from CapoMintHelpers

import {
    capoSettings
} from CustomCapoSettings

enum DelegateDatum {
    IsDelegation {
        dd: DelegationDetail
    }
    ScriptReference

    func validateSettings(self, ctx: ScriptContext, settings: capoSettings) -> Bool{
        assert(false, "not valid (stubbed)");
        settings.serialize() != self.serialize() &&
        ctx.tx.serialize() != self.serialize() &&        
        true
    }

}

enum MintingActivity {
    // application can replace the placeholder, which is only here to 
    // avoid a syntax error in the unspecialized version
    _placeholder  
}

//! The minting delegate can also be used as a general spending 
// delegate (this is the default arrangement during the Capo 
// charter mint).  These activities are required by the Capo when
// spending utxos having DelegatedDatum type.
enum SpendingActivity {
    // application can replace the placeholder, which is only here to 
    // avoid a syntax error in the unspecialized version
    _placeholder  
}

enum DelegateActivity {
    // must ALWAYS be at Enum position 0
    CapoLifecycleActivities {
        activity: CapoLifecycleActivity
    }

    // must ALWAYS be at Enum position 1
    DelegateLifecycleActivities {
        // administrative activities for the delegate lifecycle, enforced
        //  by the basic mint delegate code.  Specializations can add more 
        //  restrictions, but in many/most cases they will not need to.
        activity: DelegateLifecycleActivity
    }

    // application-specific spending activities, ALWAYS at Enum position 2
    SpendingActivities {
        activity: SpendingActivity
    }

    // application-specific minting activities, ALWAYS at Enum position 3
    MintingActivities {
        activity: MintingActivity
    }

    // this function gives a general-purpose implementation of checking for 
    // valid uut minting. 
    //
    // A specialization might modify it to use different policies
    // or enforce additional requirements
    // 
    // func genericUutMinting(self, 
    //     mdd: DelegateDatum,
    //     ctx: ScriptContext
    // ) -> Bool {
    //     //!!! replace with an activity using the same seed-txn pattern:
    //     // MintingActivities::SomethingMintingUuts{sTxId, sIdx, purposes} = self;
    //     DelegateDatum::IsDelegation{dd} = mdd;
    //     returnsAuthzToken : Bool = mustReturnValueToScript(tvAuthorityToken(dd), ctx);

    //     o : []TxOutput = ctx.get_cont_outputs();
    //     if (o.length != 1) { error("single utxo only") };

    //     print ("in unsp_MD");
    //     isOk : Bool = returnsAuthzToken && 

    //     unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize(), ctx) &&

    //     // This call can serve as a template for enforcing expected mints 
    //     // of uuts (and additional token values) in validation of application-
    //     // specific activities, given (mph, sTxId, sIdx, purposes)
    //     validateUutMinting(
    //         ctx: ctx, 
    //         mph: dd.mph,
    //         seedTxId: sTxId, 
    //         seedIdx: sIdx, 
    //         purposes: purposes,
    //         // additionalValues: ()
    //         mkTokenName: mkUutTnFactory(sTxId, sIdx)
    //     );

    //     isOk
    // }

    //! used only for validating IsDelegation datum, that is,
    //   ... to approve minting requests or any customize spending modes 
    //   ... of that datum.  
    
    //  Note that the basic delegate already enforces some basic
    //    administrative expectations for DelegateLifecycleActivities and CapoLifecycleActivities
    //    so a specialization doesn't need to re-implement those checks.
    func additionalDelegateValidation( self,
        priorMddd: DelegateDatum::IsDelegation, 
        ctx: ScriptContext
    ) -> Bool {
        // print("  ----- checking additional delegate validation");
        self.switch {
            // generic DelegateLifecycleActivities is already validated, but 
            //  ... you can add more constraints here if needed
            DelegateLifecycleActivities => true,
            CapoLifecycleActivities{CLA} => {
                // CapoLifecycleActivites are always rejected except for MINTING delegates.
                //  assert(isMintingDelegate, "unreachable"); // TODO access this const defined in the main script

                // They're normally rejected in this unspecialized (minting) delegate:
                assert(false, "unspecialized mint delegate rejecting CapoLifecycleActivities") ;
                //   ... but if you have cases for creating new delegates, such as 
                //   ... named delegates for advanced constellations of contracts 
                //   ... in your Capo, you can implement checks for that here.
                //  You can use this construct as-is, or modify it to suit your needs.
                CLA.switch {
                    CreatingDelegate{seedTxn,seedIndex,purpose} => {
                        self.supportedCapoDelegatePurposes().find_safe(
                            (p : String) -> Bool { p == purpose } 
                        ).switch {
                            None => error("can't mint delegate with unsupported purpose"),
                            Some => {
                                // assert(false, "not yet implemented")
                                print("is this validateUutMinting check redundant?");

                                validateUutMinting(
                                    ctx: ctx, 
                                    mph: priorMddd.dd.mph,
                                    seedTxId: seedTxn, 
                                    seedIdx: seedIndex, 
                                    purposes: []String{purpose},
                                    // additionalValues: ()
                                    mkTokenName: mkUutTnFactory(seedTxn, seedIndex),
                                    // WE ARE the mint delegate.
                                    needsMintDelegateApproval: false 
                                )
                            }
                        }
                    },
                     _ => false
                 }
            },
            _ => false
        } || ctx.tx.serialize() != priorMddd.serialize()        
    }
    func supportedCapoDelegatePurposes(self) -> []String {
        assert(true || /* prevent unused variable */ self == self, "no way" );
         []String{ 
            // "nothingHereYet",
        }
    }

    //! Used only for validating non-IsDelegation datum types and activities.
    // if you have any special admininstrative data structures that inform 
    // ...  your minting policy, this might be useful.  Otherwise, and typically,
    // ... you should look to Activity validations above in additionalDelegateValidation,
    // ...  in which the isDelegation token is being spent with an application-specific
    // ...  activity/redeemer
    func otherDatumValidation( self,
        priorMdd: DelegateDatum, 
        ctx: ScriptContext
    ) -> Bool {
        neverTriggered = () -> {  error("never called") };
        self.switch{
            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.
            //  Using it on any other Datum type will always fail and execution will never arrive here.
            DelegateLifecycleActivities => neverTriggered(),
            CapoLifecycleActivities => neverTriggered(),

            // -- Application-specific activities can be added here 
            // -- for special & app-specific types of datum in a delegate,
            // -- for EXCEPTIONAL cases, if you really know what you're doing.  
            //  -- see above for normal cases

            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls
        } && (priorMdd.serialize() != ctx.serialize())
    }
}

