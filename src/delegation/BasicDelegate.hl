spending BasicDelegate

const rev : Int = 1
const instance : ByteArray = #67656e6572616c // -> "general"
const delegateName : String // = "💩  noName Delegate : ( "
const isMintDelegate : Bool = false
const isSpendDelegate : Bool = false
const isDgDataPolicy : Bool = false

import {
    tx, 
    get_current_input,
    get_current_validator_hash
} from ScriptContext

import {
    DelegateRole,
    DelegationDetail,
    DgTknDisposition as DgTkn,
    ManifestActivity,
    PendingDelegateChange,
    PendingDelegateAction,
    RelativeDelegateLink
} from CapoDelegateHelpers

// import {
//     ProtocolSettings
// } from ProtocolSettings

import {
    getTxCharterDatum,
    mkCapoCtx,
    CapoCtx,
    mkTokenShow,
    CapoDatum
    // CapoActivity
} from CapoHelpers

import {
    mkUutTnFactory,
    validateUutMinting
} from CapoMintHelpers

import {
    fromCip68Wrapper,
    outputAndDatum,
    returnsValueToScript,
    TODO,
    REQT,
    bREQT
    // tvCharter
} from StellarHeliosHelpers

import {
    DelegateActivity,
    DelegateDatum,
    BurningActivity,
    MintingActivity,
    SpendingActivity
} from specializedDelegate

// formerly was in Capo core contract script
// func allDelegatesAreValidatingSettings() -> Bool {
//         // print( "  ...with activity updatingSettings\n");
//         // _isRelevantDatum : Bool = capoDatum.switch {
//         //     // SettingsData => true,
//         //     CharterData => true,
//         //     _ => error("wrong use of updatingSettings action; must use only on CharterDatum")
//         // };
//         // !!! move to SettingsDelegate?  or keep as a baseline check?
//         // it requires the govAuthority to be present 
//         REQT( "gov authority must be present to update settings");
//         hasGovAuthority : Bool = mustHaveGovAuthority(
//             mph: mph,
//             charterDatum: charterDatum // already resolved
//         );

//         CapoDatum::CharterData{
//             spendDelegate,
//             spendInvariants,
//             otherNamedDelegates,
//             mintDelegate,
//             mintInvariants,
//             govDelegate,
//             manifest
//         } = capoDatum;

//         //!!! note, this is a hard-coded version of requiring the settings policy script:
//         REQT("the current Settings must be spent and updated");
//         settingsDgtLink : RelativeDelegateLink = otherNamedDelegates.get_safe("settingsPol").switch {
//             None => error("'settings' delegate must be present to do updatingSettings activity"),
//             Some{dgt} => dgt
//         };

//         settingsDgtInput = settingsDgtLink.hasDelegateInput(
//             inputs: tx.inputs,
//             mph: mph
//         ).unwrap();
//         settingsDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( 
//             mustFindInputRedeemer(settingsDgtInput)
//         ).switch {
//             SpendingActivities => true,
//             _ => assert("settings delegate must be updating the settings with its SpendingActivities variant")
//         };
//         _nextSettings : Data = cctx.getNextManifestedDatumRaw("settings");
//         isUpdatingSettings : Bool = true;
        
//         inputs: []TxInput = tx.inputs;

//         //!!! actually requiring delegates' SettingsValidation starts here.
//         REQT( "spend delegate must validate settings (wait, that's myself.  Call validate directly?");

//         spendDelegateIsValidating : Bool = 
//             spendDelegate.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: true
//             ).unwrap();

//         REQT("mint delegate must validate settings");
//         mintDelegateIsValidating : Bool = 
//             mintDelegate.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: true
//             ).unwrap();

//         // govAuthority is checking the settings
//         REQT( "govDelegate MAY contribute to settings validation");
//         govDelegateMaybeValidating : Bool = 
//             govDelegate.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: false
//             ).switch{
//                 Some => true,
//                 None => {
//                     print("  -- govAuthority isn't a script-based validator; doesn't validate new settings\n");
//                     true
//                 }
//             };
//         checkOneInvariant : (RelativeDelegateLink) -> Bool = 
//         (oneDgt: RelativeDelegateLink) -> Bool {
//             REQT( "invariant must validate settings");
//             oneDgt.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: true
//             ).unwrap()
//         };
//         // spendInvariants are checking the settings
//         REQT( "spend invariants must validate settings");
//         spendInvariantsAreValidating : Bool = spendInvariants.all( 
//             checkOneInvariant
//         );
//         // mintInvariants are checking the settings
//         REQT( "mint invariants must validate settings");
//         mintInvariantsAreValidating : Bool = mintInvariants.all( 
//             checkOneInvariant
//         );
//         // namedDelegates are checking the settings
//         REQT( "named delegates must validate settings");
//         namedDelegatesAreValidating : Bool = otherNamedDelegates.fold( 
//             REQT( "  - each named delegate must validate settings");
//             (ok: Bool, key: String, dgt: RelativeDelegateLink) -> Bool {
//                 print("  - named delegate: " + key);
//                 print("\n");
//                 ok && dgt.validatesUpdatedSettings(
//                     inputs: inputs,
//                     mph: mph,
//                     inputRequired: true
//                 ).unwrap()
//             }, true
//         );

//         isRelevantDatum &&
//         settingsDelegateIsValid &&
//         isUpdatingSettings &&
//         spendDelegateIsValidating &&
//         mintDelegateIsValidating &&
//         govDelegateMaybeValidating &&
//         spendInvariantsAreValidating &&
//         mintInvariantsAreValidating &&
//         namedDelegatesAreValidating &&
//         hasGovAuthority
// }

func main(mdd: DelegateDatum, activity: DelegateActivity) -> Bool {
    print(" 🚥❓delegate: "+delegateName + "\n");

    // input = get_current_input();
    result :Bool = mdd.switch{
        //! performs essential checks of policy for spending the minting delegate's authority token "mintDgt-*"
        // ... it also calls any additionalDelegateValidation() defined in a specialized minting delegate,
        // ... governing the minting of application-specific tokens (including UUTs, fungible tokens, 
        // ... or other sorts of tokens under our minting policy).
        //! Ditto, for our spendDgt-* token, for governing the spend of any utxos in the Capo address.
        capoStoredData => error("Data Delegates must never store the capoStoredData variant in the script; used only for data-structuring capo-stored utxo datum"),
        // todo: ensure that the utxo-creation path also does not store IsDelegatedData variants in the script

        //! This code path is also used for other authority-bearing tokens in other specialized delegates,
        //  ... such as named delegates that the mintDgt- or spendDgt- policies defer to.
        //  ... each of those cases has separate execution through this base logic, with specialization 
        //  ... applicable for each (see references to "nowActingAs").
        isD : IsDelegation{dd} => {
            // MintDelegateDatum::IsDelegation{dd, cfg} = isD;
            showMyTokens : (Value) -> String = mkTokenShow(dd.mph);
            print("  -- is spending dgTkn "+ showMyTokens(get_current_input().value ));
            print("\n");

            activity.switch {
                MultipleDelegateActivities{activities} => {
                    // NOTE: the Capo ensures that each SPENT UTxO is addressed by EXACTLY ONE SpendDgt activity.
                    // When executed in a mint/spend delegate, the policy below ensures 
                    // ... that each requested activity is matched by a UTxO in the transaction, 
                    // ... guaranteeing 1:1 coverage of activities & UTxOs.

                    // Those are executed in parts (one set of activities applicable to mintDgt-* token,
                    //   ... and the other governed by a spendDgt-* token.  It is common that the exact
                    //   ... same contract script executes both, unless it has a special need to
                    //   ... separate the code for those two; regardless, each is enforced in
                    //   ... a separate execution (different utxos, different activity/redeemer each).

                    // For now, only *DelegatedData activities are valid in mint/spend multi-activities.

                    // Special: DeletingDelegatedDatum requires a Spend validation as well as a Burn validation,
                    //   ... so it will be present in both the mintDgt and spendDgt multi-activities.

                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();

                    activities.all( (rawActivity: Data) -> Bool {
                        a : DelegateActivity = DelegateActivity::from_data(rawActivity);

                        if (cctx.nowActingAsMintDgt(required: false)) {
                            // probably can't fail here:
                            assert(isMintDelegate, "ack! non-MintDelegate can't act as mintDgt");
                            print("  -- mintDgt checking multi-activity");
                            REQT("in the mint delegate, only {Create,Delete}DelegatedData activities are valid in multi-activities");
                            a.switch {
                                // in the Mint and Spend delegates, these nested activities are expected to re-delegate 
                                // to delegated-data controllers, which will use Mint/Spend/Burn activities on the data-controller tokens.
                                CreatingDelegatedData/*{TxOutputId{seedTxn, seedIdx}, dataTypePurpose} */=> {
                                    // Note: CreatingDelegatedData activity doesn't involve the Capo at all!
                                    // Instead, the minter creates a UUT for the data, on authority of the mintDgt;
                                    // ... and the mintDgt requires the presence of the corresponding dgDataPolicy (with its MintingActivity);
                                    // ... then the dgDataPolicy checks the validity of the new data, and requires that
                                    // ... the new data is created as a DelegatedData record in the Capo address.

                                    // assert(isMintDelegate && cctx.nowActingAsMintDgt(),
                                    //     "CreatingDelegatedData only ok in mintDgt"
                                    //     // " ... use MintingActivities in a delegated-data controller"
                                    // );
                                    // recursion checks for the needed input/output and DgDataController MintingActivity                                
                                    main(mdd, a)
                                },
                                DeletingDelegatedData => {
                                    // assert(isMintDelegate, "DeletingDelegatedData only ok in mintDgt" ); // " ... use BurningActivities in a delegated-data controller"
                                    // cctx.nowActingAsMintDgt() &&
    
                                    // recursion checks for the needed input/burn                                
                                    main(mdd, a)
                                },
                                UpdatingDelegatedData => error(
                                    "UpdatingDelegatedData only ok at level-1 spendDgt"
                                ),
                                DelegateLifecycleActivities => error("multi:DelegateLifecycleActivities not ok"),
                                CapoLifecycleActivities => error("multi:CapoLifecycleActivities not ok"),
                                MultipleDelegateActivities => error("multi:multi: nesting not ok"),
    
                                _ => error("multi:non-minting activities are invalid for mintDgt")
                            }
                        } else if (cctx.nowActingAsSpendDgt(required: false)) {
                            // probably can't fail here:
                            assert(isSpendDelegate, "ack! non-SpendDelegate can't act as spendDgt");
                            print("  -- spendDgt checking multi-activity");
                            REQT("in the spend delegate, only {Updating,Deleting}DelegatedData activities are valid in multi-activities");
                            a.switch {
                                // in the Mint and Spend delegates, these nested activities are expected re-delegate to delegated-data controllers,
                                // which will use Mint/Spend/Burn activities on the data-controller tokens.
                                UpdatingDelegatedData{_typeName, _recId} => {
                                    assert(isSpendDelegate && cctx.nowActingAsSpendDgt(),
                                        "UpdatingDelegatedData only ok at level-1 spendDgt"
                                        // " ... a delegated-data-controller will use one of its SpendingActivities to govern capoStoredData's spend"
                                    );
                                    // the recursion always checks for the input-datum, so we
                                    // don't need to check it here.
                                    // _inputDD = cctx.delegatedDataTxInput(recIdBytes: recId);
                                    main(mdd, a)
                                },
                                CreatingDelegatedData => error(
                                    "CreatingDelegatedData only ok in mintDgt"
                                ),
                                DeletingDelegatedData => {
                                    error("TODO: validate spending the datum for burn")
                                },
                                DelegateLifecycleActivities => error("multi:DelegateLifecycleActivities not ok"),
                                CapoLifecycleActivities => error("multi:CapoLifecycleActivities not ok"),
                                MultipleDelegateActivities => error("multi:multi: nesting not ok"),
                                _ => error("multi: non-spending activities are invalid for spendDgt")
                            }
                        } else {
                            assert(!isMintDelegate && !isSpendDelegate, "ack! delegated-data policy can't be a mint/spend delegate");
                            TODO("assert isDgDataPolicy"); // assert(isDgDataPolicy, "invalid use of multiActivity by non-DgDataPolicy");
                            print("  -- dgDataPolicy checking multi-activity");
                            // WHEN this code is supporting a DgDataPolicy (with its own specializedDelegate module),
                            //   the multi-activity expects Minting/Spending/Burning activities, not *DelegatedData activities.
                            REQT("in DgDataPolicy, only Minting/Burning/Spending activities are valid");
                            a.switch {
                                UpdatingDelegatedData => error(
                                    "UpdatingDelegatedData only ok at level-1 spendDgt (use a SpendingActivity in dgDataPolicy)"
                                ),
                                CreatingDelegatedData => error(
                                    "CreatingDelegatedData only ok in mintDgt (use a MintingActivity in dgDataPolicy)"
                                ),
                                DeletingDelegatedData => error(
                                    "DeletingDelegatedData only ok at mint/spend dgt (use BurningActivity in dgDataPolicy)"
                                ),
                                // in the delegated-data controllers, we have to support these multi-activities.
                                // this will pass through the individual activity to be individually validated by the specialized delegate 
                                // module that governs the data-controller's UUT, in its additionalDelegateValidation() function.
                                SpendingActivities => main(mdd, a),
                                MintingActivities => main(mdd, a),
                                BurningActivities => {
                                    assert(false, "TODO: support multi:BurningActivities for dgDataPolicy or other delegate") ;
                                    main(mdd, a)
                                },
                                DelegateLifecycleActivities => error("multi:DelegateLifecycleActivities not ok"),
                                CapoLifecycleActivities => error("multi:CapoLifecycleActivities not ok"),
                                MultipleDelegateActivities => error("multi:multi: nesting not ok")
                                // _ => error("multi: invalid other activity for non-mint/spend delegate")
                            }
                        }
                    })
                },
                //   guards that the authority token is returned to this script.
                // specialized minting delegates should likely perform additional checks.
                DelegateLifecycleActivities{innerActivity} => innerActivity.switch {
                    // reassigning the authority token to a new minting delegate
                    ReplacingMe{seed, purpose} => {
                        // should burn the old UUT, mint the new UUT, and update the Charter
                        // with the new mint authority

                        //xxx -   tx.minted.get_safe( dd.acAuthorityToken() ) == 0 &&
                        //xxx -   !returnsValueToScript( dd.tvAuthorityToken())

                        BURNED: Int = -1;
                        otherMintedValue: Value = Value::new(
                            AssetClass::new(dd.mph, dd.tn), 
                            BURNED
                        );
                    
                        print("checking ReplacingMe on "+purpose + ": "+ dd.tn.decode_utf8());
                        REQT("needs the charter to be approving the the new mint-delegate");
                        TODO("  ^^^ should queue the new delegate in pendingDgtChanges");

                        cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterInput();
                        isUpdatingCharter : Bool = cctx.getCharterRedeemer().switch {
                            // THE CHARTER UPDATE ITSELF WILL CHECK THAT THERE'S A VALID DELEGATE OUTPUT FOR THE NEW DELEGATE
                            updatingCharter => true,
                            _ => false
                        };

                        isMintingOk : Bool = validateUutMinting(
                            mph: dd.mph,
                            seed: seed,
                            purposes: []String{purpose}, 
                            otherMintedValue: otherMintedValue,
                            needsMintDelegateApproval: false,
                            extraMintDelegateRedeemerCheck: false
                        );

                        isMintingOk && isUpdatingCharter

                    },

                    // the token is being burned, retiring the authority token for this minting delegate
                    // as a result, this minting delegate will no longer be consulted.  This could be combined
                    // with the creation of a new minting delegate with a new authority token, registered
                    // with the Capo in place of this one (or Reassigning could be used for such a case).
                    // If there is no replacement minting delegate, then the Capo will not be able to perform 
                    // any further minting activities.
                    //
                    // Retiring is not suitable for authorizing token-burning.
                    Retiring => {
                        tx.minted.get(dd.acAuthorityToken()) == -1
                    },

                    ValidatingSettings => {
                        _charter : CapoDatum::CharterData = getTxCharterDatum(dd.mph);

                        // each application-specific delegate must validate the settings
                        // for itself?
                        // OR: import the settings type, and trigger the validation here
                        // ... so delegate authors can have fewer hoops to jump through
                        TODO("import settings from delegate and validate them");

                        // foundSettings : ProtocolSettings = cctx.getManifestedDatum[ProtocolSettings]("settings");

                        //xxx foundSettings : outputAndDatum[CapoDatum::SettingsData] = 
                        //xxx     charter.mustFindSettingsOutput(dd.mph, dd.capoAddr);
                        //xxx customSettings = fromCip68Wrapper[ProtocolSettings](foundSettings.rawData);

                        // print("\n" + delegateName + ": delegate TRYING TO VALIDATE SETTINGS\n");
                        // validated : Bool = customSettings.validate();
                        // print("HURRAY\n");

                        // TODO: also validate any typeMap (can do this later and adopt the new delegate 
                        // into the Capo when this code is written)

                        assert( false && 
                            // validated && 
                            // isValid : Bool = 
                            //     ((isTest && throwIfBadSettings(mdd, settings)) || true) &&
                            //     mdd.validateSettings(settings);
                            // isValid
                            true,
                            "ValidateSettings temporarily disabled"
                        );
                        false
                    }
                },
                CapoLifecycleActivities{CLA} => {
                    cctx = mkCapoCtx(dd.mph).
                        withCharterInput().
                        requiresGovAuthority();                    

                    wantsRole : DelegateRole = CLA.switch {
                        forcingNewSpendDelegate => error("the forcingNewSpendDelegate escape-hatch activity is always handled directly by the Capo"),
                        forcingNewMintDelegate => error("the forcingNewMintDelegate escape-hatch activity is always handled directly by the Capo"),
                        removePendingDgtChange => DelegateRole::SpendDgt,
                        commitPendingDgtChanges => DelegateRole::BothMintAndSpendDgt,
                        updatingManifest => DelegateRole::SpendDgt,

                        CreatingDelegate => {
                            TODO("deprecate use of CLA::CreatingDelegate");
                            DelegateRole::MintDgt
                        },

                        queuePendingDgtChange => DelegateRole::BothMintAndSpendDgt
                        // we want explicit handling of each case; don't use a default match here.
                        // _ => error("DO NOT CATCH DEFAULT CASE HERE")
                    };
                    wantsRole.switch {
                        SpendDgt => {
                            assert(isSpendDelegate && cctx.nowActingAsSpendDgt(), 
                                "this Capo lifecycle activity is only valid on spend delegate, not "+ delegateName
                            )                            
                        },
                        MintDgt => {
                            assert(isMintDelegate && cctx.nowActingAsMintDgt(),
                                "this Capo lifecycle activity is only valid on mint delegate, not "+ delegateName
                        )},
                        _ => error("no way") // unreachable
                    };

                    // the Capo policy already requires that this activity is identical
                    // to the capo's own triggered lifecycle activity, given that the
                    // capoLifecycleActivity is what's involved on that end.  We
                    // ensure that is true here:
                    REQT("cross-checks that the Capo's CharterData is activity-matched with delegate's activity");
                    cctx.getCharterRedeemer().switch {
                        capoLifecycleActivity => print("ok, matched with CharterData activity capoLifecycleActivity\n"),
                        updatingCharter => {
                            CLA.switch {
                                CreatingDelegate => {
                                    print("ok, Capo:updatingCharter works for now with CreatingDelegate\n")
                                },
                                _ => error("when Capo is UpdatingCharter, the mintDelegate must be CreatingDelegate")
                            }
                        },
                        _ => error("this activity must match the capo's own CharterData activity")
                    };

                    CLA.switch {
                        // the mint delegate is validating a mint that CREATES A NEW DELEGATE
                        // FOR APPLICATION-SPECIFIC PURPOSES. This can affect the structure of the Capo
                        // it defers to the specialized minting delegate, if any; the unspecialized mint delegate
                        // rejects all delegate-creation.
                        CreatingDelegate{seed, purpose} => {
                            // print("🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞 !!!!!!!!!!!!!!!!!!! todo: fix this\n");
                            // assert(false, "obsolete CLA::CreatingDelegate?");
                            TODO("XXX it should output the new delegate token to the Capo as a PendingDelegate datum");
                            REQT("validates creation of UUT for the new delegate, aligned to the purpose indicated");

                            validateUutMinting(
                                mph: dd.mph,
                                seed: seed,
                                purposes: []String{purpose},
                                // otherMintedValue: ()
                                mkTokenName: mkUutTnFactory(seed),
                                // WE ARE the mint delegate.
                                needsMintDelegateApproval: false 
                            )
                        },
                        queuePendingDgtChange{action, role, name} => {
                            print("  -- addingPendingDgt");
                            charterDatum : CapoDatum::CharterData = cctx.getCharterDatum();
                            action.switch {
                                // when it's a Remove action, it's only valid in the spend-delegate.
                                Remove => {
                                    assert(cctx.nowActingAsSpendDgt(), "<----- that can fail, this can't");
                                    error("unreachable")
                                }, 
                                // when it's an Add action or Replace action,
                                // it's only valid in the mint-delegate 
                                _ => {
                                    assert(cctx.nowActingAsMintDgt(), "<----- that can fail, this can't")
                                }
                            };

                            REQT("the new pending-delegate action is added on the front of the existing list of pending actions");
                            oldPendingChanges = charterDatum.pendingDgtChanges;

                            expectedChanges = oldPendingChanges.prepend(
                                PendingDelegateChange{
                                    action: action,
                                    role: role,
                                    name: name
                                }
                            );

                            assert(
                                charterDatum.pendingDgtChanges == expectedChanges, 
                                "invalid update of pendingDgtChanges; should prepend the new action to the existing list."
                            );

                            hasNewPendingEntry : Bool = false; // finish me
                            // cctx.mustOutputPendingDelegate(
                            //     seed: seed,
                            //     role: role,
                            //     name: name
                            // );

                            passedAdditionalVerifications : Bool = action.switch {
                                Remove => {
                                    role.switch {
                                        MintDgt => error("cannot Remove role: MintDgt"),
                                        SpendDgt => error("cannot Remove role: SpendDgt"),
                                        MintInvariant => error("cannot Remove role: MintInvariant"),
                                        SpendInvariant => error("cannot Remove role: SpendInvariant"),
                                        DgDataPolicy => {
                                            assert(false, "todo")
                                        },
                                        OtherNamedDgt => {
                                            assert(false, "todo")
                                        },
                                        BothMintAndSpendDgt => error(
                                            "DelegateRole::BothMintAndSpend not applicable in queuePendingDgtChange activity"
                                        )
                                    };
                                    REQT("doesn't allow a Remove to duplicate an Add or Replace or Remove entry");
                                    TODO("^^^");

                                    TODO("what else should be checked here?");
                                    false
                                },
                                _ => {
                                    if(false/*redundant*/) { assert(cctx.nowActingAsMintDgt(), "<----- that can fail, this can't") };

                                    (seed: TxOutputId, purpose: String, dvh : Option[ValidatorHash], config) = action.switch { 
                                        Remove => error("unreachable"), 
                                        Add{seed, purpose, odvh, config} => {
                                            (seed, purpose, odvh, config)
                                        },
                                        Replace{seed, purpose, odvh, config, _replacesDgt} => {
                                            (seed, purpose, odvh, config)
                                        }
                                    };
                                    
                                    mkTokenName = mkUutTnFactory(seed);
                                    dgTknName = mkTokenName(purpose);

                                    
                                    mintedDgTkn : Bool = bREQT("ensures the new delegate's UUT is minted in this txn")
                                    && validateUutMinting(
                                        mph: dd.mph,
                                        seed: seed,
                                        purposes: []String{purpose},
                                        // otherMintedValue: ()
                                        mkTokenName: mkUutTnFactory(seed),
                                        // WE ARE the mint delegate.
                                        needsMintDelegateApproval: false 
                                    );

                                    REQT("the new delegate is created with the indicated authority token");
                                    delegate = RelativeDelegateLink{
                                        uutName: dgTknName,
                                        delegateValidatorHash: dvh,
                                        config: config
                                    };

                                    delegateTakesOwnership = delegate.hasValidOutput(
                                        mph: dd.mph, 
                                        required: true,
                                        createdOrReturned: DgTkn::Created
                                    );

                                    isNotADuplicate = false;
                                    REQT("TODO HERE: doesn't allow a Replace to duplicate an Add or Replace or Remove entry");
                                    REQT("TODO HERE: enforces the presence of the matching Capo charter activity:CLA.queuePendingDgtChange");

                                    possibleReplacementIsCorrect: Bool = action.switch {
                                        Remove => error("unreachable"),
                                        Add => true, // doesn't need to replace anything
                                        Replace{_seed, _purpose, _dvho, _config, acExistingDgt} => {
                                            REQT("invariants cannot be replaced");
                                            role.switch {
                                                MintInvariant => error("cannot Replace role: MintInvariant"),
                                                SpendInvariant => error("cannot Replace role: SpendInvariant"),
                                                _ => print("  -- ok (not trying to replace an invariant)")
                                            };

                                            mkSome = (ac: AssetClass) -> Option[AssetClass] { Option[AssetClass]::Some{ac} };
                                            REQT("when queuing a replacement delegate -- the PendingDelegateAction's role + replacesDgt must match the existing delegate's authority token");
                                            replacesDgTkn : Option[AssetClass] = role.switch {
                                                MintDgt => mkSome(charterDatum.mintDelegateLink.acAuthorityToken(dd.mph)),
                                                SpendDgt => mkSome(charterDatum.spendDelegateLink.acAuthorityToken(dd.mph)),
                                                DgDataPolicy => {
                                                    REQT("to Replace a dgDataPolicy, the named policy must be present in the Capo manifest");
                                                    error("todo: get authority-token for this dgDataPolicy")

                                                },
                                                OtherNamedDgt => {
                                                    REQT("to Replace a named delegate, the named delegate must already be present");
                                                    error("todo: get authority-token for this named delegate")
                                                },
                                                BothMintAndSpendDgt => error(
                                                    "DelegateRole::BothMintAndSpend not applicable in queuePendingDgtChange activity"
                                                ),
                                                MintInvariant => error("unreachable"),
                                                SpendInvariant => error("unreachable")
                                            };
                                            assert(
                                                acExistingDgt == replacesDgTkn.unwrap(),
                                                "the current "+role.switch{
                                                    MintDgt => "mint", SpendDgt => "spend", 
                                                    DgDataPolicy => "dgDataPolicy", OtherNamedDgt => "named",
                                                    _ => "‹incontheeiieivable›"
                                                }+" delegate's authority token doesn't match "+acExistingDgt.show()
                                            );

                                            true
                                        } // -> possibleReplacementIsCorrect
                                    };

                                    true
                                    && mintedDgTkn 
                                    && delegateTakesOwnership 
                                    && isNotADuplicate 
                                    && possibleReplacementIsCorrect
                                }
                            }; // -> passedAdditionalVerifications
                                                    
                            hasNewPendingEntry && passedAdditionalVerifications
                        },
                        removePendingDgtChange{_role, _name} => {
                            // this code-path is only found in the spend-delegate
                            TODO("implement removePendDgt");
                            REQT("allows the removal of a queued pending-delegate-change that can't be completed");
                            assert(false, "not yet implemented");
                            false
                        },
                        commitPendingDgtChanges => {
                            // this code-path has one leg in the spend-delegate
                            // and one leg in the mint-delegate
                            REQT("invariants cannot be replaced");

                            if (cctx.nowActingAsSpendDgt(required: false)) {
                                REQT("spendDgt: committing pending delegates: validates that all the pending delegates are installed");
                                assert(false, "not yet implemented");
                                false
                            } else if (cctx.nowActingAsMintDgt(required: false)) {
                                REQT("mintDgt: committing pending delegates: validates that all the removed dgTkns are burned");
                                false
                            } else {
                                false
                            }
                        },
                        updatingManifest{manifestActivity} => {
                            REQT("doesn't allow updating anything except the manifest");
                            manifestActivity.switch{
                                retiringEntry{_key} => {
                                    assert(false, "TODO: support retirement activity");
                                    REQT("doesn't remove a dgDataPolicy entry from the manifest (use queuePendingDgtChange instead)");
                                    REQT("removes the indicated key from the manifest");
                                    REQT("delegates MUST be allowed to validate that this doesn't drop something they need")
                                },
                                updatingEntry{_key, _tokenName} => {
                                    assert(false, "TODO: support updatingEntry activity");
                                    REQT("the indicated token MUST be referenced in the transaction");
                                    REQT("delegates MUST be allowed to validate that the manifest is acceptable for their needs")
                                },
                                addingEntry{_key, _tokenName} => {
                                    assert(false, "TODO: support addingEntry activity");
                                    REQT("the indicated token MUST be referenced in the transaction");
                                    REQT("delegates MUST be allowed to validate that the manifest is acceptable for their needs")
                                },
                                forkingThreadToken{_key, _newThreadCount} => {
                                    assert(cctx.nowActingAsMintDgt(), "<----- that can fail, this can't");
                                    assert(false, "TODO: support forkingThreadToken activity");
                                    REQT("the indicated token MUST be referenced in the transaction");
                                    REQT("validates that another copy of the token name is minted");
                                    REQT("when the key is a DgDataPolicy, the existing manifest entry is updated");
                                    REQT("for mint/spend delegates and otherNamedDelegates, a new manifest entry is created with refCount=1+newThreadCount, if it doesn't exist");
                                    REQT("when the manifest already has the entry, the refCount is incremented by newThreadCount")

                                }
                            };
                            true
                        },
                        forcingNewMintDelegate => {
                            REQT("a forced delegate change is an escape-hatch only involving the minter and the Capo");
                            error("the mint/spend delegate never is involved when the minter is instructed to force a new delegate")
                        },
                        forcingNewSpendDelegate => {
                            REQT("a forced delegate change is an escape-hatch only involving the minter and the Capo");
                            error("the mint/spend delegate never is involved when the spender is instructed to force a new delegate")
                        }
                    } && if (true) { 
                        print("BasicDelegate harness deferring to specialization for CapoLifecycleActivities\n");
                        true
                    } else { false }
                },

                // NOTE: this is a mint delegate activity on the mintDgt-* token,
                // ... used only in a Capo's MINT delegate.  Once the specialized mint delegate includes
                // ... the delegated-data controller's UUT through the re-delegation pattern,
                // ... the delegated-data controller  picks up the thread of enforcement, via Its specialized 
                // ... delegate module's additionalDelegateValidation(), by handling the 
                // ... MintingActivities variant indicated in the *Ctrl-* token's activity/redeemer.  
                // It can be tricky to recognize that this code module serves the mint delegate, 
                // ... and that it ALSO serves the data-controller delegate separately, in that completely different
                // ... context and using its separate specialization module.
                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, 
                // ... while processing different tokens for each zone of authority/responsibility.
                CreatingDelegatedData{seed, dataTypePurpose} => {
                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();
                    assert(isMintDelegate && cctx.nowActingAsMintDgt(), "<---- fails in there, not here");

                    tnFactory : (String) -> String = mkUutTnFactory(seed);
                    newDataId : ByteArray = tnFactory(dataTypePurpose).encode_utf8();
                    // as a mint delegate, we should see to it that any minting does play by the rules
                    //   ... however, this module is generic, so we can only perform generic checks here.
                    //   ... we additionally call application-provided validation (provided by a specialization)
                    //       (we haven't fully implemented generic data-controller registration, so that's a key limitation for now)
                    // xxx WE are the mint delegate : ) -  cctx.requiresMintDelegateInput().requiresValidOutput() 
                    // this needs to be done by the speciization for now
                    // && cctx.requiresDelegatedDataController(dataTypePurpose).requiresDataMinting()                    

                    // dgDataPolicy = cctx.findManifestEntry(dataTypePurpose).switch {
                    //     None => error(
                    //         "can't create delegatedData without a matching '"+
                    //         dataTypePurpose+"' dgDataPolicy entry in the capo manifest"),
                    //     Some{mEntry} => {
                    //         mEntry.entryType.switch {
                    //             DgDataPolicy{policyLink, _refCount} => policyLink,
                    //             _ => error(
                    //                 "can't create delegatedData type '"+
                    //                 dataTypePurpose+
                    //                 "'; its Capo manifest entry is not a DgDataPolicy"
                    //             )
                    //         }
                    //     }
                    // };

                    // no longer TODO :party: // TODO("the mint-delegate specialization MUST re-delegate authority to the right data-controller");
                    TODO("it must check that the data-controller has exactly one minting activity for the indicated recId");
                    print("    -- e.g. using CapoCtx: cctx\n      .requiresNamedDelegateInput(delegateName)\n      .withSeededMintingActivity(seed)\n");

                    //!!! if the thing being created is a Settings record,
                    //  make sure the capo CharterDatum is also being updated
                    //  with a new manifest entry (settings -> this record-id)

                    true
                    && validateUutMinting(
                        mph: dd.mph,
                        seed: seed,
                        purposes: []String{dataTypePurpose},
                        // otherMintedValue: ()
                        mkTokenName: tnFactory,
                        // WE ARE the mint delegate.
                        needsMintDelegateApproval: false 
                    // ).trace(
                    //     " ✅ checked basic UUT minting "
                    )
                    && cctx.mustOutputDelegatedData(
                        newDataId, dataTypePurpose
                    )
                    && cctx.
                        requiresDgDataPolicyInput(dataTypePurpose).
                        withUniqueSeededMintingActivity(seed).
                        orFail()

                    // assert(false, "^^^ does it implement the generic data-controller re-delegation convention? ^^");

                },
                // This is a Spend delegate activity on the spendDgt-* token, 
                // ... used within a Capo's SPEND delegate (which code may also govern 
                // ... its mintDgt- token, under separate utxo cover).
                // Once the specialized spend delegate includes the delegated-data controller UUT through the re-delegation pattern,
                // ... the spend delegate's specialized module picks up the thread of enforcement via its
                // ... additionalDelegateValidation(), by handling the SpendingActivities variant indicated in the *Pol-* token's activity/redeemer.
                // That controller activity may alternatively be a MultiActivity, one of whose nested activities provides 
                // ... the needed SpendingActivities variant.
                // It can be tricky to recognize that this code module serves the spend delegate and the mint delegate,
                // ... and that it ALSO serves the data-controller delegate separately, in that completely different context 
                // ... and using its separate specialization module.
                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, 
                // ... while processing different tokens for each zone of authority/responsibility.
                UpdatingDelegatedData{dDataType, recId} => {
                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();
                    assert(cctx.nowActingAsSpendDgt(), "<---- fails in there, not here");
                    REQT("EXPECTS j6bmfv: all and ONLY DelegatedData datums must be spent with the Capo's spendingDelegatedData activity");

                    REQT("implements a generic data-controller re-delegation convention based on the capo's manifest (those with type= DgDataPolicy)");

                    REQT("ensures the data-controller is invoked with ONE spending activity for the indicated recId");
                    assert( cctx.
                        requiresDgDataPolicyInput(dDataType).
                        withUniqueDDSpendingActivity(recId).
                        orFail(),
                         "^^^ those can fail, this assert won't."
                    );

                    inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);
                    assert(inputDD == inputDD, "no way");
                    // ^^ same as vv
                    // hasDDofType : (TxInput) -> Bool = cctx.mkDelegatedDataPredicate(dDataType);
                    // simply finding the input is enough to imply that the that those utxos are spend-governed by the Capo 
                    // ... which at j6bmfv, explicitly requires the token that leads to this code path
                    // ddInputs : []TxInput = ctx.tx.inputs.filter(hasDDofType);
                    // assert(ddInputs.length == 1, "extra DD input(s)");


                    if ("settings" == dDataType) {
                        curSettingsId = cctx.getSettingsId(required: true).unwrap();
                        REQT(
                            "when updating the current Capo settings, the delegates must all "+
                            "have a chance to ensure the settings are valid for their needs"
                        );
                        if (curSettingsId == recId) {
                            assert(
                                // fails if the delegates aren't all validating settings:
                                cctx.allDelegatesAreValidatingSettings(),
                                // can't fail:
                                "no way"
                            )
                        } else {
                            print("  -- NOTE: updating "+ recId.decode_utf8()
                            +", which isn't currentSettings="+curSettingsId.decode_utf8())
                        }
                    };

                    cctx.mustOutputDelegatedData(recId, dDataType)
                    && true
                },

                DeletingDelegatedData {_dataType, recId} => {
                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();

                    REQT("this code is triggered by both the mintDgt and spendDgt, with each doing their parts of the job");
                    REQT("the spendDgt allows the spending of the utxo");
                    REQT("the mintDgt requires the burning of its UUT");
                    REQT("it must not delete a record that's still referenced by the Capo manifest");
                    REQT("a matching manifest entry has to be changed or removed prior to deletion");

                    _inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);
                    // the mintDelegate should be triggered with 
                    TODO("verify the input was found ^");

                    assert(false, "Delete not supported yet");

                    TODO("implement the generic data-controller re-delegation convention here");
                    TODO("ensure that the right delegate is consulted with its BurningActivities.*");

                    cctx.nowActingAsMintDgt() &&
                    false
                },
                // We made these explicit so they're functionally required of every specialized delegate.
                // All of the mint/spend/burn activities must be handled by the specialized delegate.  
                // Note that this code module is generic, so it can't know the internal semantics of those activities,
                // ... or even what their nested variants will be.  It's up to the specialization to handle them.
                // Each of these indicates plural "activities", but they're actually each an individual, discrete, single activity
                // ... with an Enum allowing ONE of various possible specialization-specific activities at that spot.
                // ... MultipleActivities would be used to express "it does multiple separate activities on different utxos")
                SpendingActivities => true, // handled by the specialized delegate
                MintingActivities => true,  // handled by the specialized delegate
                BurningActivities => true // handled by the specialized delegate
            } && if (activity.additionalDelegateValidation(isD)) {
                print ("delegate: "+ delegateName + ": additionalDelegateValidation ok!\n");
                true
            } else {
                error("delegate: "+ delegateName + ": additionalDelegateValidation returned false (without any thrown error)")
            }
        },
        _ => {
            // to trigger an invalid redeemer, call this function
            kaboomInvalidRedeemer = () -> {  error("wrong Actvy/dtm") }; // Activity custom datum must not use Activities reserved for IsDelegation datum.") };

            activity.switch{
                DelegateLifecycleActivities => kaboomInvalidRedeemer(), 
                CapoLifecycleActivities => kaboomInvalidRedeemer(),
                _ => activity.otherDatumValidation(mdd)
            }
        }
    };

    print ("🚥🟢 delegate: "+ delegateName + ": ok!\n");

    result
}
