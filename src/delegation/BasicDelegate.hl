spending BasicDelegate

const rev : Int = 1
const instance : ByteArray = #67656e6572616c // -> "general"
const devGen : Int = 0
const isDev: Bool = false
const delegateName : String // = "💩  noName Delegate : ( "
const isMintDelegate : Bool = false
const isSpendDelegate : Bool = false

import {
    tx, 
    get_current_input,
    get_current_validator_hash
} from ScriptContext

import {
    // DelegationDetail,
    acAuthorityToken,
    tvAuthorityToken
    // unmodifiedDelegation,
    // mustReturnValueToScript
} from CapoDelegateHelpers

import {
    capoSettings
} from CustomCapoSettings

import {
    getTxCharterDatum,
    mkCapoCtx,
    CapoCtx,
    mkTokenShow,
    CapoDatum
    // CapoActivity
} from CapoHelpers

import {
    mkUutTnFactory,
    validateUutMinting,
    mintsUutForCharterUsingRedeemerIndex
} from CapoMintHelpers

import {
    returnsValueToScript,
    // mkTv,
    outputAndDatum,
    TODO,
    REQT
    // tvCharter
} from StellarHeliosHelpers

import {
    DelegateActivity,
    DelegateDatum
} from specializedDelegate


func main(mdd: DelegateDatum, activity: DelegateActivity) -> Bool {
    print(" 🚥❓delegate: " + delegateName +
        if (isDev) {
            " - is dev @gen " + devGen.show()
        } else { "" }
    );

    // input = get_current_input();
    result :Bool = mdd.switch{
        //! performs essential checks of policy for spending the minting delegate's authority token "mintDgt-*"
        // ... it also calls any additionalDelegateValidation() defined in a specialized minting delegate,
        // ... governing the minting of application-specific tokens (including UUTs, fungible tokens, 
        // ... or other sorts of tokens under our minting policy).
        //! Ditto, for our spendDgt-* token, for governing the spend of any utxos in the Capo address.
        //! This code path is also used for other authority-bearing tokens in other specialized delegates,
        //  ... such as named delegates that the mintDgt- or spendDgt- policies defer to.
        //  ... each of those cases has separate execution through this base logic, with specialization 
        //  ... applicable for each.  
        isD : IsDelegation{dd} => {
            // MintDelegateDatum::IsDelegation{dd, cfg} = isD;
            showMyTokens : (Value) -> String = mkTokenShow(dd.mph);
            print("  -- checking spend of dgTkn "+ showMyTokens(get_current_input().value ));

            activity.switch {
                MultipleDelegateActivities{activities} => {
                    activities
                        .map(DelegateActivity::from_data)
                        .all( (a : DelegateActivity) -> Bool { 
                        cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();

                        // Context: the Capo ensures that each spent UTxO is addressed by EXACTLY ONE SpendDgt activity.
                        //   ... when we hit this path as a SpendDelegate, we ensure that each of the activities 

                        a.switch {
                            // in the Mint and Spend delegates, these nested activities are expected re-delegate to delegated-data controllers,
                            // which will use Mint/Spend/Burn activities on the data-controller tokens.
                            CreatingDelegatedData/*{TxOutputId{seedTxn, seedIdx}, dataTypePurpose} */=> {
                                assert(isMintDelegate,
                                    "CreatingDelegatedData only ok in mintDgt"
                                    // " ... use MintingActivities in a delegated-data controller"
                                );
                                cctx.actingAsMintDgt() &&
                                main(mdd, a)
                            },
                            UpdatingDelegatedData{/*typeName*/ _, recId} => {
                                assert(isSpendDelegate,
                                    "UpdatingDelegatedData only ok at level-1 spendDgt"
                                    // " ... use one of the SpendingActivities for a delegated-data controller"
                                );
                                inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);
                                assert(inputDD == inputDD, "no way");
            
                                cctx.actingAsSpendDgt() &&
                                main(mdd, a)
                            },
                            DeletingDelegatedData => {
                                assert(isMintDelegate,
                                    "DeletingDelegatedData only ok in mintDgt"
                                    // " ... use BurningActivities in a delegated-data controller"
                                );
                                cctx.actingAsMintDgt() &&
                                main(mdd, a)
                            },
                            // in the delegated-data controllers, we have to support these multi-activities.                            
                            SpendingActivities => {
                                assert(!cctx.actingAsMintDgt(required: false),
                                    "inconcthieeeevable! mintDgt can't do SpendingActivities!"
                                );
                                //XXX error("SpendingActivities not currently supported in MultipleDelegateActivities"),   
                                assert(!isSpendDelegate,
                                    "multi:Spend: only dgData activities ok in spendDgt"
                                    // " - use UpdatingDelegatedData for such cases"
                                );
                                assert(!cctx.actingAsSpendDgt(required: false),
                                    "inconcthieeeevable! already failed above"
                                    // "a SpendDelegate with a multi-activity only supports delegated-data activities at this time.  \n"+
                                    // "  - use a delegated data controller and trigger SpendDelegate's generic UpdatingDelegatedData activity in the multi-activities struct"
                                );
                                // okay, now we're probably in a delegated-data controller, or at least another (special) case of re-delegation

                                // this will pass through the individual activity to be individually validated
                                // by the specialized delegate module that governs the data-controller's UUT
                                // ... in its additionalDelegateValidation() function.
                                main(mdd, a)
                            },
                            MintingActivities => {
                                // XXX error("MintingActivities not currently supported in MultipleDelegateActivities"),
                                assert(!cctx.actingAsMintDgt(required: false),
                                    "multi:Minting: only dgData activities ok in mintDgt"
                                    // "  - use a delegated data controller and trigger MintDelegate's generic CreatingDelegatedData activity in the multi-activities struct"
                                );
                                assert(!isSpendDelegate && !isMintDelegate,
                                    "multi:Minting: only dgData activities ok in spendDgt" // - use CreatingDelegatedData for such cases"
                                );
                                assert(!cctx.actingAsSpendDgt(required: false),
                                    "inconcthieeeevable! spend delegate can't do MintingActivities!"
                                );
                                // okay, now we're probably in a delegated-data controller, or at least another (special) case of re-delegation

                                // this will pass through the individual activity to be individually validated
                                // by the specialized delegate module that governs the data-controller's UUT
                                // ... in its additionalDelegateValidation() function.
                                main(mdd, a)
                            },
                            BurningActivities => {
                                assert(false, "multi:BurningActivities not yet supported");

                                assert( !isSpendDelegate && !isMintDelegate,                                   
                                    "multi:BurningActivities: only dgData activities ok in mint/spend Dgt "
                                    // " - use DeletingDelegatedData for such cases"
                                );
                                // assert(!cctx.actingAsMintDgt(required: false),
                                //     "a MintDelegate with a multi-activity only supports delegated-data activities at this time.  \n"+
                                //     "  - use a delegated data controller and trigger MintDelegate's generic DeletingDelegatedData activity in the multi-activities struct"
                                // );
                                // okay, now we're probably in a delegated-data controller, 
                                // ... or at least another (special) case of re-delegation

                                // this will pass through the individual activity to be individually validated
                                // by the specialized delegate module that governs the data-controller's UUT
                                // ... in its additionalDelegateValidation() function.
                                result : Bool = main(mdd, a);
                                // when we're confident in our good treatment of real use-cases for this, 
                                // ... we can remove the errors and return results
                                result
                            },
                            DelegateLifecycleActivities => error(
                                "multi:DelegateLifecycleActivities not ok"
                            ),
                            CapoLifecycleActivities => error(
                                "multi:CapoLifecycleActivities not ok"
                            ),
                            MultipleDelegateActivities => error(
                                "multi:multi: nesting not ok"
                            )
                        }
                    }
                )
                },
                //   guards that the authority token is returned to this script.
                // specialized minting delegates should likely perform additional checks.
                DelegateLifecycleActivities{innerActivity} => innerActivity.switch {
                    // reassigning the authority token to a new minting delegate
                    ReplacingMe{seed, purpose} => {
                        // should burn the old UUT, mint the new UUT, and update the Charter
                        // with the new mint authority

                        //xxx -   tx.minted.get_safe( acAuthorityToken(dd) ) == 0 &&
                        //xxx -   !returnsValueToScript( tvAuthorityToken(dd))

                        BURNED: Int = -1;
                        otherMintedValue: Value = Value::new(
                            AssetClass::new(dd.mph, dd.tn), 
                            BURNED
                        );
                    
                        print("checking ReplacingMe on "+purpose+": "+dd.tn.decode_utf8());
                        
                        cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterInput();
                        isUpdatingCharter : Bool = cctx.getCharterRedeemer().switch {
                            // THE CHARTER UPDATE ITSELF WILL CHECK THAT THERE'S A VALID DELEGATE OUTPUT FOR THE NEW DELEGATE
                            updatingCharter => true,
                            _ => false
                        };

                        isMintingOk : Bool = validateUutMinting(
                            mph: dd.mph,
                            seed: seed,
                            purposes: []String{purpose}, 
                            otherMintedValue: otherMintedValue,
                            needsMintDelegateApproval: false,
                            extraMintDelegateRedeemerCheck: false
                        );

                        isMintingOk && isUpdatingCharter

                    },

                    // the token is being burned, retiring the authority token for this minting delegate
                    // as a result, this minting delegate will no longer be consulted.  This could be combined
                    // with the creation of a new minting delegate with a new authority token, registered
                    // with the Capo in place of this one (or Reassigning could be used for such a case).
                    // If there is no replacement minting delegate, then the Capo will not be able to perform 
                    // any further minting activities.
                    //
                    // Retiring is not suitable for authorizing token-burning.
                    Retiring => {
                        tx.minted.get(acAuthorityToken(dd)) == -1
                    },

                    ValidatingSettings => {
                        //!!! todo: verify if any cost diff between this vs direct-field-access.
                        // CapoDatum::CharterToken {
                        //     /*spendDgt*/ _,  
                        //     /* spendInvariants */ _,
                        //     settingsUut,
                        //     /* namedDelegates */ _,
                        //     /* mintDgt */ _, 
                        //     /* mintInvariants */ _, 
                        //     /* govAuthority */ _
                    // } = getTxCharterDatum(dd.mph);
                    charter : CapoDatum::CharterToken = getTxCharterDatum(dd.mph);
                    foundSettings : outputAndDatum[CapoDatum::SettingsData] = 
                        charter.mustFindSettingsOutput(dd.mph, dd.capoAddr);
                    customSettings = capoSettings::from_data(foundSettings.rawData);

                    print(delegateName + ": delegate TRYING TO VALIDATE SETTINGS");
                    validated : Bool = customSettings.validate();
                    print("HURRAY");

                    // TODO: also validate any typeMap (can do this later and adopt the new delegate 
                    // into the Capo when this code is written)

                    validated && 
                        // isValid : Bool = 
                        //     ((isTest && throwIfBadSettings(mdd, settings)) || true) &&
                        //     mdd.validateSettings(settings);
                        // isValid
                        true
                    }

                },
                CapoLifecycleActivities{CLA} => {
                    assert(isMintDelegate, 
                        "CapoLifecycleActivities can't be triggered on non-minting delegate "+ delegateName
                    );
                    CLA.switch {
                        // the mint delegate is validating a mint that CREATES A NEW DELEGATE
                        // FOR APPLICATION-SPECIFIC PURPOSES. This can affect the structure of the Capo
                        // it defers to the specialized minting delegate, if any; the unspecialized mint delegate
                        // rejects all delegate-creation.
                        CreatingDelegate{seed ,purpose} => {
                            print("🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞 !!!!!!!!!!!!!!!!!!! todo: fix this");
                            TODO("it should output the new delegate token to the Capo as a PendingDelegate datum");
                            REQT("validates creation of UUT for the new delegate, aligned to the purpose indicated");
                                // true || 
                                validateUutMinting(
                                    mph: dd.mph,
                                    seed: seed,
                                    purposes: []String{purpose},
                                    // otherMintedValue: ()
                                    mkTokenName: mkUutTnFactory(seed),
                                    // WE ARE the mint delegate.
                                    needsMintDelegateApproval: false 
                                )
                            }
                        } && if (true) { 
                            print("BasicDelegate harness deferring to specialization for CapoLifecycleActivities");
                            true
                        } else { false }
                },

                // NOTE: this is a mint delegate activity on the mintDgt-* token,
                // ... used only in a Capo's MINT delegate.  Once the specialized mint delegate includes
                // ... the delegated-data controller's UUT through the re-delegation pattern,
                // ... the delegated-data controller  picks up the thread of enforcement, via Its specialized 
                // ... delegate module's additionalDelegateValidation(), by handling the 
                // ... MintingActivities variant indicated in the *Ctrl-* token's activity/redeemer.  
                // It can be tricky to recognize that this code module serves the mint delegate, 
                // ... and that it ALSO serves the data-controller delegate separately, in that completely different
                // ... context and using its separate specialization module.
                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, 
                // ... while processing different tokens for each zone of authority/responsibility.
                CreatingDelegatedData{seed, dataTypePurpose} => {
                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();
                    tnFactory : (String) -> String = mkUutTnFactory(seed);
                    newDataId : ByteArray = tnFactory(dataTypePurpose).encode_utf8();
                    // as a mint delegate, we should see to it that any minting does play by the rules
                    //   ... however, this module is generic, so we can only perform generic checks here.
                    //   ... we additionally call application-provided validation (provided by a specialization)
                    //       (we haven't fully implemented generic data-controller registration, so that's a key limitation for now)
                    // xxx WE are the mint delegate : ) -  cctx.requiresMintDelegateInput().requiresValidOutput() 
                    // this needs to be done by the speciization for now
                    // && cctx.requiresDelegatedDataController(dataTypePurpose).requiresDataMinting()                    
                    TODO("make a generic data-controller re-delegation convention");
                    TODO("the mint-delegate specialization MUST re-delegate authority to the right data-controller");
                    TODO("it must check that the data-controller has exactly one minting activity for the indicated recId");
                    print("    -- e.g. using CapoCtx: cctx\n      .requiresNamedDelegateInput(delegateName)\n      .withSeededMintingActivity(seed)");

                    true
                    && isMintDelegate 
                    && cctx.actingAsMintDgt()
                    && validateUutMinting(
                        mph: dd.mph,
                        seed: seed,
                        purposes: []String{dataTypePurpose},
                        // otherMintedValue: ()
                        mkTokenName: tnFactory,
                        // WE ARE the mint delegate.
                        needsMintDelegateApproval: false 
                    // ).trace(
                    //     " ✅ checked basic UUT minting "
                    )
                    && cctx.mustOutputDelegatedData(
                        newDataId, dataTypePurpose
                    )
                },
                // This is a Spend delegate activity on the spendDgt-* token, 
                // ... used within a Capo's SPEND delegate (which code may also govern 
                // ... its mintDgt- token, under separate utxo cover).
                // Once the specialized spend delegate includes the delegated-data controller UUT through the re-delegation pattern,
                // ... the spend delegate's specialized module picks up the thread of enforcement via its
                // ... additionalDelegateValidation(), by handling the SpendingActivities variant indicated in the *Ctrl-* token's activity/redeemer.
                // That controller activity may alternatively be a MultiActivity, one of whose nested activities provides 
                // ... the needed SpendingActivities variant.
                // It can be tricky to recognize that this code module serves the spend delegate and the mint delegate,
                // ... and that it ALSO serves the data-controller delegate separately, in that completely different context 
                // ... and using its separate specialization module.
                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, 
                // ... while processing different tokens for each zone of authority/responsibility.
                UpdatingDelegatedData{dDataType, recId} => {
                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();
                    TODO("Basic delegate: implement typeMap-based redelegation");
                    TODO("for now, the application-level Spend Delegate MUST enforce correct data-controller delegation");
                    // check data controller's SpendingActivities
                    // the Capo enforces that delegatedData utxo is ALWAYS spent with its generic `spendingDelegatedDatum` activity

                    // todo validate this path in multi-activity
                    inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);
                    assert(inputDD == inputDD, "no way");
                    // ^^ same as vv
                    // hasDDofType : (TxInput) -> Bool = cctx.mkDelegatedDataPredicate(dDataType);
                    // simply finding the input is enough to imply that the that those utxos are spend-governed by the Capo 
                    // ... which at j6bmfv, explicitly requires the token that leads to this code path
                    // ddInputs : []TxInput = ctx.tx.inputs.filter(hasDDofType);
                    // assert(ddInputs.length == 1, "extra DD input(s)");

                    cctx.mustOutputDelegatedData(recId, dDataType)
                    && true
                },
                DeletingDelegatedData => { // {dataType, recId} => {
                    TODO("Basic delegate: implement typeMap-based redelegation");
                    TODO("for now, the application-level Mint Delegate MUST enforce correct data-controller delegation");
                    // check data controller's BurningActivities

                    assert(false, "not supported yet");
                    false
                },
                // We made these explicit so they're functionally required of every specialized delegate.
                // All of the mint/spend/burn activities must be handled by the specialized delegate.  
                // Note that this code module is generic, so it can't know the internal semantics of those activities,
                // ... or even what their nested variants will be.  It's up to the specialization to handle them.
                // Each of these indicates plural "activities", but they're actually each an individual, discrete, single activity
                // ... with an Enum allowing ONE of various possible specialization-specific activities at that spot.
                // ... MultipleActivities would be used to express "it does multiple separate activities on different utxos")
                SpendingActivities => true,
                MintingActivities => true,
                BurningActivities => true,
                _ => true
            } && if (activity.additionalDelegateValidation(isD)) {
                print ("delegate: "+ delegateName + ": additionalDelegateValidation ok!");
                true
            } else {
                error("delegate: "+ delegateName + ": additionalDelegateValidation returned false (without any thrown error)")
            }
        },
        _ => {
            // to trigger an invalid redeemer, call this function
            kaboomInvalidRedeemer = () -> {  error("wrong Actvy/dtm") }; // Activity custom datum must not use Activities reserved for IsDelegation datum.") };

            activity.switch{
                DelegateLifecycleActivities => kaboomInvalidRedeemer(), 
                CapoLifecycleActivities => kaboomInvalidRedeemer(),
                _ => activity.otherDatumValidation(mdd)
            }
        }
    };

    print ("🚥🟢 delegate: "+ delegateName + ": ok!");

    result
}
