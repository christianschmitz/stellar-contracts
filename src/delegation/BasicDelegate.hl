spending BasicMintDelegate

const rev : Int = 1
const instance : ByteArray = #67656e6572616c
const devGen : Int = 0
const isDev: Bool = false
const delegateName : String // = "💩  noName Delegate : ( "
const isMintDelegate : Bool = false

import {
    // DelegationDetail,
    acAuthorityToken,
    tvAuthorityToken
    // unmodifiedDelegation,
    // mustReturnValueToScript
} from CapoDelegateHelpers

import {
    capoSettings
} from CustomCapoSettings

import {
    getTxCharterDatum,
    CapoDatum
    // CapoActivity
} from CapoHelpers

import {
    mkUutTnFactory,
    validateUutMinting,
    mintsUutForCharterUsingRedeemerIndex
} from CapoMintHelpers

import {
    returnsValueToScript,
    // mkTv,
    outputAndDatum
    // tvCharter
} from StellarHeliosHelpers

import {
    DelegateActivity,
    DelegateDatum
} from specializedDelegate



func main(mdd: DelegateDatum, activity: DelegateActivity, ctx: ScriptContext) -> Bool {
    print(" 🚥❓delegate: " + delegateName +
        if (isDev) {
            " - is dev @gen " + devGen.show()
        } else { "" }
    );

    // input = ctx.get_current_input();
    result :Bool = mdd.switch{
        //! performs essential checks of policy for spending the minting delegate's authority token "mintDgt-*"
        //! It also calls any additionalDelegateValidation() defined in a specialized minting delegate.
        isD : IsDelegation{dd} => {
            // MintDelegateDatum::IsDelegation{dd, cfg} = isD;
            activity.switch {
                // authorizing minting of a new token or burning an existing token:
                //   guards that the authority token is returned to this script.
                // specialized minting delegates should likely perform additional checks.

                DelegateLifecycleActivities{innerActivity} => innerActivity.switch {
                    // reassigning the authority token to a new minting delegate
                    ReplacingMe{seedTxId, seedIdx, purpose} => {
                        // should burn the old UUT, mint the new UUT, and update the Charter
                        // with the new mint authority

                        //xxx -   ctx.tx.minted.get_safe( acAuthorityToken(dd) ) == 0 &&
                        //xxx -   !returnsValueToScript( tvAuthorityToken(dd), ctx)

                        BURNED: Int = -1;
                        otherMintedValue: Value = Value::new(
                            AssetClass::new(dd.mph, dd.tn), 
                            BURNED
                        );
                    
                        print("checking ReplacingMe on "+purpose+": "+dd.tn.decode_utf8());
                        // THE CHARTER UPDATE ITSELF WILL CHECK THAT THERE'S A VALID DELEGATE OUTPUT FOR THE NEW DELEGATE
                        updatingCharter: Int = 1;
                        mintsUutForCharterUsingRedeemerIndex(
                            charterRedeemerIndex: updatingCharter,
                            ctx: ctx, 
                            mph: dd.mph,
                            purpose: purpose,
                            seedTxId: seedTxId,
                            seedIdx: seedIdx,
                            otherMintedValue: otherMintedValue,
                            needsMintDelegateApproval: false,
                            extraMintDelegateRedeemerCheck: false
                        )
                    },

                    // the token is being burned, retiring the authority token for this minting delegate
                    // as a result, this minting delegate will no longer be consulted.  This could be combined
                    // with the creation of a new minting delegate with a new authority token, registered
                    // with the Capo in place of this one (or Reassigning could be used for such a case).
                    // If there is no replacement minting delegate, then the Capo will not be able to perform 
                    // any further minting activities.
                    //
                    // Retiring is not suitable for authorizing token-burning.
                    Retiring => {
                        ctx.tx.minted.get(acAuthorityToken(dd)) == -1
                    },

                    ValidatingSettings => {
                        //!!! todo: verify if any cost diff between this vs direct-field-access.
                        // CapoDatum::CharterToken {
                        //     /*spendDgt*/ _,  
                        //     /* spendInvariants */ _,
                        //     settingsUut,
                        //     /* namedDelegates */ _,
                        //     /* mintDgt */ _, 
                        //     /* mintInvariants */ _, 
                        //     /* govAuthority */ _
                    // } = getTxCharterDatum(ctx, dd.mph);
                    charter : CapoDatum::CharterToken = getTxCharterDatum(ctx, dd.mph);
                    foundSettings : outputAndDatum[CapoDatum::SettingsData] = 
                        charter.mustFindSettingsOutput(ctx, dd.mph, dd.capoAddr);
                    customSettings = capoSettings::from_data(foundSettings.rawData);

                    print(delegateName + ": delegate TRYING TO VALIDATE SETTINGS");
                    validated : Bool = customSettings.validate();
                    print("HURRAY");

                    // TODO: also validate any typeMap (can do this later and adopt the new delegate 
                    // into the Capo when this code is written)

                    validated && 
                        // isValid : Bool = 
                        //     ((isTest && throwIfBadSettings(ctx, mdd, settings)) || true) &&
                        //     mdd.validateSettings(settings, ctx);
                        // isValid
                        true
                    }

                },
                CapoLifecycleActivities{CLA} => {
                    assert(isMintDelegate, 
                        "CapoLifecycleActivities can't be triggered on non-minting delegate "+ delegateName
                    );
                    CLA.switch {
                        // the mint delegate is validating a mint that CREATES A NEW DELEGATE
                        // FOR APPLICATION-SPECIFIC PURPOSES. This can affect the structure of the Capo
                        // it defers to the specialized minting delegate, if any; the unspecialized mint delegate
                        // rejects all delegate-creation.
                        CreatingDelegate{seedTxn,seedIndex,purpose} => {
                            print("🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞 !!!!!!!!!!!!!!!!!!! todo: fix this");
                            print("🐞 🐞🐞 it should ouput the new delegate token to the Capo as a PendingDelegate datum");
                                true || validateUutMinting(
                                    ctx: ctx, 
                                    mph: dd.mph,
                                    seedTxId: seedTxn, 
                                    seedIdx: seedIndex, 
                                    purposes: []String{purpose},
                                    // additionalValues: ()
                                    mkTokenName: mkUutTnFactory(seedTxn, seedIndex),
                                    // WE ARE the mint delegate.
                                    needsMintDelegateApproval: false 
                                )
                            }
                        } && if (true) { 
                            print("BasicDelegate harness deferring to specialization for CapoLifecycleActivities");
                            true
                        } else { false }
                },
                _ => true
            } && if (activity.additionalDelegateValidation(isD, ctx)) {
                print ("delegate: "+ delegateName + ": additionalDelegateValidation ok!");
                true
            } else {
                error("delegate: "+ delegateName + ": additionalDelegateValidation returned false (without any thrown error)")
            }
        },
        _ => {
            invalidRedeemer = () -> {  error("wrong Actvy/dtm") }; ///Activity custom datum must not use Activities reserved for IsDelegation datum.") };
            activity.switch{
                DelegateLifecycleActivities => invalidRedeemer(), 
                CapoLifecycleActivities => invalidRedeemer(),
                _ => activity.otherDatumValidation(mdd, ctx)
            }
        }
    };

    print ("🚥🟢 delegate: "+ delegateName + ": ok!");

    result
}
