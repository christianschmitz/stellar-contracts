spending BasicDelegate

const rev : Int = 1
const instance : ByteArray = #67656e6572616c
const devGen : Int = 0
const isDev: Bool = false
const delegateName : String // = "💩  noName Delegate : ( "
const isMintDelegate : Bool = false

import {
    // DelegationDetail,
    acAuthorityToken,
    tvAuthorityToken
    // unmodifiedDelegation,
    // mustReturnValueToScript
} from CapoDelegateHelpers

import {
    capoSettings
} from CustomCapoSettings

import {
    getTxCharterDatum,
    mkCapoCtx,
    CapoCtx,
    mkTokenShow,
    CapoDatum
    // CapoActivity
} from CapoHelpers

import {
    mkUutTnFactory,
    validateUutMinting,
    mintsUutForCharterUsingRedeemerIndex
} from CapoMintHelpers

import {
    returnsValueToScript,
    // mkTv,
    outputAndDatum,
    TODO,
    REQT
    // tvCharter
} from StellarHeliosHelpers

import {
    DelegateActivity,
    DelegateDatum
} from specializedDelegate


func main(mdd: DelegateDatum, activity: DelegateActivity, ctx: ScriptContext) -> Bool {
    print(" 🚥❓delegate: " + delegateName +
        if (isDev) {
            " - is dev @gen " + devGen.show()
        } else { "" }
    );

    // input = ctx.get_current_input();
    result :Bool = mdd.switch{
        //! performs essential checks of policy for spending the minting delegate's authority token "mintDgt-*"
        //! It also calls any additionalDelegateValidation() defined in a specialized minting delegate.
        isD : IsDelegation{dd} => {
            // MintDelegateDatum::IsDelegation{dd, cfg} = isD;
            showMyTokens : (Value) -> String = mkTokenShow(dd.mph);
            print("  -- checking spend of dgTkn "+ showMyTokens(ctx.get_current_input().value ));
            activity.switch {
                //   guards that the authority token is returned to this script.
                // specialized minting delegates should likely perform additional checks.


                DelegateLifecycleActivities{innerActivity} => innerActivity.switch {
                    // reassigning the authority token to a new minting delegate
                    ReplacingMe{seedTxId, seedIdx, purpose} => {
                        // should burn the old UUT, mint the new UUT, and update the Charter
                        // with the new mint authority

                        //xxx -   ctx.tx.minted.get_safe( acAuthorityToken(dd) ) == 0 &&
                        //xxx -   !returnsValueToScript( tvAuthorityToken(dd), ctx)

                        BURNED: Int = -1;
                        otherMintedValue: Value = Value::new(
                            AssetClass::new(dd.mph, dd.tn), 
                            BURNED
                        );
                    
                        print("checking ReplacingMe on "+purpose+": "+dd.tn.decode_utf8());
                        
                        cctx : CapoCtx = mkCapoCtx(ctx, dd.mph).withCharterInput();
                        isUpdatingCharter : Bool = cctx.getCharterRedeemer().switch {
                            // THE CHARTER UPDATE ITSELF WILL CHECK THAT THERE'S A VALID DELEGATE OUTPUT FOR THE NEW DELEGATE
                            updatingCharter => true,
                            _ => false
                        };

                        isMintingOk : Bool = validateUutMinting(
                            ctx: ctx, 
                            mph: dd.mph,
                            seedTxId: seedTxId, 
                            seedIdx: seedIdx, 
                            purposes: []String{purpose}, 
                            otherMintedValue: otherMintedValue,
                            needsMintDelegateApproval: false,
                            extraMintDelegateRedeemerCheck: false
                        );

                        isMintingOk && isUpdatingCharter

                    },

                    // the token is being burned, retiring the authority token for this minting delegate
                    // as a result, this minting delegate will no longer be consulted.  This could be combined
                    // with the creation of a new minting delegate with a new authority token, registered
                    // with the Capo in place of this one (or Reassigning could be used for such a case).
                    // If there is no replacement minting delegate, then the Capo will not be able to perform 
                    // any further minting activities.
                    //
                    // Retiring is not suitable for authorizing token-burning.
                    Retiring => {
                        ctx.tx.minted.get(acAuthorityToken(dd)) == -1
                    },

                    ValidatingSettings => {
                        //!!! todo: verify if any cost diff between this vs direct-field-access.
                        // CapoDatum::CharterToken {
                        //     /*spendDgt*/ _,  
                        //     /* spendInvariants */ _,
                        //     settingsUut,
                        //     /* namedDelegates */ _,
                        //     /* mintDgt */ _, 
                        //     /* mintInvariants */ _, 
                        //     /* govAuthority */ _
                    // } = getTxCharterDatum(ctx, dd.mph);
                    charter : CapoDatum::CharterToken = getTxCharterDatum(ctx, dd.mph);
                    foundSettings : outputAndDatum[CapoDatum::SettingsData] = 
                        charter.mustFindSettingsOutput(ctx, dd.mph, dd.capoAddr);
                    customSettings = capoSettings::from_data(foundSettings.rawData);

                    print(delegateName + ": delegate TRYING TO VALIDATE SETTINGS");
                    validated : Bool = customSettings.validate();
                    print("HURRAY");

                    // TODO: also validate any typeMap (can do this later and adopt the new delegate 
                    // into the Capo when this code is written)

                    validated && 
                        // isValid : Bool = 
                        //     ((isTest && throwIfBadSettings(ctx, mdd, settings)) || true) &&
                        //     mdd.validateSettings(settings, ctx);
                        // isValid
                        true
                    }

                },
                CapoLifecycleActivities{CLA} => {
                    assert(isMintDelegate, 
                        "CapoLifecycleActivities can't be triggered on non-minting delegate "+ delegateName
                    );
                    CLA.switch {
                        // the mint delegate is validating a mint that CREATES A NEW DELEGATE
                        // FOR APPLICATION-SPECIFIC PURPOSES. This can affect the structure of the Capo
                        // it defers to the specialized minting delegate, if any; the unspecialized mint delegate
                        // rejects all delegate-creation.
                        CreatingDelegate{seedTxn,seedIndex,purpose} => {
                            print("🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞 !!!!!!!!!!!!!!!!!!! todo: fix this");
                            TODO("it should output the new delegate token to the Capo as a PendingDelegate datum");
                                // true || 
                                validateUutMinting(
                                    ctx: ctx, 
                                    mph: dd.mph,
                                    seedTxId: seedTxn, 
                                    seedIdx: seedIndex, 
                                    purposes: []String{purpose},
                                    // otherMintedValue: ()
                                    mkTokenName: mkUutTnFactory(seedTxn, seedIndex),
                                    // WE ARE the mint delegate.
                                    needsMintDelegateApproval: false 
                                )
                            }
                        } && if (true) { 
                            print("BasicDelegate harness deferring to specialization for CapoLifecycleActivities");
                            true
                        } else { false }
                },

                CreatingDelegatedData{dataTypePurpose, seedTxn, seedIdx} => {
                    cctx : CapoCtx = mkCapoCtx(ctx, dd.mph).withCharterRef();
                    tnFactory : (String) -> String = mkUutTnFactory(seedTxn, seedIdx);
                    newDataId : String = tnFactory(dataTypePurpose);
                    // as a mint delegate, we should see to it that any minting does play by the rules
                    //   ... however, this module is generic, so we can only perform generic checks here.
                    //   ... we additionally call application-provided validation (provided by a specialization)
                    //       (we haven't fully implemented generic data-controller registration, so that's a key limitation for now)
                    // xxx WE are the mint delegate : ) -  cctx.requiresMintDelegateInput().requiresValidOutput() 
                    // this needs to be done by the speciization for now
                    // && cctx.requiresDelegatedDataController(dataTypePurpose).requiresDataMinting()                    
                    TODO("make a generic data-controller re-delegation convention");
                    TODO("mint-delegate specialization MUST re-delegate authority to the right data-controller");
                    true
                    && validateUutMinting(
                        ctx: ctx, 
                        mph: dd.mph,
                        seedTxId: seedTxn, 
                        seedIdx: seedIdx, 
                        purposes: []String{dataTypePurpose},
                        // otherMintedValue: ()
                        mkTokenName: tnFactory,
                        // WE ARE the mint delegate.
                        needsMintDelegateApproval: false 
                    // ).trace(
                    //     " ✅ checked basic UUT minting "
                    )
                    && cctx.mustOutputDelegatedData(
                        newDataId, dataTypePurpose
                    )
                },
                UpdatingDelegatedData{dDataType, recId} => {
                    cctx : CapoCtx = mkCapoCtx(ctx, dd.mph).withCharterRef();
                    TODO("Basic Delegate: implement typeMap-based redelegation");
                    TODO("for now, the application-level Spend Delegate MUST enforce correct data-controller delegation");
                    // check data controller's SpendingActivities

                    hasDDofType : (TxInput) -> Bool = cctx.mkDelegatedDataPredicate(dDataType);
                    ddInputs : []TxInput = ctx.tx.inputs.filter(hasDDofType);
                    assert(ddInputs.length == 1, "extra DD input(s)");
                    // the Capo enforces that delegatedData utxo is ALWAYS spent with its generic `spendingDelegatedDatum` activity

                    cctx.mustOutputDelegatedData(recId, dDataType)
                    && true
                },
                DeletingDelegatedData => { // {dataType, recId} => {
                    TODO("Basic Delegate: implement typeMap-based redelegation");
                    TODO("for now, the application-level Mint Delegate MUST enforce correct data-controller delegation");
                    // check data controller's BurningActivities

                    true
                },
                // made these explicit so they're functionally required of every specialized delegate
                SpendingActivities => true,
                MintingActivities => true,
                BurningActivities => true,
                _ => true
            } && if (activity.additionalDelegateValidation(isD, ctx)) {
                print ("delegate: "+ delegateName + ": additionalDelegateValidation ok!");
                true
            } else {
                error("delegate: "+ delegateName + ": additionalDelegateValidation returned false (without any thrown error)")
            }
        },
        _ => {
            // to trigger an invalid redeemer, call this function
            kaboomInvalidRedeemer = () -> {  error("wrong Actvy/dtm") }; // Activity custom datum must not use Activities reserved for IsDelegation datum.") };

            activity.switch{
                DelegateLifecycleActivities => kaboomInvalidRedeemer(), 
                CapoLifecycleActivities => kaboomInvalidRedeemer(),
                _ => activity.otherDatumValidation(mdd, ctx)
            }
        }
    };

    print ("🚥🟢 delegate: "+ delegateName + ": ok!");

    result
}
