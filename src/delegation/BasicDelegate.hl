spending BasicDelegate

const rev : Int = 1
const instance : ByteArray = #67656e6572616c // -> "general"
const delegateName : String // = "💩  noName Delegate : ( "
const isMintDelegate : Bool = false
const isSpendDelegate : Bool = false
const isDgDataPolicy : Bool = false

import {
    tx, 
    get_current_input,
    get_current_validator_hash
} from ScriptContext

import {
    DelegateRole,
    DelegationDetail,
    DgTknDisposition as DgTkn,
    ManifestActivity,
    PendingDelegateChange,
    PendingDelegateAction,
    RelativeDelegateLink
} from CapoDelegateHelpers

// import {
//     ProtocolSettings
// } from ProtocolSettings

import {
    getTxCharterData,
    mkCapoCtx,
    CapoCtx,
    mkTokenShow,
    CapoDatum,
    CapoManifestEntry,
    ManifestEntryType
    // CapoActivity
} from CapoHelpers

import {
    mkUutTnFactory,
    validateUutMinting
} from CapoMintHelpers

import {
    fromCip68Wrapper,
    outputAndDatum,
    returnsValueToScript,
    TODO,
    REQT,
    bREQT
    // tvCharter
} from StellarHeliosHelpers

import {
    DelegateActivity,
    DelegateDatum,
    BurningActivity,
    MintingActivity,
    SpendingActivity
} from specializedDelegate

// formerly was in Capo core contract script
// func allDelegatesAreValidatingSettings() -> Bool {
//         // print( "  ...with activity updatingSettings\n");
//         // _isRelevantDatum : Bool = capoDatum.switch {
//         //     // SettingsData => true,
//         //     CharterData => true,
//         //     _ => error("wrong use of updatingSettings action; must use only on CharterData")
//         // };
//         // !!! move to SettingsDelegate?  or keep as a baseline check?
//         // it requires the govAuthority to be present 
//         REQT( "gov authority must be present to update settings");
//         hasGovAuthority : Bool = mustHaveGovAuthority(
//             mph: mph,
//             charterData: charterData // already resolved
//         );

//         CapoDatum::CharterData{
//             spendDelegate,
//             spendInvariants,
//             otherNamedDelegates,
//             mintDelegate,
//             mintInvariants,
//             govDelegate,
//             manifest
//         } = capoDatum;

//         //!!! note, this is a hard-coded version of requiring the settings policy script:
//         REQT("the current Settings must be spent and updated");
//         settingsDgtLink : RelativeDelegateLink = otherNamedDelegates.get_safe("settingsPol").switch {
//             None => error("'settings' delegate must be present to do updatingSettings activity"),
//             Some{dgt} => dgt
//         };

//         settingsDgtInput = settingsDgtLink.hasDelegateInput(
//             inputs: tx.inputs,
//             mph: mph
//         ).unwrap();
//         settingsDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( 
//             mustFindInputRedeemer(settingsDgtInput)
//         ).switch {
//             SpendingActivities => true,
//             _ => assert("settings delegate must be updating the settings with its SpendingActivities variant")
//         };
//         _nextSettings : Data = cctx.getNextManifestedDatumRaw("settings");
//         isUpdatingSettings : Bool = true;
        
//         inputs: []TxInput = tx.inputs;

//         //!!! actually requiring delegates' SettingsValidation starts here.
//         REQT( "spend delegate must validate settings (wait, that's myself.  Call validate directly?");

//         spendDelegateIsValidating : Bool = 
//             spendDelegate.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: true
//             ).unwrap();

//         REQT("mint delegate must validate settings");
//         mintDelegateIsValidating : Bool = 
//             mintDelegate.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: true
//             ).unwrap();

//         // govAuthority is checking the settings
//         REQT( "govDelegate MAY contribute to settings validation");
//         govDelegateMaybeValidating : Bool = 
//             govDelegate.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: false
//             ).switch{
//                 Some => true,
//                 None => {
//                     print("  -- govAuthority isn't a script-based validator; doesn't validate new settings\n");
//                     true
//                 }
//             };
//         checkOneInvariant : (RelativeDelegateLink) -> Bool = 
//         (oneDgt: RelativeDelegateLink) -> Bool {
//             REQT( "invariant must validate settings");
//             oneDgt.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: true
//             ).unwrap()
//         };
//         // spendInvariants are checking the settings
//         REQT( "spend invariants must validate settings");
//         spendInvariantsAreValidating : Bool = spendInvariants.all( 
//             checkOneInvariant
//         );
//         // mintInvariants are checking the settings
//         REQT( "mint invariants must validate settings");
//         mintInvariantsAreValidating : Bool = mintInvariants.all( 
//             checkOneInvariant
//         );
//         // namedDelegates are checking the settings
//         REQT( "named delegates must validate settings");
//         namedDelegatesAreValidating : Bool = otherNamedDelegates.fold( 
//             REQT( "  - each named delegate must validate settings");
//             (ok: Bool, key: String, dgt: RelativeDelegateLink) -> Bool {
//                 print("  - named delegate: " + key);
//                 print("\n");
//                 ok && dgt.validatesUpdatedSettings(
//                     inputs: inputs,
//                     mph: mph,
//                     inputRequired: true
//                 ).unwrap()
//             }, true
//         );

//         isRelevantDatum &&
//         settingsDelegateIsValid &&
//         isUpdatingSettings &&
//         spendDelegateIsValidating &&
//         mintDelegateIsValidating &&
//         govDelegateMaybeValidating &&
//         spendInvariantsAreValidating &&
//         mintInvariantsAreValidating &&
//         namedDelegatesAreValidating &&
//         hasGovAuthority
// }

func main(mdd: DelegateDatum, activity: DelegateActivity) -> Bool {
    print(" 🚥❓delegate: "+delegateName + "\n");

    // input = get_current_input();
    result :Bool = mdd.switch{
        //! performs essential checks of policy for spending the minting delegate's authority token "mintDgt-*"
        // ... it also calls any additionalDelegateValidation() defined in a specialized minting delegate,
        // ... governing the minting of application-specific tokens (including UUTs, fungible tokens, 
        // ... or other sorts of tokens under our minting policy).
        //! Ditto, for our spendDgt-* token, for governing the spend of any utxos in the Capo address.
        capoStoredData => error("Data Delegates must never store the capoStoredData variant in the script; used only for data-structuring capo-stored utxo datum"),
        // todo: ensure that the utxo-creation path also does not store IsDelegatedData variants in the script

        //! This code path is also used for other authority-bearing tokens in other specialized delegates,
        //  ... such as named delegates that the mintDgt- or spendDgt- policies defer to.
        //  ... each of those cases has separate execution through this base logic, with specialization 
        //  ... applicable for each (see references to "nowActingAs").
        isD : IsDelegation{dd} => {
            // MintDelegateDatum::IsDelegation{dd, cfg} = isD;
            showMyTokens : (Value) -> String = mkTokenShow(dd.mph);
            print("  -- is spending dgTkn "+ showMyTokens(get_current_input().value ));
            print("\n");

            activity.switch {
                MultipleDelegateActivities{activities} => {
                    // NOTE: the Capo ensures that each SPENT UTxO is addressed by EXACTLY ONE SpendDgt activity.
                    // When executed in a mint/spend delegate, the policy below ensures 
                    // ... that each requested activity is matched by a UTxO in the transaction, 
                    // ... guaranteeing 1:1 coverage of activities & UTxOs.

                    // Those are executed in parts (one set of activities applicable to mintDgt-* token,
                    //   ... and the other governed by a spendDgt-* token.  It is common that the exact
                    //   ... same contract script executes both, unless it has a special need to
                    //   ... separate the code for those two; regardless, each is enforced in
                    //   ... a separate execution (different utxos, different activity/redeemer each).

                    // For now, only *DelegatedData activities are valid in mint/spend multi-activities.

                    // Special: DeletingDelegatedDatum requires a Spend validation as well as a Burn validation,
                    //   ... so it will be present in both the mintDgt and spendDgt multi-activities.

                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();

                    activities.all( (rawActivity: Data) -> Bool {
                        a : DelegateActivity = DelegateActivity::from_data(rawActivity);

                        if (isMintDelegate && cctx.nowActingAsMintDgt(required: false)) {
                            // probably can't fail here:
                            // assert(isMintDelegate, "ack! non-MintDelegate can't act as mintDgt");
                            print("  -- mintDgt checking multi-activity");
                            REQT("in the mint delegate, only {Create,Delete}DelegatedData activities are valid in multi-activities");
                            a.switch {
                                // in the Mint and Spend delegates, these nested activities are expected to re-delegate 
                                // to delegated-data controllers, which will use Mint/Spend/Burn activities on the data-controller tokens.
                                CreatingDelegatedData/*{TxOutputId{seedTxn, seedIdx}, dataTypePurpose} */=> {
                                    // Note: CreatingDelegatedData activity doesn't involve the Capo at all!
                                    // Instead, the minter creates a UUT for the data, on authority of the mintDgt;
                                    // ... and the mintDgt requires the presence of the corresponding dgDataPolicy (with its MintingActivity);
                                    // ... then the dgDataPolicy checks the validity of the new data, and requires that
                                    // ... the new data is created as a DelegatedData record in the Capo address.

                                    // assert(isMintDelegate && cctx.nowActingAsMintDgt(),
                                    //     "CreatingDelegatedData only ok in mintDgt"
                                    //     // " ... use MintingActivities in a delegated-data controller"
                                    // );
                                    // recursion checks for the needed input/output and DgDataController MintingActivity                                
                                    main(mdd, a)
                                },
                                DeletingDelegatedData => {
                                    // assert(isMintDelegate, "DeletingDelegatedData only ok in mintDgt" ); // " ... use BurningActivities in a delegated-data controller"
                                    // cctx.nowActingAsMintDgt() &&
    
                                    // recursion checks for the needed input/burn                                
                                    main(mdd, a)
                                },
                                UpdatingDelegatedData => error(
                                    "UpdatingDelegatedData only ok at level-1 spendDgt"
                                ),
                                DelegateLifecycleActivities => error("multi:DelegateLifecycleActivities not ok"),
                                CapoLifecycleActivities => error("multi:CapoLifecycleActivities not ok"),
                                MultipleDelegateActivities => error("multi:multi: nesting not ok"),
    
                                _ => error("multi:non-minting activities are invalid for mintDgt")
                            }
                        } else if (isSpendDelegate && cctx.nowActingAsSpendDgt(required: false)) {
                            // probably can't fail here:
                            // assert(isSpendDelegate, "ack! non-SpendDelegate can't act as spendDgt");
                            print("  -- spendDgt checking multi-activity");
                            REQT("in the spend delegate, only {Updating,Deleting}DelegatedData activities are valid in multi-activities");
                            a.switch {
                                // in the Mint and Spend delegates, these nested activities are expected re-delegate to delegated-data controllers,
                                // which will use Mint/Spend/Burn activities on the data-controller tokens.
                                UpdatingDelegatedData{_typeName, _recId} => {
                                    assert(isSpendDelegate && cctx.nowActingAsSpendDgt(),
                                        "UpdatingDelegatedData only ok at level-1 spendDgt"
                                        // " ... a delegated-data-controller will use one of its SpendingActivities to govern capoStoredData's spend"
                                    );
                                    // the recursion always checks for the input-datum, so we
                                    // don't need to check it here.
                                    // _inputDD = cctx.delegatedDataTxInput(recIdBytes: recId);
                                    main(mdd, a)
                                },
                                CreatingDelegatedData => error(
                                    "CreatingDelegatedData only ok in mintDgt"
                                ),
                                DeletingDelegatedData => {
                                    error("TODO: validate spending the datum for burn")
                                },
                                DelegateLifecycleActivities => error("multi:DelegateLifecycleActivities not ok"),
                                CapoLifecycleActivities => error("multi:CapoLifecycleActivities not ok"),
                                MultipleDelegateActivities => error("multi:multi: nesting not ok"),
                                _ => error("multi: non-spending activities are invalid for spendDgt")
                            }
                        } else {
                            assert(!isMintDelegate && !isSpendDelegate, "ack! delegated-data policy can't be a mint/spend delegate");
                            TODO("assert isDgDataPolicy"); // assert(isDgDataPolicy, "invalid use of multiActivity by non-DgDataPolicy");
                            print("  -- dgDataPolicy checking multi-activity");
                            // WHEN this code is supporting a DgDataPolicy (with its own specializedDelegate module),
                            //   the multi-activity expects Minting/Spending/Burning activities, not *DelegatedData activities.
                            REQT("in DgDataPolicy, only Minting/Burning/Spending activities are valid");
                            a.switch {
                                UpdatingDelegatedData => error(
                                    "UpdatingDelegatedData only ok at level-1 spendDgt (use a SpendingActivity in dgDataPolicy)"
                                ),
                                CreatingDelegatedData => error(
                                    "CreatingDelegatedData only ok in mintDgt (use a MintingActivity in dgDataPolicy)"
                                ),
                                DeletingDelegatedData => error(
                                    "DeletingDelegatedData only ok at mint/spend dgt (use BurningActivity in dgDataPolicy)"
                                ),
                                // in the delegated-data controllers, we have to support these multi-activities.
                                // this will pass through the individual activity to be individually validated by the specialized delegate 
                                // module that governs the data-controller's UUT, in its additionalDelegateValidation() function.
                                SpendingActivities => main(mdd, a),
                                MintingActivities => main(mdd, a),
                                BurningActivities => {
                                    assert(false, "TODO: support multi:BurningActivities for dgDataPolicy or other delegate") ;
                                    main(mdd, a)
                                },
                                DelegateLifecycleActivities => error("multi:DelegateLifecycleActivities not ok"),
                                CapoLifecycleActivities => error("multi:CapoLifecycleActivities not ok"),
                                MultipleDelegateActivities => error("multi:multi: nesting not ok")
                                // _ => error("multi: invalid other activity for non-mint/spend delegate")
                            }
                        }
                    })
                },
                //   guards that the authority token is returned to this script.
                // specialized minting delegates should likely perform additional checks.
                DelegateLifecycleActivities{innerActivity} => innerActivity.switch {
                    // reassigning the authority token to a new minting delegate
                    ReplacingMe{seed, purpose} => {
                        // should burn the old UUT, mint the new UUT, and update the Charter
                        // with the new mint authority

                        //xxx -   tx.minted.get_safe( dd.acAuthorityToken() ) == 0 &&
                        //xxx -   !returnsValueToScript( dd.tvAuthorityToken())

                        BURNED: Int = -1;
                        otherMintedValue: Value = Value::new(
                            AssetClass::new(dd.mph, dd.tn), 
                            BURNED
                        );
                    
                        print("checking ReplacingMe on "+purpose + ": "+ dd.tn.decode_utf8());
                        REQT("needs the charter to be approving the the new mint-delegate");
                        TODO("  ^^^ should queue the new delegate in pendingDgtChanges");

                        cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterInput();
                        isUpdatingCharter : Bool = cctx.getCharterRedeemer().switch {
                            // THE CHARTER UPDATE ITSELF WILL CHECK THAT THERE'S A VALID DELEGATE OUTPUT FOR THE NEW DELEGATE
                            updatingCharter => true,
                            _ => false
                        };

                        isMintingOk : Bool = validateUutMinting(
                            mph: dd.mph,
                            seed: seed,
                            purposes: []String{purpose}, 
                            otherMintedValue: otherMintedValue,
                            needsMintDelegateApproval: false,
                            extraMintDelegateRedeemerCheck: false
                        );

                        isMintingOk && isUpdatingCharter

                    },

                    // the token is being burned, retiring the authority token for this minting delegate
                    // as a result, this minting delegate will no longer be consulted.  This could be combined
                    // with the creation of a new minting delegate with a new authority token, registered
                    // with the Capo in place of this one (or Reassigning could be used for such a case).
                    // If there is no replacement minting delegate, then the Capo will not be able to perform 
                    // any further minting activities.
                    //
                    // Retiring is not suitable for authorizing token-burning.
                    Retiring => {
                        tx.minted.get(dd.acAuthorityToken()) == -1
                    },

                    ValidatingSettings => {
                        _charter : CapoDatum::CharterData = getTxCharterData(dd.mph);

                        // each application-specific delegate must validate the settings
                        // for itself?
                        // OR: import the settings type, and trigger the validation here
                        // ... so delegate authors can have fewer hoops to jump through
                        TODO("import settings from delegate and validate them");

                        // _foundSettings = ProtocolSettings::from_data(cctx.getManifestedData("settings"));

                        //xxx foundSettings : outputAndDatum[CapoDatum::SettingsData] = 
                        //xxx     charter.mustFindSettingsOutput(dd.mph, dd.capoAddr);
                        //xxx customSettings = fromCip68Wrapper[ProtocolSettings](foundSettings.rawData);

                        // print("\n" + delegateName + ": delegate TRYING TO VALIDATE SETTINGS\n");
                        // validated : Bool = customSettings.validate();
                        // print("HURRAY\n");

                        // TODO: also validate any typeMap (can do this later and adopt the new delegate 
                        // into the Capo when this code is written)

                        assert( false && 
                            // validated && 
                            // isValid : Bool = 
                            //     ((isTest && throwIfBadSettings(mdd, settings)) || true) &&
                            //     mdd.validateSettings(settings);
                            // isValid
                            true,
                            "ValidateSettings temporarily disabled"
                        );
                        false
                    }
                },
                CapoLifecycleActivities{dCLA} => {
                    REQT("... with any CapoLifecycle activity: ");
                    cctx = mkCapoCtx(dd.mph).
                        withCharterInput().
                        requiresGovAuthority();                    

                    // wantsRole : DelegateRole = CLA.switch {
                    //     forcingNewSpendDelegate => error("the forcingNewSpendDelegate escape-hatch activity is always handled directly by the Capo"),
                    //     forcingNewMintDelegate => error("the forcingNewMintDelegate escape-hatch activity is always handled directly by the Capo"),
                    //     removePendingDgtChange => DelegateRole::SpendDgt,
                    //     commitPendingDgtChanges => DelegateRole::BothMintAndSpendDgt,
                    //     updatingManifest => DelegateRole::SpendDgt,

                    //     CreatingDelegate => {
                    //         TODO("deprecate use of CLA::CreatingDelegate");
                    //         DelegateRole::MintDgt
                    //     },

                    //     queuePendingDgtChange => DelegateRole::BothMintAndSpendDgt
                    //     // we want explicit handling of each case; don't use a default match here.
                    //     // _ => error("DO NOT CATCH DEFAULT CASE HERE")
                    // };
                    // wantsRole.switch {
                    neededRole = cctx.dgtRolesForLifecycleActivity(dCLA);
                    myCurrentRole : DelegateRole = neededRole.switch {
                        HandledByCapoOnly => {
                            error("delegate invoked with invalid escape-hatch activity (always handled directly by the Capo)")
                        },
                        SpendDgt => {
                            REQT(
                                "... this Capo lifecycle activity is only valid on spend delegate",
                                isSpendDelegate 
                            );
                            assert(cctx.nowActingAsSpendDgt(), "<----- that can fail, this can't");                            
                            print("  -- ok: spendDgt checking CapoLifecycleActivity");
                            neededRole
                        },
                        MintDgt => {
                            REQT(
                                "... this Capo lifecycle activity is only valid on mint delegate",
                                isMintDelegate
                            );
                            assert(cctx.nowActingAsMintDgt(), "<----- that can fail, this can't");
                            print("  -- ok: mintDgt checking CapoLifecycleActivity");
                            neededRole
                        },
                        BothMintAndSpendDgt => {
                            REQT("It EXPECTS the Capo to enforce the presence of the mintDgt (to check the right mint) and spendDgt (to validate the charter-update logic)");
                            // REQT("  ... it needs the mintDgt to check mints & burns");// the new dgTkn creation");
                            // REQT("  ... it uses the spendDgt to verify the correct charterData update");
                            if (cctx.nowActingAsMintDgt(required:false)) {
                                DelegateRole::MintDgt
                            } else if (cctx.nowActingAsSpendDgt(required:false)) {
                                DelegateRole::SpendDgt
                            } else {
                                error("this Capo lifecycle activity is only valid on mint/spend delegate, not "+ delegateName)
                            }
                        },
                        _ => error("no way") // unreachable
                    };

                    // the Capo policy already requires that this activity is identical
                    // to the capo's own triggered lifecycle activity, given that the
                    // capoLifecycleActivity is what's involved on that end.  We
                    // ensure that is true here:
                    REQT("requires the Capo's CharterData activity to match this delegate's activity");
                    cctx.getCharterRedeemer().switch {
                        capoLifecycleActivity{cCLA} => {
                            assert(
                                cCLA == dCLA,
                                "activity mismatch with Capo's CharterData activity"
                            );
                            print("  -- ok, CharterData capoLifecycleActivity matches ours\n")

                        },
                        updatingCharter => {
                            dCLA.switch {
                                CreatingDelegate => {
                                    print("ok, Capo:updatingCharter works for now with CreatingDelegate\n")
                                },
                                _ => error("when Capo is UpdatingCharter, the mintDelegate must be CreatingDelegate")
                            }
                        },
                        _ => error("this activity must match the capo's own CharterData activity")
                    };

                    dCLA.switch {
                        // the mint delegate is validating a mint that CREATES A NEW DELEGATE
                        // FOR APPLICATION-SPECIFIC PURPOSES. This can affect the structure of the Capo
                        // it defers to the specialized minting delegate, if any; the unspecialized mint delegate
                        // rejects all delegate-creation.
                        CreatingDelegate{seed, purpose} => {
                            // print("🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞 !!!!!!!!!!!!!!!!!!! todo: fix this\n");
                            // assert(false, "obsolete CLA::CreatingDelegate?");
                            TODO("XXX it should output the new delegate token to the Capo as a PendingDelegate datum");
                            REQT("validates creation of UUT for the new delegate, aligned to the purpose indicated");

                            mkTn = mkUutTnFactory(seed);
                            myCurrentRole.switch {
                                MintDgt => {
                                    REQT(
                                        "validates the new delegate's UUT is minted"
                                    );
                                    if (validateUutMinting(
                                        mph: dd.mph,
                                        seed: seed,
                                        purposes: []String{purpose},
                                        // otherMintedValue: ()
                                        mkTokenName: mkTn,
                                        // WE ARE the mint delegate.
                                        needsMintDelegateApproval: false 
                                    )) {
                                        print("  -- ok, minted the new delegate's UUT\n") 
                                    };
                                    REQT(
                                        "the UUT must have the right disposition (is it checked somewhere else?!?)"
                                    );
                                    cctx.getNextCharterData().otherNamedDelegates.get_safe(purpose).switch {
                                        None => error("the new delegate is not present in the Capo's manifest"),
                                        Some{dgtLink} => {
                                            assert(dgtLink.uutName == mkTn(purpose), "uutName mismatch");

                                            dgtLink.hasValidOutput(
                                                mph: dd.mph, 
                                                required: true,
                                                createdOrReturned: DgTkn::Created
                                            )
                                        }
                                    }
                                },
                                _ => error("unreachable wrong role for CreatingDelegate")
                            }
                        },
                        queuePendingDgtChange => {
                            REQT("... for the addingPendingDgt activity:");

                            charterData : CapoDatum::CharterData = cctx.getCharterData();

                            REQT("The new pending-delegate action is found at the head of the new change-list");
                            oldPendingChanges = charterData.pendingDgtChanges;
                            nextCharterData = cctx.getNextCharterData();
                            nextChangeList = nextCharterData.pendingDgtChanges;
                            newChange = nextChangeList.head;
                            PendingDelegateChange{
                                action, // PendingDelegateAction
                                role, // : DelegateRole
                                Option[String]::Some{
                                    name
                                }, //: Option[String] // only valid for named delegates and dgDataPolicy
                                OdgtLink //: Option[RelativeDelegateLink]
                            } = newChange;
                            action.switch {
                                Remove => {
                                    print("   -- another delegate-role check would be redundant.");

                                    myCurrentRole.switch {
                                        SpendDgt => {
                                            REQT("verifies that the delegate queued for removal is present in the Capo's charterData");
                                            error("implement me")
                                        },
                                        _ => error("unreachable")
                                    }
                                }, 
                                _ => assert(true, "no way")

                            };



                            REQT("the remainder of the change-list should be unchanged");
                            assert(
                                nextChangeList.tail == oldPendingChanges, 
                                "invalid update of pendingDgtChanges; the new action must be prepended to the existing list."
                            );
                            (
                                seed: TxOutputId, 
                                purpose: String,
                                pendingActionIdPrefix: String
                                // uutName: String, 
                                // dvh : Option[ValidatorHash], 
                                // config : ByteArray
                            ) = action.switch { 
                                Remove => error("unreachable"), 
                                Add{seed, purpose, idPrefix} => {
                                    (seed, purpose, idPrefix) 
                                },
                                Replace{seed, purpose, idPrefix, _replacesDgt } => { 
                                    (seed, purpose, idPrefix ) 
                                }
                            };

                            possibleMintDgtVerifications : Bool = myCurrentRole.switch {
                                SpendDgt => /* no-op */ true,
                                MintDgt => bREQT(
                                    "(general) the mintDgt checks everything about the mint"
                                ) && action.switch {
                                    Remove => {
                                        role.switch {
                                            MintDgt => error("cannot Remove role: MintDgt"),
                                            SpendDgt => error("cannot Remove role: SpendDgt"),
                                            MintInvariant => error("cannot Remove role: MintInvariant"),
                                            SpendInvariant => error("cannot Remove role: SpendInvariant"),
                                            DgDataPolicy => {
                                                assert(false, "todo")
                                            },
                                            OtherNamedDgt => {
                                                assert(false, "todo")
                                            },
                                            BothMintAndSpendDgt => error(
                                                "DelegateRole::BothMintAndSpend not applicable in queuePendingDgtChange activity"
                                            )
                                        };
                                        REQT("doesn't allow a Remove to duplicate an Add or Replace or Remove entry");
                                        TODO("^^^");

                                        assert(false, "what else should be checked here?");
                                        false
                                    },
                                    _ => { // Replace or Add
                                        if(false/*redundant*/) { assert(cctx.nowActingAsMintDgt(), "<----- that can fail, this can't") };

                                        mkTokenName = mkUutTnFactory(seed);
                                        dgTknName = mkTokenName(purpose);
                        
                                        mintedDgTkn = bREQT("the new delegate is created with the indicated authority token")
                                        && validateUutMinting(
                                            mph: dd.mph,
                                            seed: seed,
                                            // "dgtPol", until/unless we get fancy like "settingsPol", "reqtsPol", "mktSalePol", etc:
                                            purposes: []String{purpose}, 
                                            // otherMintedValue: ()
                                            mkTokenName: mkUutTnFactory(seed),
                                            // WE ARE the mint delegate.
                                            needsMintDelegateApproval: false 
                                        );
                                        
                                        REQT("The new policy-token must match the seed");
                                        dgtLink = OdgtLink.switch {
                                            None => error("missing required delegate link in pending dgt change"),
                                            Some{dl} => dl
                                        };
                                        assert(
                                            dgtLink.uutName == dgTknName,
                                            "uutName mismatch; expected "+dgTknName+" but found "+dgtLink.uutName
                                        );

                                        delegateTakesOwnership = bREQT("the new policy-delegate-script must take ownership of the dgTkn",
                                            dgtLink.hasValidOutput(
                                                mph: dd.mph, 
                                                required: true,
                                                createdOrReturned: DgTkn::Created
                                        ));

                                        possibleExtraReplacementCheck = action.switch {
                                            Replace => {
                                                REQT("Replace: the queued change must match the idPrefix of the current delegate ");
                                                TODO("VALIDATE this through a unit-test ^");
                                                charterData.manifest.get_safe(name).switch {
                                                    Some{dde} => {
                                                        CapoManifestEntry{entryType, _tn, _mph} = dde;
                                                        entryType.switch {
                                                            DgDataPolicy{_polLink, idPrefix, _refCount} => {
                                                                REQT("expects the queued idPrefix to match the existing policy's idPrefix");
                                                                print("   -- expected: " + idPrefix);
                                                                print("   --     actual:"+pendingActionIdPrefix);
                                                                assert(
                                                                    idPrefix == pendingActionIdPrefix,
                                                                    "idPrefix mismatch"
                                                                )
                                                            },
                                                            _ => error("invalid Replace; the matching manifest entry for '"+name+"' isn't a DgDataPolicy.")
                                                        }
                                                    },
                                                    None => error("no existing dgDataPolicy found with key: "+name)
                                                };
                                                true
                                            },
                                            _ => true
                                        };
                                        mintedDgTkn && delegateTakesOwnership && possibleExtraReplacementCheck
                                    }
                                },
                                _ => error("unreachable") // other DelegateRoles 
                            }; // -> possibleMintDgtVerifications

                            possibleSpendDgtVerifications : Bool = myCurrentRole.switch {
                                MintDgt => /* no-op */ true,
                                SpendDgt => {
                                    REQT("(general) the spendDgt checks everything about the charterData update");

                                    REQT("doesn't allow a queued change to duplicate any other pending entry for the same delegate name");
                                    isNotADuplicate = charterData.pendingDgtChanges.all( (pdChange: PendingDelegateChange) -> Bool {
                                        pdChange.name.unwrap() != name
                                    });
                                    assert(isNotADuplicate, "already has a pending change for this delegate: "+name);

                                    possibleReplacementIsCorrect: Bool = action.switch {
                                        Remove => error("unreachable"),
                                        Add => true, // doesn't need to replace anything
                                        Replace{_seed, _purpose, _recPrefix, acExistingDgt} => { 
                                            REQT("... when queuing a replacement delegate: ");
                                            REQT("invariants cannot be replaced");
                                            role.switch {
                                                MintInvariant => error("cannot Replace role: MintInvariant"),
                                                SpendInvariant => error("cannot Replace role: SpendInvariant"),
                                                HandledByCapoOnly => error("HandledByCapoOnly role is not applicable in delegate context"),
                                                _ => print("  -- ok (not trying to replace an invariant)")
                                            };

                                            mkSome = (ac: AssetClass) -> Option[AssetClass] { Option[AssetClass]::Some{ac} };
                                            REQT("the PendingDelegateAction's role + replacesDgt must match the existing delegate's authority token");
                                            replacesDgTkn : Option[AssetClass] = role.switch {
                                                MintDgt => mkSome(charterData.mintDelegateLink.acAuthorityToken(dd.mph)),
                                                SpendDgt => mkSome(charterData.spendDelegateLink.acAuthorityToken(dd.mph)),
                                                DgDataPolicy => {
                                                    REQT("to Replace a dgDataPolicy, the named policy must be present in the Capo manifest");
                                                    error("todo: get authority-token for this dgDataPolicy")

                                                },
                                                OtherNamedDgt => {
                                                    REQT("to Replace a named delegate, the named delegate must already be present");
                                                    error("todo: get authority-token for this named delegate")
                                                },
                                                BothMintAndSpendDgt => error(
                                                    "DelegateRole::BothMintAndSpend not applicable in queuePendingDgtChange activity"
                                                ),
                                                MintInvariant => error("unreachable"),
                                                SpendInvariant => error("unreachable"),
                                                HandledByCapoOnly => error("unreachable")
                                            };
                                            assert(
                                                acExistingDgt == replacesDgTkn.unwrap(),
                                                "the current "+role.switch{
                                                    MintDgt => "mint", SpendDgt => "spend", 
                                                    DgDataPolicy => "dgDataPolicy", OtherNamedDgt => "named",
                                                    _ => "‹incontheeiieivable›"
                                                }+" delegate's authority token doesn't match "+acExistingDgt.show()
                                            );

                                            true
                                        } 
                                    }; // -> possibleReplacementIsCorrect

                                    true
                                    && isNotADuplicate 
                                    && possibleReplacementIsCorrect
                                }, 
                                _ => error("unreachable") // other DelegateRoles 
                            }; // -> possibleSpendDgtVerifications
                                                 
                            true
                            && possibleMintDgtVerifications 
                            && possibleSpendDgtVerifications
                        },
                        removePendingDgtChange{_role, _name} => {
                            // this code-path is only found in the spend-delegate
                            TODO("implement removePendDgt");
                            REQT("allows the removal of a queued pending-delegate-change that can't be completed");
                            assert(false, "not yet implemented");
                            false
                        },
                        commitPendingDgtChanges => {
                            // this code-path has one leg in the spend-delegate
                            // and one leg in the mint-delegate
                            REQT("invariants cannot be replaced");
                            pendingChangesList : []PendingDelegateChange = cctx.getCharterData().pendingDgtChanges;
                            previousManifest : Map[String]CapoManifestEntry = cctx.getCharterData().manifest;
                            nextCharterData = cctx.getNextCharterData();
                            nextManifest : Map[String]CapoManifestEntry = nextCharterData.manifest;

                            assert(
                                bREQT("the next-changes list must be empty") &&
                                nextCharterData.pendingDgtChanges.length == 0,
                                "pendingDgtChanges must be emptied"
                            );

                            if (cctx.nowActingAsSpendDgt(required: false)) {
                                REQT("spendDgt: committing pending delegates: validates that all the pending delegates are installed");
                                // the pending changes are moved into the nextManifest

                                // walks through the pending changes and next-manifest entries
                                // ... and also holds a temporary picture of previous-manifest entries.
                                //  - verifies that each next change is reflected in the next-manifest's next entry
                                //  - verifies at the end that the remainder of the next-manifest-tail (after verifying changes added in its "head" section) 
                                //    ... contains all the entries expected (from the previous-manifest-remainder,
                                //    ...   == previous-manifest, when no Remove/Replace actions are present);
                                //  - verifies that any Removed entries are missing from the next-manifest-map
                                //    ... while removing them from the previous-manifest-remainder's "expected remaining entries"
                                //  - verifies any Replaced entries have been added at the next-manifest's next entry
                                //    ... AND that they're removed from the remainder of the next-manifest-map,
                                //    ... while removing them from the "expected remaining entries" in the previous-manifest-remainder.
                                // At the end, it verifies that the two remaining partial-maps are identical.
                                (
                                    prevManifestRemainder, nextManifestRemainder: Map[String]CapoManifestEntry
                                ) = pendingChangesList.fold2[ Map[String]CapoManifestEntry, Map[String]CapoManifestEntry ]( 
                                    (
                                        prevManifestRemainder : Map[String]CapoManifestEntry, 
                                        nextCMEs: Map[String]CapoManifestEntry, 
                                        pdChange: PendingDelegateChange
                                    ) -> ( Map[String]CapoManifestEntry, Map[String]CapoManifestEntry ) {
                                        pdChange.role.switch {
                                            DgDataPolicy => print("  -- ok: DgDataPolicy in commitPendingDgtChanges"),
                                            _ => error("invalid delegate-change role (for now) in commitPendingDgtChanges")
                                        };
                                        //void
                                        pdChange.action.switch {
                                            Remove => {
                                                REQT("dgt-change: Remove: verifies that the delegate queued for removal is now removed from the Capo manifest");
                                                nextCMEs.get_safe(pdChange.name.unwrap()).switch { 
                                                    Some => error(
                                                        "queued Remove failed: name still present in next-manifest item: "+ 
                                                        pdChange.name.unwrap()
                                                    )
                                                }
                                            },
                                            _ => {
                                                REQT("verifies that added & replaced entries are present in the updated map (at its next position)");
                                                if (nextCMEs.length == 0) {
                                                    error("queued Add/Replace failed: no more items in next-manifest map")
                                                };
                                                ( CME_key : String, CapoManifestEntry{ME_type, _tn, _mph} ) = nextCMEs.head;
                                                ManifestEntryType::DgDataPolicy{ME_policyLink, ME_idPrefix, refCount} = ME_type;
                                                TODO("support minting multiple threads of a dgDataPolicy");
                                                assert(refCount == 1, "refCount must be 1 when adding a new dgDataPolicy");
                                                assert(pdChange.name.unwrap() == CME_key,
                                                    "queued change: name mismatch with next-manifest item"
                                                );
                                                assert(ME_policyLink == pdChange.dgtLink.unwrap(),
                                                    "queued change: policyLink mismatch with next-manifest item"
                                                );

                                                nextIdPrefix = pdChange.action.switch {
                                                    Replace{_,_,idPrefix,_} => {
                                                        REQT("Replace: verifies that the next-manifest no longer has the replaced entry");

                                                        nextManifest.tail.get_safe(pdChange.name.unwrap()).switch {
                                                            Some => error(
                                                                "queued Replace failed: duplicate name remaining in next-manifest map: "+ 
                                                                pdChange.name.unwrap()
                                                            )
                                                        };
                                                        idPrefix
                                                    },
                                                    Add{_,_,idPrefix} => idPrefix,
                                                    _ => error( "unreachable")
                                                };
                                                print("     vv @entry: "+CME_key);
                                                REQT("  -- @each manifest entry: next-manifest's idPrefix must match the queued change");
                                                assert(nextIdPrefix == ME_idPrefix,
                                                    "idPrefix mismatch with next-manifest's dgDataPolicy"
                                                )
                                            }
                                        }; // void assertions; all needed checks are done ^^^^

                                        // traverses to next state for the reducer:
                                        pdChange.action.switch {
                                            Add => {
                                                ( prevManifestRemainder, nextCMEs.tail )
                                            },
                                            _ => { // Remove, Replace => {
                                                ( prevManifestRemainder.delete(pdChange.name.unwrap()), nextCMEs.tail )
                                            }
                                        }
                                    }, // reducer
                                    previousManifest, // init1
                                    nextManifest // init2
                                );
                                nextManifestRemainder == prevManifestRemainder
                            } // spendDgt
                            else if (cctx.nowActingAsMintDgt(required: false)) {
                                REQT("mintDgt: committing pending delegates: validates that all the removed dgTkns are burned");
                                
                                REQT("the txn must have all the expected burns");
                                observedTokenBurn = if( tx.minted.contains_policy(dd.mph) ) {
                                    minted = tx.minted;
                                    if (minted.to_map().length > 1) {
                                        error("currently supporting only one minting policy being burned in the tx")
                                    };
                                    tx.minted.get_policy(dd.mph)
                                } else {
                                    Map[ByteArray]Int{} // no burns expected
                                };

                                remainingMint: Map[ByteArray]Int = pendingChangesList.fold[ Map[ByteArray]Int ]( 
                                    (burning: Map[ByteArray]Int, pdChange: PendingDelegateChange) -> Map[ByteArray]Int {
                                        REQT("EXPECTS the spendDgt to check details of Replace activities");
                                        // ignores the dgtLink details if present in a Replace activity
                                        pdChange.role.switch {
                                            DgDataPolicy => {
                                                print("  -- ok: DgDataPolicy in commitPendingDgtChanges");
                                                PendingDelegateChange{action, role, nameMaybe, _dgtLinkMaybe} = pdChange;
                                                REQT("each pending change must have a name, which must be found in the current manifest");
                                                name = nameMaybe.unwrap();
                                                print( "     -- ok: name");
                                                role.switch {
                                                    DgDataPolicy => print("  -- ok: DgDataPolicy role"),
                                                    _ => error("delegate changes only recognize DgDataPolicy role for now")
                                                };
                                                action.switch {
                                                    Add => {
                                                        // doesn't accumulate any expected mints or burns for Add 
                                                        // (the mint happens in a previous transaction while queueing the change
                                                        burning
                                                    },
                                                    _ => { // Replace, Remove => {
                                                        REQT("verifies that a delegate queued for removal or replacement is burned");
                                                        previousManifest.get_safe(name).switch {
                                                            None => error("queued Remove failed: not present in previous-manifest map: "+ name),
                                                            Some{CapoManifestEntry{ME_type, tn, mph}} => {
                                                                mph.switch {
                                                                    Some => {
                                                                        print( "    -- TODO: manifest entry with other-mph: allow optional burn");
                                                                        // doesn't accumulate any additional expected burns
                                                                        burning
                                                                    },
                                                                    _ => {
                                                                        ManifestEntryType::DgDataPolicy{_ME_policyLink, _ME_recPrefix, refCount} = ME_type;
                                                                        burning.get_safe(tn).switch {
                                                                            None => error("queued Remove/Replace failed: no burn, or double-burn: "+ tn.decode_utf8()),
                                                                            Some{burningCount} => {
                                                                                print("    -- ok: BURN 🔥"+ burningCount.show() + "×💴 "+ tn.decode_utf8());
                                                                                assert(0 - refCount == burningCount, // negative = burning
                                                                                    "queued Remove/Replace failed: expected burn of " + 
                                                                                    refCount.show() + "×💴 "+ tn.decode_utf8() 
                                                                                );
                                                                                burning.delete(tn)
                                                                            } // burningCount
                                                                        } // check burn quantity
                                                                    }
                                                                } // mph
                                                            }
                                                        }
                                                    } // Remove/Replace
                                                } // action
                                            }, // DgDataPolicy
                                            _ => error("invalid delegate-change role (for now) in commitPendingDgtChanges")
                                        } // role
                                    },  // reducer
                                    observedTokenBurn // initial value
                                );

                                REQT("requires all the burns of our policy-id to be accounted for");
                                assert(remainingMint.length == 0, 
                                    "extra burns found in the transaction: \n"+remainingMint.show());
                                true
                            } /* mintDgt */ 
                            else {
                                error("unreachable? not mintDgt or spendDgt")
                            }
                        }, // commitPendingDgtChanges

                        updatingManifest{manifestActivity} => {
                            REQT("doesn't allow updating anything except the manifest");
                            manifestActivity.switch{
                                retiringEntry{_key} => {
                                    assert(false, "TODO: support retirement activity");
                                    REQT("doesn't remove a dgDataPolicy entry from the manifest (use queuePendingDgtChange instead)");
                                    REQT("removes the indicated key from the manifest");
                                    REQT("delegates MUST be allowed to validate that this doesn't drop something they need")
                                },
                                updatingEntry{_key, _tokenName} => {
                                    TODO("if delegates need a hook to validate that the updte is acceptable, that might be enforced here");
                                    assert(false, "TODO: support updatingEntry activity");
                                    REQT("the indicated token MUST be referenced in the transaction")
                                },
                                addingEntry{key, tokenName} => {
                                    charterData : CapoDatum::CharterData = cctx.getCharterData();
                                    nextCharterData = cctx.getNextCharterData();
                                    REQT("the indicated token MUST be referenced in the transaction");
                                    _refInput = cctx.delegatedDataRef(recIdBytes: tokenName);

                                    REQT("the new entry MUST be found in the new manifest");
                                    nextCharterData.manifest.get_safe(key).switch {
                                        None => error("the new manifest entry is missing: "+key),
                                        Some{CapoManifestEntry{entryType, tn, mph}} => {
                                            print("   -- ok, found the manifest entry for "+ key);
                                            REQT("the new entry must have the right token-name");
                                            assert(tn == tokenName, "token-name mismatch");
                                            mph.switch { Some => error("other-mph not yet supported") };
                                            entryType.switch {
                                                NamedTokenRef => print("   -- ok: matching name, with NamedTokenRef added in updatingManifest"),
                                                _ => error("addingEntry: the new manifest entry must be a NamedTokenRef for now")                                                
                                            }
                                        }
                                    };
                                    REQT("the remainder of the manifest must be unchanged");
                                    // NOTE if you're troubleshooting a txn-building functoin, that the order 
                                    //   of elements is significant.
                                    assert(charterData.manifest == nextCharterData.manifest.delete(key),
                                        "manifest modified in an unexpected way"
                                    );
                                    print("  -- ok! new manifest as expected")
                                },
                                forkingThreadToken{_key, _newThreadCount} => {
                                    assert(cctx.nowActingAsMintDgt(), "<----- that can fail, this can't");
                                    assert(false, "TODO: support forkingThreadToken activity");
                                    REQT("the indicated token MUST be referenced in the transaction");
                                    REQT("validates that another copy of the token name is minted");
                                    REQT("when the key is a DgDataPolicy, the existing manifest entry is updated");
                                    REQT("for mint/spend delegates and otherNamedDelegates, a new manifest entry is created with refCount=1+newThreadCount, if it doesn't exist");
                                    REQT("when the manifest already has the entry, the refCount is incremented by newThreadCount")

                                }
                            }; // void assertions;
                            true
                        },
                        forcingNewMintDelegate => {
                            REQT("a forced delegate change is an escape-hatch only involving the minter and the Capo");
                            error("the mint/spend delegate never is involved when the minter is instructed to force a new delegate")
                        },
                        forcingNewSpendDelegate => {
                            REQT("a forced delegate change is an escape-hatch only involving the minter and the Capo");
                            error("the mint/spend delegate never is involved when the spender is instructed to force a new delegate")
                        }
                    } && if (true) { 
                        print("BasicDelegate harness deferring to specialization for CapoLifecycleActivities\n");
                        true
                    } else { false }
                },

                // NOTE: this is a mint delegate activity on the mintDgt-* token,
                // ... used only in a Capo's MINT delegate.  Once the specialized mint delegate includes
                // ... the delegated-data controller's UUT through the re-delegation pattern,
                // ... the delegated-data controller  picks up the thread of enforcement, via Its specialized 
                // ... delegate module's additionalDelegateValidation(), by handling the 
                // ... MintingActivities variant indicated in the *Ctrl-* token's activity/redeemer.  
                // It can be tricky to recognize that this code module serves the mint delegate, 
                // ... and that it ALSO serves the data-controller delegate separately, in that completely different
                // ... context and using its separate specialization module.
                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, 
                // ... while processing different tokens for each zone of authority/responsibility.
                CreatingDelegatedData{seed, dataTypePurpose} => {
                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();
                    REQT("context: CreatingDelegatedData");
                    assert(isMintDelegate && cctx.nowActingAsMintDgt(), "<---- fails in there, not here");

                    policyDelegateInput = cctx.
                        requiresDgDataPolicyInput(dataTypePurpose);

                    tnFactory : (String) -> String = mkUutTnFactory(seed);
                    purpose = policyDelegateInput.idPrefix.unwrap();
                    newDataId : ByteArray = tnFactory( purpose ).encode_utf8();
                    // as a mint delegate, we should see to it that any minting does play by the rules
                    //   ... however, this module is generic, so we can only perform generic checks here.
                    //   ... we additionally call application-provided validation (provided by a specialization)
                    //       (we haven't fully implemented generic data-controller registration, so that's a key limitation for now)
                    // xxx WE are the mint delegate : ) -  cctx.requiresMintDelegateInput().requiresValidOutput() 
                    // this needs to be done by the speciization for now
                    // && cctx.requiresDelegatedDataController(dataTypePurpose).requiresDataMinting()                    

                    // dgDataPolicy = cctx.findManifestEntry(dataTypePurpose).switch {
                    //     None => error(
                    //         "can't create delegatedData without a matching '"+
                    //         dataTypePurpose+"' dgDataPolicy entry in the capo manifest"),
                    //     Some{mEntry} => {
                    //         mEntry.entryType.switch {
                    //             DgDataPolicy{policyLink, _refCount} => policyLink,
                    //             _ => error(
                    //                 "can't create delegatedData type '"+
                    //                 dataTypePurpose+
                    //                 "'; its Capo manifest entry is not a DgDataPolicy"
                    //             )
                    //         }
                    //     }
                    // };

                    // no longer TODO :party: // TODO("the mint-delegate specialization MUST re-delegate authority to the right data-controller");
                    TODO("it must check that the data-controller has exactly one minting activity for the indicated recId");
                    print("    -- e.g. using CapoCtx: cctx\n      .requiresNamedDelegateInput(delegateName)\n      .withSeededMintingActivity(seed)\n");

                    //!!! if the thing being created is a Settings record,
                    //  make sure the capo CharterData is also being updated
                    //  with a new manifest entry (settings -> this record-id)

                    true
                    && validateUutMinting(
                        mph: dd.mph,
                        seed: seed,
                        purposes: []String{purpose},
                        // otherMintedValue: ()
                        mkTokenName: tnFactory,
                        // WE ARE the mint delegate.
                        needsMintDelegateApproval: false 
                    // ).trace(
                    //     " ✅ checked basic UUT minting "
                    )
                    && bREQT("it outputs the new delegated-data record to the Capo address")
                    && cctx.mustOutputDelegatedData(
                        newDataId, dataTypePurpose
                    )
                    && bREQT("ensures the data-controller is invoked with ONE minting activity for the indicated recId")
                    && policyDelegateInput.
                        withUniqueSeededMintingActivity(seed).
                        orFail()

                    // assert(false, "^^^ does it implement the generic data-controller re-delegation convention? ^^");

                },
                // This is a Spend delegate activity on the spendDgt-* token, 
                // ... used within a Capo's SPEND delegate (which code may also govern 
                // ... its mintDgt- token, under separate utxo cover).
                // Once the specialized spend delegate includes the delegated-data controller UUT through the re-delegation pattern,
                // ... the spend delegate's specialized module picks up the thread of enforcement via its
                // ... additionalDelegateValidation(), by handling the SpendingActivities variant indicated in the *Pol-* token's activity/redeemer.
                // That controller activity may alternatively be a MultiActivity, one of whose nested activities provides 
                // ... the needed SpendingActivities variant.
                // It can be tricky to recognize that this code module serves the spend delegate and the mint delegate,
                // ... and that it ALSO serves the data-controller delegate separately, in that completely different context 
                // ... and using its separate specialization module.
                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, 
                // ... while processing different tokens for each zone of authority/responsibility.
                UpdatingDelegatedData{dDataType, recId} => {
                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();
                    assert(cctx.nowActingAsSpendDgt(), "<---- fails in there, not here");
                    REQT("EXPECTS j6bmfv: all and ONLY DelegatedData datums must be spent with the Capo's spendingDelegatedData activity");

                    REQT("implements a generic data-controller re-delegation convention based on the capo's manifest (those with type= DgDataPolicy)");

                    REQT("ensures the data-controller is invoked with ONE spending activity for the indicated recId");
                    assert( cctx.
                        requiresDgDataPolicyInput(dDataType).
                        withUniqueDDSpendingActivity(recId).
                        orFail(),
                         "^^^ those can fail, this assert won't."
                    );

                    inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);
                    assert(inputDD == inputDD, "no way");
                    // ^^ same as vv
                    // hasDDofType : (TxInput) -> Bool = cctx.mkDelegatedDataPredicate(dDataType);
                    // simply finding the input is enough to imply that the that those utxos are spend-governed by the Capo 
                    // ... which at j6bmfv, explicitly requires the token that leads to this code path
                    // ddInputs : []TxInput = ctx.tx.inputs.filter(hasDDofType);
                    // assert(ddInputs.length == 1, "extra DD input(s)");


                    if ("settings" == dDataType) {
                        curSettingsId = cctx.getSettingsId(required: true).unwrap();
                        REQT(
                            "when updating the current Capo settings, the delegates must all "+
                            "have a chance to ensure the settings are valid for their needs"
                        );
                        if (curSettingsId == recId) {
                            assert(
                                // fails if the delegates aren't all validating settings:
                                cctx.allDelegatesAreValidatingSettings(),
                                // can't fail:
                                "no way"
                            )
                        } else {
                            print("  -- NOTE: updating "+ recId.decode_utf8()
                            +", which isn't currentSettings="+curSettingsId.decode_utf8())
                        }
                    };

                    cctx.mustOutputDelegatedData(recId, dDataType)
                    && true
                },

                DeletingDelegatedData {_dataType, recId} => {
                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();

                    REQT("this code is triggered by both the mintDgt and spendDgt, with each doing their parts of the job");
                    REQT("the spendDgt allows the spending of the utxo");
                    REQT("the mintDgt requires the burning of its UUT");
                    REQT("it must not delete a record that's still referenced by the Capo manifest");
                    REQT("a matching manifest entry has to be changed or removed prior to deletion");

                    _inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);
                    // the mintDelegate should be triggered with 
                    TODO("verify the input was found ^");

                    assert(false, "Delete not supported yet");

                    TODO("implement the generic data-controller re-delegation convention here");
                    TODO("ensure that the right delegate is consulted with its BurningActivities.*");

                    cctx.nowActingAsMintDgt() &&
                    false
                },
                // We made these explicit so they're functionally required of every specialized delegate.
                // All of the mint/spend/burn activities must be handled by the specialized delegate.  
                // Note that this code module is generic, so it can't know the internal semantics of those activities,
                // ... or even what their nested variants will be.  It's up to the specialization to handle them.
                // Each of these indicates plural "activities", but they're actually each an individual, discrete, single activity
                // ... with an Enum allowing ONE of various possible specialization-specific activities at that spot.
                // ... MultipleActivities would be used to express "it does multiple separate activities on different utxos")
                SpendingActivities => true, // handled by the specialized delegate
                MintingActivities => true,  // handled by the specialized delegate
                BurningActivities => true // handled by the specialized delegate
            } && if (activity.additionalDelegateValidation(isD)) {
                print ("delegate: "+ delegateName + ": additionalDelegateValidation ok!\n");
                true
            } else {
                error("delegate: "+ delegateName + ": additionalDelegateValidation returned false (without any thrown error)")
            }
        },
        _ => {
            // to trigger an invalid redeemer, call this function
            kaboomInvalidRedeemer = () -> {  error("wrong Actvy/dtm") }; // Activity custom datum must not use Activities reserved for IsDelegation datum.") };

            activity.switch{
                DelegateLifecycleActivities => kaboomInvalidRedeemer(), 
                CapoLifecycleActivities => kaboomInvalidRedeemer(),
                _ => activity.otherDatumValidation(mdd)
            }
        }
    };

    print ("🚥🟢 delegate: "+ delegateName + ": ok!\n");

    result
}
