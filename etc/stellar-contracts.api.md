## API Report File for "@donecollectively/stellar-contracts"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Address } from '@hyperionbt/helios';
import { anyState as anyState_2 } from './StellarTxnContext.js';
import { anyState as anyState_3 } from '../StellarTxnContext.js';
import { AssetClass } from '@hyperionbt/helios';
import { Assets } from '@hyperionbt/helios';
import { ByteArray } from '@hyperionbt/helios';
import { ByteArrayData } from '@hyperionbt/helios';
import { capoDelegateConfig as capoDelegateConfig_2 } from './delegation/RolesAndDelegates.js';
import { Datum } from '@hyperionbt/helios';
import { devConfigProps as devConfigProps_2 } from './StellarContract.js';
import * as helios from '@hyperionbt/helios';
import { HeliosData } from '@hyperionbt/helios';
import { MintingPolicyHash } from '@hyperionbt/helios';
import { Network } from '@hyperionbt/helios';
import { NetworkEmulator } from '@hyperionbt/helios';
import { NetworkParams } from '@hyperionbt/helios';
import { Program } from '@hyperionbt/helios';
import { ReqtsMap as ReqtsMap_2 } from '../Requirements.js';
import { ReqtsMap as ReqtsMap_3 } from './Requirements.js';
import { RoleInfo } from './delegation/RolesAndDelegates.js';
import { RoleMap as RoleMap_2 } from './Capo.js';
import { SeedTxnParams as SeedTxnParams_2 } from './SeedTxn.js';
import { SimpleWallet } from '@hyperionbt/helios';
import { StakeAddress } from '@hyperionbt/helios';
import { StakingValidatorHash } from '@hyperionbt/helios';
import type { TestContext } from 'vitest';
import { textToBytes } from '@hyperionbt/helios';
import { Tx } from '@hyperionbt/helios';
import { TxId } from '@hyperionbt/helios';
import { TxInput } from '@hyperionbt/helios';
import { TxOutput } from '@hyperionbt/helios';
import { TxOutputId } from '@hyperionbt/helios';
import { UplcData } from '@hyperionbt/helios';
import { UplcDataValue } from '@hyperionbt/helios';
import { UplcProgram } from '@hyperionbt/helios';
import { ValidatorHash } from '@hyperionbt/helios';
import { Value } from '@hyperionbt/helios';
import { Wallet } from '@hyperionbt/helios';
import { WalletHelper } from '@hyperionbt/helios';

// @public
export const Activity: {
    partialTxn(proto: any, thingName: any, descriptor: any): any;
    redeemer(proto: any, thingName: any, descriptor: any): any;
    redeemerData(proto: any, thingName: any, descriptor: any): any;
};

// @public
export const ADA = 1000000n;

// @public
export function addrAsString(address: Address): string;

export { Address }

// Warning: (ae-forgotten-export) The symbol "stellarTestHelperSubclass" needs to be exported by the entry point index.d.ts
//
// @public
export function addTestContext<SC extends StellarContract<any>, P extends paramsBase = SC extends StellarContract<infer PT> ? PT : never>(context: StellarTestContext<any, SC>, TestHelperClass: stellarTestHelperSubclass<SC>, params?: P): Promise<void>;

// @public
export class AnyAddressAuthorityPolicy extends AuthorityPolicy {
    // (undocumented)
    activityAuthorizing(): isActivity<undefined>;
    // (undocumented)
    protected activityUsingAuthority(): isActivity;
    // (undocumented)
    DelegateAddsAuthorityToken<TCX extends StellarTxnContext>(tcx: TCX, fromFoundUtxo: TxInput, redeemer?: isActivity): Promise<TCX>;
    // (undocumented)
    DelegateMustFindAuthorityToken(tcx: StellarTxnContext, label: string): Promise<TxInput>;
    // (undocumented)
    DelegateRetiresAuthorityToken(tcx: StellarTxnContext, fromFoundUtxo: TxInput): Promise<StellarTxnContext>;
    // (undocumented)
    get delegateValidatorHash(): undefined;
    // (undocumented)
    findActorAuthorityToken(): Promise<TxInput | undefined>;
    findAuthorityToken(): Promise<TxInput | undefined>;
    // (undocumented)
    loadProgramScript(params: any): undefined;
    // (undocumented)
    txnReceiveAuthorityToken<TCX extends StellarTxnContext>(tcx: TCX, tokenValue: Value, fromFoundUtxo: TxInput): Promise<TCX>;
}

// @public
export type anyDatumProps = Record<string, any>;

// @public
export interface anyState {
    // (undocumented)
    uuts: Record<string, UutName>;
}

// @public
export function assetsAsString(a: Assets): any;

// @public
export abstract class AuthorityPolicy<T extends capoDelegateConfig = capoDelegateConfig> extends StellarDelegate<T> {
}

// Warning: (ae-forgotten-export) The symbol "MintDelegateArgs" needs to be exported by the entry point index.d.ts
//
// @public
export class BasicMintDelegate extends StellarDelegate<MintDelegateArgs> {
    // @internal @deprecated
    activityAuthorizing(): isActivity;
    // (undocumented)
    activityMintingUuts({ seedTxn, seedIndex: sIdx, purposes, }: MintUutActivityArgs): isActivity;
    // (undocumented)
    activityRetiringDelegate(): isActivity;
    // (undocumented)
    contractSource(): any;
    // (undocumented)
    static currentRev: bigint;
    // (undocumented)
    static get defaultParams(): {
        rev: bigint;
        devGen: bigint;
    };
    // (undocumented)
    getContractScriptParams(config: any): {
        rev: any;
        isDev: boolean;
        devGen: bigint;
    };
    // (undocumented)
    importModules(): HeliosModuleSrc[];
    // (undocumented)
    mkDatumScriptReference(): Datum;
    // (undocumented)
    static mkDelegateWithArgs(a: MintDelegateArgs): void;
    // (undocumented)
    mkDelegationDatum(txin?: TxInput): Datum;
    // (undocumented)
    get scriptActivitiesName(): string;
    // (undocumented)
    get scriptDatumName(): string;
    // (undocumented)
    get specializedCapo(): HeliosModuleSrc;
    get specializedMintDelegate(): HeliosModuleSrc;
    // (undocumented)
    txnCreatingTokenPolicy(tcx: StellarTxnContext, tokenName: string): Promise<StellarTxnContext<anyState>>;
    txnGenericMintingUuts<TCX extends hasSeedUtxo & hasUutContext<purposes>, purposes extends string>(tcx: TCX, uutPurposes: purposes[], activity?: isActivity): Promise<TCX>;
    // (undocumented)
    txnGrantAuthority<TCX extends StellarTxnContext>(tcx: TCX, redeemer: isActivity, returnExistingDelegate?: boolean): Promise<TCX>;
    txnReceiveAuthorityToken<TCX extends StellarTxnContext>(tcx: TCX, tokenValue: Value, fromFoundUtxo?: TxInput): Promise<TCX>;
}

// @public
export function byteArrayAsString(ba: ByteArray | ByteArrayData): string;

// @public
export function byteArrayListAsString(items: ByteArray[] | ByteArrayData[], joiner?: string): string;

// Warning: (ae-forgotten-export) The symbol "MinterBaseMethods" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "anyDatumArgs" needs to be exported by the entry point index.d.ts
//
// @public
export abstract class Capo<settingsType, minterType extends MinterBaseMethods & CapoMinter = CapoMinter, charterDatumType extends anyDatumArgs = anyDatumArgs, configType extends CapoBaseConfig = CapoBaseConfig> extends StellarContract<configType> {
    // (undocumented)
    protected abstract activityUpdatingCharter(args: charterDatumType): isActivity;
    // (undocumented)
    activityUsingAuthority(): isActivity;
    // (undocumented)
    static bootstrapWith(args: StellarFactoryArgs<CapoBaseConfig>): any;
    // (undocumented)
    capoRequirements(): ReqtsMap_3<"is a base class for leader/Capo pattern" | "can create unique utility tokens" | "supports the Delegation pattern using roles and strategy-variants" | "supports well-typed role declarations and strategy-adding" | "supports just-in-time strategy-selection using txnCreateDelegateLink()" | "given a configured delegate-link, it can create a ready-to-use Stellar subclass with all the right settings" | "supports concrete resolution of existing role delegates" | "Each role uses a RoleVariants structure which can accept new variants" | "provides a Strategy type for binding a contract to a strategy-variant name" | "can locate UUTs in the user's wallet", never>;
    // (undocumented)
    get charterTokenAsValue(): Value;
    // (undocumented)
    get charterTokenPredicate(): ((something: any) => any) & {
        value: Value;
    };
    // (undocumented)
    connectDelegateWithLink<DelegateType extends StellarDelegate<any>, configType extends (DelegateType extends StellarContract<infer c> ? c : paramsBase) = DelegateType extends StellarContract<infer c> ? c : paramsBase>(roleName: string, delegateLink: RelativeDelegateLink<DelegateType>): Promise<DelegateType>;
    // (undocumented)
    connectMintingScript(params: SeedTxnParams): Promise<minterType>;
    // (undocumented)
    abstract contractSource(): HeliosModuleSrc;
    // (undocumented)
    static currentRev: bigint;
    // (undocumented)
    static get defaultParams(): {
        rev: bigint;
        devGen: bigint;
    };
    // (undocumented)
    abstract get delegateRoles(): RoleMap<any>;
    // (undocumented)
    devGen: bigint;
    findActorGovAuthority(): Promise<TxInput | undefined>;
    // (undocumented)
    findActorUut(uutPrefix: string, mph?: MintingPolicyHash): Promise<FoundUut | undefined>;
    // @deprecated
    findCharterAuthority(): void;
    findGovAuthority(): Promise<TxInput | undefined>;
    // (undocumented)
    abstract findGovDelegate(): Promise<AuthorityPolicy>;
    // Warning: (ae-forgotten-export) The symbol "devConfigProps" needs to be exported by the entry point index.d.ts
    getContractScriptParams(config: configType): paramsBase & devConfigProps & Partial<configType>;
    getMinterParams(): {
        seedTxn: TxId;
        seedIndex: bigint;
    };
    // (undocumented)
    importModules(): HeliosModuleSrc[];
    // (undocumented)
    init(args: StellarFactoryArgs<configType>): Promise<this>;
    // (undocumented)
    abstract initSettingsAdapter(): DatumAdapter<any, settingsType, this>;
    // (undocumented)
    get isConfigured(): Promise<boolean>;
    // (undocumented)
    minter: minterType;
    // Warning: (ae-forgotten-export) The symbol "BasicMinterParams" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    get minterClass(): stellarSubclass<CapoMinter, BasicMinterParams>;
    // (undocumented)
    get mintingPolicyHash(): MintingPolicyHash;
    // (undocumented)
    abstract mkDatumCharterToken(args: charterDatumType): InlineDatum | Promise<InlineDatum>;
    // (undocumented)
    abstract mkDatumSettingsData(settings: settingsType): Datum;
    // (undocumented)
    mkDelegatePredicate(dgtLink: RelativeDelegateLink<any>): ((something: any) => any) & {
        value: Value;
    };
    // Warning: (ae-forgotten-export) The symbol "DelegationDetail" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mkImpliedDelegationDetails(uut: UutName): DelegationDetail;
    // (undocumented)
    abstract mkInitialSettings(): settingsType;
    // (undocumented)
    get mph(): MintingPolicyHash;
    // (undocumented)
    mustFindCharterUtxo(): Promise<TxInput>;
    // Warning: (ae-forgotten-export) The symbol "PreconfiguredDelegate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mustGetDelegate<T extends StellarDelegate<any>>(configuredDelegate: PreconfiguredDelegate<T>): Promise<T>;
    // (undocumented)
    static parseConfig(rawJsonConfig: any): void;
    // (undocumented)
    readSettingsDatum(parsedDatum: OnchainSettingsType<this>): Promise<settingsType>;
    // (undocumented)
    relativeLink<DT extends StellarDelegate<any>>(configured: ConfiguredDelegate<DT>): RelativeDelegateLink<DT>;
    // (undocumented)
    settingsAdapter: DatumAdapter<any, settingsType, this> & SettingsAdapterFor<this>;
    // (undocumented)
    tokenAsValue(tokenName: string | number[] | UutName, count?: bigint): Value;
    // (undocumented)
    tvCharter(): Value;
    // (undocumented)
    tvForDelegate(dgtLink: RelativeDelegateLink<any>): Value;
    // @deprecated
    txnAddCharterAuthorityTokenRef<TCX extends StellarTxnContext>(): Promise<void>;
    // (undocumented)
    abstract txnAddGovAuthority<TCX extends StellarTxnContext>(tcx: TCX): Promise<TCX>;
    txnAddGovAuthorityTokenRef<TCX extends StellarTxnContext>(tcx: TCX): Promise<TCX>;
    // (undocumented)
    abstract txnAttachScriptOrRefScript<TCX extends StellarTxnContext>(tcx: TCX, program?: UplcProgram): Promise<TCX>;
    txnCreateConfiguredDelegate<DT extends StellarDelegate<any>, const RN extends string>(tcx: hasUutContext<RN>, roleName: RN & keyof this["delegateRoles"], delegateInfo?: MinimalDelegateLink<DT>): Promise<ConfiguredDelegate<DT>>;
    txnCreateDelegateLink<DT extends StellarDelegate, const RN extends string>(tcx: hasUutContext<RN>, roleName: RN, delegateInfo?: MinimalDelegateLink<DT>): Promise<ConfiguredDelegate<DT> & RelativeDelegateLink<DT>>;
    // (undocumented)
    txnKeepCharterToken<TCX extends StellarTxnContext>(tcx: TCX, datum: InlineDatum): TCX;
    txnMustGetSeedUtxo(tcx: StellarTxnContext, purpose: string, tokenNames: string[]): Promise<TxInput | never>;
    // (undocumented)
    txnMustUseCharterUtxo<TCX extends StellarTxnContext>(tcx: TCX, redeemer: isActivity, newDatum?: InlineDatum): Promise<TCX>;
    // (undocumented)
    txnMustUseCharterUtxo<TCX extends StellarTxnContext>(tcx: TCX, useReferenceInput: "refInput" | true): Promise<TCX>;
    // (undocumented)
    txnUpdateCharterUtxo(tcx: StellarTxnContext, redeemer: isActivity, newDatum: InlineDatum): Promise<StellarTxnContext | never>;
    uutsValue(uutMap: uutPurposeMap<any>): Value;
    uutsValue(tcx: hasUutContext<any>): Value;
    uutsValue(uutName: UutName | number[]): Value;
    // (undocumented)
    verifyConfigs(): Promise<any>;
    // (undocumented)
    abstract verifyCoreDelegates(): Promise<any>;
}

// Warning: (ae-forgotten-export) The symbol "rootCapoConfig" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type CapoBaseConfig = paramsBase & rootCapoConfig & SeedTxnParams & {
    mph: MintingPolicyHash;
    rev: bigint;
    bootstrapping?: true;
};

// @public
export type capoDelegateConfig = paramsBase & devConfigProps & {
    capoAddr: Address;
    capo: Capo<any, any, any>;
    mph: MintingPolicyHash;
    tn: number[];
    rev: bigint;
    addrHint: Address[];
};

// @public
export class CapoMinter extends StellarContract<BasicMinterParams> implements MinterBaseMethods {
    activityAddingMintInvariant({ seedTxn, seedIndex: sIdx, }: Omit<MintUutActivityArgs, "purposes">): isActivity;
    activityAddingSpendInvariant({ seedTxn, seedIndex: sIdx, }: Omit<MintUutActivityArgs, "purposes">): isActivity;
    // @deprecated (undocumented)
    activityBurningUuts(...uutNames: string[]): isActivity;
    activityCreatingNewSpendDelegate({ seedTxn, seedIndex: seedIndex, replacingUut, }: Omit<MintUutActivityArgs, "purposes"> & {
        replacingUut?: number[];
    }): {
        redeemer: any;
    };
    activityForcingNewMintDelegate({ seedTxn, seedIndex, }: Omit<MintUutActivityArgs, "purposes">): {
        redeemer: any;
    };
    // Warning: (ae-forgotten-export) The symbol "MintCharterActivityArgs" needs to be exported by the entry point index.d.ts
    activityMintingCharter(ownerInfo: MintCharterActivityArgs): isActivity;
    // @deprecated (undocumented)
    activityMintingUuts({ seedTxn, seedIndex: sIdx, purposes, }: MintUutActivityArgs): isActivity;
    activityMintWithDelegateAuthorizing(): isActivity;
    // (undocumented)
    attachRefScript(tcx: any): Promise<any>;
    // (undocumented)
    get charterTokenAsValue(): Value;
    // (undocumented)
    get charterTokenAsValuesEntry(): valuesEntry;
    // (undocumented)
    contractSource(): any;
    // (undocumented)
    currentRev: bigint;
    // (undocumented)
    getContractScriptParams(config: BasicMinterParams): paramsBase & SeedTxnParams;
    // (undocumented)
    importModules(): HeliosModuleSrc[];
    // (undocumented)
    get mintingPolicyHash(): MintingPolicyHash;
    // (undocumented)
    get scriptActivitiesName(): string;
    // (undocumented)
    tvCharter(): Value;
    // (undocumented)
    txnBurnUuts<existingTcx extends StellarTxnContext<any>>(initialTcx: existingTcx, uutNames: UutName[]): Promise<existingTcx & Promise<any>>;
    // (undocumented)
    txnMintingCharter<TCX extends StellarTxnContext<anyState>>(tcx: TCX, { owner, capoGov, mintDelegate, spendDelegate, settingsUut, }: {
        owner: Address;
        capoGov: UutName;
        mintDelegate: UutName;
        spendDelegate: UutName;
        settingsUut: UutName;
    }): Promise<TCX>;
    // (undocumented)
    txnMIntingWithoutDelegate<TCX extends StellarTxnContext>(tcx: TCX, vEntries: valuesEntry[], minterActivity: isActivity): Promise<TCX>;
    // (undocumented)
    txnMintWithDelegateAuthorizing<TCX extends StellarTxnContext>(tcx: TCX, vEntries: valuesEntry[], mintDelegate: BasicMintDelegate, mintDgtRedeemer: isActivity, returnExistingDelegate?: boolean): Promise<TCX>;
}

// @public
export abstract class CapoTestHelper<SC extends Capo<any, MinterBaseMethods & CapoMinter, CDT, CT>, CDT extends anyDatumArgs = SC extends Capo<any, infer iCDT> ? iCDT : anyDatumArgs, //prettier-ignore
CT extends CapoBaseConfig = SC extends Capo<any, any, any, infer iCT> ? iCT : never> extends StellarTestHelper<SC> {
    // Warning: (ae-forgotten-export) The symbol "MinimalDefaultCharterDatumArgs" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    bootstrap(args?: MinimalDefaultCharterDatumArgs): Promise<SC>;
    // (undocumented)
    initialize({ randomSeed, config, }?: {
        config?: CT;
        randomSeed?: number;
    }): Promise<SC>;
    // (undocumented)
    abstract mintCharterToken(args?: MinimalDefaultCharterDatumArgs<any>): Promise<hasUutContext<"govAuthority" | "capoGov" | "mintDelegate" | "mintDgt"> & hasBootstrappedConfig<CapoBaseConfig>>;
    // (undocumented)
    abstract mkDefaultCharterArgs(): Partial<MinimalDefaultCharterDatumArgs<any>>;
    mkTcx(): StellarTxnContext<anyState_3>;
    // (undocumented)
    get ready(): boolean;
}

// @public
export type ConfigFor<SC extends StellarContract<C>, C extends paramsBase = SC extends StellarContract<infer inferredConfig> ? inferredConfig : never> = C;

// @public
export type ConfiguredDelegate<DT extends StellarDelegate<any>> = {
    delegateClass: stellarSubclass<DT>;
    delegate: DT;
    roleName: string;
    config: ConfigFor<DT>;
} & RelativeDelegateLink<DT>;

export { Datum }

// @public
export function datum(proto: any, thingName: any, descriptor: any): any;

// @public
export abstract class DatumAdapter<appType, OnchainBridgeType, contractType extends StellarContract<any>> {
    constructor(strella: contractType);
    // (undocumented)
    get capo(): contractType & Record<"initSettingsAdapter", unknown>;
    // (undocumented)
    abstract datumName: string;
    abstract fromOnchainDatum(raw: OnchainBridgeType): appType | Promise<appType>;
    // (undocumented)
    get onChainDatumType(): any;
    // (undocumented)
    get onChainTypes(): {
        [x: string]: any;
    };
    // (undocumented)
    strella: contractType;
    // (undocumented)
    toMapData<T = any>(k: Record<string, T>, transformer?: (n: T) => helios.UplcData): helios.MapData;
    abstract toOnchainDatum(d: appType): Datum;
    // (undocumented)
    toRealNum(n: number): helios.IntData;
}

// @public
export function datumAsString(d: Datum | null | undefined): string;

// Warning: (ae-forgotten-export) The symbol "RealNumberSettingsMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "hasUutCreator" needs to be exported by the entry point index.d.ts
//
// @public
export class DefaultCapo<settingsType extends OffchainSettingsType<any> = RealNumberSettingsMap, MinterType extends CapoMinter = CapoMinter, CDT extends DefaultCharterDatumArgs = DefaultCharterDatumArgs, configType extends CapoBaseConfig = CapoBaseConfig> extends Capo<settingsType, MinterType, CDT, configType> implements hasUutCreator {
    // (undocumented)
    activityUpdatingCharter(): isActivity;
    // (undocumented)
    activityUpdatingSettings(): isActivity;
    addSeedUtxo<TCX extends StellarTxnContext>(tcx: TCX): Promise<TCX & hasSeedUtxo>;
    get capoHelpers(): HeliosModuleSrc;
    // (undocumented)
    contractSource(): any;
    // (undocumented)
    get customCapoSettings(): HeliosModuleSrc;
    // (undocumented)
    get delegateRoles(): RoleMap_2<    {
    readonly govAuthority: RoleInfo<StellarContract<any>, {
    readonly address: {
    readonly delegateClass: typeof AnyAddressAuthorityPolicy;
    readonly validateConfig: (args: any) => strategyValidation;
    };
    }, "capoGov", "address">;
    readonly mintDelegate: RoleInfo<StellarContract<any>, {
    readonly default: {
    readonly delegateClass: typeof BasicMintDelegate;
    readonly partialConfig: {};
    readonly validateConfig: (args: any) => strategyValidation;
    };
    }, "mintDgt", "default">;
    readonly spendDelegate: RoleInfo<StellarContract<any>, {
    readonly default: {
    readonly delegateClass: typeof BasicMintDelegate;
    readonly partialConfig: {};
    readonly validateConfig: (args: any) => strategyValidation;
    };
    }, "spendDgt", "default">;
    }>;
    // (undocumented)
    findCharterDatum(currentCharterUtxo?: TxInput): Promise<DefaultCharterDatumArgs>;
    // (undocumented)
    findGovDelegate(): Promise<AuthorityPolicy<capoDelegateConfig_2>>;
    // (undocumented)
    findScriptReferences(): Promise<[TxInput, any][]>;
    // (undocumented)
    findSettingsDatum({ settingsUtxo, charterUtxo, }?: {
        settingsUtxo?: TxInput;
        charterUtxo?: TxInput;
    }): Promise<settingsType>;
    // (undocumented)
    findSettingsUtxo(charterUtxo?: TxInput): Promise<TxInput>;
    // (undocumented)
    findUutSeedUtxo(uutPurposes: string[], tcx: StellarTxnContext<any>): Promise<TxInput>;
    // @deprecated
    getDelegateRoles(): void;
    // (undocumented)
    getGovDelegate(): Promise<AuthorityPolicy<capoDelegateConfig_2>>;
    // (undocumented)
    getMintDelegate(): Promise<BasicMintDelegate>;
    // (undocumented)
    getSpendDelegate(): Promise<StellarDelegate<any, string>>;
    // (undocumented)
    importModules(): HeliosModuleSrc[];
    // (undocumented)
    initSettingsAdapter(): any;
    // (undocumented)
    mkDatumCharterToken(args: CDT): Promise<Datum>;
    // (undocumented)
    mkDatumScriptReference(): Datum;
    // (undocumented)
    mkDatumSettingsData(settings: settingsType): Datum;
    // (undocumented)
    mkInitialSettings(): settingsType;
    // (undocumented)
    mkOnchainDelegateLink(dl: RelativeDelegateLink<any>): any;
    // (undocumented)
    mkSettingsUutName(settingsUut: UutName | number[]): number[];
    // (undocumented)
    mkTxnAddingMintInvariant<DT extends StellarDelegate, thisType extends DefaultCapo<settingsType, MinterType, CDT, configType>>(this: thisType, delegateInfo: MinimalDelegateLink<DT> & {
        strategyName: string & keyof thisType["delegateRoles"]["mintDelegate"];
    }, tcx?: StellarTxnContext): Promise<StellarTxnContext>;
    // (undocumented)
    mkTxnAddingNamedDelegate<DT extends StellarDelegate, thisType extends DefaultCapo<settingsType, MinterType, CDT, configType>>(this: thisType, delegateName: string, delegateInfo: MinimalDelegateLink<DT> & {
        strategyName: string & keyof thisType["delegateRoles"]["spendDelegate"];
    }, tcx?: StellarTxnContext): Promise<hasUutContext<"spendDelegate" | "spendDgt"> & StellarTxnContext<anyState> & hasSeedUtxo>;
    // (undocumented)
    mkTxnAddingSpendInvariant<DT extends StellarDelegate, thisType extends DefaultCapo<settingsType, MinterType, CDT, configType>>(this: thisType, delegateInfo: MinimalDelegateLink<DT> & {
        strategyName: string & keyof thisType["delegateRoles"]["spendDelegate"];
    }, tcx?: StellarTxnContext): Promise<hasUutContext<"spendDelegate" | "spendDgt"> & StellarTxnContext<anyState> & hasSeedUtxo>;
    // Warning: (ae-forgotten-export) The symbol "otherAddlTxnNames" needs to be exported by the entry point index.d.ts
    mkTxnMintCharterToken<TCX extends undefined | StellarTxnContext<anyState>, TCX2 = TCX extends StellarTxnContext<infer TCXT> ? StellarTxnContext<TCXT> : {}>(charterDatumArgs: MinimalDefaultCharterDatumArgs<CDT>, existingTcx?: TCX): Promise<hasAddlTxns<"refScriptMinter" | otherAddlTxnNames<hasAddlTxns<"refScriptCapo" | otherAddlTxnNames<hasAddlTxns<"refScriptMintDelegate" | otherAddlTxnNames<hasUutContext<string> & TCX2 & hasBootstrappedConfig<{
        rev: bigint;
    } & Record<string, any> & devConfigProps_2 & {
        rootCapoScriptHash?: ValidatorHash | undefined;
    } & SeedTxnParams_2 & {
        mph: MintingPolicyHash;
        rev: bigint;
        bootstrapping?: true | undefined;
    } & configType>>, hasUutContext<string> & TCX2 & hasBootstrappedConfig<{
        rev: bigint;
    } & Record<string, any> & devConfigProps_2 & {
        rootCapoScriptHash?: ValidatorHash | undefined;
    } & SeedTxnParams_2 & {
        mph: MintingPolicyHash;
        rev: bigint;
        bootstrapping?: true | undefined;
    } & configType>>>, hasAddlTxns<"refScriptMintDelegate" | otherAddlTxnNames<hasUutContext<string> & TCX2 & hasBootstrappedConfig<{
        rev: bigint;
    } & Record<string, any> & devConfigProps_2 & {
        rootCapoScriptHash?: ValidatorHash | undefined;
    } & SeedTxnParams_2 & {
        mph: MintingPolicyHash;
        rev: bigint;
        bootstrapping?: true | undefined;
    } & configType>>, hasUutContext<string> & TCX2 & hasBootstrappedConfig<{
        rev: bigint;
    } & Record<string, any> & devConfigProps_2 & {
        rootCapoScriptHash?: ValidatorHash | undefined;
    } & SeedTxnParams_2 & {
        mph: MintingPolicyHash;
        rev: bigint;
        bootstrapping?: true | undefined;
    } & configType>>>>, hasAddlTxns<"refScriptCapo" | otherAddlTxnNames<hasAddlTxns<"refScriptMintDelegate" | otherAddlTxnNames<hasUutContext<string> & TCX2 & hasBootstrappedConfig<{
        rev: bigint;
    } & Record<string, any> & devConfigProps_2 & {
        rootCapoScriptHash?: ValidatorHash | undefined;
    } & SeedTxnParams_2 & {
        mph: MintingPolicyHash;
        rev: bigint;
        bootstrapping?: true | undefined;
    } & configType>>, hasUutContext<string> & TCX2 & hasBootstrappedConfig<{
        rev: bigint;
    } & Record<string, any> & devConfigProps_2 & {
        rootCapoScriptHash?: ValidatorHash | undefined;
    } & SeedTxnParams_2 & {
        mph: MintingPolicyHash;
        rev: bigint;
        bootstrapping?: true | undefined;
    } & configType>>>, hasAddlTxns<"refScriptMintDelegate" | otherAddlTxnNames<hasUutContext<string> & TCX2 & hasBootstrappedConfig<{
        rev: bigint;
    } & Record<string, any> & devConfigProps_2 & {
        rootCapoScriptHash?: ValidatorHash | undefined;
    } & SeedTxnParams_2 & {
        mph: MintingPolicyHash;
        rev: bigint;
        bootstrapping?: true | undefined;
    } & configType>>, hasUutContext<string> & TCX2 & hasBootstrappedConfig<{
        rev: bigint;
    } & Record<string, any> & devConfigProps_2 & {
        rootCapoScriptHash?: ValidatorHash | undefined;
    } & SeedTxnParams_2 & {
        mph: MintingPolicyHash;
        rev: bigint;
        bootstrapping?: true | undefined;
    } & configType>>>>>;
    // (undocumented)
    mkTxnUpdateCharter(args: CDT, activity?: isActivity, tcx?: StellarTxnContext): Promise<StellarTxnContext>;
    // (undocumented)
    mkTxnUpdateOnchainSettings<TCX extends StellarTxnContext>(data: settingsType, settingsUtxo?: TxInput, tcx?: StellarTxnContext): Promise<TCX>;
    mkTxnUpdatingMintDelegate<DT extends StellarDelegate, thisType extends DefaultCapo<settingsType, MinterType, CDT, configType>>(this: thisType, delegateInfo: MinimalDelegateLink<DT> & {
        strategyName: string & keyof thisType["delegateRoles"]["mintDelegate"]["variants"];
    }, options?: {
        forcedUpdate?: true;
    }, tcx?: StellarTxnContext): Promise<StellarTxnContext>;
    // (undocumented)
    mkTxnUpdatingSpendDelegate<DT extends StellarDelegate, thisType extends DefaultCapo<settingsType, MinterType, CDT, configType>>(this: thisType, delegateInfo: MinimalDelegateLink<DT> & {
        strategyName: string & keyof thisType["delegateRoles"]["spendDelegate"]["variants"];
    }, options?: {
        forcedUpdate?: true;
    }, tcx?: StellarTxnContext): Promise<StellarTxnContext>;
    // (undocumented)
    mkValuesBurningDelegateUut(current: RelativeDelegateLink<any>): valuesEntry[];
    // (undocumented)
    static parseConfig(rawJsonConfig: any): any;
    // (undocumented)
    requirements(): ReqtsMap_3<"positively governs all administrative actions" | "has a unique, permanent charter token" | "has a unique, permanent treasury address" | "the charter token is always kept in the contract" | "the charter details can be updated by authority of the capoGov-* token" | "can mint other tokens, on the authority of the charter's registered mintDgt- token" | "can handle large transactions with reference scripts" | "has a singleton minting policy" | "can update the minting delegate in the charter data" | "can update the spending delegate in the charter data" | "can add invariant minting delegates to the charter data" | "can add invariant spending delegates to the charter data" | "supports an abstract Settings structure stored in the contact" | "mkTxnUpdateSettings(): can update the settings" | "added and updated delegates always validate the present configuration data" | "can commit new delegates" | "supports storing new types of datum not pre-defined in the Capo's on-chain script" | "the charter has a namedDelegates structure for semantic delegate links" | "CreatingDelegatedDatum: creates a UTxO with any custom datum" | "UpdatingDelegatedDatum: checks that a custom data element can be updated", never>;
    get specializedCapo(): HeliosModuleSrc;
    // (undocumented)
    txnAddGovAuthority<TCX extends StellarTxnContext>(tcx: TCX): Promise<TCX>;
    // (undocumented)
    txnAddSettingsOutput<TCX extends StellarTxnContext>(tcx: TCX, settings: settingsType): TCX;
    txnAttachScriptOrRefScript<TCX extends StellarTxnContext>(tcx: TCX, program?: UplcProgram): Promise<TCX>;
    // Warning: (ae-forgotten-export) The symbol "UutCreationAttrs" needs to be exported by the entry point index.d.ts
    txnMintingUuts<const purposes extends string, existingTcx extends StellarTxnContext & hasSeedUtxo, const RM extends Record<ROLES, purposes>, const ROLES extends keyof RM & string = string & keyof RM>(initialTcx: existingTcx, uutPurposes: purposes[], options?: UutCreationAttrs, roles?: RM): Promise<hasUutContext<ROLES | purposes> & existingTcx>;
    txnMkAddlRefScriptTxn<TCX extends StellarTxnContext<anyState>, scriptName extends string>(tcx: TCX, scriptName: scriptName, script: UplcProgram): Promise<hasAddlTxns<`refScript${Capitalize<scriptName>}` | otherAddlTxnNames<TCX>, TCX>>;
    // Warning: (ae-forgotten-export) The symbol "UutCreationAttrsWithSeed" needs to be exported by the entry point index.d.ts
    txnWillMintUuts<const purposes extends string, existingTcx extends StellarTxnContext, const RM extends Record<ROLES, purposes>, const ROLES extends string & keyof RM = string & keyof RM>(tcx: existingTcx, uutPurposes: purposes[], { usingSeedUtxo }: Pick<UutCreationAttrsWithSeed, "usingSeedUtxo">, roles?: RM): Promise<hasUutContext<ROLES | purposes> & existingTcx>;
    verifyCoreDelegates(): Promise<[AuthorityPolicy<capoDelegateConfig_2>, BasicMintDelegate, StellarDelegate<any, string>]>;
}

// @public
export class DefaultCapoTestHelper<DC extends DefaultCapo<any, CapoMinter, CDT, CT> = DefaultCapo, //prettier-ignore
CDT extends DefaultCharterDatumArgs = DC extends Capo<any, any, infer iCDT> ? iCDT : DefaultCharterDatumArgs, //prettier-ignore
CT extends CapoBaseConfig = DC extends Capo<any, any, any, infer iCT> ? iCT : never> extends CapoTestHelper<DC, CDT, CT> {
    static forCapoClass<DC extends DefaultCapo<any, CapoMinter, any, any>>(s: stellarSubclass<DC>): DefaultCapoTestHelperClass<DC>;
    // (undocumented)
    mintCharterToken(args?: MinimalDefaultCharterDatumArgs<CDT>): Promise<StellarTxnContext<any>>;
    // (undocumented)
    mkCharterSpendTx(): Promise<StellarTxnContext>;
    // (undocumented)
    mkDefaultCharterArgs(): MinimalDefaultCharterDatumArgs<CDT>;
    // (undocumented)
    setupActors(): Promise<void>;
    // (undocumented)
    get stellarClass(): stellarSubclass<DC>;
    // (undocumented)
    updateCharter(args: CDT): Promise<StellarTxnContext>;
    // (undocumented)
    updateSettings(args: OffchainSettingsType<DC>): Promise<StellarTxnContext<anyState_3>>;
}

// Warning: (ae-forgotten-export) The symbol "canHaveRandomSeed" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type DefaultCapoTestHelperClass<SC extends DefaultCapo<any, any, any, any>> = new (config: ConfigFor<SC> & canHaveRandomSeed) => StellarTestHelper<SC> & DefaultCapoTestHelper<SC>;

// @public
export interface DefaultCharterDatumArgs {
    // (undocumented)
    govAuthorityLink: RelativeDelegateLink<AuthorityPolicy>;
    // (undocumented)
    mintDelegateLink: RelativeDelegateLink<BasicMintDelegate>;
    // (undocumented)
    mintInvariants: RelativeDelegateLink<StellarDelegate<any>>[];
    // (undocumented)
    namedDelegates: Record<string, RelativeDelegateLink<StellarDelegate<any>>>;
    // (undocumented)
    settingsUut: UutName | number[];
    // (undocumented)
    spendDelegateLink: RelativeDelegateLink<StellarDelegate<any>>;
    // (undocumented)
    spendInvariants: RelativeDelegateLink<StellarDelegate<any>>[];
}

// Warning: (ae-forgotten-export) The symbol "RoleInfo_2" needs to be exported by the entry point index.d.ts
//
// @public
export function defineRole<const UUTP extends string, SC extends StellarContract<any>, const VMv extends RoleInfo_2<SC, any, UUTP>["variants"]>(uutBaseName: UUTP, baseClass: stellarSubclass<SC> & any, variants: VMv): RoleInfo_2<SC, VMv, UUTP>;

// @public
export function delegateRoles<const RM extends RoleMap<any>>(roleMap: RM): RoleMap<RM>;

// @public
export function dumpAny(x: Tx | StellarTxnContext | Address | Value | TxOutput | TxInput | TxInput[] | TxId | ByteArray | ByteArray[] | ByteArrayData | ByteArrayData[], networkParams?: NetworkParams): string;

// @public
export type ErrorMap = Record<string, string[]>;

// @public
export function errorMapAsString(em: ErrorMap, prefix?: string): string;

// @public (undocumented)
export type FoundUut = {
    utxo: TxInput;
    uut: UutName;
};

// @public
export type hasAddlTxns<txnName extends string, TCX extends StellarTxnContext<any>, existingStateType extends anyState = TCX["state"], unwrapped = TCX extends hasAddlTxns<any, infer uw, any, any> ? uw : TCX> = StellarTxnContext<existingStateType & {
    addlTxns: Record<txnName, AddlTxInfo<any>>;
}> & unwrapped;

// @public
export type hasAllUuts<uutEntries extends string> = {
    uuts: uutPurposeMap<uutEntries>;
};

// @public
export type hasBootstrappedConfig<CT extends CapoBaseConfig> = StellarTxnContext<{
    bsc: CT;
    uuts: uutMap;
    bootstrappedConfig: any;
}>;

// @public
export function hasReqts<R extends ReqtsMap<validReqts, inheritedNames>, const validReqts extends string = string & keyof R, const inheritedNames extends string | never = never>(reqtsMap: R): ReqtsMap<validReqts, inheritedNames>;

// @public (undocumented)
export namespace hasReqts {
    var // (undocumented)
    TODO: unique symbol;
}

// @public
export type hasSeedUtxo = StellarTxnContext<anyState & {
    seedUtxo: TxInput;
}>;

// @public
export type hasUutContext<uutEntries extends string> = StellarTxnContext<hasAllUuts<uutEntries>>;

export { helios }

// @public
export type HeliosModuleSrc = string & {
    srcFile: string;
    purpose: string;
    moduleName: string;
};

// @public
export function heliosRollupLoader(opts?: {
    include: string;
    exclude: never[];
}): {
    name: string;
    transform(content: any, id: any): {
        code: string;
        map: {
            mappings: string;
        };
    } | undefined;
};

// @public
export function hexToPrintableString(hexStr: any): string;

// Warning: (ae-forgotten-export) The symbol "DatumInline" needs to be exported by the entry point index.d.ts
//
// @public
export type InlineDatum = ReturnType<typeof DatumInline>;

// @public (undocumented)
export const insufficientInputError: RegExp;

// @public
export type isActivity<T = never> = {
    redeemer: UplcDataValue | UplcData | T;
};

// @public
export function lovelaceToAda(l: bigint | number): string;

// @public
export function mergesInheritedReqts<IR extends ReqtsMap<inheritedReqts>, R extends ReqtsMap<myReqts, inheritedReqts>, const inheritedReqts extends string = string & keyof IR, const myReqts extends string = keyof R extends keyof IR ? never : string & keyof R>(inherits: IR, reqtsMap: R): ReqtsMap<myReqts | inheritedReqts, inheritedReqts> & IR;

// @public
export type MinimalDelegateLink<SC extends StellarDelegate<any>> = Required<Pick<RelativeDelegateLink<SC>, "strategyName">> & Partial<Omit<RelativeDelegateLink<SC>, "uutName">>;

// @public
export type MintUutActivityArgs = {
    seedTxn: TxId;
    seedIndex: bigint | number;
    purposes: string[];
};

// @public
export function mkHeliosModule(src: string, filename: string): HeliosModuleSrc;

// @public
export function mkUutValuesEntries(uuts: UutName[]): valuesEntry[];

// @public (undocumented)
export function mkUutValuesEntries(uuts: uutPurposeMap<any>): valuesEntry[];

// @public
export function mkValuesEntry(tokenName: string | number[], count: bigint): valuesEntry;

export { Network }

// @public (undocumented)
export type OffchainSettingsType<CAPO_TYPE extends Capo<any, any, any, any>> = ReturnType<CAPO_TYPE["initSettingsAdapter"]> extends DatumAdapter<infer appType, any, any> ? appType : never;

// @public (undocumented)
export type OnchainSettingsType<CAPO_TYPE extends Capo<any, any, any, any>> = anyDatumProps & SettingsAdapterFor<CAPO_TYPE> extends DatumAdapter<any, infer Onchain, any> ? Onchain : never;

// @public
export type paramsBase = {
    rev: bigint;
} & Record<string, any>;

// @public
export function partialTxn(proto: any, thingName: any, descriptor: any): any;

// @public (undocumented)
export function policyIdAsString(p: MintingPolicyHash): string;

// @public
export type RelativeDelegateLink<DT extends StellarDelegate<any>> = {
    uutName: string;
    strategyName: string;
    config: Partial<ConfigFor<DT>>;
    delegateValidatorHash?: ValidatorHash;
};

// Warning: (ae-forgotten-export) The symbol "TODO_TYPE" needs to be exported by the entry point index.d.ts
//
// @public
export type ReqtsMap<validReqts extends string, inheritedNames extends string | never = never> = {
    [reqtDescription in validReqts]: TODO_TYPE | RequirementEntry<reqtDescription, validReqts, inheritedNames>;
};

// @public
export type RequirementEntry<reqtName extends string, reqts extends string, inheritedNames extends string | never> = {
    purpose: string;
    details: string[];
    mech: string[];
    impl?: string;
    requires?: reqtName extends inheritedNames ? inheritedNames[] : Exclude<reqts, reqtName | inheritedNames>[];
    requiresInherited?: inheritedNames[];
};

// @public
export type RoleMap<KR extends Record<string, RoleInfo_2<any, any, any, any>>> = {
    [roleName in keyof KR]: KR[roleName];
};

// @public
export type SeedAttrs = {
    seedTxn: TxId;
    seedIndex: bigint;
};

// @public
export type SeedTxnParams = {
    seedTxn: TxId;
    seedIndex: bigint;
};

// @public (undocumented)
export type SettingsAdapterFor<CAPO_TYPE extends Capo<any, any, any, any>> = DatumAdapter<any, any, CAPO_TYPE> & ReturnType<CAPO_TYPE["initSettingsAdapter"]>;

export { StakeAddress }

export { StakingValidatorHash }

// @public
export class StellarContract<ConfigType extends paramsBase> {
    constructor(setup: SetupDetails, internal: typeof isInternalConstructor);
    // (undocumented)
    ADA(n: bigint | number): bigint;
    // (undocumented)
    get address(): Address;
    // (undocumented)
    addStrellaWithConfig<SC extends StellarContract<any>>(TargetClass: stellarSubclass<SC>, config: SC extends StellarContract<infer iCT> ? iCT : never): Promise<SC>;
    // Warning: (ae-forgotten-export) The symbol "ComputedScriptProperties" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    _cache: ComputedScriptProperties;
    // (undocumented)
    compiledScript: UplcProgram;
    // (undocumented)
    configIn?: ConfigType;
    // (undocumented)
    contractParams?: paramsBase;
    // (undocumented)
    contractSource(): string | never;
    static createWith<thisType extends StellarContract<configType>, configType extends paramsBase = thisType extends StellarContract<infer iCT> ? iCT : never>(this: stellarSubclass<any>, args: StellarFactoryArgs<configType>): Promise<StellarContract<configType> & InstanceType<typeof this>>;
    // (undocumented)
    get datumType(): any;
    // (undocumented)
    static get defaultParams(): {};
    // (undocumented)
    delegateAddrHint(): Address[] | undefined;
    // (undocumented)
    delegateReqdAddress(): false | Address;
    // (undocumented)
    findActorUtxo(name: string, predicate: (u: TxInput) => TxInput | undefined): Promise<TxInput | undefined>;
    // (undocumented)
    findAnySpareUtxos(tcx: StellarTxnContext): Promise<TxInput[] | never>;
    // (undocumented)
    findChangeAddr(): Promise<Address>;
    // (undocumented)
    findSmallestUnusedUtxo(lovelace: bigint, utxos: TxInput[], tcx?: StellarTxnContext): TxInput | undefined;
    // (undocumented)
    getContractScriptParams(config: ConfigType): paramsBase & Partial<ConfigType>;
    // (undocumented)
    hasMyUtxo(semanticName: string, predicate: utxoPredicate): Promise<TxInput | undefined>;
    // (undocumented)
    hasOnlyAda(value: Value, tcx: StellarTxnContext | undefined, u: TxInput): TxInput | undefined;
    hasUtxo(semanticName: string, predicate: utxoPredicate, { address, wallet, exceptInTcx }: UtxoSearchScope): Promise<TxInput | undefined>;
    // (undocumented)
    get identity(): string;
    // (undocumented)
    importModules(): HeliosModuleSrc[];
    // (undocumented)
    protected _infoBackToUtxo({ u }: utxoInfo): TxInput;
    // (undocumented)
    init(args: StellarFactoryArgs<ConfigType>): Promise<this>;
    // (undocumented)
    get isConnected(): boolean;
    // (undocumented)
    loadProgramScript(params?: Partial<ConfigType>): Program | undefined;
    // (undocumented)
    get mintingPolicyHash(): MintingPolicyHash | undefined;
    // (undocumented)
    mkAssetValue(tokenId: AssetClass, count?: bigint): Value;
    // (undocumented)
    mkMinAssetValue(tokenId: AssetClass, count?: bigint): Value;
    // (undocumented)
    mkMinTv(mph: MintingPolicyHash, tokenName: string | UutName | number[], count?: bigint): Value;
    // (undocumented)
    mkTokenPredicate(val: Value): tokenPredicate<any>;
    // (undocumented)
    mkTokenPredicate(mph: MintingPolicyHash, tokenName: string, quantity?: bigint): tokenPredicate<any>;
    // (undocumented)
    mkTokenPredicate(vOrMph: AssetClass, quantity?: bigint): tokenPredicate<any>;
    // @internal (undocumented)
    protected _mkUtxoSortInfo(min: bigint, max?: bigint): (u: TxInput) => utxoInfo;
    // Warning: (ae-forgotten-export) The symbol "tokenPredicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mkValuePredicate(lovelace: bigint, tcx?: StellarTxnContext): tokenPredicate<TxInput>;
    // (undocumented)
    mustFindActorUtxo(name: string, predicate: (u: TxInput) => TxInput | undefined, exceptInTcx: StellarTxnContext<any>, extraErrorHint?: string): Promise<TxInput>;
    // (undocumented)
    mustFindActorUtxo(name: string, predicate: (u: TxInput) => TxInput | undefined, extraErrorHint?: string): Promise<TxInput>;
    mustFindMyUtxo(semanticName: string, predicate: utxoPredicate, exceptInTcx: StellarTxnContext, extraErrorHint?: string): Promise<TxInput>;
    // (undocumented)
    mustFindMyUtxo(semanticName: string, predicate: utxoPredicate, extraErrorHint?: string): Promise<TxInput>;
    // Warning: (ae-forgotten-export) The symbol "UtxoSearchScope" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mustFindUtxo(semanticName: string, predicate: utxoPredicate, searchScope: UtxoSearchScope, extraErrorHint?: string): Promise<TxInput>;
    mustGetActivity(activityName: string): any;
    // (undocumented)
    mustGetEnumVariant(enumType: typeof HeliosData, variantName: string): any;
    // (undocumented)
    myActor?: Wallet;
    // (undocumented)
    network: Network;
    // (undocumented)
    networkParams: NetworkParams;
    get onChainActivitiesType(): any;
    get onChainDatumType(): any;
    get onChainTypes(): {
        [x: string]: any;
    };
    // (undocumented)
    outputsSentToDatum(datum: InlineDatum): Promise<TxInput[]>;
    // (undocumented)
    static parseConfig(rawJsonConfig: any): void;
    // (undocumented)
    partialConfig?: Partial<ConfigType>;
    // (undocumented)
    get purpose(): scriptPurpose | "non-script";
    // Warning: (ae-forgotten-export) The symbol "scriptPurpose" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    _purpose?: scriptPurpose;
    // (undocumented)
    readDatum<DPROPS extends anyDatumProps, adapterType extends DatumAdapter<any, DPROPS, any> | undefined = undefined>(datumNameOrAdapter: string | adapterType, datum: Datum | InlineDatum): Promise<(adapterType extends DatumAdapter<any, any, any> ? adapterType : DPROPS) | undefined>;
    // (undocumented)
    readOtherUplcType(fn: string, uplcDataField: any, fieldType: any): Promise<any>;
    get scriptActivitiesName(): string;
    get scriptDatumName(): string;
    // (undocumented)
    scriptProgram?: Program;
    // Warning: (ae-forgotten-export) The symbol "SetupDetails" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    setup: SetupDetails;
    // (undocumented)
    submit(tcx: StellarTxnContext, { signers, }?: {
        signers?: Address[];
    }): Promise<helios.TxId>;
    // Warning: (ae-forgotten-export) The symbol "AddlTxnCallback" needs to be exported by the entry point index.d.ts
    submitAddlTxns(tcx: hasAddlTxns<any, any>, callback?: AddlTxnCallback): Promise<void>;
    // (undocumented)
    tokenAsValue(tokenName: string | number[], quantity: bigint, mph?: MintingPolicyHash): Value;
    // (undocumented)
    totalValue(utxos: TxInput[]): Value;
    // (undocumented)
    toUtxoId(u: TxInput): string;
    txnKeepValue(tcx: StellarTxnContext, value: Value, datum: InlineDatum): StellarTxnContext<anyState_2>;
    // @internal (undocumented)
    protected _utxoCountAdaOnly(c: number, { minAdaAmount }: utxoInfo): number;
    // @internal (undocumented)
    protected _utxoIsPureADA({ u }: utxoInfo): TxInput | undefined;
    // @internal (undocumented)
    protected _utxoIsSufficient({ sufficient }: utxoInfo): boolean;
    // (undocumented)
    utxoSearchError(semanticName: string, searchScope: UtxoSearchScope, extraErrorHint?: string): string;
    // Warning: (ae-forgotten-export) The symbol "utxoInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    protected _utxoSortSmallerAndPureADA({ free: free1, minAdaAmount: r1 }: utxoInfo, { free: free2, minAdaAmount: r2 }: utxoInfo): 0 | 1 | -1;
    // (undocumented)
    get validatorHash(): helios.ValidatorHash;
    get wallet(): helios.Wallet;
    // Warning: (ae-forgotten-export) The symbol "NetworkName" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    walletNetworkCheck?: Promise<NetworkName> | NetworkName;
}

// @public
export abstract class StellarDelegate<CT extends paramsBase & capoDelegateConfig = capoDelegateConfig, DCCT extends Record<string, any> | string = string> extends StellarContract<CT> {
    activityAuthorizing(): {
        redeemer: any;
    };
    // (undocumented)
    activityModifying(): {
        redeemer: any;
    };
    activityReplacingMe({ // todo: add type for seedTxnDetails
        seedTxn, seedIndex, purpose }: Omit<MintUutActivityArgs, "purposes"> & {
        purpose?: string;
    }): {
        redeemer: any;
    };
    activityRetiring(): {
        redeemer: any;
    };
    // (undocumented)
    activityValidatingSettings(): {
        redeemer: any;
    };
    // (undocumented)
    get authorityTokenName(): number[];
    // (undocumented)
    static currentRev: bigint;
    // (undocumented)
    static get defaultParams(): {
        rev: bigint;
    };
    protected DelegateAddsAuthorityToken<TCX extends StellarTxnContext>(tcx: TCX, uutxo: TxInput, redeemer: isActivity): Promise<TCX>;
    DelegateMustFindAuthorityToken(tcx: StellarTxnContext, label: string): Promise<TxInput>;
    delegateRequirements(): ReqtsMap_2<"provides an interface for providing arms-length proof of authority to any other contract" | "implementations SHOULD positively govern spend of the UUT" | "implementations MUST provide an essential interface for transaction-building" | "requires a txnReceiveAuthorityToken(tcx, delegateAddr, fromFoundUtxo?)" | "requires a mustFindAuthorityToken(tcx)" | "requires a txnGrantAuthority(tcx, delegateAddr, fromFoundUtxo)" | "requires txnRetireCred(tcx, fromFoundUtxo)", never>;
    protected DelegateRetiresAuthorityToken(tcx: StellarTxnContext, fromFoundUtxo: TxInput): Promise<StellarTxnContext>;
    get delegateValidatorHash(): ValidatorHash | undefined;
    findActorAuthorityToken(): Promise<TxInput | undefined>;
    findAuthorityToken(): Promise<TxInput | undefined>;
    // (undocumented)
    mkAuthorityTokenPredicate(): ((something: any) => any) & {
        value: Value;
    };
    mkDatumIsDelegation(dd: DelegationDetail, ...args: DCCT extends string ? [string] | [] : [DCCT]): InlineDatum;
    // (undocumented)
    mustGetDelegateActivity(delegateActivityName: string): {
        DelegateActivity: any;
        activity: any;
    };
    // (undocumented)
    tvAuthorityToken(useMinTv?: boolean): Value;
    txnGrantAuthority<TCX extends StellarTxnContext>(tcx: TCX, redeemer?: isActivity, returnExistingDelegate?: boolean): Promise<TCX>;
    abstract txnReceiveAuthorityToken<TCX extends StellarTxnContext>(tcx: TCX, tokenValue: Value, fromFoundUtxo?: TxInput): Promise<TCX>;
    txnRetireAuthorityToken<TCX extends StellarTxnContext>(tcx: TCX): Promise<StellarTxnContext<anyState_3>>;
}

// @public
export type StellarFactoryArgs<CT extends paramsBase> = {
    setup: SetupDetails;
    config?: CT;
    partialConfig?: Partial<CT>;
};

// @public
export type stellarSubclass<S extends StellarContract<CT>, CT extends paramsBase = S extends StellarContract<infer iCT> ? iCT : paramsBase> = (new (setup: SetupDetails, internal: typeof isInternalConstructor) => S) & {
    defaultParams: Partial<CT>;
    createWith(args: StellarFactoryArgs<CT>): Promise<S>;
    parseConfig(rawJsonConfig: any): any;
};

// @public
export interface StellarTestContext<HTH extends StellarTestHelper<SC>, SC extends StellarContract<any> = HTH extends StellarTestHelper<infer iSC> ? iSC : never> extends canHaveRandomSeed, TestContext {
    // (undocumented)
    h: HTH;
    // Warning: (ae-forgotten-export) The symbol "canSkipSetup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    initHelper(config: Partial<ConfigFor<SC>> & canHaveRandomSeed & canSkipSetup): Promise<StellarTestHelper<SC>>;
    // (undocumented)
    get strella(): SC;
}

// @public
export abstract class StellarTestHelper<SC extends StellarContract<any>> {
    constructor(config?: ConfigFor<SC> & canHaveRandomSeed & canSkipSetup);
    // (undocumented)
    get actorName(): string;
    // Warning: (ae-forgotten-export) The symbol "actorMap" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    actors: actorMap;
    addActor(roleName: string, walletBalance: bigint, ...moreUtxos: bigint[]): Wallet;
    // (undocumented)
    address?: Address;
    // (undocumented)
    config?: ConfigFor<SC>;
    get currentActor(): SimpleWallet;
    set currentActor(actorName: string);
    // (undocumented)
    currentSlot(): bigint | null;
    // (undocumented)
    defaultActor?: string;
    // (undocumented)
    delay(ms: any): Promise<unknown>;
    // (undocumented)
    initialize(config: ConfigFor<SC> & canHaveRandomSeed): Promise<SC>;
    // (undocumented)
    initStellarClass(config?: (SC extends StellarContract<infer inferredConfig extends {
        rev: bigint;
    } & Record<string, any>> ? inferredConfig : never) | undefined): Promise<SC>;
    // (undocumented)
    initStrella(TargetClass: stellarSubclass<SC, ConfigFor<SC>>, config?: ConfigFor<SC>): Promise<SC>;
    // (undocumented)
    liveSlotParams: NetworkParams;
    // Warning: (ae-forgotten-export) The symbol "enhancedNetworkParams" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mkNetwork(): [NetworkEmulator, enhancedNetworkParams];
    // (undocumented)
    mkRandomBytes(length: number): number[];
    // (undocumented)
    mkSeedUtxo(seedIndex?: bigint): Promise<helios.TxId>;
    // (undocumented)
    network: NetworkEmulator;
    // (undocumented)
    networkParams: NetworkParams;
    // (undocumented)
    optimize: boolean;
    // (undocumented)
    rand?: () => number;
    // (undocumented)
    randomSeed?: number;
    // (undocumented)
    setActor(actorName: string): Promise<void>;
    // (undocumented)
    setupActors(): Promise<void>;
    // (undocumented)
    setupPending?: Promise<any>;
    // (undocumented)
    slotToTimestamp(s: bigint): bigint | Date;
    // (undocumented)
    state: Record<string, any>;
    // (undocumented)
    abstract get stellarClass(): stellarSubclass<SC, any>;
    // (undocumented)
    strella: SC;
    // (undocumented)
    submitTx(tx: Tx, force?: "force"): Promise<TxId>;
    // (undocumented)
    waitUntil(time: Date): bigint;
}

// @public
export class StellarTxnContext<S extends anyState = anyState> {
    constructor(actor?: Wallet, state?: Partial<S>);
    // (undocumented)
    actor?: Wallet;
    // (undocumented)
    addCollateral(collateral: TxInput): this;
    // Warning: (ae-forgotten-export) The symbol "addInputArgs" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "RedeemerArg" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    addInput<TCX extends StellarTxnContext<S>>(this: TCX, input: addInputArgs[0], r?: RedeemerArg): TCX;
    // (undocumented)
    addInputs<TCX extends StellarTxnContext<S>>(this: TCX, inputs: Parameters<Tx["addInputs"]>[0], r: RedeemerArg): TCX;
    // (undocumented)
    addOutput<TCX extends StellarTxnContext<S>>(this: TCX, ...args: Parameters<Tx["addOutput"]>): TCX;
    // (undocumented)
    addOutputs<TCX extends StellarTxnContext<S>>(this: TCX, ...args: Parameters<Tx["addOutputs"]>): TCX;
    // Warning: (ae-forgotten-export) The symbol "addRefInputArgs" needs to be exported by the entry point index.d.ts
    addRefInput<TCX extends StellarTxnContext<S>>(this: TCX, ...inputArgs: addRefInputArgs): TCX;
    // Warning: (ae-forgotten-export) The symbol "addRefInputsArgs" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    addRefInputs<TCX extends StellarTxnContext<S>>(this: TCX, ...args: addRefInputsArgs): TCX;
    // @deprecated
    addScript(): void;
    // (undocumented)
    addScriptProgram(...args: Parameters<Tx["attachScript"]>): this;
    // (undocumented)
    addSignature(wallet: Wallet): Promise<void>;
    // (undocumented)
    addState<TCX extends StellarTxnContext, K extends string, V>(this: TCX, key: K, value: V): StellarTxnContext<{
        [keyName in K]: V;
    } & anyState> & TCX;
    // (undocumented)
    addUut<T extends string, TCX extends StellarTxnContext>(this: TCX, uutName: UutName, ...names: T[]): hasUutContext<T> & TCX;
    // (undocumented)
    attachScript(...args: Parameters<Tx["attachScript"]>): void;
    // (undocumented)
    collateral?: TxInput;
    // (undocumented)
    dump(networkParams?: NetworkParams): string;
    // (undocumented)
    feeLimit?: bigint;
    // (undocumented)
    getSeedAttrs<TCX extends hasSeedUtxo>(this: TCX): SeedAttrs;
    // (undocumented)
    includeAddlTxn<TCX extends StellarTxnContext<anyState>, txnName extends string>(this: TCX, txnName: txnName, txInfo: AddlTxInfo<any>): hasAddlTxns<txnName, TCX>;
    // (undocumented)
    inputs: TxInput[];
    // (undocumented)
    mintTokens(...args: Parameters<Tx["mintTokens"]>): StellarTxnContext<S>;
    // (undocumented)
    neededSigners: Address[];
    // (undocumented)
    outputs: TxOutput[];
    // (undocumented)
    reservedUtxos(): TxInput[];
    // (undocumented)
    state: S;
    // (undocumented)
    tx: Tx;
    // (undocumented)
    txRefInputs: TxInput[];
    // (undocumented)
    utxoNotReserved(u: TxInput): TxInput | undefined;
    // (undocumented)
    validFor<TCX extends StellarTxnContext<S>>(this: TCX, durationMs: number, backwardMs?: number): TCX;
}

// Warning: (ae-internal-missing-underscore) The name "strategyValidation" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type strategyValidation = ErrorMap | undefined;

// @public
export const stringToNumberArray: typeof textToBytes;

// @public
export type tokenNamesOrValuesEntry = [string | number[], bigint];

export { Tx }

// @public
export function txAsString(tx: Tx, networkParams?: NetworkParams): string;

// @public (undocumented)
export function txidAsString(x: TxId): string;

export { TxInput }

// @public
export function txInputAsString(x: TxInput, prefix?: string): string;

// @public
export function txn(proto: any, thingName: any, descriptor: any): any;

export { TxOutput }

// @public
export function txOutputAsString(x: TxOutput, prefix?: string): string;

// @public (undocumented)
export function txOutputIdAsString(x: TxOutputId): string;

// Warning: (ae-internal-missing-underscore) The name "utxoAsString" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function utxoAsString(x: TxInput, prefix?: string): string;

// @public
export type utxoPredicate = ((u: TxInput) => TxInput | undefined) | ((u: TxInput) => boolean) | ((u: TxInput) => boolean | undefined);

// @public
export function utxosAsString(utxos: TxInput[], joiner?: string): string;

// @public
export class UutName {
    constructor(purpose: string, fullUutName: string | number[]);
    get name(): string;
    // (undocumented)
    purpose: string;
    // (undocumented)
    toString(): string;
}

// @public
export type uutPurposeMap<unionPurpose extends string> = {
    [purpose in unionPurpose]: UutName;
};

export { ValidatorHash }

export { Value }

// @public
export function valueAsString(v: Value): string;

// @public
export type valuesEntry = [number[], bigint];

// @public
export type VariantStrategy<DT extends StellarContract<capoDelegateConfig & any>> = {
    delegateClass: stellarSubclass<DT>;
    partialConfig?: PartialParamConfig<ConfigFor<DT>>;
    validateConfig?: (p: ConfigFor<DT>) => strategyValidation;
};

export { Wallet }

export { WalletHelper }

// Warnings were encountered during analysis:
//
// src/Capo.ts:247:9 - (ae-forgotten-export) The symbol "uutMap" needs to be exported by the entry point index.d.ts
// src/DefaultCapo.ts:359:17 - (ae-incompatible-release-tags) The symbol "validateConfig" is marked as @public, but its signature references "strategyValidation" which is marked as @internal
// src/DefaultCapo.ts:367:3 - (ae-incompatible-release-tags) The symbol "validateConfig" is marked as @public, but its signature references "strategyValidation" which is marked as @internal
// src/DefaultCapo.ts:398:3 - (ae-incompatible-release-tags) The symbol "validateConfig" is marked as @public, but its signature references "strategyValidation" which is marked as @internal
// src/StellarTxnContext.ts:64:9 - (ae-forgotten-export) The symbol "AddlTxInfo" needs to be exported by the entry point index.d.ts
// src/delegation/RolesAndDelegates.ts:263:5 - (ae-forgotten-export) The symbol "PartialParamConfig" needs to be exported by the entry point index.d.ts
// src/delegation/RolesAndDelegates.ts:265:5 - (ae-incompatible-release-tags) The symbol "validateConfig" is marked as @public, but its signature references "strategyValidation" which is marked as @internal

// (No @packageDocumentation comment for this package)

```
