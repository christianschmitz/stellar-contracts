## API Report File for "@donecollectively/stellar-contracts"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Address } from '@hyperionbt/helios';
import { AssetClass } from '@hyperionbt/helios';
import { Assets } from '@hyperionbt/helios';
import { Datum } from '@hyperionbt/helios';
import * as helios from '@hyperionbt/helios';
import { MintingPolicyHash } from '@hyperionbt/helios';
import { Network } from '@hyperionbt/helios';
import { NetworkEmulator } from '@hyperionbt/helios';
import { NetworkParams } from '@hyperionbt/helios';
import { Program } from '@hyperionbt/helios';
import { ReqtsMap as ReqtsMap_2 } from './Requirements.js';
import { SimpleWallet } from '@hyperionbt/helios';
import { TestContext } from 'vitest';
import { Tx } from '@hyperionbt/helios';
import { TxId } from '@hyperionbt/helios';
import { TxInput } from '@hyperionbt/helios';
import { TxOutput } from '@hyperionbt/helios';
import { UplcData } from '@hyperionbt/helios';
import { UplcDataValue } from '@hyperionbt/helios';
import { UplcProgram } from '@hyperionbt/helios';
import { Value } from '@hyperionbt/helios';
import { Wallet } from '@hyperionbt/helios';

// @public (undocumented)
export const Activity: {
    partialTxn(proto: any, thingName: any, descriptor: any): any;
    redeemer(proto: any, thingName: any, descriptor: any): any;
    redeemerData(proto: any, thingName: any, descriptor: any): any;
};

// @public (undocumented)
export const ADA = 1000000n;

// Warning: (ae-forgotten-export) The symbol "stellarTestHelperSubclass" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function addTestContext<SC extends StellarContract<any>, P extends paramsBase = SC extends StellarContract<infer PT> ? PT : never>(context: StellarTestContext<any, SC>, TestHelperClass: stellarTestHelperSubclass<SC>, params?: P): Promise<void>;

// @public (undocumented)
export type anyDatumProps = Record<string, any>;

// @public (undocumented)
export function assetsAsString(v: any): string;

// Warning: (ae-forgotten-export) The symbol "MintDelegateArgs" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class BasicMintDelegate extends StellarContract<MintDelegateArgs> {
    // (undocumented)
    contractSource(): any;
    // (undocumented)
    static currentRev: bigint;
    // (undocumented)
    static get defaultParams(): {
        rev: bigint;
    };
    // (undocumented)
    getContractScriptParams(config: MintDelegateArgs): paramsBase;
    // (undocumented)
    static mkDelegateWithArgs(a: MintDelegateArgs): void;
    // (undocumented)
    servesDelegationRole(role: string): true | undefined;
    // (undocumented)
    txnCreatingTokenPolicy(tcx: StellarTxnContext, tokenName: string): Promise<StellarTxnContext>;
}

// Warning: (ae-forgotten-export) The symbol "MinterBaseMethods" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "anyDatumArgs" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "CapoBaseConfig" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "hasUutCreator" needs to be exported by the entry point index.d.ts
//
// @public
export abstract class Capo<minterType extends MinterBaseMethods & DefaultMinter = DefaultMinter, charterDatumType extends anyDatumArgs = anyDatumArgs, configType extends CapoBaseConfig = CapoBaseConfig> extends StellarContract<configType> implements hasUutCreator {
    // Warning: (ae-forgotten-export) The symbol "StellarConstructorArgs" needs to be exported by the entry point index.d.ts
    constructor(args: StellarConstructorArgs<CapoBaseConfig>);
    // (undocumented)
    capoRequirements(): ReqtsMap_2<"is a base class for leader/Capo pattern" | "can create unique utility tokens" | "supports the Delegation pattern using roles and strategy-variants" | "supports well-typed role declarations and strategy-adding" | "supports just-in-time strategy-selection using withDelegates() and txnMustGetDelegate()" | "supports concrete resolution of existing role delegates" | "Each role uses a RoleVariants structure which can accept new variants" | "provides a Strategy type for binding a contract to a strategy-variant name">;
    // (undocumented)
    get charterTokenAsValue(): Value;
    // (undocumented)
    get charterTokenPredicate(): ((something: any) => any) & {
        value: Value;
    };
    // Warning: (ae-forgotten-export) The symbol "RelativeDelegateLink" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    connectDelegateWith<DelegateType extends StellarContract<any>>(roleName: string, delegateLink: RelativeDelegateLink<ConfigFor<DelegateType>>): Promise<DelegateType>;
    // (undocumented)
    connectMintingScript(params: SeedTxnParams): minterType;
    // (undocumented)
    abstract contractSource(): string;
    // (undocumented)
    getCapoRev(): bigint;
    getContractScriptParams(config: configType): paramsBase & Partial<configType>;
    getMinterParams(): {
        seedTxn: TxId;
        seedIndex: bigint;
    };
    // (undocumented)
    importModules(): HeliosModuleSrc[];
    // (undocumented)
    minter?: minterType;
    // (undocumented)
    get minterClass(): stellarSubclass<DefaultMinter, SeedTxnParams>;
    // (undocumented)
    get mintingPolicyHash(): MintingPolicyHash;
    // (undocumented)
    abstract mkDatumCharterToken(args: charterDatumType): InlineDatum;
    // (undocumented)
    abstract mkFullConfig(baseConfig: CapoBaseConfig): configType;
    // Warning: (ae-forgotten-export) The symbol "UutName" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "CapoImpliedSettings" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mkImpliedUutDetails(uut: UutName): CapoImpliedSettings;
    // Warning: (ae-forgotten-export) The symbol "hasSelectedDelegates" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract mkTxnMintCharterToken<TCX extends hasSelectedDelegates>(charterDatumArgs: Partial<charterDatumType>, existingTcx?: TCX): Promise<never | (TCX & hasBootstrappedConfig<CapoBaseConfig & configType>)>;
    // (undocumented)
    mockMinter?: minterType;
    // (undocumented)
    get mph(): MintingPolicyHash;
    // (undocumented)
    mustFindCharterUtxo(): Promise<TxInput>;
    // (undocumented)
    abstract get roles(): RoleMap;
    // (undocumented)
    tokenAsValue(tokenName: string, quantity?: bigint): Value;
    // (undocumented)
    tvCharter(): Value;
    // (undocumented)
    txnAddAuthority(tcx: StellarTxnContext<any>): Promise<StellarTxnContext<any>>;
    // (undocumented)
    abstract txnAddCharterAuthz(tcx: StellarTxnContext, datum: InlineDatum): Promise<StellarTxnContext<any> | never>;
    // (undocumented)
    txnCreatingUuts<const purposes extends string, TCX extends StellarTxnContext<any>>(tcx: TCX, uutPurposes: purposes[], seedUtxo?: TxInput): Promise<TCX & hasUutContext<purposes>>;
    // Warning: (ae-forgotten-export) The symbol "PartialParamConfig" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ConfigFor" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    txnGetSelectedDelegateConfig<T extends StellarContract<any>, const RN extends string>(tcx: hasSelectedDelegates, roleName: RN): PartialParamConfig<ConfigFor<T>>;
    // (undocumented)
    txnKeepCharterToken(tcx: StellarTxnContext<any>, datum: InlineDatum): StellarTxnContext<any>;
    // Warning: (ae-forgotten-export) The symbol "DelegateSettings" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected txnMustConfigureSelectedDelegate<T extends StellarContract<any>, const RN extends string>(tcx: hasSelectedDelegates & hasUutContext<RN>, roleName: RN): DelegateSettings<T>;
    // (undocumented)
    txnMustGetDelegate<T extends StellarContract<any>, const RN extends string>(tcx: hasSelectedDelegates & hasUutContext<RN>, roleName: RN, configuredDelegate?: DelegateSettings<T>): T;
    // (undocumented)
    txnMustGetSeedUtxo(tcx: StellarTxnContext, purpose: string, tokenNames: string[]): Promise<TxInput | never>;
    // Warning: (ae-forgotten-export) The symbol "SelectedDelegate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    txnMustSelectDelegate<T extends StellarContract<any>, const RN extends string, TCX extends hasSelectedDelegates>(tcx: TCX, roleName: RN): SelectedDelegate<T>;
    // (undocumented)
    txnMustUseCharterUtxo(tcx: StellarTxnContext<any>, redeemer: isActivity, newDatum?: InlineDatum): Promise<StellarTxnContext<any> | never>;
    // (undocumented)
    txnMustUseCharterUtxo(tcx: StellarTxnContext<any>, useReferenceInput: true, forceAddRefScript?: true): Promise<StellarTxnContext<any> | never>;
    // (undocumented)
    txnUpdateCharterUtxo(tcx: StellarTxnContext, redeemer: isActivity, newDatum: InlineDatum): Promise<StellarTxnContext | never>;
    // (undocumented)
    protected abstract updatingCharter(args: charterDatumType): isActivity;
    // (undocumented)
    protected usingAuthority(): isActivity;
    // (undocumented)
    uutsValue(uutMap: uutPurposeMap<any>): Value;
    // (undocumented)
    uutsValue(tcx: hasUutContext<any>): Value;
    // Warning: (ae-forgotten-export) The symbol "SelectedDelegates" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    withDelegates(delegates: Partial<SelectedDelegates>): hasSelectedDelegates;
}

// @public (undocumented)
export abstract class CapoTestHelper<SC extends Capo<DefaultMinter & MinterBaseMethods, CDT, CT>, CDT extends anyDatumArgs = SC extends Capo<DefaultMinter, infer iCDT> ? iCDT : anyDatumArgs, CT extends CapoBaseConfig = SC extends Capo<any, any, infer iCT> ? iCT : never> extends StellarTestHelper<SC> {
    // (undocumented)
    bootstrap(args?: CDT): Promise<SC>;
    // (undocumented)
    initialize({ randomSeed, config }?: {
        config?: CT;
        randomSeed?: number;
    }): Promise<SC>;
    // (undocumented)
    abstract mintCharterToken(args?: CDT): Promise<hasBootstrappedConfig<CT>>;
    // (undocumented)
    abstract mkDefaultCharterArgs(): Partial<CDT>;
}

// @public (undocumented)
export function datum(proto: any, thingName: any, descriptor: any): any;

// @public
export class DefaultCapo<MinterType extends DefaultMinter = DefaultMinter, CDT extends DefaultCharterDatumArgs = DefaultCharterDatumArgs, configType extends CapoBaseConfig = CapoBaseConfig> extends Capo<MinterType, CDT, configType> {
    // (undocumented)
    contractSource(): any;
    // (undocumented)
    importModules(): HeliosModuleSrc[];
    // (undocumented)
    mkDatumCharterToken(args: CDT): InlineDatum;
    mkFullConfig(baseConfig: CapoBaseConfig): CapoBaseConfig & configType;
    // Warning: (ae-forgotten-export) The symbol "PartialDefaultCharterDatumArgs" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mkTxnMintCharterToken<TCX extends hasSelectedDelegates>(charterDatumArgs: PartialDefaultCharterDatumArgs<CDT>, existingTcx?: TCX): Promise<never | (TCX & hasBootstrappedConfig<CapoBaseConfig & configType>)>;
    // (undocumented)
    mkTxnUpdateCharter(args: CDT, tcx?: StellarTxnContext): Promise<StellarTxnContext>;
    // (undocumented)
    requirements(): ReqtsMap_2<"the trustee group can be changed" | "positively governs all administrative actions" | "has a unique, permanent charter token" | "has a unique, permanent treasury address" | "the trustee threshold is enforced on all administrative actions" | "the charter token is always kept in the contract" | "can mint other tokens, on the authority of the Charter token" | "has a singleton minting policy" | "foo">;
    // (undocumented)
    get roles(): RoleMap;
    // (undocumented)
    get specializedCapo(): HeliosModuleSrc;
    // (undocumented)
    txnAddCharterAuthz(tcx: StellarTxnContext, datum: InlineDatum): Promise<StellarTxnContext<{}>>;
    // (undocumented)
    updatingCharter(): isActivity;
}

// @public
export class DefaultCapoTestHelper<DC extends DefaultCapo<DefaultMinter, CDT, CT> = DefaultCapo, CDT extends DefaultCharterDatumArgs = DC extends Capo<DefaultMinter, infer iCDT> ? iCDT : DefaultCharterDatumArgs, CT extends CapoBaseConfig = DC extends Capo<any, any, infer iCT> ? iCT : never> extends CapoTestHelper<DC, CDT, CT> {
    // (undocumented)
    static forCapoClass<DC extends DefaultCapo<DefaultMinter, any, any>>(s: stellarSubclass<DC>): stellarTestHelperSubclass<DC>;
    // (undocumented)
    mintCharterToken(args?: CDT): Promise<hasBootstrappedConfig<CT>>;
    // (undocumented)
    mkCharterSpendTx(): Promise<StellarTxnContext>;
    // (undocumented)
    mkDefaultCharterArgs(): PartialDefaultCharterDatumArgs;
    // (undocumented)
    setupActors(): void;
    // (undocumented)
    get stellarClass(): stellarSubclass<DC>;
    // (undocumented)
    updateCharter(args: CDT): Promise<StellarTxnContext>;
}

// @public
export type DefaultCharterDatumArgs<CT extends paramsBase = CapoBaseConfig> = {
    govAuthorityLink: RelativeDelegateLink<CT>;
};

// @public (undocumented)
export class DefaultMinter extends StellarContract<SeedTxnParams> implements MinterBaseMethods {
    // (undocumented)
    get charterTokenAsValue(): Value;
    // (undocumented)
    get charterTokenAsValuesEntry(): valuesEntry;
    // (undocumented)
    contractSource(): any;
    // (undocumented)
    importModules(): HeliosModuleSrc[];
    // Warning: (ae-forgotten-export) The symbol "MintCharterRedeemerArgs" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected mintingCharter({ owner, }: MintCharterRedeemerArgs): isActivity;
    // (undocumented)
    get mintingPolicyHash(): MintingPolicyHash;
    // (undocumented)
    protected mintingUuts({ seedTxn, seedIndex: sIdx, purposes, }: MintUutRedeemerArgs): isActivity;
    // (undocumented)
    tvCharter(): Value;
    // (undocumented)
    txnCreatingUuts<const purposes extends string, TCX extends StellarTxnContext<any>>(initialTcx: TCX, uutPurposes: purposes[], seedUtxo?: TxInput): Promise<TCX & hasUutContext<purposes>>;
    // (undocumented)
    txnMintingCharter<TCX extends StellarTxnContext<any>>(tcx: TCX, { owner, authZor }: {
        authZor: UutName;
        owner: Address;
    }): Promise<TCX>;
    // (undocumented)
    txnWithUuts<const purposes extends string, existingTcx extends StellarTxnContext<any>, const R extends string>(tcx: existingTcx, uutPurposes: purposes[], seedUtxo: TxInput, role: R): Promise<existingTcx & hasUutContext<purposes | (R extends "" ? never : R)>>;
}

// Warning: (ae-forgotten-export) The symbol "ErrorMap" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function errorMapAsString(em: ErrorMap, prefix?: string): string;

// @public
export type hasAllUuts<uutEntries extends string> = {
    uuts: uutPurposeMap<uutEntries>;
};

// @public (undocumented)
export type hasBootstrappedConfig<CT extends CapoBaseConfig> = StellarTxnContext<{
    bootstrappedConfig: CT;
}>;

// @public
export function hasReqts<R extends ReqtsMap<validReqts>, const validReqts extends string = string & keyof R>(reqtsMap: R): ReqtsMap<validReqts>;

// @public (undocumented)
export namespace hasReqts {
    var // (undocumented)
    TODO: unique symbol;
}

// @public
export type hasUutContext<uutEntries extends string> = StellarTxnContext<hasAllUuts<uutEntries>>;

// @public (undocumented)
export type HeliosModuleSrc = string & {
    srcFile: string;
    purpose: string;
    moduleName: string;
};

// @public (undocumented)
export function heliosRollupLoader(opts?: {
    include: string;
    exclude: never[];
}): {
    name: string;
    transform(content: any, id: any): {
        code: String;
        map: {
            mappings: string;
        };
    } | undefined;
};

// Warning: (ae-forgotten-export) The symbol "DatumInline" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type InlineDatum = ReturnType<typeof DatumInline>;

// @public
export type isActivity = {
    redeemer: UplcDataValue | UplcData;
};

// @public (undocumented)
export function lovelaceToAda(l: bigint | number): string;

// @public
export type MintUutRedeemerArgs = {
    seedTxn: TxId;
    seedIndex: bigint | number;
    purposes: string[];
};

// @public (undocumented)
export function mkHeliosModule(src: string, filename: string): HeliosModuleSrc;

// @public (undocumented)
export function mkUutValuesEntries(uuts: UutName[]): valuesEntry[];

// @public (undocumented)
export function mkUutValuesEntries(uuts: uutPurposeMap<any>): valuesEntry[];

// @public (undocumented)
export function mkValuesEntry(tokenName: string, count: bigint): valuesEntry;

// @public (undocumented)
export type paramsBase = Record<string, any>;

// @public (undocumented)
export function partialTxn(proto: any, thingName: any, descriptor: any): any;

// Warning: (ae-forgotten-export) The symbol "TODO_TYPE" needs to be exported by the entry point index.d.ts
//
// @public
export type ReqtsMap<validReqts extends string> = {
    [reqtDescription in validReqts]: TODO_TYPE | RequirementEntry<validReqts>;
};

// @public
export type RequirementEntry<reqts extends string> = {
    purpose: string;
    details: string[];
    mech: string[];
    impl?: string;
    requires?: reqts[];
};

// Warning: (ae-forgotten-export) The symbol "VariantMap" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type RoleMap = Record<string, VariantMap<any>>;

// @public (undocumented)
export type SeedTxnParams = {
    seedTxn: TxId;
    seedIndex: bigint;
};

// @public (undocumented)
export class StellarContract<ConfigType extends paramsBase> {
    constructor(args: StellarConstructorArgs<ConfigType>);
    // (undocumented)
    ADA(n: bigint | number): bigint;
    // (undocumented)
    get address(): Address;
    // (undocumented)
    addScriptWithParams<SC extends StellarContract<any>>(TargetClass: new (a: SC extends StellarContract<any> ? StellarConstructorArgs<ConfigFor<SC>> : never) => SC, params: SC extends StellarContract<infer P> ? P : never): SC;
    // (undocumented)
    compiledScript: UplcProgram;
    // (undocumented)
    configIn?: ConfigType;
    // (undocumented)
    contractParams?: paramsBase;
    // (undocumented)
    contractSource(): string | never;
    // (undocumented)
    get datumType(): any;
    // (undocumented)
    static get defaultParams(): {};
    // (undocumented)
    findAnySpareUtxos(tcx: StellarTxnContext): Promise<TxInput[] | never>;
    // (undocumented)
    findSmallestUnusedUtxo(lovelace: bigint, utxos: TxInput[], tcx?: StellarTxnContext): TxInput | undefined;
    // (undocumented)
    getContractScriptParams(config: ConfigType): paramsBase & Partial<ConfigType>;
    // (undocumented)
    getMyActorAddress(): Promise<Address>;
    // (undocumented)
    hasMyUtxo(semanticName: string, predicate: utxoPredicate): Promise<TxInput | undefined>;
    // (undocumented)
    hasOnlyAda(value: Value, tcx: StellarTxnContext | undefined, u: TxInput): TxInput | undefined;
    // (undocumented)
    hasUtxo(semanticName: string, predicate: utxoPredicate, { address, exceptInTcx, }: {
        address: Address;
        exceptInTcx?: StellarTxnContext<any>;
    }): Promise<TxInput | undefined>;
    // (undocumented)
    get identity(): string;
    // (undocumented)
    importModules(): HeliosModuleSrc[];
    // (undocumented)
    protected _infoBackToUtxo({ u }: utxoInfo): TxInput;
    // (undocumented)
    loadProgramScript(params?: Partial<ConfigType>): Program | undefined;
    // (undocumented)
    get mintingPolicyHash(): MintingPolicyHash | undefined;
    // (undocumented)
    mkAssetValue(tokenId: AssetClass, count?: number): Value;
    // (undocumented)
    mkTokenPredicate(val: Value): tokenPredicate<any>;
    // (undocumented)
    mkTokenPredicate(mph: MintingPolicyHash, tokenName: string, quantity?: bigint): tokenPredicate<any>;
    // (undocumented)
    mkTokenPredicate(vOrMph: AssetClass, quantity?: bigint): tokenPredicate<any>;
    // @internal (undocumented)
    protected _mkUtxoSortInfo(min: bigint, max?: bigint): (u: TxInput) => utxoInfo;
    // Warning: (ae-forgotten-export) The symbol "tokenPredicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mkValuePredicate(lovelace: bigint, tcx?: StellarTxnContext): tokenPredicate<TxInput>;
    // (undocumented)
    mustFindActorUtxo(name: string, predicate: (u: TxInput) => TxInput | undefined, exceptInTcx: StellarTxnContext<any>, extraErrorHint?: string): Promise<TxInput | never>;
    // (undocumented)
    mustFindActorUtxo(name: string, predicate: (u: TxInput) => TxInput | undefined, extraErrorHint?: string): Promise<TxInput | never>;
    // (undocumented)
    mustFindMyUtxo(semanticName: string, predicate: (u: TxInput) => TxInput | undefined, exceptInTcx: StellarTxnContext<any>, extraErrorHint?: string): Promise<TxInput | never>;
    // (undocumented)
    mustFindMyUtxo(semanticName: string, predicate: (u: TxInput) => TxInput | undefined, extraErrorHint?: string): Promise<TxInput | never>;
    // (undocumented)
    mustFindUtxo(semanticName: string, predicate: (u: TxInput) => TxInput | undefined, { address, exceptInTcx, }: {
        address: Address;
        exceptInTcx?: StellarTxnContext<any>;
    }, extraErrorHint?: string): Promise<TxInput | never>;
    // (undocumented)
    myActor?: Wallet;
    // (undocumented)
    network: Network;
    // (undocumented)
    networkParams: NetworkParams;
    // (undocumented)
    outputsSentToDatum(datum: InlineDatum): Promise<TxInput[]>;
    // (undocumented)
    partialConfig?: Partial<ConfigType>;
    // (undocumented)
    get purpose(): scriptPurpose | "non-script";
    // Warning: (ae-forgotten-export) The symbol "scriptPurpose" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    _purpose?: scriptPurpose;
    // (undocumented)
    readDatum<DPROPS extends anyDatumProps>(datumName: string, datum: Datum | InlineDatum): Promise<DPROPS>;
    // (undocumented)
    scriptProgram?: Program;
    // Warning: (ae-forgotten-export) The symbol "SetupDetails" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    setup: SetupDetails;
    // (undocumented)
    submit(tcx: StellarTxnContext, { sign, signers, }?: {
        sign?: boolean;
        signers?: Wallet[];
    }): Promise<TxId>;
    // (undocumented)
    tokenAsValue(tokenName: string, quantity: bigint, mph?: MintingPolicyHash): Value;
    // (undocumented)
    totalValue(utxos: TxInput[]): Value;
    // (undocumented)
    toUtxoId(u: TxInput): string;
    // (undocumented)
    txnFindUtxo(tcx: StellarTxnContext<any>, name: string, predicate: utxoPredicate, address?: Address): Promise<TxInput | undefined>;
    // (undocumented)
    txnKeepValue(tcx: StellarTxnContext, value: Value, datum: InlineDatum): StellarTxnContext<{}>;
    // @internal (undocumented)
    protected _utxoCountAdaOnly(c: number, { minAdaAmount }: utxoInfo): number;
    // @internal (undocumented)
    protected _utxoIsPureADA({ u }: utxoInfo): TxInput | undefined;
    // @internal (undocumented)
    protected _utxoIsSufficient({ sufficient }: utxoInfo): boolean;
    // Warning: (ae-forgotten-export) The symbol "utxoInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    protected _utxoSortSmallerAndPureADA({ free: free1, minAdaAmount: r1 }: utxoInfo, { free: free2, minAdaAmount: r2 }: utxoInfo): 1 | -1 | 0;
}

// @public (undocumented)
export type stellarSubclass<S extends StellarContract<CT>, CT extends paramsBase = S extends StellarContract<infer iCT> ? iCT : paramsBase> = (new (args: StellarConstructorArgs<CT>) => S & StellarContract<CT>) & {
    defaultParams: Partial<CT>;
};

// Warning: (ae-forgotten-export) The symbol "canHaveRandomSeed" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface StellarTestContext<HTH extends StellarTestHelper<SC>, SC extends StellarContract<any> = HTH extends StellarTestHelper<infer iSC> ? iSC : never> extends canHaveRandomSeed, TestContext {
    // (undocumented)
    h: HTH;
    // Warning: (ae-forgotten-export) The symbol "canSkipSetup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    initHelper(config: Partial<ConfigFor<SC>> & canHaveRandomSeed & canSkipSetup): Promise<StellarTestHelper<SC>>;
    // (undocumented)
    get strella(): SC;
}

// @public (undocumented)
export abstract class StellarTestHelper<SC extends StellarContract<any>> {
    constructor(config?: ConfigFor<SC> & canHaveRandomSeed & canSkipSetup);
    // Warning: (ae-forgotten-export) The symbol "actorMap" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    actors: actorMap;
    // (undocumented)
    addActor(roleName: string, walletBalance: bigint): helios.SimpleWallet;
    // (undocumented)
    address?: Address;
    // (undocumented)
    config?: ConfigFor<SC>;
    // (undocumented)
    get currentActor(): SimpleWallet;
    set currentActor(actorName: string);
    // (undocumented)
    currentSlot(): bigint | null;
    // (undocumented)
    defaultActor?: string;
    // (undocumented)
    delay(ms: any): Promise<unknown>;
    // (undocumented)
    initialize(config: ConfigFor<SC> & canHaveRandomSeed): Promise<SC>;
    // (undocumented)
    initStellarClass(): SC & StellarContract<SC extends StellarContract<infer inferredConfig extends paramsBase> ? inferredConfig : never>;
    // (undocumented)
    initStrella(TargetClass: stellarSubclass<SC, ConfigFor<SC>>, config?: ConfigFor<SC>): SC & StellarContract<SC extends StellarContract<infer inferredConfig extends paramsBase> ? inferredConfig : never>;
    // (undocumented)
    liveSlotParams: NetworkParams;
    // Warning: (ae-forgotten-export) The symbol "enhancedNetworkParams" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mkNetwork(): [NetworkEmulator, enhancedNetworkParams];
    // (undocumented)
    mkRandomBytes(length: number): number[];
    // (undocumented)
    mkSeedUtxo(seedIndex?: bigint): Promise<helios.TxId>;
    // (undocumented)
    network: NetworkEmulator;
    // (undocumented)
    networkParams: NetworkParams;
    // (undocumented)
    optimize: boolean;
    // (undocumented)
    rand?: () => number;
    // (undocumented)
    randomSeed?: number;
    // (undocumented)
    setupActors(): void;
    // (undocumented)
    setupPending?: Promise<any>;
    // (undocumented)
    slotToTimestamp(s: bigint): bigint | Date;
    // (undocumented)
    state: Record<string, any>;
    // (undocumented)
    abstract get stellarClass(): stellarSubclass<SC, any>;
    // (undocumented)
    strella: SC;
    // (undocumented)
    submitTx(tx: Tx, force?: "force"): Promise<TxId>;
    // (undocumented)
    waitUntil(time: Date): bigint;
}

// Warning: (ae-forgotten-export) The symbol "noState" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class StellarTxnContext<S = noState> {
    constructor(state?: Partial<S>);
    // (undocumented)
    addCollateral(collateral: TxInput): this;
    // (undocumented)
    addInput(...args: Parameters<Tx["addInput"]>): StellarTxnContext<S>;
    // (undocumented)
    addInputs(...args: Parameters<Tx["addInputs"]>): StellarTxnContext<S>;
    // (undocumented)
    addOutput(...args: Parameters<Tx["addOutput"]>): StellarTxnContext<S>;
    // (undocumented)
    addOutputs(...args: Parameters<Tx["addOutputs"]>): StellarTxnContext<S>;
    // @deprecated
    addScript(): void;
    // (undocumented)
    addSignature(wallet: Wallet): Promise<void>;
    // (undocumented)
    attachScript(...args: Parameters<Tx["attachScript"]>): this;
    // (undocumented)
    collateral?: TxInput;
    // (undocumented)
    dump(): string;
    // (undocumented)
    feeLimit?: bigint;
    // (undocumented)
    inputs: TxInput[];
    // (undocumented)
    mintTokens(...args: Parameters<Tx["mintTokens"]>): StellarTxnContext<S>;
    // (undocumented)
    outputs: TxOutput[];
    // (undocumented)
    reservedUtxos(): TxInput[];
    // (undocumented)
    state: S;
    // (undocumented)
    tx: Tx;
    // (undocumented)
    utxoNotReserved(u: TxInput): TxInput | undefined;
}

// @public (undocumented)
export type strategyValidation = ErrorMap | undefined;

// @public (undocumented)
export function stringToNumberArray(str: string): number[];

// @public (undocumented)
export type tokenNamesOrValuesEntry = [string | number[], bigint];

// @public (undocumented)
export function txAsString(tx: Tx): string;

// @public (undocumented)
export function txInputAsString(x: TxInput, prefix?: string): string;

// @public (undocumented)
export function txn(proto: any, thingName: any, descriptor: any): any;

// @public (undocumented)
export function txOutputAsString(x: TxOutput, prefix?: string): string;

// @public (undocumented)
export function utxoAsString(x: TxInput, prefix?: string): string;

// @public (undocumented)
export type utxoPredicate = ((u: TxInput) => TxInput | undefined) | ((u: TxInput) => boolean) | ((u: TxInput) => boolean | undefined);

// @public (undocumented)
export function utxosAsString(utxos: TxInput[], joiner?: string): string;

// @public
export type uutPurposeMap<unionPurpose extends string> = {
    [purpose in unionPurpose]: UutName;
};

// @public (undocumented)
export function valueAsString(v: Value): string;

// @public (undocumented)
export type valuesEntry = [number[], bigint];

// @public (undocumented)
export function variantMap<T extends StellarContract<any>>(vm: VariantMap<T>): VariantMap<T>;

// (No @packageDocumentation comment for this package)

```
