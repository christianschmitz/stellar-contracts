module specializedMintDelegate

//! provides a basic version, not yet specialized,
// of the "specializedMintDelegate" interface, which simply
// exports a DelegateDatum enum and DelegateActivities (redeemer enum).  

//! these specializations MAY include additional enum variants, and 
//  ... they MUST include the same enum variants found in this
//  ... unspecialized version.   If you're specializing and you get a Helios 
//  ... compiler error, these are the first things you should check!

// The MintDelegateActivity (redeemer) enum reserves the first 10
// ... variants for use-cases inside the script, with the remaining
// ... available for authorizing application-specific use-cases.

// The mintingUuts activity is deprecated, and should be replaced with
// ... application-specific activities that validate minting of UUTs.
// It's recommended to retain the error-throwing behavior of the
// ... genericUutMinting function, and expect that it will no longer 
// ... be called after Stellar Contracts v1.0

// The MintDelegateDatum enum reserves the first variant for the
// ... "IsDelegation" datum.

//! Your specialization MAY include any 
// ... additional functions, imports or methods

import {
    DelegationDetail,
    mustReturnValueToScript,
    tvAuthorityToken,
    DelegateActivity,
    unmodifiedDelegation
} from CapoDelegateHelpers

import {
    validateUutMinting,
    mkUutTnFactory
} from CapoMintHelpers

import {
    capoSettings
} from CustomCapoSettings

enum MintDelegateDatum {
    IsDelegation {
        dd: DelegationDetail
    }
    ScriptReference

    func validateSettings(self, ctx: ScriptContext, settings: capoSettings) -> Bool{
        assert(false, "not valid (stubbed)");
        settings.serialize() != self.serialize() &&
        ctx.tx.serialize() != self.serialize() &&        
        true
    }

    func validateCDConfig(self, updated: MintDelegateDatum::IsDelegation) -> Bool {
        self.switch {
            IsDelegation => {
                (updated == self)
            },
            _ => error("unreachable")
        }
    }
}

enum MintDelegateActivity {
    // Authorizing  - obsolete
    DelegateActivity {
        activity: DelegateActivity
    }
    mintingUuts {  
        seedTxn: TxId
        seedIndex: Int
        purposes: []String
    }

    // this function gives a general-purpose implementation of checking for 
    // valid uut mints. A specialization might modify it use different policies
    // or enforce additional requirements
    func genericUutMinting(self, 
        mdd: MintDelegateDatum,
        ctx: ScriptContext
    ) -> Bool {
        MintDelegateActivity::mintingUuts{sTxId, sIdx, purposes} = self;
        MintDelegateDatum::IsDelegation{dd} = mdd;
        returnsAuthzToken : Bool = mustReturnValueToScript(tvAuthorityToken(dd), ctx);

        o : []TxOutput = ctx.get_cont_outputs();
        if (o.length != 1) { error("single utxo only") };

        print ("in uutMintingDelegate");
        isOk : Bool = returnsAuthzToken && 

        unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize(), ctx) &&

        // This call can serve as a template for enforcing expected mints 
        // of uuts (and additional token values) in validation of application-
        // specific activities, given (mph, sTxId, sIdx, purposes)
        validateUutMinting(
            ctx: ctx, 
            mph: dd.mph,
            seedTxId: sTxId, 
            seedIdx: sIdx, 
            purposes: purposes,
            // additionalValues: ()
            mkTokenName: mkUutTnFactory(sTxId, sIdx)
        );

        isOk
    }

    //! used only for validating IsDelegation datum, that is,
    //   ... to approve minting requests or any customize spending modes 
    //   ... of that datum.  In the unspecialized version, 
    //   ... the "Modifying" activity is a stand-in for that use-case, that always rejects.
    //  Note that the basic mint delegate already enforces some basic
    //    administrative expectations for Reassigning, Retiring, Modifying activites, 
    //    so a specialization doesn't need to re-implement those checks.
    func additionalDelegateValidation( self,
        priorMddd: MintDelegateDatum::IsDelegation, 
        ctx: ScriptContext
    ) -> Bool {
        // print("  ----- checking additional delegate validation");
        self.switch {
            // todo: delete this obsolete activity.
            mintingUuts => self.genericUutMinting(priorMddd, ctx),
            // generic DelegateActivity is already validated, but 
            //  ... you can add more constraints here if needed
            DelegateActivity => true,

            _ => false
        } || ctx.tx.serialize() != priorMddd.serialize()
    }

    //! used only for validating non-IsDelegation datum types and activities.
    //   if you have any admininstrative data structures that inform 
    //   your minting policy, this might be useful.  Otherise, look to Activity validations
    //   above, in which the isDelegation token is being spent with an application-specific
    //   activity/redeemer
    func otherDatumValidation( self,
        priorMdd: MintDelegateDatum, 
        ctx: ScriptContext
    ) -> Bool {
        neverTriggered = () -> {  error("never called") };
        self.switch{
            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.
            //  Using it on any other Datum type will always fail and execution will never arrive here.
            DelegateActivity => neverTriggered(),
            
            // ------------------- application-specific activities can be added here

            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls
        } && (priorMdd.serialize() != ctx.serialize())
    }
}

struct types {
    redeemers: MintDelegateActivity
    datum : MintDelegateDatum
}
