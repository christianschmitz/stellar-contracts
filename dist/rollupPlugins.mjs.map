{
  "version": 3,
  "sources": ["../src/helios/heliosRollupLoader.ts", "../src/helios/heliosRollupTypeGen.ts", "../src/helios/StellarHeliosProject.ts", "../src/helios/dataBridge/BundleTypes.ts", "../src/helios/dataBridge/BundleBasedGenerator.ts", "../src/helios/dataBridge/BundleTypeGenerator.ts", "../src/helios/dataBridge/dataBridgeGenerator.ts", "../src/HeliosPromotedTypes.ts"],
  "sourcesContent": ["import { readFileSync } from \"fs\";\nimport path from \"path\";\n\nimport { createFilter } from \"rollup-pluginutils\";\nimport type { LoadResult, ResolveIdResult } from \"rollup\";\n\n/**\n * Rollup loader for Helios source files\n * @public\n **/\nexport function heliosRollupLoader(\n    opts: {\n        include?: string;\n        exclude?: string[];\n        project?: string;\n        resolve?: string | false | null;\n    } = {}\n) {\n    const filterOpts = {\n        ...{\n            include: [\"*.hl\", \"**/*.hl\"],\n            exclude: [],\n            project: \"\"\n        },\n        ...opts,\n    };\n    if (!filterOpts.include) {\n        throw Error(\"missing required 'include' option for helios loader\");\n    }\n\n    const filter = createFilter(\n        filterOpts.include || [\"*.hl\", \"**/*.hl\"],\n        filterOpts.exclude,\n        {\n            resolve: filterOpts.resolve,\n        }\n    );\n    const project = filterOpts.project ? `${filterOpts.project}` : \"\";\n\n    type Loader = {\n        code: string;\n        map: { mappings: string };\n    };\n    let esbuildApi;\n    const resolveId = (source, importer, options) => {\n        // the source is a relative path name\n        // the importer is an a fully resolved id of the imported module\n        const where = new Error(`here!`).stack;\n        if (!filter(source)) {\n            // console.log(`resolver1: resolving ${source} for ${importer}`, where);\n            // } else {\n            // if (source.match(/\\.hl$/))\n            // console.log(\n            //     `resolver1: skipping ${source} due to filter mismatch`\n            //     // filterOpts.include\n            // );\n            return null;\n        }\n        return {\n            id: source,\n        } as ResolveIdResult;\n    };\n    return {\n        name: \"helios\",\n        resolveId, // the resolver hook from above\n\n        load(id): LoadResult {\n            if (filter(id)) {\n                const relPath = path.relative(\".\", id);\n\n                const content = readFileSync(relPath, \"utf-8\");\n                // console.warn(\n                //     `heliosLoader: ${relPath}`\n                // );\n\n                // helios.Program.new(content) // fails unless it can resolve deps\n\n                // todo: use Helios' logic for this\n                const [_, purpose, moduleName] =\n                    content.match(\n                        /(module|minting|spending|endpoint)\\s+([a-zA-Z0-9]+)/m\n                    ) || [];\n\n                if (!(purpose && moduleName))\n                    throw new Error(`Bad format for helios file ${id}`);\n\n                const code =\n                    `const heliosModule = {\\n` +\n                    `  content: ${JSON.stringify(content)},\\n` +\n                    // `  srcFile: ${JSON.stringify(relPath)},\\n`+\n                    `  project: ${JSON.stringify(project)},\\n` +\n                    `  purpose: ${JSON.stringify(purpose)},\\n` +\n                    `  name:  ${JSON.stringify(\n                        relPath\n                    )}, // source filename\\n` +\n                    `  moduleName:  ${JSON.stringify(moduleName)},\\n` +\n                    `}\\n` +\n                    `\\nexport default heliosModule\\n`;\n                return {\n                    code: code,\n                    // id: `${id}\u2039generated\u203A.ts`,\n                    map: { mappings: \"\" },\n                };\n            }\n        },\n\n        // buildStart({ plugins }) {\n        // \tconst parentName = 'esbuild';\n        // \tconst parentPlugin = plugins.find(\n        // \t\tplugin => plugin.name === parentName\n        // \t);\n        // \tif (!parentPlugin) {\n        // \t\t// or handle this silently if it is optional\n        // \t\tthrow new Error(\n        // \t\t\t`This plugin depends on the \"${parentName}\" plugin.`\n        // \t\t);\n        // \t}\n        // \t// now you can access the API methods in subsequent hooks\n        // \tesbuildApi = parentPlugin;\n        // },\n    };\n}\n", "import { blake2b } from \"@helios-lang/crypto\";\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from \"fs\";\nimport path from \"path\";\nimport { createFilter } from \"rollup-pluginutils\";\nimport {\n    type InputOptions,\n    type ResolveIdHook,\n    type ResolveIdResult,\n    type PartialResolvedId,\n    type LoadResult,\n    type PluginContext,\n    type LoadHook,\n    type CustomPluginOptions,\n    rollup,\n} from \"rollup\";\nimport esbuild from \"rollup-plugin-esbuild\";\n\nimport { StellarHeliosProject } from \"./StellarHeliosProject.js\";\nimport { heliosRollupLoader } from \"./heliosRollupLoader.js\";\nimport { bytesToHex } from \"@helios-lang/codec-utils\";\nimport { textToBytes } from \"../HeliosPromotedTypes.js\";\n\ntype TypeGenPluginState = {\n    capoBundle: any; // CapoHeliosBundle;\n    hasExplicitCapoBundle: boolean;\n    hasOtherBundles: boolean;\n    project: StellarHeliosProject;\n}\n\n/**\n * Rollup loader for generating typescript types from Helios source files\n * @remarks\n * This rollup plugin is designed to be used in a rollup configuration\n * to generate typescript types from Helios source files.\n *\n * The plugin is designed to be used in conjunction with the helios rollup loader,\n * which compiles the helios source files into javascript.\n *\n * The following Rollup build hooks are used to make it all happen:\n * - resolveId: this hook is used to intercept the import of the helios bundle files, and use the\n *   project to generate updated types if needed and available.\n * @public\n **/\nexport function heliosRollupTypeGen(\n    opts: { \n        include?: string; \n        exclude?: string[]; \n        project?: string,\n        compile?: boolean\n    } = {}\n) {\n    const options = {\n        ...{\n            include: /.*\\.hlb\\.[jt]s$/,\n            exclude: [],\n            project: \"\",\n            compile: false\n        },\n        ...opts,\n    };\n\n    // creates a temporary directory for dynamic loading,\n    // in the project-root's .temp directory\n    const tempDir = path.join(process.cwd(), \".hltemp\", \"typeGen\");\n    // create the tempdir if needed\n    if (!existsSync(tempDir)) {\n        mkdirSync(tempDir, { recursive: true });\n    }\n    // console.log(`heliosTypeGen: using tempDir: ${tempDir}`);\n\n    const filter = createFilter(options.include, options.exclude);\n    // const project = options.project ? `${options.project}` : \"\";\n\n    // const lib = loadCompilerLib();\n    const projectRoot = StellarHeliosProject.findProjectRoot();\n\n    //read package.json from project root, parse and check its package name\n    // const packageJsonPath = path.join(projectRoot, \"package.json\");\n    // const packageJson = JSON.parse(readFileSync(packageJsonPath, \"utf-8\"));\n    // const isStellarContracts = \"@donecollectively/stellar-contracts\" === packageJson.name;\n\n    const state : TypeGenPluginState = {\n        capoBundle: null, // new CapoHeliosBundle(),\n        hasExplicitCapoBundle: false,\n        hasOtherBundles: false,\n        project: new StellarHeliosProject()\n    };\n\n    const isJavascript = /\\.js$/;\n    return {\n        name: \"helios-type-gen\",\n        buildEnd: {\n            order: \"pre\",\n            handler(this: PluginContext, error?: Error) {\n                // write the project file after the build, skipping any\n                // pending delay from calls to `deferredWriteProjectFile()`\n                console.log(\"heliosTypeGen: buildEnd: \" + error ? \"error: \" : \"\" + error?.message);\n                // return state.project.writeProjectFile();\n            },\n        },\n        resolveId: {\n            order: \"pre\",\n            async handler(this: PluginContext, source, importer, options) {\n                // console.log(\"heliosTypeGen: resolveId\", { source, importer });\n                // if (source.match(/\\.hlb/)) {\n                //     throw new Error(\n                //         `first .hlb file is being loaded by ${importer}`\n                //     );\n                // }\n                const {project} = state;\n                if (\n                    importer?.match(isJavascript) &&\n                    source?.match(isJavascript) &&\n                    importer?.indexOf(project.projectRoot) === 0\n                ) {\n                    // work around vitest not resolving .ts files from .js using\n                    // the correct rules...\n                    const sourceWithTs = source.replace(/\\.js$/, \".ts\");\n                    const resolved = await this.resolve(\n                        source,\n                        importer.replace(/\\.js$/, \".ts\"),\n                        {\n                            ...options,\n                            skipSelf: true,\n                        }\n                    );\n                    if (resolved) {\n                        console.log(\n                            `heliosTypeGen: in vitest: resolving ${source} as ${sourceWithTs} for ${importer}`\n                            // {\n                            //     source,\n                            //     importer,\n                            //     resolved,\n                            // }\n                        );\n                        return resolved;\n                    }\n                }\n            },\n        },\n        load: {\n            order: \"pre\",\n            handler: async function (this: PluginContext, id: string): Promise<LoadResult> {\n                // the source is a relative path name\n                // the importer is an a fully resolved id of the imported module\n                // console.log(\"heliosTypeGen: load\");\n\n                const {project} = state;\n                if (!filter(id)) {\n                    if (id.match(/hlb/)) {\n                        console.log(\n                            `typeGen resolve: skipping due to filter mismatch`,\n                            { source: id }\n                        );\n                        debugger;\n                        //no-op, but helpful for debugging:\n                        filter(id); // trace into here to see what's up with the filter\n                    }\n\n                    return null;\n                }\n\n                // ->  todo: load an existing bundle if it's already compiled, and ask that class to\n                // ->   check its sources for changes, so we can skip rollup and recompilation if\n                // ->   things are already up-to-date.\n                const SomeBundleClass = await rollupMakeBundledScriptClass(id);\n                const relativeFilename = path.relative(projectRoot, id);\n                this.warn(`\uD83D\uDC41\uFE0F checking helios bundle ${SomeBundleClass.name} from ${relativeFilename}`)\n                //??? addWatchFile for all the .hl scripts in the bundle\n                // return null as LoadResult;\n\n                let bundle = new SomeBundleClass()\n                // compile the program seen in that bundle!\n                // ... to trigger helios syntax-checking:\n                let program = bundle.program;\n \n                let replacedCapo = false\n                if (SomeBundleClass.isCapoBundle) {\n                    let skipInstallingThisOne = false; \n                    if (state.hasExplicitCapoBundle) {\n                            let existingBundleProtoChainNames : string[]= [];\n                            // if the new class is just a base class for a more specific one, that's ok\n                            // we will still return it, without installing it as \"the\" Capo bundle\n                            let existingBundleProto = state.capoBundle.constructor;\n                            while (existingBundleProto) {\n                                existingBundleProtoChainNames.push(existingBundleProto.name);\n                                existingBundleProto = Object.getPrototypeOf(existingBundleProto);\n                            }\n                            if (existingBundleProtoChainNames.includes(SomeBundleClass.name)) {\n                                skipInstallingThisOne = true\n                                console.log(\n                                    `Helios project-loader: not adopting ${SomeBundleClass.name} as the project Capo\\n`+\n                                    `  ... because it looks like a base class of already-loaded ${\n                                        state.capoBundle.constructor.name\n                                    }`\n                                )\n                            } else {\n                                // console.log({id, x, y})\n                                debugger\n                            }\n\n\n                    } \n                    if (state.hasOtherBundles && !skipInstallingThisOne) {\n                        const digestExisting = shortHash(JSON.stringify(state.capoBundle.modules));\n                        const digestNew = shortHash(JSON.stringify(SomeBundleClass.prototype.modules));\n\n                        if (digestExisting !== digestNew) {\n                            throw new Error(`unreachable code path`)\n                            console.log(`existing = ${digestExisting}`, state.capoBundle.modules.map(x => (JSON.stringify({name: x.name, content: shortHash(x.content)}))))\n                            console.log(`late arrival: ${digestNew}`, SomeBundleClass.prototype.modules.map( x => (JSON.stringify({name: x.name, content: shortHash(x.content)}))))\n                            console.log(\"  ^^^^ from\", id)\n                            console.log(\"  ---- Late-arriving Capo.  Reinitializing project with updated dependencies...\");\n                            const ts1 = Date.now();\n                            state.project = state.project.replaceWithNewCapo(id, SomeBundleClass);\n                            console.log(\"  ---- Reinitialized project in\", Date.now() - ts1, \"ms\");\n                            replacedCapo = true;\n                        } else {\n                            console.log(\"  ---- warning: second capo discovered, though its modules aren't different from default. Generatings its types, but otherwise, Ignoring.\")\n                            // make a new project, add the new Capo bundle to it, generate types.\n                            const newProject = new StellarHeliosProject();\n                            newProject.loadBundleWithClass(id, SomeBundleClass);\n                            newProject.generateBundleTypes(id);\n                        }\n                    }\n                    state.hasExplicitCapoBundle = true;\n\n                    bundle =  new SomeBundleClass();\n                    if (!replacedCapo) {\n                        // state.project.loadBundleWithClass(id, SomeBundleClass);\n                        // state.project.generateBundleTypes(id);\n                    }\n                    console.log(` \uD83D\uDC41\uFE0F checking (Capo) helios bundle ${SomeBundleClass.name}`)\n                    if (!skipInstallingThisOne) {\n                        state.capoBundle = bundle;\n                        state.project.loadBundleWithClass(id, SomeBundleClass);\n                        state.project.generateBundleTypes(id);\n                    }\n                } else {\n                    state.hasOtherBundles = true;\n                    if (state.project.bundleEntries.size === 0 ) {\n                        console.log(\"looks like you're using the default Capo bundle. ok!\\n\");\n\n                        const capoName = bundle.capoBundle.constructor.name;\n                        if (capoName == \"CapoHeliosBundle\" && !state.capoBundle) {\n                            state.project.loadBundleWithClass(\n                                \"src/CapoHeliosBundle.ts\", \n                                bundle.capoBundle.constructor\n                            );\n                            state.project.generateBundleTypes(\n                                \"src/CapoHeliosBundle.ts\"\n                            );\n                        }\n                    }\n                    // try {\n                    //     bundle = new SomeBundleClass(state.capoBundle);\n                    //     this.warn(`\uD83D\uDC41\uFE0F checking helios bundle ${SomeBundleClass.name} from ${relativeFilename}`)\n                    // } catch (e:any) {\n                    //     this.error(`Error loading helios bundle ${SomeBundleClass.name}: ${e.message}`);\n                    // }\n                    state.project.loadBundleWithClass(id, SomeBundleClass);\n                    try {\n                        state.project.generateBundleTypes(id)\n                    } catch(e:any) {\n                        if (e.message.match(\"compilerError\")) {\n                            console.error(e);\n                            throw new Error(`Error in Helios script (see above)`);\n                        }\n                        console.error(`Error generating types for ${id}:\\n`, e);\n                        return new Promise((resolve, reject) => {\n                            setTimeout(() => {\n                                reject(new Error(`type-generation error (see above)`));\n                            }, 5000)\n                        })\n                    }\n                    this.warn(\"ok\")\n                }\n                return null as LoadResult;\n                //     id: source,\n                // };\n                //  throw new Error(`heliosLoader: ${importer} is importing ${source}`);\n            },\n        },\n    };\n    \n    async function rollupMakeBundledScriptClass(inputFile: string) {\n        // writes the output file next to the input file as *.hlb.bundled.mjs\n        const outputFile = inputFile.replace(\n            /\\.hlb\\.[tj]s$/,\n            \".hlb.bundled.mjs\" // ??? move to dist/ or .hltemp/?  hlbundle\n        );\n        if (inputFile == outputFile) {\n            throw new Error(`inputFile cannot be the same as outputFile`);\n        }\n\n        const buildStartTime = Date.now();\n\n        // throw new Error(inputFile);\n        console.log(`\uD83D\uDCE6 StellarHeliosProject: loading ${inputFile}`);\n        let didWarn = false;\n        const bundle = await rollup({\n            input: inputFile,\n            external(id) {\n                return !/^[./]/.test(id);\n            },\n\n            onwarn( warning, warn ) {\n                if (warning.code === 'UNUSED_EXTERNAL_IMPORT') return;\n                if (warning.code === 'CIRCULAR_DEPENDENCY') {\n                    if (\n                        warning.message == \"Circular dependency: src/StellarTxnContext.ts -> src/diagnostics.ts -> src/StellarTxnContext.ts\" \n                        || warning.message == \"Circular dependency: src/diagnostics.ts -> src/StellarTxnContext.ts -> src/delegation/jsonSerializers.ts -> src/diagnostics.ts\"\n                        || warning.message == \"Circular dependency: src/helios/CachedHeliosProgram.ts -> src/helios/CachedHeliosProgramFs.ts -> src/helios/CachedHeliosProgram.ts\"\n                        || warning.message == \"Circular dependency: src/helios/CachedHeliosProgram.ts -> src/helios/CachedHeliosProgramWeb.ts -> src/helios/CachedHeliosProgram.ts\"\n                        || warning.message == \"Circular dependency: src/diagnostics.ts -> src/StellarTxnContext.ts -> src/diagnostics.ts\"                \n                        || warning.message == \"Circular dependency: src/diagnostics.ts -> src/delegation/jsonSerializers.ts -> src/diagnostics.ts\"\n                    ) {\n                        if (didWarn) return;\n                        didWarn = true\n                        // warn(\"    ... all the usual Circular dependencies...\")\n                        return;\n                    }\n                }\n                warn(warning);\n            },\n            plugins: [\n                heliosRollupLoader({\n                    // todo make this right for the context\n                    project: \"stellar-contracts\",\n                    // onLoadHeliosFile: (filename) => {\n                    //   remember this list of files\n                    // }\n                }),\n                // !!! figure out how to make the bundle include the compiled & optimized\n                //   program, when options.compile is true.  \n                esbuild({\n                    tsconfig: \"./tsconfig.json\",\n                    target: [\"node18\"],\n\n                    sourceMap: false,\n                }),\n                // after the build is finished, append the list of input files\n                // in a way making it quick and easy to load an existing compiled\n                // file and let it check its own input files for changes.  Then\n                // we can save time and avoid this build step if everything is already good.\n            ],\n            // output: {\n            //     file: this.compiledProjectFilename,\n            //     sourcemap: true,\n            //     format: \"es\",\n            // },\n        }).catch((error) => {\n            console.error(\"Error during rollup of helios bundle:\", error);\n            throw error;\n        });\n\n        const result = await bundle.generate({ format: \"es\" });\n        if (result.output.length > 1) {\n            throw new Error(`unexpected: bundle should have one output`);\n        }\n        const compiled = result.output[0].code;\n        let buildTime = Date.now() - buildStartTime;\n\n        let needsWrite = true\n        // if the file is not changed, skip write of the compiled file\n        if (existsSync(outputFile)) {\n            const existing = readFileSync(outputFile, \"utf-8\");\n            if (existing === compiled) {\n                console.log(\n                    `\uD83D\uDCE6 StellarHeliosProject: unchanged bundle (${buildTime}ms): ${outputFile}`\n                );\n                needsWrite = false\n            }\n        }\n        if (needsWrite) {\n            await bundle.write({\n                file: outputFile,\n                // sourcemap: true,  // ?? how to get this to work properly?  debugging goes to wrong site\n                format: \"es\",\n            });\n            buildTime = Date.now() - buildStartTime;\n            console.log(\n                `\uD83D\uDCE6 StellarHeliosProject: wrote compiled bundle (${buildTime}ms): ${outputFile}`\n            );\n        }\n        bundle.close();\n        return import(outputFile).then((mod) => {\n            if (mod.default) {\n                const BundleClass = mod.default;\n                return BundleClass\n            } else {\n                throw new Error(`no default export in ${outputFile}`);\n            }\n        });\n    }\n\n    async function makeCapoHeliosBundle() {\n        // uses rollup to make a CapoHeliosBundle.mjs in .hltemp/typegen\n\n        throw new Error(`not implemented2`);\n\n        const outputFile = path.join(tempDir, \"CapoHeliosBundle.mjs\");\n        console.log(`\uD83D\uDCE6 StellarHeliosProject: making CapoHeliosBundle: ${outputFile}`);\n        const buildStartTime = Date.now();\n        let didWarn = false;\n        const bundle = await rollup({\n            input: path.join(\"src/CapoHeliosBundle.ts\"),\n            external(id) {\n                return !/^[./]/.test(id);\n            },\n            onwarn( warning, warn ) {\n                if (warning.code === 'UNUSED_EXTERNAL_IMPORT') return;\n                if (warning.code === \"CIRCULAR_DEPENDENCY\") {\n                    if (\n                        warning.message == \"Circular dependency: src/StellarTxnContext.ts -> src/diagnostics.ts -> src/StellarTxnContext.ts\" \n                        || warning.message == \"Circular dependency: src/diagnostics.ts -> src/StellarTxnContext.ts -> src/delegation/jsonSerializers.ts -> src/diagnostics.ts\"\n                        || warning.message == \"Circular dependency: src/helios/CachedHeliosProgram.ts -> src/helios/CachedHeliosProgramFs.ts -> src/helios/CachedHeliosProgram.ts\"\n                        || warning.message == \"Circular dependency: src/helios/CachedHeliosProgram.ts -> src/helios/CachedHeliosProgramWeb.ts -> src/helios/CachedHeliosProgram.ts\"\n                        || warning.message == \"Circular dependency: src/diagnostics.ts -> src/StellarTxnContext.ts -> src/diagnostics.ts\"\n                        || warning.message == \"Circular dependency: src/diagnostics.ts -> src/delegation/jsonSerializers.ts -> src/diagnostics.ts\"\n                    ) {\n                        if (didWarn) return;\n                        didWarn = true\n                        // warn(\"    ... all the usual Circular dependencies...\")\n                        return;\n                    }\n                }    \n                warn(warning);\n            },\n            plugins: [\n                heliosRollupLoader({\n                    project: \"stellar-contracts\",\n                }),\n                esbuild({\n                    tsconfig: \"./tsconfig.json\",\n                    target: [\"node18\"],\n                    sourceMap: false,\n                }),\n            ],\n        }).catch((error) => {\n            console.error(\"Error during rollup of CapoHeliosBundle:\", error);\n            throw error;\n        });\n        const result = await bundle.generate({ format: \"es\" });\n        const compiled = result.output[0].code;\n        const buildTime = Date.now() - buildStartTime;\n        console.log(`\uD83D\uDCE6 CapoHeliosBundle: generated temporary bundle (${buildTime}ms): ${outputFile}`);\n        let needsWrite = true;\n        // if the file is not changed, skip write of the compiled file\n        if (existsSync(outputFile)) {\n            const existing = readFileSync(outputFile, \"utf-8\");\n            if (existing === compiled) {\n                console.log(\n                    `\uD83D\uDCE6 CapoHeliosBundle: unchanged bundle (${buildTime}ms): ${outputFile}`\n                );\n                needsWrite = false;\n            }\n        }\n\n        if (needsWrite) {\n            await bundle.write({\n                file: outputFile,\n                format: \"es\",\n            });\n            console.log(\n                `\uD83D\uDCE6 CapoHeliosBundle: wrote compiled bundle (${buildTime}ms): ${outputFile}`\n            );\n        }\n\n        console.log(\"importing CapoHeliosBundle\");\n        return import(outputFile).then((mod) => {\n            console.log(\"CapoHeliosBundle loaded\", outputFile);\n            return mod.CapoHeliosBundle;\n        })\n    }\n}\n\n\nfunction shortHash(str: string) {\n    return bytesToHex(blake2b(textToBytes(str)).slice(0, 5));\n}", "import { existsSync, readFileSync, writeFileSync } from \"fs\";\nimport path from \"path\";\nimport type { HeliosScriptBundle } from \"./HeliosScriptBundle.js\";\nimport type { UplcData } from \"@helios-lang/uplc\";\nimport { BundleTypeGenerator } from \"./dataBridge/BundleTypeGenerator.js\";\nimport { dataBridgeGenerator } from \"./dataBridge/dataBridgeGenerator.js\";\n// import {CapoHeliosBundle} from \"../CapoHeliosBundle.js\";\n\nconst startTime = Date.now();\n\ntype BundleStatusEntry = {\n    filename: string;\n    status: \"registering\" | \"pendingLoad\" | \"loaded\";\n    bundleClassName: string;\n    parentClassName?: string;\n    bundleClass?: typeof HeliosScriptBundle; // or a subclass\n    bundle?: HeliosScriptBundle;\n};\n\nexport function isUplcData(x: any): x is UplcData {\n    return \"kind\" in x && \"toCbor\" in x;\n}\n\n/**\n * Gathers `*.hlb.[tj]s` files along with their status and attributes.\n * @public\n * @remarks\n * For script bundles that have previously been loaded, the project will\n * have access to the bundle's type information, and  be able to\n * instantiate the bundle, given a CapoBundle that typically provides\n * library dependencies.\n *\n * For script bundles that are being loaded for the first time, the project\n * can generate a \"placeholder\" type-definition, to be updated once the\n * bundle has been transformed by the helios rollup loader to be able to\n * do the above.\n */\nexport class StellarHeliosProject {\n    static root: string;\n\n    bundleEntries: Map<string, BundleStatusEntry>;\n    capoBundle: HeliosScriptBundle | undefined = undefined;\n    projectRoot: string;\n    constructor() {\n        this.bundleEntries = new Map();\n        this.projectRoot = StellarHeliosProject.findProjectRoot();\n    }\n\n    _isSC: boolean | undefined;\n\n    isStellarContracts() {\n        if (this._isSC == undefined) {\n            const packageJsonPath = path.join(this.projectRoot, \"package.json\");\n            if (!existsSync(packageJsonPath)) {\n                throw new Error(`package.json not found at ${packageJsonPath}`);\n            }\n            const packageJson = JSON.parse(\n                readFileSync(packageJsonPath, \"utf-8\")\n            );\n\n            this._isSC =\n                packageJson.name === \"@donecollectively/stellar-contracts\";\n        }\n        return this._isSC;\n    }\n\n    replaceWithNewCapo(\n        absoluteFilename: string,\n        newCapoClass: typeof HeliosScriptBundle\n    ) {\n        const replacement = new StellarHeliosProject();\n        replacement.loadBundleWithClass(absoluteFilename, newCapoClass);\n        replacement.generateBundleTypes(absoluteFilename);\n        for (const [filename, entry] of this.bundleEntries.entries()) {\n            if (!entry.bundleClass?.isCapoBundle) {\n                replacement.loadBundleWithClass(filename, entry.bundleClass!);\n                replacement.generateBundleTypes(filename);\n            }\n        }\n        return replacement;\n    }\n\n    // call from code-generated hlproject.mjs with instantiated bundle\n    // call from rollup plugin with bundle filename\n    loadBundleWithClass(\n        absoluteFilename: string,\n        bundleClass: typeof HeliosScriptBundle,\n        harmlessSecondCapo: boolean = false\n    ) {\n        // if the file location is within the project root, make it relative\n        // otherwise, use the absolute path\n        const filename = absoluteFilename.startsWith(this.projectRoot)\n            ? path.relative(this.projectRoot, absoluteFilename)\n            : absoluteFilename;\n\n        if (filename.startsWith(\"/\")) debugger;\n        const bundleClassName = bundleClass.name;\n\n        // we need to do rollup on the project before we'll ever hit this path\n        let bundle: HeliosScriptBundle | undefined;\n        // if the bundle has a CapoBundle, use it\n        // searches the bundle class hierarchy for the presence of a class named CapoHeliosBundle.\n        let isCapoBundle = bundleClass.isCapoBundle;\n        let proto = bundleClass.prototype;\n        let parentClassName = \"\";\n        while (proto) {\n            const thisClassName = proto.constructor.name;\n            if (!parentClassName && bundleClassName !== thisClassName) {\n                parentClassName = proto.constructor.name;\n                break;\n            }\n            proto = Object.getPrototypeOf(proto);\n        }\n\n        if (isCapoBundle && !harmlessSecondCapo) {\n            if (this.capoBundle) {\n                throw new Error(`only one CapoBundle is currently supported`);\n            }\n            // console.log(`Project: loading CapoBundle ${bundleClassName}`);\n            this.capoBundle = new (bundleClass as any)();\n            if (this.bundleEntries.size > 0) {\n                throw new Error(`register capo first!! ??`);\n                // update any pending bundles with an instantiated\n                // bundle including the newly-discovered CapoBundle\n                // for (const filename of this.bundleEntries.keys()) {\n                //     const entry = this.bundleEntries.get(filename);\n                //     if (entry?.status !== \"pendingLoad\") {\n                //         throw new Error(`unexpected status: ${entry?.status}`);\n                //     }\n                //     const bundleClass = entry.bundleClass;\n                //     if (!bundleClass) {\n                //         throw new Error(\n                //             `no bundleClass for entry with status '${entry?.status}': ${filename}`\n                //         );\n                //     }\n                //     console.log(\"finishing pending load for\", filename);\n                //     entry.bundle = new (bundleClass as any)(this.capoBundle);\n                //     entry.status = \"loaded\";\n                // }\n            }\n            this.bundleEntries.set(filename, {\n                filename,\n                status: \"loaded\",\n                bundle: this.capoBundle,\n                bundleClassName: bundleClassName,\n                parentClassName,\n                bundleClass,\n            });\n        } else if (isCapoBundle && harmlessSecondCapo) {\n            console.log(`Project: loading CapoBundle ${bundleClassName}`);\n            console.log(\n                `  (replaces existing capo ${this.capoBundle?.constructor.name})`\n            );\n            debugger;\n            this.bundleEntries.set(filename, {\n                filename,\n                status: \"loaded\",\n                bundle: new (bundleClass as any)(), // harmless second capo\n                bundleClassName: bundleClassName,\n                parentClassName,\n                bundleClass,\n            });\n        } else {\n            const bundleEntry: BundleStatusEntry = {\n                filename,\n                status: \"registering\", // overwritten below, one way or other\n                bundleClass,\n                bundleClassName: bundleClassName,\n                parentClassName,\n            };\n            // if we have the CapoBundle, we can use it to instantiate this bundle now.\n            bundle = new (bundleClass as any)(this.capoBundle);\n            bundleEntry.bundle = bundle;\n            bundleEntry.status = \"loaded\";\n            this.bundleEntries.set(filename, bundleEntry);\n        }\n\n        // this.bundleEntries.set(filename, { filename, bundle, types, importName });\n    }\n\n    hasBundleClass(filename: string) {\n        if (this.bundleEntries.has(filename)) {\n            return this.bundleEntries.get(filename)?.bundle !== undefined;\n        }\n        if (filename.startsWith(this.projectRoot)) {\n            const relativeFilename = path.relative(this.projectRoot, filename);\n            return this.hasBundleClass(\"./\" + relativeFilename);\n        }\n        console.log(\n            `heliosTypeGen: no bundle yet for ${filename}\\n` +\n                `${[...this.bundleEntries.keys()]\n                    .map((k) => `  - ${k}`)\n                    .join(\"\\n\")}`\n        );\n    }\n\n    generateBundleTypes(oneFile: string) {\n        const fn = this.normalizeFilePath(oneFile);\n        const bundleEntry = this.bundleEntries.get(fn);\n        if (!bundleEntry) {\n            throw new Error(`bundle not found: ${fn}`);\n        }\n        this.writeTypeInfo(oneFile, bundleEntry);\n        this.writeDataBridgeCode(\n            oneFile.replace(/(\\.hlb)?\\.[tj]s$/, \".bridge.ts\"),\n            bundleEntry\n        );\n\n        // this.writeReadDatabridge(\n        //     oneFile.replace(/\\.hlb\\.[tj]s$/, \".readData.ts\"),\n        //     bundleEntry\n        // );\n\n        // throw new Error(`don't use omnibus generation anymore!`);\n\n        // // for each bundle, generate the types\n        // for (const filename of this.bundleEntries.keys()) {\n        //     if (oneFile && oneFile !== filename) continue;\n        //     this.writeTypeInfo(filename);\n        // }\n    }\n\n    // uses the dataBridgeGenerator class to generate a *.bridge.ts file\n    writeDataBridgeCode(oneFilename: string, bundleEntry: BundleStatusEntry) {\n        const fn = this.normalizeFilePath(oneFilename);\n        const dataBridgeFn = fn.replace(/\\.hlb\\.[jt]s$/, \".bridge.ts\");\n\n        const bundle = bundleEntry.bundle;\n        const status = bundleEntry.status;\n        if (!bundle) {\n            console.warn(\n                `not writing data bridge for ${fn} for newly-added bundle (check for hasBundleClass() first?)`\n            );\n            return;\n        }\n        if (status !== \"loaded\") {\n            throw new Error(\n                `cannot generate data bridge for ${fn} with status ${status}`\n            );\n        }\n        const ts1 = Date.now();\n        // console.log(\"writing data bridge code: \", bundle.moduleName);\n        const bridgeGenerator = dataBridgeGenerator.create(bundle);\n        if (this.isStellarContracts())\n            bridgeGenerator._isInStellarContractsLib(true);\n        const bridgeSourceCode = this.isStellarContracts()\n            ? bridgeGenerator.generateDataBridge(fn, \"stellar-contracts\")\n            : bridgeGenerator.generateDataBridge(fn);\n        this.writeIfUnchanged(dataBridgeFn, bridgeSourceCode);\n        // console.log(`NOT writing data bridge code to ${dataBridgeFn}:${bridgeSourceCode}`);\n        writeFileSync(dataBridgeFn, bridgeSourceCode);\n        console.log(\n            `\uD83D\uDCE6 ${bundle.moduleName}: generated data bridge: ${\n                Date.now() - ts1\n            }ms`\n        );\n    }\n\n    writeIfUnchanged(filename: string, source: string) {\n        if (existsSync(filename)) {\n            const existingSource = readFileSync(filename, \"utf-8\");\n            if (existingSource === source) {\n                // console.log(`   -- unchanged: ${filename}`);\n                return;\n            }\n        }\n        writeFileSync(filename, source);\n        return source;\n    }\n\n    normalizeFilePath(filename: string) {\n        const fn = filename.startsWith(this.projectRoot)\n            ? path.relative(this.projectRoot, filename)\n            : filename;\n\n        if (fn.startsWith(\"/\")) debugger;\n        // console.log(\"normalizedFilePath: \", fn);\n        return fn;\n    }\n\n    writeTypeInfo(filename: string, bundleEntry: BundleStatusEntry) {\n        const fn = this.normalizeFilePath(filename);\n        const bundle = bundleEntry.bundle;\n        const status = bundleEntry.status;\n\n        if (!bundle) {\n            console.warn(\n                `not writing type info for ${filename} for newly-added bundle (check for hasBundleClass() first?)`\n            );\n            return;\n        }\n        if (status !== \"loaded\") {\n            throw new Error(\n                `cannot generate types for ${filename} with status ${status}`\n            );\n        }\n\n        let typeFilename = filename.replace(/(\\.hlb)?\\.[jt]s$/, \".typeInfo.ts\");\n        const { bundleClassName, parentClassName } = bundleEntry;\n\n        if (!parentClassName) {\n            throw new Error(`no parent class name for ${filename}`);\n        }\n\n        const ts1 = Date.now();\n        const typeContext = BundleTypeGenerator.create(bundle);\n        if (this.isStellarContracts())\n            typeContext._isInStellarContractsLib(true);\n\n        const typesSource = typeContext.createAllTypesSource(\n            bundleClassName,\n            parentClassName,\n            typeFilename\n        );\n        // console.log(\"not writing type info yet:\", {\n        //     filename,\n        //     typeFilename,\n        // });\n        // return\n\n        if (this.writeIfUnchanged(typeFilename, typesSource)) {\n            console.log(\n                `\uD83D\uDCE6 ${bundleClassName}: generated types (${Date.now() - ts1}ms)`\n            );\n        }\n    }\n\n    static findProjectRoot() {\n        // starting in the current working directory,\n        // look for package.json\n        // if not found, go up a directory and try again\n        // repeat until found or at root\n        // throw error if not found\n        // returns the full path to the project root\n\n        if (this.root) return this.root;\n\n        const cwd = process.cwd();\n        let dir = cwd;\n        let found = false;\n        while (!found) {\n            if (existsSync(path.join(dir, \"package.json\"))) {\n                found = true;\n            } else {\n                const parent = path.dirname(dir);\n                if (parent === dir) {\n                    throw new Error(\n                        `could not find package.json in ${cwd} or any parent directories`\n                    );\n                }\n                dir = parent;\n            }\n        }\n        console.log(`\uD83D\uDCE6 StellarHeliosProject: found project root at ${dir}`);\n        this.root = dir;\n        return dir;\n    }\n}\n\nfunction ts() {\n    return Date.now() - startTime;\n}\n", "import { genTypes } from \"@helios-lang/contract-utils\";\nimport type {\n    HeliosScriptBundle,\n} from \"../HeliosScriptBundle.js\";\nimport type {\n    anyTypeDetails,\n    EnumId,\n    EnumTypeMeta,\n    enumTypeDetails,\n    HeliosBundleTypeDetails,\n    HeliosBundleTypes, \n    makesUplcActivityEnumData,\n    singleEnumVariantMeta,\n    typeDetails,\n    TypeVariety,\n    VariantFlavor,\n    variantTypeDetails\n} from \"../HeliosMetaTypes.js\";\nimport type {\n    EnumTypeSchema,\n    VariantTypeSchema,\n    TypeSchema\n} from \"@helios-lang/type-utils\";\nimport type { DataType, EnumMemberType } from \"@helios-lang/compiler\";\n\nexport interface TypeGenHooks<T> {\n    registerNamedType?(details: anyTypeDetails): void;\n    getMoreEnumInfo?(details: enumTypeDetails): T;\n    getMoreStructInfo?(details: typeDetails): T;\n    getMoreVariantInfo?(details: variantTypeDetails): T;\n    getMoreTypeInfo?(details: typeDetails): T;\n}\n\n/**\n * Gathers any number of types expressible for an on-chain Helios script,\n * and generates types and type aliases for the off-chain TypeScript context.\n *\n * Each struct type is directly expressed as its name\n * Each enum type is expressed as a proxy type, unioned with the possible raw enum variants for that type\n * As each type is encountered (as a **nested field** within a datum or redeemer), any named types encountered\n * are added to the context, with any recursive expansions generated and added to the context, depth-first,\n * ... then the named type is used for the **nested field** where it was encountered.\n */\nexport class BundleTypes implements TypeGenHooks<undefined> {\n    topLevelTypeDetails: HeliosBundleTypeDetails;\n    topLevelDataTypes: HeliosBundleTypes;\n    namedTypes: Record<string, anyTypeDetails> = {};\n\n    constructor(\n        public bundle: HeliosScriptBundle,\n        public collaborator?: TypeGenHooks<any>\n    ) {\n        this.namedTypes = {};\n        const dataTypes = (this.topLevelDataTypes =\n            this.bundle.getTopLevelTypes());\n        this.topLevelTypeDetails = this.gatherTopLevelTypeDetails(dataTypes);\n    }\n\n    get activityTypeDetails(): anyTypeDetails {\n        return this.topLevelTypeDetails.redeemer;\n    }\n\n    get datumTypeDetails(): anyTypeDetails | undefined {\n        return this.topLevelTypeDetails.datum;\n    }\n\n    // it can begin gathering the types from the bundle's main contract\n    // this has a side-effect of adding all nested named types to the context\n    gatherTopLevelTypeDetails(\n        dataTypes: HeliosBundleTypes\n    ): HeliosBundleTypeDetails {\n        const {datum, redeemer, ...others} = dataTypes;\n        const typeDetails = {\n            datum: datum\n                ? this.gatherTypeDetails(datum)\n                : undefined,\n            redeemer: this.gatherTypeDetails(redeemer),\n        };\n\n        for (const [typeName, dataType] of Object.entries(others)) {\n            this.gatherTypeDetails(dataType as DataType);\n        }\n\n        return typeDetails\n    }\n\n    gatherTypeDetails(\n        type: DataType,\n        useTypeNamesAt?: \"nestedField\"\n    ): anyTypeDetails {\n        const schema = type.toSchema();\n        if (schema.kind === \"enum\") {\n            return this.gatherEnumDetails(type as any, useTypeNamesAt);\n        } else {\n            return this.gatherOtherTypeDetails(type, useTypeNamesAt);\n        }\n    }\n\n    /**\n     * type-gen interface: registers a named type in the context\n     */\n    registerNamedType(details: anyTypeDetails) {\n        const {\n            //@ts-expect-error - some schemas don't have a name, but anything here does.\n            typeSchema: { name },\n            canonicalTypeName,\n        } = details;\n        const useTypeName = canonicalTypeName || name;\n        if (!this.namedTypes[useTypeName]) {\n            this.namedTypes[useTypeName] = details;\n        } else {\n            // console.log(\"No need to re-register type:\", useTypeName, \"(right?)\");\n            // right!\n        }\n    }\n\n    private extractModuleName(id: string) {\n        return id.replace(/__module__(\\w+)?__.*$/, \"$1\");\n    }\n\n    private extractVariantParentName(id: string) {\n        // given input \"__module__CapoHelpers__CapoDatum[]__CharterData\",\n        //   ... returns \"CapoDatum\", not \"CapoHelpers\"\n        return id.replace(/__module__(\\w+)?__(\\w+)?\\[\\]__.*/, \"$2\");\n    }\n\n    gatherOtherTypeDetails(\n        dataType: DataType,\n        useTypeNamesAt?: \"nestedField\"\n    ): typeDetails {\n        // gathers names for any nested types, then generates minimal types\n        // based on having those names registered in the context.\n        let typeName: string | undefined = undefined;\n        const schema = dataType.toSchema();\n        if (schema.kind === \"enum\") {\n            throw new Error(\n                \"must not call gatherNonEnumTypeInfo with an enum schema\"\n            );\n        }\n        if (\"internal\" != schema.kind && \"name\" in schema) {\n            typeName = schema.name;\n        }\n\n        let parentNameMaybe : string | undefined = undefined;\n        // gather nested types where applicable, so they are added to the context.\n        switch (schema.kind) {\n            case \"internal\":\n                // built-in data types don't need to be registered in the type context\n                break;\n            case \"reference\":\n            case \"tuple\":\n                console.log(\n                    \"Not registering nested types for (as-yet unsupported)\",\n                    schema.kind\n                );\n                break;\n            case \"list\":\n                this.gatherTypeDetails((dataType as any)._types[0]);\n                // this.gatherTypeDetails(type.itemType);\n                break;\n            case \"map\":\n                this.gatherTypeDetails((dataType as any)._types[0]);\n                this.gatherTypeDetails((dataType as any)._types[1]);\n            case \"option\":\n                this.gatherTypeDetails((dataType as any)._types[0]);\n                break;\n            case \"struct\":\n                for (const field of dataType.fieldNames) {\n                    this.gatherTypeDetails(\n                        dataType.instanceMembers[field].asDataType!,\n                        \"nestedField\"\n                    );\n                }\n                break;\n            case \"variant\":\n                // we only hit this case when a nested variant is encountered\n                //   as a field of some other data structure, where only that specific variant-type\n                //   is expected.  When iterating the variants defined in an enum type,\n                //   gatherEnumDetails() calls gatherVariantDetails(), but when this path\n                //   is hit, we may need to gather those enum details separately.\n                // if (schema.name == \"CharterData\")\n                //     debugger;\n\n                const vType = dataType as EnumMemberType;\n                parentNameMaybe = vType.parentType.name;\n                return this.gatherVariantDetails(\n                    vType as any,\n                    { \n                        module:  this.extractModuleName(schema.id),\n                        enumName: vType.parentType.name\n                    }\n                );\n                break;\n            default:\n                //@ts-expect-error - when all cases are covered, schema is \u2039never\u203A\n                throw new Error(`Unsupported schema kind: ${schema.kind}`);\n        }\n\n        const canonType = this.mkMinimalType(\"canonical\", schema, undefined, parentNameMaybe);\n        const ergoType = this.mkMinimalType(\"ergonomic\", schema, undefined, parentNameMaybe);\n        const details: typeDetails<any> = {\n            typeSchema: schema,\n            typeName,\n            dataType,\n            canonicalType: canonType,\n            ergoCanonicalType:\n                ergoType == canonType\n                    ? typeName\n                        ? `${typeName}/*like canon-other*/`\n                        : ergoType\n                    : ergoType,\n            permissiveType: this.mkMinimalType(\"permissive\", schema, undefined, parentNameMaybe),\n            moreInfo: undefined,\n        };\n        // if (schema.kind !== \"internal\") debugger\n        // if (schema.kind === \"struct\") debugger\n        if (typeName) {\n            details.canonicalTypeName = typeName;\n            details.ergoCanonicalTypeName = `Ergo${typeName}`;\n            details.permissiveTypeName = `${typeName}Like`;\n            this.registerNamedType(details);\n            const moreInfo =\n                schema.kind == \"struct\"\n                    ? this.collaborator?.getMoreStructInfo?.(details)\n                    : this.collaborator?.getMoreTypeInfo?.(details);\n            if (moreInfo) details.moreInfo = moreInfo;\n            this.collaborator?.registerNamedType?.(details);\n        }\n        return details;\n    }\n\n    gatherEnumDetails(\n        enumType: { toSchema(): EnumTypeSchema } & DataType,\n        useTypeNamesAt?: \"nestedField\"\n    ): enumTypeDetails {\n        // gathers names for any nested types, then generates minimal types\n        // based on having those names registered in the context.\n        const schema = enumType.toSchema();\n        const enumName = schema.name;\n        const module = this.extractModuleName(schema.id);\n        // at type-gen time, we don't need this to be a fully-typed VariantMap.\n        //  ... a lookup record is fine.\n        const variants: Record<string, variantTypeDetails> = {};\n        for (const member of schema.variantTypes) {\n            const memberType =\n                enumType.typeMembers[member.name].asEnumMemberType;\n            if (!memberType) {\n                throw new Error(\n                    `Enum member type for ${member.name} not found`\n                );\n            }\n            variants[member.name] = this.gatherVariantDetails(\n                memberType as any,\n                { module, enumName }\n            );\n        }\n\n        if (useTypeNamesAt) {\n            // this happens when the enum is a nested field of a struct or variant\n            // console.log(\"enum\", enumName, \"is used as a nested field, and that's okay!\");\n            // it's fine to have this useTypeNames hint coming in, but we don't want\n            // to use the type-name when registering the enum itself; see \"XXX\" comments below.\n        }\n\n        const canonType = this.mkMinimalType(\"canonical\", schema);\n        const ergoType = this.mkMinimalType(\"ergonomic\", schema);\n        const details: enumTypeDetails<any> = {\n            enumName: schema.name,\n            dataType: enumType,\n            typeSchema: schema,\n            variants,\n            canonicalTypeName: `${enumName}`,\n            ergoCanonicalTypeName: `Ergo${enumName}`,\n            permissiveTypeName: `${enumName}Like`,\n            canonicalMetaType: this.mkMinimalEnumMetaType(\"canonical\", schema),\n            permissiveMetaType: this.mkMinimalEnumMetaType(\n                \"permissive\",\n                schema\n            ),\n            canonicalType: canonType,\n            ergoCanonicalType:\n                ergoType == canonType\n                    ? `${enumName}/*like canon enum*/`\n                    : ergoType,\n            permissiveType: this.mkMinimalType(\n                \"permissive\",\n                schema\n                // XXX here, we always want to register the true type of the enum, not the type-name\n                // XXX useTypeNamesAt\n            ),\n            moreInfo: undefined,\n        };\n        this.registerNamedType(details);\n        const moreInfo = this.collaborator?.getMoreEnumInfo?.(details);\n        if (moreInfo) details.moreInfo = moreInfo;\n        this.collaborator?.registerNamedType?.(details);\n\n        return details;\n    }\n\n    gatherVariantDetails(\n        variantDataType: { toSchema(): VariantTypeSchema } & EnumMemberType,\n        enumId: EnumId\n    ): variantTypeDetails {\n        if (!variantDataType.toSchema) debugger;\n        const schema = variantDataType.toSchema();\n\n        // console.log(\"Enum-variant name: \" + schema.name);\n        if (schema.kind !== \"variant\") {\n            throw new Error(\n                \"Must not call gatherVariantTypeInfo with a non-variant schema\"\n            );\n        }\n        const fieldCount = schema.fieldTypes.length;\n        const fields = {};\n\n        // uses dataType.fieldNames and dataType.instanceMembers to gather the fields\n        for (const fieldName of variantDataType.fieldNames) {\n            const fieldMember = variantDataType.instanceMembers[fieldName];\n            if (!fieldMember) {\n                throw new Error(`Field member ${fieldName} not found`);\n            }\n            fields[fieldName] = this.gatherTypeDetails(fieldMember.asDataType!);\n        }\n\n        const variantName = schema.name;\n        const canonicalTypeName =\n            fieldCount > 0 ? `${enumId.enumName}$${variantName}` : \"tagOnly\";\n        const permissiveTypeName =\n            fieldCount > 0\n                ? `${enumId.enumName}$${variantName}Like`\n                : \"tagOnly\";\n        const canonType = this.mkMinimalType(\n            \"canonical\",\n            schema,\n            undefined,\n            enumId.enumName\n        );\n        const ergoType = this.mkMinimalType(\n            \"ergonomic\",\n            schema,\n            undefined,\n            enumId.enumName\n        );\n        const details: variantTypeDetails<any> = {\n            fields,\n            fieldCount: fieldCount,\n            variantName: variantName,\n            typeSchema: schema,\n            dataType: variantDataType,\n            canonicalTypeName,\n            ergoCanonicalTypeName: `${enumId.enumName}$Ergo$${variantName}`,\n            permissiveTypeName,\n            canonicalType: canonType,\n            ergoCanonicalType:\n                ergoType == canonType\n                    ? `${enumId.enumName}$${variantName}/*ergo like-canonical-this-variant*/`\n                    : ergoType,\n            permissiveType: this.mkMinimalType(\n                \"permissive\",\n                schema,\n                undefined,\n                enumId.enumName\n            ),\n            canonicalMetaType: this.mkMinimalVariantMetaType(\n                \"canonical\",\n                schema,\n                enumId\n            ), //, \"nestedField\"),\n            permissiveMetaType: this.mkMinimalVariantMetaType(\n                \"permissive\",\n                schema,\n                enumId\n            ), //, \"nestedField\"),\n            moreInfo: undefined,\n        };\n        if (this.collaborator) {\n            const moreInfo = this.collaborator.getMoreVariantInfo?.(details);\n            details.moreInfo = moreInfo;\n        }\n        if (fieldCount == 1) {\n            // debugger\n        }\n\n        // don't register named types for tagOnly variants; worthless indirection\n        if (fieldCount > 1) {\n            this.registerNamedType(details);\n            this.collaborator?.registerNamedType?.(details);\n        }\n\n        // the enum itself is registered, and we don't need the variants registered separately.\n        // this.collaborator?.registerNamedType?.(details);\n        return details;\n    }\n\n    mkMinimalType(\n        typeVariety: TypeVariety,\n        schema: TypeSchema,\n        useTypeNamesAt?: \"nestedField\",\n        parentName?: string\n    ): string {\n        // uses the canonical underlying type for \"ergonomic\" versions of internal types\n        const varietyIndex = typeVariety === \"permissive\" ? 1 : 0;\n        //@ts-expect-error - not every schema-type has a name\n        let name = schema.name as string | undefined;\n        let nameLikeOrName = name;\n        let $nameLike = name ? `${name}Like` : undefined;\n\n        // switch on each schema kind...\n        switch (schema.kind) {\n            case \"internal\":\n                // use genType directly to return the indicated type\n                return genTypes(schema)[varietyIndex];\n            case \"reference\":\n                throw new Error(\"References are not yet supported\");\n            case \"tuple\":\n                throw new Error(\"Tuples are not yet supported\");\n            case \"list\":\n                return `Array<${this.mkMinimalType(\n                    typeVariety,\n                    schema.itemType,\n                    \"nestedField\"\n                )}>`;\n            case \"map\":\n                // todo: support string keys with simpler Record<string, ...> type\n                return `Map<${this.mkMinimalType(\n                    typeVariety,\n                    schema.keyType,\n                    \"nestedField\"\n                )}, ${this.mkMinimalType(\n                    typeVariety,\n                    schema.valueType,\n                    \"nestedField\"\n                )}>`;\n            case \"option\":\n                return `${this.mkMinimalType(\n                    typeVariety,\n                    schema.someType,\n                    useTypeNamesAt\n                )} | undefined`;\n            case \"struct\":\n                if (typeVariety === \"permissive\") {\n                    nameLikeOrName = $nameLike;\n                } else if (typeVariety === \"ergonomic\") {\n                    nameLikeOrName = `Ergo${name}`;\n                }\n                if (useTypeNamesAt) return nameLikeOrName as string;\n\n                return `{\\n${schema.fieldTypes\n                    .map(\n                        (field) =>\n                            `    ${\n                                field.name\n                            }: /*minStructField*/ ${this.mkMinimalType(\n                                typeVariety,\n                                field.type,\n                                \"nestedField\"\n                            )}`\n                    )\n                    .join(\"\\n\")}\\n}\\n`;\n            case \"enum\":\n                if (typeVariety === \"permissive\") {\n                    nameLikeOrName = $nameLike; // `IntersectedEnum<${$nameLike}>`;\n                } else if (typeVariety === \"ergonomic\") {\n                    nameLikeOrName = `Ergo${name}`;\n                }\n                if (useTypeNamesAt) return nameLikeOrName as string;\n\n                const module = this.extractModuleName(schema.id);\n                const enumId: EnumId = { module, enumName: name! };\n\n                return schema.variantTypes\n                    .map((variant) => {\n                        return `\\n        | { ${\n                            variant.name\n                        }: ${this.mkMinimalType(\n                            typeVariety,\n                            variant,\n                            \"nestedField\",\n                            enumId.enumName\n                        )} /*minEnumVariant*/ }`;\n                    })\n                    .join(\"\") + \"\\n\";\n\n            case \"variant\":\n                if (!parentName) {\n                    parentName = this.extractVariantParentName(schema.id);\n                }\n\n                const variantInfo = this.mkMinimalVariantType(\n                    schema,\n                    typeVariety,\n                    parentName\n                );\n                if (variantInfo === \"tagOnly\") return variantInfo;\n                if (Array.isArray(variantInfo)) {\n                    const fullVariantName = `${parentName}$${name}`;\n                    if (typeVariety === \"permissive\") {\n                        nameLikeOrName = `${parentName}$${$nameLike}`;\n                    } else if (typeVariety === \"ergonomic\") {\n                        // todo maybe; it will tend to shrink the type output size\n                        //  -- the issue is, the type info isn't necessarily available yet\n                        //  -- might need to use a two-pass process, gathering type info first\n\n                        // const thisType = this.namedTypes[fullVariantName];\n                        // if (!thisType) {\n                        //     debugger\n                        //     throw new Error(`No named type found for ${fullVariantName}`);\n                        // }\n                        // nameLikeOrName = thisType.canonicalType == thisType.ergoCanonicalType ?\n                        //     `${parentName}$${name} /*same as $Ergo$ variant*/` :\n                        nameLikeOrName = `${parentName}$Ergo$${name}`;\n                    } else {\n                        nameLikeOrName = fullVariantName;\n                    }\n                    if (useTypeNamesAt) return nameLikeOrName;\n\n                    return `{${variantInfo.join(`,`)}\\n` + `}\\n`;\n                } else {\n                    // variant only has one field\n\n                    return `/* implied wrapper { ${schema.fieldTypes[0].name}: ... } for singleVariantField */ \\n\\t\\t\\t${variantInfo}   `;\n                }\n            default:\n                //@ts-expect-error - when all cases are covered, schema is \u2039never\u203A\n                throw new Error(`Unsupported schema kind: ${schema.kind}`);\n        }\n    }\n\n    mkMinimalEnumMetaType(typeVariety: TypeVariety, schema: EnumTypeSchema) {\n        const name = schema.name;\n\n        const module = this.extractModuleName(schema.id);\n        const enumId: EnumId = { module, enumName: name! };\n        const $enumId = `{module: \"${enumId.module}\", enumName: \"${enumId.enumName}\"}`;\n\n        return `EnumTypeMeta<\\n    ${$enumId}, {\\n${schema.variantTypes\n            .map((variantSchema) => {\n                return `        ${\n                    variantSchema.name\n                }: ${this.mkMinimalVariantMetaType(\n                    typeVariety,\n                    variantSchema,\n                    enumId\n                    // \"nestedField\"\n                )}`;\n            })\n            .join(\",\\n\")}\\n    }\\n>;\\n`;\n    }\n\n    mkMinimalVariantMetaType(\n        typeVariety: TypeVariety,\n        schema: VariantTypeSchema,\n        enumId: EnumId\n        // useTypeNamesAt?: \"nestedField\"\n    ) {\n        // When writing an enum variant with 0 fields, the typescript api for generating\n        //   ... that enum variant data should require only the variant name,\n        //   ... IF it is accessed via that type's named proxy (e.g. mkDatum.variantName\n        //   ... or  `{ ..., someNestedField: /*proxy*/ SomeEnumType.variantName }`).  If not\n        //   ... using the proxy type, then raw `{ ... someNestedField: { variantName: {} } }`\n        //   ... form will be needed.\n        //\n        // When writing a single-field variant, the raw form needed will look like\n        //   ... `{ variantName: { singleFIeldName: \u2039nestedFieldData\u203A } }` or,\n        //   ... `{ ..., someNestedField: { variantName: { singleFieldName: \u2039nestedFieldData\u203A } } }`\n        //   ... while the interface can be used like\n        //   ... `mkDatum.variantName({...nestedFieldData})`\n        //   ...  or `{ ..., someNestedField: /*proxy*/ SomeEnumType.variantName(\u2039nestedFieldData\u203A) }`\n        //\n        // When an enum variant has multiple fields, we use the variant like a struct,\n        //   ... with each named field being represented in the the type-proxy:\n        //   ... `mkDatum.variantName({ field1: \u2039fieldData\u203A, field2: ... })`\n        //   ... or `{ ..., someNestedField: /*proxy*/ SomeEnumType.variantName({ field1: \u2039fieldData\u203A, field2: ... }) }`\n        //\n        // In all these cases, the types for any datum/redeemer enum (or enum nested-field)\n        //   ... should ideally indicate the EnumTypeProxy's aggregate named type, with the raw type\n        //   ... as a secondary alternative for people who prefer to write out the full structure.\n        //\n        // The types returned by the proxy's accessors will be identical to the raw types.\n        let variantName = schema.name;\n        // if (typeVariety === \"permissive\") {\n        //     if (useTypeNamesAt) {\n        //         // throw new Error(\"Write path not yet supported for variants\");\n        //         return `${variantName}Like /*writePath*/`;\n        //     }\n        //     // variant name remains unchanged in this case\n        //     // variantName = `${variantName}Like`;\n        // }\n        // if (useTypeNamesAt) return `${variantName}`;\n\n        const variantFlavor = this.variantFlavor(schema);\n        const $nlindent = \"\\n\" + \" \".repeat(12);\n        const $nloutdent = \"\\n\" + \" \".repeat(8);\n        let quotedFlavor =\n            \"fields\" === variantFlavor\n                ? `${$nlindent}\"${variantFlavor}\"`\n                : `\"${variantFlavor}\"`;\n\n        const fieldDefs = this.mkMinimalType(\n            typeVariety,\n            schema,\n            \"nestedField\",\n            enumId.enumName\n        );\n        // this.mkMinimalVariantType(schema, typeVariety);\n\n        const specialFlags: string[] = [];\n        if (schema.fieldTypes[0]?.name === \"seed\") {\n            specialFlags.push(`\"isSeededActivity\"`);\n        }\n        const $specialFlags = specialFlags.join(\" | \") || `\"noSpecialFlags\"`;\n        //pretter-ignore\n        const minimalVariantSrc =\n            `singleEnumVariantMeta<${enumId.enumName}Meta, \"${variantName}\",` +\n            `${$nlindent}\"Constr#${schema.tag}\", ${quotedFlavor}, ` +\n            `${fieldDefs}, ${$specialFlags}` +\n            `${$nloutdent}>`;\n        return minimalVariantSrc;\n    }\n\n    variantFlavor(schema: VariantTypeSchema): VariantFlavor {\n        switch (schema.fieldTypes.length) {\n            case 0:\n                return \"tagOnly\";\n            case 1:\n                return \"singletonField\";\n            default:\n                return \"fields\";\n        }\n    }\n\n    private mkMinimalVariantType(\n        schema: VariantTypeSchema,\n        typeVariety: TypeVariety,\n        parentName: string\n    ): string | string[] {\n        const $nlindent = \"\\n\" + \" \".repeat(4);\n        // const $nlindentMore = \"\\n\" + \" \".repeat(16);\n\n        const variantFlavor = this.variantFlavor(schema);\n        switch (variantFlavor) {\n            case \"tagOnly\":\n                return \"tagOnly\";\n            case \"singletonField\":\n                return this.mkMinimalType(\n                    typeVariety,\n                    schema.fieldTypes[0].type,\n                    \"nestedField\"\n                );\n            case \"fields\":\n                //pretter-ignore\n                return schema.fieldTypes.map(\n                    (field) =>\n                        `${$nlindent}${field.name}: ${this.mkMinimalType(\n                            typeVariety,\n                            field.type,\n                            \"nestedField\"\n                        )}  /*minVariantField*/ `\n                );\n            default:\n                throw new Error(\n                    `Incomplete switch or invalid variant flavor: ${variantFlavor}`\n                );\n        }\n    }\n}\n", "import { BundleTypes } from \"./BundleTypes.js\";\nimport type { HeliosScriptBundle } from \"../HeliosScriptBundle.js\";\nimport path from \"path\";\n\nconst CREATED = Symbol(\"withCreate\");\n\nexport class BundleBasedGenerator {\n    bundle: HeliosScriptBundle;\n    typeBundle!: BundleTypes;\n\n    /**\n     * ## Don't use this constructor directly!\n     * For proper initialization, you must use `\u2039class\u203A.create(bundle)`, not `new \u2039class\u203A(bundle)`\n     */\n    constructor(bundle: HeliosScriptBundle, isBrandedCreate: typeof CREATED) {\n        if (isBrandedCreate !== CREATED) {\n            throw new Error(`Invalid use of \\`new ${this.constructor.name}.new(bundle)\\`\\n  ... use \\`${this.constructor.name}.create(bundle)\\` instead`);\n        }\n        this.bundle = bundle;\n    }\n\n    /**\n     * provides delayed iniitalization of the BundleTypes\n     */\n    static create<T extends BundleBasedGenerator>(this: (\n        new (bundle: HeliosScriptBundle, isBrandedCreate: typeof CREATED) => T\n    ), bundle: HeliosScriptBundle): T {\n        const item = new this(bundle, CREATED)\n        item.initTypeBundle()\n        return item\n    }\n\n    initTypeBundle() {\n        this.typeBundle = new BundleTypes(this.bundle, this as any);\n    }\n\n    get namedTypes() {\n        return this.typeBundle.namedTypes;\n    }\n\n    get topLevelTypeDetails() {\n        return this.typeBundle.topLevelTypeDetails;\n    }\n\n    get activityTypeDetails() {\n        return this.typeBundle.activityTypeDetails;\n    }\n\n    get datumTypeDetails() {\n        return this.typeBundle.datumTypeDetails;\n    }\n\n    /**\n     * internal use for modifying imports for .hlb*.[tj]s that are part of the stellar contracts library\n     * if it is true, then the imports will be expressed in a way relative to the stellar contracts \n     * repository.  Otherwise, all the stellar contracts types will be imported from the\n     * \\`\\@donecollectively\\/stellar-contracts\\` package.\n     */\n    protected _isSC = false;\n    _isInStellarContractsLib(t: true) {\n        this._isSC = true;\n    }\n\n    /**\n     * computes relative path from inputFile to importFile\n     */\n    mkRelativeImport(inputFile: string, importFile: string) {\n        let relativePath = path.relative(\n            path.dirname(inputFile),\n            path.join(importFile)\n        );\n        if (relativePath[0] !== \".\") {\n            relativePath = `./${relativePath}`;\n        }\n        return relativePath;\n    }\n\n    get datumTypeName() {\n        return this.bundle.effectiveDatumTypeName();\n    }\n}", "\nimport type {\n    anyTypeDetails,\n    EnumId,\n    EnumTypeMeta,\n    enumTypeDetails,\n    HeliosBundleTypeDetails,\n    HeliosBundleTypes, makesUplcActivityEnumData,\n    singleEnumVariantMeta,\n    typeDetails,\n    variantTypeDetails\n} from \"../HeliosMetaTypes.js\";\nimport type {\n    EnumTypeSchema,\n    TypeSchema,\n    VariantTypeSchema,\n} from \"@helios-lang/type-utils\";\n\n// import { BundleTypes } from \"./BundleTypes.js\";\nimport { BundleBasedGenerator } from \"./BundleBasedGenerator.js\";\n\n/**\n * Gathers any number of types expressible for an on-chain Helios script,\n * and generates types and type aliases for the off-chain TypeScript context.\n *\n * Each struct type is directly expressed as its name\n * Each enum type is expressed as a proxy type, unioned with the possible raw enum variants for that type\n * As each type is encountered (as a **nested field** within a datum or redeemer), any named types encountered\n * are added to the context, with any recursive expansions generated and added to the context, depth-first,\n * ... then the named type is used for the **nested field** where it was encountered.\n * @public\n */\nexport class BundleTypeGenerator extends BundleBasedGenerator {\n    createAllTypesSource(\n        className: string,\n        parentClassName: string,\n        inputFile: string\n    ) {\n        let stellarImports = `        \nimport type {\n    CapoHeliosBundle,\n    CapoDelegateBundle,\n    minimalData,\n    HeliosScriptBundle,\n    EnumTypeMeta,\n    singleEnumVariantMeta,\n    tagOnly,\n    IntersectedEnum\n} from \"@donecollectively/stellar-contracts\"\n`;\n\n        if (this._isSC) {\n            stellarImports = `\nimport {HeliosScriptBundle} from \"${this.mkRelativeImport(\n                inputFile,\n                \"src/helios/HeliosScriptBundle.js\"\n            )}\"\nimport type { \n    tagOnly, \n    EnumTypeMeta, \n    singleEnumVariantMeta\n} from \"${this.mkRelativeImport(\n                inputFile,\n                \"src/helios/HeliosMetaTypes.js\"\n            )}\"\nimport type { minimalData } from \"${this.mkRelativeImport(\n            inputFile,\n            \"src/delegation/DelegatedData.js\"\n)}\"\nimport type { IntersectedEnum } from \"${this.mkRelativeImport(\n                inputFile,\n                \"src/helios/typeUtils.js\"\n            )}\"\n                \n`;\n            // import type {CapoHeliosBundle} from \"${this.mkRelativeImport(\n            //                 inputFile,\n            //                 \"src/CapoHeliosBundle.js\"\n            //             )}\"\n            // import type {CapoDelegateBundle} from \"${this.mkRelativeImport(\n            //                 inputFile,\n            //                 \"src/delegation/CapoDelegateBundle.js\"\n            //             )}\"\n            // `;\n        }\n        return (\n            \"\" +\n            `// generated by StellarHeliosProject using Stellar heliosRollupTypeGen()\n// recommended: CHECK THIS FILE INTO YOUR VERSION CONTROL SYSTEM\n//   ... and keep checking in the changes as your on-chain types evolve.\n//\n// NOTE: this file is auto-generated; do not edit directly\n\nimport type { UplcData } from \"@helios-lang/uplc\";\nimport type {\n    Address,\n    AssetClass,\n    DatumHash,\n    MintingPolicyHash,\n    PubKey,\n    PubKeyHash,\n    ScriptHash,\n    SpendingCredential,\n    StakingCredential,\n    StakingValidatorHash,\n    TimeRange,\n    TxId,\n    TxInput,\n    TxOutput,\n    TxOutputId,\n    InlineTxOutputDatum,\n    ValidatorHash,\n    Value,\n} from \"@helios-lang/ledger\";\nimport type { Cast } from \"@helios-lang/contract-utils\";\nimport type { \n    IntLike,\n    // BytesLike,\n } from \"@helios-lang/codec-utils\";\n\n type TimeLike = IntLike;\n \n${stellarImports}\n\n${this.generateNamedDependencyTypes()}\n`\n            // export default\n            // class ${className}\n            // extends ${parentClassName} {\n            // ${this.generateDatumApiTypes()}\n            // ${this.generateRedeemerApiTypes()}\n            // }\n            // `\n        );\n    }\n\n    generateNamedDependencyTypes() {\n        return Object.entries(this.namedTypes)\n            .map(([name, typeInfo]) => {\n                if (typeInfo.typeSchema.kind === \"enum\") {\n                    return this.generateEnumTypeSource(\n                        name,\n                        typeInfo as enumTypeDetails\n                    );\n                } else {\n                    return this.generateOtherNamedTypeSource(\n                        name,\n                        typeInfo as typeDetails\n                    );\n                }\n            })\n            .join(\"\\n\");\n    }\n\n    generateEnumTypeSource(name: string, typeInfo: enumTypeDetails) {\n        return (\n            `export type ${name}Meta = ${typeInfo.canonicalMetaType}\\n` +\n            `\\n/**\\n` +\n            ` * ${name} enum variants\\n` +\n            ` * \\n` +\n            ` * @remarks - expresses the essential raw data structures\\n` +\n            ` * supporting the **${\n                Object.keys(typeInfo.variants).length\n            } variant(s)** of the ${name} enum type\\n` +\n            ` * \\n` +\n            ` * - **Note**: Stellar Contracts provides a higher-level \\`${name}Helper\\` class\\n` +\n            ` *     for generating UPLC data for this enum type\\n` +\n            ` */\\n` +\n            `export type ${name} = ${typeInfo.canonicalType}\\n` +\n            `export type ${typeInfo.ergoCanonicalTypeName} = IntersectedEnum<${typeInfo.ergoCanonicalType}>\\n` +\n            // `// factory signatures for this Enum: \\n` +\n            // `// makesUplcEnumData<${name}Like>;\\n` +\n            // `// ^^ calling such a factory makes a EnumUplcResult\\n` +\n            // `// makesUplcActivityEnumData<${name}Like>; // if activity!\\n` +\n            // `// ^^ calling such a factory makes a EnumUplcResult\\n` +\n            // `// reader signature for this Enum: \\n` +\n            // `// readsUplcEnumData<${name}>;\\n` +\n            `\\n/**\\n` +\n            ` * ${name} enum variants (permissive)\\n` +\n            ` * \\n` +\n            ` * @remarks - expresses the allowable data structure\\n` +\n            ` * for creating any of the **${\n                Object.keys(typeInfo.variants).length\n            } variant(s)** of the ${name} enum type\\n` +\n            ` * \\n` +\n            ` * - **Note**: Stellar Contracts provides a higher-level \\`${name}Helper\\` class\\n` +\n            ` *     for generating UPLC data for this enum type\\n` +\n            ` *\\n` +\n            ` * ### Permissive Type\\n` +\n            ` * This is a permissive type that allows additional input data types, which are \\n` +\n            ` * converted by convention to the canonical types used in the on-chain context.\\n` +\n            ` */\\n` +\n            `export type ${name}Like = IntersectedEnum<${typeInfo.permissiveType}>\\n` +\n            \"\"\n        );\n    }\n\n    generateOtherNamedTypeSource(name: string, typeInfo: typeDetails) {\n        if (!typeInfo.ergoCanonicalTypeName) throw new Error(\"missing ergoCanonicalTypeName\");\n        if (!typeInfo.permissiveTypeName) throw new Error(\"missing permissiveTypeName\");\n        const schema = typeInfo.typeSchema;\n        const minimalTypeInfo = schema.kind === \"struct\" &&\n        !! schema.fieldTypes.find((f) => f.name === \"id\" && f.type.kind == \"internal\" && f.type.name == \"ByteArray\") &&\n        !! schema.fieldTypes.find((f) => f.name === \"type\" && f.type.kind == \"internal\" && f.type.name == \"String\") \n        ?\n            `export type minimal${typeInfo.canonicalTypeName} = minimalData<${typeInfo.permissiveTypeName}>` : \"\";\n\n        return (\n            `export type ${typeInfo.canonicalTypeName || name} = ${typeInfo.canonicalType}\\n` +\n            `export type ${typeInfo.ergoCanonicalTypeName} = ${typeInfo.ergoCanonicalType}\\n` +\n            `export type ${typeInfo.permissiveTypeName} = ${typeInfo.permissiveType}\\n`+\n            minimalTypeInfo\n        );\n    }\n\n    // // redeemer is write-only\n    // generateRedeemerApiTypes() {\n    //     return this.generateWriteApiTypes(\n    //         this.topLevelTypeDetails.redeemer,\n    //         \"Activity\"\n    //     );\n    // }\n\n    // // datums are read/write, when present\n    // generateDatumApiTypes() {\n    //     // datum: HeliosTypeInfo | HeliosEnumInfo) {\n    //     if (!this.topLevelTypeDetails.datum) {\n    //         return `// no datum types in this script`;\n    //     }\n\n    //     return (\n    //         this.generateWriteApiTypes(\n    //             this.topLevelTypeDetails.datum,\n    //             \"mkDatum\"\n    //         ) +\n    //         this.generateReadApiTypes(\n    //             this.topLevelTypeDetails.datum,\n    //             \"readDatum\"\n    //         )\n    //     );\n\n    //     // mkDatum: {\n    //     //     placeholder: \"generate proxy types here\";\n    //     // }\n    //     // readDatum: {\n    //     //     placeholder: \"show proxy types here\";\n    //     // }\n    // }\n\n    // generateWriteApiTypes(typeInfo: anyTypeDetails, accessorName?: string) {\n    //     if (!accessorName) {\n    //         //@ts-expect-error - name not always present\n    //         if (!typeInfo.typeSchema.name) {\n    //             throw new Error(\"typeName must be provided for unnamed types\");\n    //         }\n    //         //@ts-expect-error - name already guarded above\n    //         accessorName = `mk${typeInfo.typeSchema.name}`;\n    //     }\n    //     const isActivity = \"Activity\" == accessorName ? \"Activity\" : \"\";\n    //     if (typeInfo.typeSchema.kind === \"enum\") {\n    //         return `    ${accessorName}: makesUplc${isActivity}EnumData<${typeInfo.typeSchema.name}Like>;\\n`;\n    //     }\n\n    //     //@ts-expect-error - name not always present\n    //     if (typeInfo.typeSchema.name) {\n    //         //@ts-expect-error - name already guarded above\n    //         return `    ${accessorName}: uplcDataMaker<${typeInfo.typeSchema.name}Like>;\\n`;\n    //     } else {\n    //         console.log(\n    //             \" ????????? is non-named uplcDataMaker ever used?\\nyes:\" +\n    //                 new Error(\"\").stack!.split(\"\\n\").splice(2).join(\"\\n\")\n    //         );\n    //         return `    ${accessorName}: uplcDataMaker<${typeInfo.permissiveType}>;\\n`;\n    //     }\n    // }\n\n    // generateReadApiTypes(typeInfo: anyTypeDetails, accessorName?: string) {\n    //     if (!accessorName) {\n    //         //@ts-expect-error - name not always present\n    //         if (!typeInfo.typeSchema.name) {\n    //             throw new Error(\"typeName must be provided for unnamed types\");\n    //         }\n    //         //@ts-expect-error - name already guarded above\n    //         accessorName = `read${typeInfo.typeSchema.name}`;\n    //     }\n    //     if (typeInfo.typeSchema.kind === \"enum\") {\n    //         return `    ${accessorName}: readsUplcEnumData<${typeInfo.typeSchema.name}>;\\n`;\n    //     }\n    //     //@ts-expect-error - name not always present\n    //     if (typeInfo.typeSchema.name) {\n    //         //@ts-expect-error - name already guarded above\n    //         return `    ${accessorName}: readsUplcData<${typeInfo.typeSchema.name}>;\\n`;\n    //     }\n    //     return `    ${accessorName}: readsUplcData<${typeInfo.canonicalType}>;\\n`;\n    // }\n}\n", "import path from \"path\";\nimport { type TypeGenHooks } from \"./BundleTypes.js\";\nimport type {\n    anyTypeDetails,\n    enumTypeDetails,\n    typeDetails,\n    variantTypeDetails\n} from \"../HeliosMetaTypes.js\";\nimport type {\n    EnumTypeSchema,\n    TypeSchema,\n} from \"@helios-lang/type-utils\";\nimport { BundleBasedGenerator } from \"./BundleBasedGenerator.js\";\n\ntype dataBridgeTypeInfo = {\n    accessorCode: string;\n    castCode?: string;\n    helperClassName?: string;\n};\n\ntype fullDetails = anyTypeDetails<dataBridgeTypeInfo>;\ntype fullEnumTypeDetails = enumTypeDetails<dataBridgeTypeInfo>;\ntype fullVariantTypeDetails = variantTypeDetails<dataBridgeTypeInfo>;\ntype fullTypeDetails = typeDetails<dataBridgeTypeInfo>;\n\n/**\n * Gathers any number of types expressible for an on-chain Helios script,\n * and does code generation for a class, including accessors for generating typed data\n * by converting expected data using the Cast class.\n *\n * The class uses a various subclasses of DataBridge for different types defined\n * in the contract script.\n *\n * Uses the BundleTypes class as a helper, in which the bridge-generator is a\n * \"collaborator\" in that class.  Thus, the data-bridge has access to the same\n * key events in the schema-finding process, and can tap into all the essential\n * logic for finding types.\n *\n * This strategy is also used for generating the data-reader class.\n *\n * When generating methods in the new class, the following rules apply:\n *\n * 1.  Each struct type is directly exposed as its name, making \u2039bridge\u203A.\u2039struct name\u203A\n *      available for generating any data expected to match that form.\n *\n * 2.  Each enum type is exposed as its name, with nested accessors for each enum variant,\n *       ... with the accessors for each variant depend on the number of fields in the variant.\n *\n *     - if the variant has no fields, the accessor directly returns \u2039cast\u203A.toUplcData(\\{ variantName: \\{\\} \\})\n *\n *     - if the variant has a single field, the accessor is a function that takes the field value\n *        (with a strong type) and returns \u2039cast\u203A.toUplcData(\\{ variantName: \\{ fieldName: value \\} \\}\n *\n *     - if the variant has multiple fields, the accessor is a function that takes a strongly-typed\n *       object having the fields and returns \u2039cast\u203A.toUplcData(\\{ variantName: \\{ ...fields \\} \\})\n *\n * 3. Datum creator functions return a InlineTxOutputDatum, not just UplcData.\n *\n * 4. Reader types use an ergonomic type, where enum variants at any level are merged into a single\n *     type, not a union of its variants.  Enums and Structs with nested enums are also ergonomic.\n *\n * While gathering types, all the known type names are registered in a local namespace,\n * with function implementations gathered for each type.\n *\n * As each type is encountered (as a **nested field** within a datum or redeemer), any named\n * types encountered are added to the context, with any recursive expansions generated and\n * added to the context, depth-first... then the named type is used for the **nested field**\n * where it was encountered.\n * @public\n */\nexport class dataBridgeGenerator\n    extends BundleBasedGenerator\n    implements TypeGenHooks<dataBridgeTypeInfo>\n{\n    namedSchemas: Record<string, TypeSchema> = {};\n\n    // satisfies TypeGenHooks<dataBridgeTypeInfo> for creating more details for an enum type\n    getMoreEnumInfo?(typeDetails: enumTypeDetails): dataBridgeTypeInfo {\n        const enumName = typeDetails.enumName;\n        const helperClassName = `${enumName}Helper`;\n\n        this.namedSchemas[enumName] = typeDetails.typeSchema;\n\n        return {\n            accessorCode: `get ${enumName}() {\n                return new ${helperClassName}();\n            }`,\n            helperClassName,\n        };\n    }\n\n    getMoreStructInfo?(typeDetails: typeDetails): dataBridgeTypeInfo {\n        const structName = typeDetails.typeName!;\n        const castMemberName = `\u1C7A\u1C7A${structName}Cast`;\n        const helperClassName = `${structName}Helper`;\n\n        this.namedSchemas[structName] = typeDetails.typeSchema;\n\n        return {\n            castCode: `\n                 /*unused?*/ ${castMemberName}: Cast<${structName}Like, ${structName}> \n                    = makeCast<${structName}Like, ${structName}>(\n                        this.schema.${structName}, \n                        { isMainnet: true, unwrapSingleFieldEnumVariants: true }\n                    );\n            `,\n            accessorCode: `${structName}(fields: ${structName}Like}) {\n                throw new Error(\"hey, this isn't actually unused!\");\n                \n                return this.${castMemberName}.toUplcData(fields);\n            }`,\n            helperClassName,\n        };\n    }\n\n    getMoreVariantInfo?(details: variantTypeDetails): dataBridgeTypeInfo {\n        return {} as any;\n    }\n    getMoreTypeInfo?(details: typeDetails): dataBridgeTypeInfo {\n        return {} as any;\n    }\n\n    // creates a class providing an interface for creating each type of data relevent\n    // for a contract script, with an 'activity' accessor for creating redeemer data,\n    // a 'datum' accessor well-typed on-chain datum, and any utility functions defined\n    // in on-chain scripts.\n    // Any of these that are enums will have their own helper classes for creating\n    //  the enum's specific variants.\n    generateDataBridge(inputFile: string, projectName?: string) {\n        const { bridgeClassName } = this.bundle;\n\n        let imports =\n            /*-----------------imports---------------*/\n            `\nimport { makeCast, type Cast } from \"@helios-lang/contract-utils\"\nimport type { UplcData, ConstrData } from \"@helios-lang/uplc\";\nimport type { \n    IntLike,\n } from \"@helios-lang/codec-utils\";\nimport type {\n    Address,\n    AssetClass,\n    DatumHash,\n    MintingPolicyHash,\n    PubKey,\n    PubKeyHash,\n    ScriptHash,\n    SpendingCredential,\n    StakingCredential,\n    StakingValidatorHash,\n    TimeRange,\n    TxId,\n    TxInput,\n    TxOutput,\n    TxOutputId,\n    ValidatorHash,\n    Value,\n} from \"@helios-lang/ledger\";\n import { makeInlineTxOutputDatum, type InlineTxOutputDatum, type TxOutputDatum } from \"@helios-lang/ledger\";\nimport type { EnumTypeSchema, StructTypeSchema } from \"@helios-lang/type-utils\";\n\n`; // ---------------------/imports------------------------------\n        let scImports = /*--------------stellar-contracts-imports --------------*/ `import {\n    ContractDataBridge,\n    DataBridge, \n    DataBridgeReaderClass ,\n    EnumBridge,\n    impliedSeedActivityMaker,\n    type tagOnly, \n    type hasSeed, \n    type isActivity, \n    type funcWithImpliedSeed,\n    type SeedAttrs,\n    type JustAnEnum,\n    type callWith,\n    type IntersectedEnum,\n} from \"@donecollectively/stellar-contracts\"\\n`;\n        if (this._isSC) {\n            scImports =\n                `import { \n    DataBridge, \n    ContractDataBridge, \n    DataBridgeReaderClass,\n    type callWith,\n} from \"${this.mkRelativeImport(\n                    inputFile,\n                    \"src/helios/dataBridge/DataBridge.js\"\n                )}\"\\n` +\n                `import { \n    EnumBridge,\n    type JustAnEnum,\n} from \"${this.mkRelativeImport(\n                    inputFile,\n                    \"src/helios/dataBridge/EnumBridge.js\"\n                )}\"\\n` +\n                `import type { tagOnly } from \"${this.mkRelativeImport(\n                    inputFile,\n                    \"src/helios/HeliosMetaTypes.js\"\n                )}\"\\n` +\n                `import type { IntersectedEnum } from \"${this.mkRelativeImport(\n                    inputFile,\n                    \"src/helios/typeUtils.js\"\n                )}\"\\n` +\n                `import { \\n` +\n                `    impliedSeedActivityMaker, SeedActivity, type hasSeed, type isActivity, \\n` +\n                `    type funcWithImpliedSeed, type SeedAttrs\\n} from \"${this.mkRelativeImport(\n                    inputFile,\n                    \"src/ActivityTypes.js\"\n                )}\"\\n`;\n            //---------------------/sc-imports-----------------------;\n        }\n        return /* --------------overall file format----------------*/ `// generated by Stellar Contracts dataBridgeGenerator\n// based on types defined in ${this.bundle.program.name} (${\n            this.bundle.main.name\n        })\n// recommended: CHECK THIS FILE INTO YOUR VERSION CONTROL SYSTEM\n//   ... and keep checking in the changes as your on-chain types evolve.\n//\n// NOTE: this file is auto-generated; do not edit directly\n${imports}\n${scImports}\nexport type TimeLike = IntLike;\n\n${this.includeScriptNamedTypes(inputFile)}\n\n/**\n * GENERATED data bridge for **${\n     this.bundle.program.name\n }** script (defined in class ***${this.bundle.constructor.name}***)\n * main: **${this.bundle.main.name}**, project: **${\n            this.bundle.main.project || \"\u2039local proj\u203A\"\n        }**\n * @remarks - note that you may override \\`get dataBridgeName() { return \"...\" }\\` to customize the name of this bridge class\n* @public\n */\nexport class ${bridgeClassName} extends ContractDataBridge {\n    static isAbstract = false as const;\n    isAbstract = false as const;\n${this.includeDatumAccessors()}\n${this.includeActivityCreator()}\n${this.includeDataReaderHelper()}\n${this.includeTypeAccessors()}\n${this.includeUtilityFunctions()}\n}\nexport default ${bridgeClassName};\n${this.gatherHelperClasses()}\n${this.includeAllHelperClasses()}\n${this.includeNamedSchemas()}\n// }\n`;\n        //------------------------------/overall formal------------------------------\n    }\n\n    includeCastMemberInitializers() {\n        return Object.values(this.additionalCastMemberDefs).join(\"\");\n    }\n\n    includeDataReaderHelper() {\n        const readerClassName = `${this.bundle.bridgeClassName}Reader`;\n        this.helperClasses[readerClassName] =\n            this.generateDataReaderClass(readerClassName);\n        return `    reader = new ${readerClassName}(this);\\n`;\n    }\n\n    generateDataReaderClass(className: string) {\n        return `/*\n * @public\n */\nexport class ${className} extends DataBridgeReaderClass {\n    constructor(public bridge: ${this.bundle.bridgeClassName}) {\n        super();\n    }\n${this.includeEnumReaders()}\n${this.includeStructReaders()}\n}\\n`;\n    }\n\n    includeEnumReaders() {\n        return Object.keys(this.typeBundle.namedTypes)\n            .filter((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[typeName];\n                return typeDetails.typeSchema.kind === \"enum\";\n            })\n            .map((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[\n                    typeName\n                ] as unknown as fullEnumTypeDetails;\n                const helperClassName = typeDetails.moreInfo.helperClassName;\n                const isDatum = this.datumTypeName === typeName;\n\n                const generateFunc = /* -------------enum-reader-func--------------*/ `    /**\n        * reads UplcData *known to fit the **${typeName}*** enum type,\n        * for the ${this.bundle.program.name} script.\n        * ### Standard WARNING\n        * \n        * This is a low-level data-reader for use in ***advanced development scenarios***.\n        * \n        * Used correctly with data that matches the enum type, this reader\n        * returns strongly-typed data - your code using these types will be safe.\n        * \n        * On the other hand, reading non-matching data will not give you a valid result.  \n        * It may throw an error, or it may throw no error, but return a value that\n        * causes some error later on in your code, when you try to use it.\n        */\n    ${typeName}(d : UplcData) { \n        const typeHelper = this.bridge.types.${typeName};\n        const cast = typeHelper.\u1C7A\u1C7Acast;  \n\n        return cast.fromUplcData(d) as Ergo${typeName};        \n    } /* enumReader helper */\\n`;\n                //---------------/enum-reader-func--------------------\n                if (isDatum) {\n                    return (\n                        `datum = (d: UplcData) => { return this.${typeName}(d) }\\n` +\n                        generateFunc\n                    );\n                }\n                return generateFunc;\n            })\n            .join(\"\\n\");\n    }\n\n    includeStructReaders() {\n        return Object.keys(this.typeBundle.namedTypes)\n            .filter((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[typeName];\n                return typeDetails.typeSchema.kind === \"struct\";\n            })\n            .map((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[typeName];\n                const castMemberName = `\u1C7A\u1C7A${typeName}Cast`;\n                const isDatum = this.datumTypeName === typeName;\n                const func = /*-------------struct-reader-func--------------*/ `    /**\n        * reads UplcData *known to fit the **${typeName}*** struct type,\n        * for the ${this.bundle.program.name} script.\n        * ### Standard WARNING\n        * \n        * This is a low-level data-reader for use in ***advanced development scenarios***.\n        * \n        * Used correctly with data that matches the type, this reader\n        * returns strongly-typed data - your code using these types will be safe.\n        * \n        * On the other hand, reading non-matching data will not give you a valid result.  \n        * It may throw an error, or it may throw no error, but return a value that\n        * causes some error later on in your code, when you try to use it.\n        */\n    ${typeName}(d: UplcData) {\n        const cast = this.bridge.${castMemberName};\n        return cast.fromUplcData(d) //??? as Ergo${typeName};\n    } /* structReader helper */\\n`;\n                // ----------------struct-reader-func----------------\n                if (isDatum) {\n                    return (\n                        `datum = (d: UplcData) => { return this.${typeName}(d) }\\n` +\n                        func\n                    );\n                }\n                return func;\n            })\n            .join(\"\\n\");\n    }\n\n    additionalCastMemberDefs: Record<string, string> = {};\n\n    includeTypeAccessors() {\n        return (\n            `    /**\\n` +\n            `     * accessors for all the types defined in the \\`${this.bundle.program.name}\\` script\\n` +\n            `     * @remarks - these accessors are used to generate UplcData for each type\\n` +\n            `     */\\n` +\n            `    types = {\\n` +\n            this.includeEnumTypeAccessors() +\n            `\\n\\n` +\n            this.includeStructTypeAccessors() +\n            `    }    \\n\\n` +\n            this.includeCastMemberInitializers()\n        );\n    }\n\n    includeEnumTypeAccessors() {\n        const accessors = Object.keys(this.typeBundle.namedTypes)\n            .filter((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[typeName];\n                return typeDetails.typeSchema.kind === \"enum\";\n            })\n            .map((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[\n                    typeName\n                ] as unknown as fullEnumTypeDetails;\n                const helperClassName = typeDetails.moreInfo.helperClassName;\n\n                return (\n                    `      /**\\n` +\n                    `       * generates UplcData for the enum type ***${typeName}*** for the \\`${this.bundle.program.name}\\` script\\n` +\n                    `       */\\n` +\n                    `        ${typeName}: new ${helperClassName}(),`\n                );\n            })\n            .join(\"\\n\");\n\n        return accessors;\n    }\n\n    // emits accessors for all the struct types defined in the bundle\n    // for inclusion in the bridge's 'types' namespace\n    // gathers Cast initializers to include in the bridge class\n\n    includeStructTypeAccessors() {\n        const accessors = Object.keys(this.typeBundle.namedTypes)\n            .filter((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[typeName];\n                return typeDetails.typeSchema.kind === \"struct\";\n            })\n            .map((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[\n                    typeName\n                ] as unknown as fullTypeDetails;\n\n                const {\n                    canonicalTypeName,\n                    permissiveType,\n                    permissiveTypeName,\n                } = typeDetails;\n                const castMemberName = `\u1C7A\u1C7A${typeName}Cast`;\n                this.additionalCastMemberDefs[castMemberName] =\n                    `    /**\n                * uses unicode U+1c7a - sorts to the end */\\n` +\n                    `    ${castMemberName} = makeCast<${\n                        canonicalTypeName}, ${permissiveTypeName\n                    }>(\\n`+\n                    `        ${typeName}Schema,\\n`+\n                    `        { isMainnet: true, unwrapSingleFieldEnumVariants: true }\\n`+\n                    `    );\\n`;\n                return (\n                    `      /**\\n` +\n                    `       * generates UplcData for the enum type ***${typeName}*** for the \\`${this.bundle.program.name}\\` script\\n` +\n                    `       */\\n` +\n                    `        ${typeName}: (fields: ${permissiveTypeName} | ${permissiveType}) => {\n        return this.${castMemberName}.toUplcData(fields);\n    },`\n                );\n            })\n            .join(\"\\n\");\n\n        return accessors;\n    }\n    includeUtilityFunctions() {\n        // TODO: include any utility functions defined in the contract\n        return ``;\n    }\n\n    includeScriptNamedTypes(inputFile: string) {\n        // if (inputFile.match(/StructDatum/)) debugger;\n        const typeFile = inputFile.replace(/\\.bridge.ts$/, \".typeInfo.js\");\n        let relativeTypeFile = path.relative(path.dirname(inputFile), typeFile);\n        if (relativeTypeFile[0] !== \".\") {\n            relativeTypeFile = `./${relativeTypeFile}`;\n        }\n\n        return `\nimport type {\\n${Object.entries(this.typeBundle.namedTypes)\n            .map(\n                ([\n                    typeName,\n                    {\n                        canonicalTypeName,\n                        ergoCanonicalTypeName,\n                        permissiveTypeName,\n                    },\n                ]) => {\n                    return `    ${[\n                        canonicalTypeName,\n                        ergoCanonicalTypeName,\n                        permissiveTypeName,\n                    ]\n                        .filter((x) => !!x)\n                        .join(\", \")}`;\n                }\n            )\n            .join(\",\\n\")}\n} from \"${relativeTypeFile}\";\n\nexport type * as types from \"${relativeTypeFile}\";\nimport type * as types from \"${relativeTypeFile}\";\\n\\n`;\n    }\n\n    includeActivityCreator() {\n        // like datumAccessors, but without a need for reading\n        const activityDetails = this.activityTypeDetails;\n        if (!activityDetails) {\n            throw new Error(\n                `${this.bundle.constructor.name}: missing required activity type`\n            );\n        }\n\n        let schemaName = \"\";\n        let activityName;\n        switch (activityDetails.typeSchema.kind) {\n            case \"enum\":\n                activityName = activityDetails.typeSchema.name;\n                schemaName = `${activityName}Schema`;\n                break;\n            case \"variant\":\n                activityName = activityDetails.typeSchema.name;\n                schemaName = `${activityName}Schema`;\n                break;\n            case \"struct\":\n                activityName = activityDetails.typeSchema.name;\n                schemaName = `${activityName}Schema`;\n                break;\n            default:\n                schemaName = JSON.stringify(activityDetails.typeSchema);\n        }\n        const canonicalType =\n            activityDetails.canonicalTypeName! || activityDetails.canonicalType;\n        const permissiveType =\n            activityDetails.permissiveTypeName! ||\n            activityDetails.permissiveType;\n        const activityTypeName = activityDetails.canonicalTypeName!;\n        const castDef = `\n    \u1C7A\u1C7AactivityCast = makeCast<\n        ${canonicalType}, ${permissiveType}\n    >(${schemaName}, { \n        isMainnet: true,\n        unwrapSingleFieldEnumVariants: true\n    }); // activityAccessorCast`;\n\n        if (activityDetails.typeSchema.kind === \"enum\") {\n            //  enum -------------------\n            const helperClassName = `${activityName}Helper`;\n            return `\n    /**\n     * generates UplcData for the activity type (***${activityTypeName}***) for the \\`${this.bundle.program.name}\\` script\n     */\n    activity : ${helperClassName}= new ${helperClassName}({isActivity: true}); // activityAccessor/enum\n        ${activityName}: ${helperClassName} = this.activity;\\n`;\n            // ---------------------------------\n        } else if (activityDetails.typeSchema.kind === \"struct\") {\n            //  struct? -------------------\n            return `${castDef}\n\n    /**\n     * generates UplcData for the activity type (***${activityTypeName}***) for the \\`${this.bundle.program.name}\\` script\n     * @remarks - same as {@link activity}\n     */\n    ${activityTypeName}(fields: ${activityTypeName}Like) {\n        return this.\u1C7A\u1C7AactivityCast.toUplcData(fields);\n    }\\n\\n`; // --------------------------\n        } else {\n            //  not an enum, not a struct; probably an unnamed type -------------------\n            const permissiveTypeInfo = `${activityDetails.permissiveType}`;\n            const helperClassName = `OtherActivityTypeHelper`;\n            const helperClassType = `callWith<${permissiveTypeInfo}, ${helperClassName}>`;\n            const helperClassTypeCast = \"as any\";\n            const helperClass = this.mkOtherDataHelperClass(\n                helperClassName,\n                activityDetails as unknown as fullTypeDetails\n            );\n            this.helperClasses[helperClassName] = helperClass;\n\n            const moreTypeGuidance = /*------------*/ `\n     * \n     * This accessor object is callable with the indicated argument-type\n     * @example - contract.mkDatum(arg: /* ... see the indicated callWith args \\\\*\\\\/)\\\\n`;\n            // ---------------------------------\n            const accessorVarietyAnnotation = ` // activityAccessor/other\\n`;\n            return (\n                \"\" +\n                `    /**\\n` +\n                `     * Helper class for generating TxOutputDatum for the ***activity type ${\n                    activityTypeName ? `(${activityTypeName})` : \"\"\n                }***\\n` +\n                `     * (\"redeemer\" type) for this \\`${this.bundle.program.name}\\` contract script. ${moreTypeGuidance}\\n` +\n                `     */\\n` +\n                `    activity: ${helperClassType}\\n     = new ${helperClassName}({}) ${helperClassTypeCast} ` +\n                accessorVarietyAnnotation\n            );\n        }\n    }\n\n    includeDatumAccessors() {\n        const datumDetails = this.datumTypeDetails;\n        if (!datumDetails) {\n            // debugger;\n            this.datumTypeDetails;\n            return `datum = undefined // no datum type defined for this bundle (minter / rewards script)\\n`;\n        }\n\n        if (datumDetails.typeSchema.kind === \"variant\") {\n            throw new Error(`Datum as specific enum-variant not yet supported`);\n            // can frame this up with the same approach as the other-datum-type\n        }\n\n        // We always create a helper class for datum access, whether its a struct, enum,\n        //  ... or other type (including primitives)\n        //  - TODO: convert existing code-gen for struct-creators to add helper classes\n        //  - TODO: trigger creation of datum-helper class for non-struct/non-enum\n        // This arrangement ensures that the 'datum' property is a uniform type\n        //   ... generally, that type is Option<DataBridge> (minters and rewards scripts will have null here)\n        //\n        // if the datum type is is an enum or struct, we ALSO generate an accessor with its type name\n        let typeNameAccessor = \"\";\n        let helperClassName = \"\";\n        let helperClassType = \"\";\n        let datumTypeName = this.datumTypeName;\n        const typeName =\n            (\"canonicalTypeName\" in datumDetails\n                ? datumDetails.canonicalTypeName\n                : \"\") || datumDetails.canonicalType;\n        const permissiveTypeName =\n            (\"permissiveTypeName\" in datumDetails\n                ? datumDetails.permissiveTypeName\n                : \"\") || datumDetails.permissiveType;\n\n        let moreTypeGuidance = \"\";\n        let helperClassTypeCast = \"\";\n        let datumAccessorVarietyAnnotation = \"\";\n        if (datumDetails.typeSchema.kind === \"enum\") {\n            //@ts-expect-error - todo: use type-branding & type-inspection function to mke this safer\n            const d: fullEnumTypeDetails = datumDetails as fullEnumTypeDetails;\n            const {\n                moreInfo: { helperClassName: hCN },\n            } = d;\n            if (!hCN)\n                throw new Error(\n                    `missing helperClassName for enum ${d.enumName}`\n                );\n            helperClassName = hCN;\n            helperClassType = hCN;\n            typeNameAccessor =\n                `\\n    /**\\n` +\n                `     * this is the specific type of datum for the \\`${this.bundle.program.name}\\` script\\n` +\n                `     */\\n` +\n                `    ${datumDetails.typeSchema.name}: ${helperClassType} = this.datum;`;\n            datumAccessorVarietyAnnotation = ` // datumAccessor/enum\\n`;\n        } else if (datumDetails.typeSchema.kind === \"struct\") {\n            //@ts-expect-error - todo: use type-branding & type-inspection function to mke this safer\n            const d: fullTypeDetails = datumDetails as fullTypeDetails;\n            const {\n                moreInfo: { helperClassName: hCN },\n            } = d;\n            if (!hCN)\n                throw new Error(\n                    `missing helperClassName for struct ${d.typeName}`\n                );\n            helperClassName = hCN;\n            const permissiveTypeInfo = `${d.permissiveTypeName} | ${d.permissiveType}`;\n            helperClassType = `callWith<${permissiveTypeInfo}, ${hCN}>`;\n            helperClassTypeCast = \"as any\";\n            moreTypeGuidance = `\n     * \n     * This accessor object is callable with the indicated argument-type\n     * @example - contract.mkDatum(arg: /* ... see the indicated callWith args \\\\*\\\\/)\n    *\n    * ${permissiveTypeName} is the same as the expanded type details given\\n`;\n            // -----\n\n            typeNameAccessor =\n                `\\n\\n    /**\\n` +\n                `     * this is the specific type of datum for the \\`${this.bundle.program.name}\\` script\\n` +\n                `     * normally, we suggest accessing the \\`datum\\` property instead.\\n` +\n                `     */\\n` +\n                `    ${datumDetails.typeSchema.name}: ${helperClassType} = this.datum;`;\n            datumAccessorVarietyAnnotation = ` // datumAccessor/struct\\n`;\n        } else {\n            // triggers generation of a helper class for this type\n            //  ... and also sets the type name to callWith<helper-class>\n\n            const permissiveTypeInfo = `${datumDetails.permissiveType}`;\n            helperClassName = `OtherDatumTypeHelper`;\n            helperClassType = `callWith<${permissiveTypeInfo}, ${helperClassName}>`;\n            helperClassTypeCast = \"as any\";\n            this.helperClasses[helperClassName] = this.mkOtherDataHelperClass(\n                helperClassName,\n                datumDetails as unknown as fullTypeDetails\n            );\n            moreTypeGuidance = `\n     * \n     * This accessor object is callable with the indicated argument-type\n     * @example - contract.mkDatum(arg: /* ... see the indicated callWith args \\\\*\\\\/)\\\\n`;\n            // ----\n            datumAccessorVarietyAnnotation = ` // datumAccessor/other\\n`;\n        }\n        return (\n            \"\" +\n            `    /**\\n` +\n            `     * Helper class for generating TxOutputDatum for the ***datum type ${\n                datumTypeName ? `(${datumTypeName})` : \"\"\n            }***\\n` +\n            `     * for this contract script. ${moreTypeGuidance}\\n` +\n            `     */\\n` +\n            `    datum: ${helperClassType}\\n     = new ${helperClassName}({}) ${helperClassTypeCast} ` +\n            datumAccessorVarietyAnnotation +\n            typeNameAccessor +\n            `\\n\\n    readDatum : (d: UplcData) => Ergo${typeName} = (d) =>  {\\n` +\n            //            `        //return this.datum.\u1C7A\u1C7Acast.fromUplcData(d);\\n` +\n            `        return this.reader.${typeName}(d)\\n` +\n            `    }\\n`\n        );\n        // ----\n    }\n\n    mkOtherDataHelperClass(helperClassName: string, details: fullTypeDetails) {\n        const typeName =\n            (\"canonicalTypeName\" in details ? details.canonicalTypeName : \"\") ||\n            details.canonicalType;\n        const permissiveTypeName =\n            (\"permissiveTypeName\" in details\n                ? details.permissiveTypeName\n                : \"\") || details.permissiveType;\n        if (\n            details.typeSchema.kind != \"internal\" &&\n            (typeName || permissiveTypeName)\n        ) {\n            throw new Error(\n                `type name (${typeName}) and permissive type name (${permissiveTypeName}) are NOT expected for an other-data-type accessor (schema kind=${details.typeSchema.kind})`\n            );\n        }\n        const { canonicalType, permissiveType, typeSchema } = details;\n        const castDef =\n            `    /**\n        * uses unicode U+1c7a - sorts to the end */\\n` +\n            `    \u1C7A\u1C7Acast = makeCast<\n        ${canonicalType}, ${permissiveType}\n    >(\n        ${JSON.stringify(typeSchema)}, \n        { isMainnet: true, unwrapSingleFieldEnumVariants: true }\n    ); // datumAccessorCast\\n`;\n\n        return `export class ${helperClassName} extends DataBridge {\n    isCallable = true\n    ${castDef}\n    \n    } // mkOtherDatumHelperClass\n    `;\n\n        //         const datumAccessor = `\n        //     /**\n        //      * Generates UplcData for the datum type (${typeName}) for the ${this.bundle.program.name} script\n        //      */\n        //     datum(x: ${permissiveTypeName}) {\n        //         return this.\u1C7A\u1C7AdatumCast.toUplcData(x);\n        //     }\\n`;\n\n        //         const readDatum = `\n        //         /**\n        //          * reads UplcData for the datum type (${typeName}) for the ${this.bundle.program.name} script\n        //          */\n        //         readDatum(d: UplcData) { return this.\u1C7A\u1C7AdatumCast.fromUplcData(d); }\\n`;\n\n        //         if (details.typeSchema.kind === \"struct\") {\n        //             return (\n        //                 castDef +\n        //                 readDatum +\n        //                 datumAccessor +\n        //                 `\n        //     /**\n        //      * generates UplcData for the datum type (${typeName}) for the ${this.bundle.program.name} script\n        //      * @remarks - same as {@link datum}\n        //      */\n        // ` +\n        //                 `    ${details.typeSchema.name}(fields: ${permissiveTypeName}) {\\n` +\n        //                 `        return this.\u1C7A\u1C7AdatumCast.toUplcData(fields);\\n` +\n        //                 `    } // datumAccessor/byName \\n`\n        //             );\n        //         }\n\n        //         // if it's not an enum or struct, there's no name to expose separately;\n        //         // just the accessor+readDatum is enough, with it supporting cast object.\n\n        //         return castDef + readDatum + datumAccessor;\n    }\n\n    helperClasses: Record<string, string> = {};\n\n    // iterate all the named types, generating helper classes for each\n    gatherHelperClasses() {\n        const classSources = [] as string[];\n        for (const [name, typeDetails] of Object.entries(\n            this.typeBundle.namedTypes\n        )) {\n            if (typeDetails.typeSchema.kind === \"enum\") {\n                const enumDetails =\n                    typeDetails as unknown as fullEnumTypeDetails;\n                this.helperClasses[name] = this.mkEnumHelperClass(enumDetails);\n            } else if (typeDetails.typeSchema.kind === \"struct\") {\n                const structDetails = typeDetails as unknown as fullTypeDetails;\n                this.helperClasses[name] =\n                    this.mkStructHelperClass(structDetails);\n            }\n        }\n        return \"\";\n    }\n\n    includeAllHelperClasses() {\n        return Object.values(this.helperClasses).join(\"\\n\");\n    }\n\n    get redeemerTypeName() {\n        return this.activityTypeDetails.dataType.name;\n    }\n\n    nestedHelperClassName(\n        typeDetails: fullEnumTypeDetails,\n        isActivity: boolean\n    ) {\n        let helperClassName = typeDetails.moreInfo.helperClassName;\n        //  - matches \"Activities\" or \"Activity\":\n        if (isActivity && !helperClassName?.match(/Activit/)) {\n            helperClassName = `Activity${helperClassName}`;\n        }\n\n        return `${helperClassName}Nested`;\n    }\n\n    mkStructHelperClass(typeDetails: fullTypeDetails) {\n        const structName = typeDetails.typeName!;\n        return (\n            `/**\\n` +\n            ` * Helper class for generating UplcData for the struct ***${structName}*** type.\\n` +\n            ` * @public\\n`+\n            ` */\\n` +\n            `export class ${structName}Helper extends DataBridge {\\n` +\n            `    isCallable = true\\n` +\n            `   /**\n            * uses unicode U+1c7a - sorts to the end */\\n` +\n            `    \u1C7A\u1C7Acast = makeCast<${\n                typeDetails.canonicalTypeName}, ${ typeDetails.permissiveTypeName                     \n            }>(\\n`+\n            `        ${structName}Schema,\\n`+\n            `        { isMainnet: true, unwrapSingleFieldEnumVariants: true }\\n`+\n            `    );\\n\\n` +\n            `    // You might expect a function as follows.  We provide this interface and result, \\n` +\n            `    // using a proxy in the inheritance chain.\\n` +\n            `    // see the callableDataBridge type on the 'datum' property in the contract bridge.\\n` +\n            `    //\\n` +\n            `    //Also: if you're reading this, ask in our discord server about a \uD83C\uDF81 for curiosity-seekers! \\n` +\n            `    //\\n` +\n            `    // ${structName}(fields: ${typeDetails.permissiveTypeName}) {\\n` +\n            `    //    return this.\u1C7A\u1C7Acast.toUplcData(fields);\\n` +\n            `    //}\\n` +\n            `} //mkStructHelperClass \\n\\n`\n        );\n    }\n\n    mkEnumHelperClass(\n        typeDetails: fullEnumTypeDetails,\n        isActivity = this.redeemerTypeName === typeDetails.enumName,\n        isNested?: \"isNested\"\n    ) {\n        const enumName = typeDetails.enumName;\n        // const maybeNested = isNested ? \", Nested\" : \"\";\n        const isDatum = this.datumTypeName === enumName;\n        // console.log(this.datumTypeName, enumName, isDatum, \"-------------------------------------???\");\n        const parentClass = isActivity\n            ? `EnumBridge<isActivity>` // ${maybeNested}>`\n            : `EnumBridge<JustAnEnum>`; //${maybeNested}>`;\n        const normalType = isDatum ? \"InlineTxOutputDatum\" : \"UplcData\";\n\n        const helperClassName = isNested\n            ? this.nestedHelperClassName(typeDetails, isActivity)\n            : typeDetails.moreInfo.helperClassName;\n\n        return (\n            `/**\\n` +\n            ` * Helper class for generating ${normalType} for variants of the ***${enumName}*** enum type.\\n` +\n            ` * @public\\n` +\n            ` */\\n` +\n            `export class ${helperClassName} extends ${parentClass} {\\n` +\n            `    /*mkEnumHelperClass*/\\n` +\n            `    /**\n            *  uses unicode U+1c7a - sorts to the end */\\n` +\n            `    \u1C7A\u1C7Acast = makeCast<${\n                typeDetails.canonicalTypeName}, ${typeDetails.permissiveTypeName\n            }>(\\n`+\n            `        ${enumName}Schema,\\n`+\n            `        { isMainnet: true, unwrapSingleFieldEnumVariants: true }\\n`+\n            `    );\\n\\n` +\n\n            this.mkEnumVariantAccessors(\n                typeDetails,\n                isDatum,\n                isActivity,\n                isNested\n            ) +\n            `\\n}/*mkEnumHelperClass*/\\n\\n`\n        );\n    }\n\n    mkNestedEnumAccessor(\n        enumTypeDetails: fullEnumTypeDetails,\n        variantDetails: variantTypeDetails<dataBridgeTypeInfo>,\n        variantName: string,\n        fieldName: string,\n        oneField: anyTypeDetails<dataBridgeTypeInfo>,\n        isInActivity?: boolean\n    ) {\n        const enumName = enumTypeDetails.enumName;\n        const isActivity = isInActivity || this.redeemerTypeName === enumName;\n\n        const enumPathExpr = this.getEnumPathExpr(variantDetails);\n        const nestedEnumDetails = oneField.typeSchema as EnumTypeSchema;\n        const nestedEnumName = nestedEnumDetails.name;\n\n        const nestedEnumField: fullEnumTypeDetails = oneField as any;\n        const nestedHelperClassName = this.nestedHelperClassName(\n            nestedEnumField,\n            isActivity\n        );\n\n        const nestedHelper = this.mkEnumHelperClass(\n            nestedEnumField,\n            isActivity,\n            \"isNested\"\n        );\n\n        // registers the nested helper class\n        this.helperClasses[nestedHelperClassName] = nestedHelper; \n\n        // const nestedHelperTypeParams = `<\\n        ${\n        //     isActivity ? \"isActivity\" : \"JustAnEnum\"\n        // }, Nested\\n        >`;\n\n        const nestedFieldName = fieldName;\n        return (\n            `    /**\\n` +\n            `     * access to different variants of the ***nested ${nestedEnumName}*** type needed for ***${enumName}:${variantName}***.\\n` +\n            `     */\\n` +\n            `    get ${variantName}() {\\n` +\n            `        const nestedAccessor = new ${nestedHelperClassName}({\n            isNested: true, isActivity: ${isActivity ? \"true\" : \"false\"} \n        });\\n` +\n            `        ${\"//\"}@ts-expect-error drilling through the protected accessor.  See more comments about that above\\n` +\n            `        nestedAccessor.mkDataVia(\\n` +\n            `            (${nestedFieldName}: ${nestedEnumName}Like) => {\\n` +\n            `                return  this.mkUplcData({ ${variantName}: ${nestedFieldName} }, \n            ${enumPathExpr});\\n` +\n            `        });\\n` +\n            `        return nestedAccessor;\\n` +\n            `    } /* nested enum accessor */`\n        );\n    }\n\n    getEnumPathExpr(variantDetails: variantTypeDetails<any>, quoted = true) {\n        const { parentType } = variantDetails.dataType.asEnumMemberType!;\n        const enumName =\n            variantDetails.dataType.asEnumMemberType?.parentType.name;\n        // parentType.path looks like __module__SomeModule__EnumName[]\n        const [_1, _module, moduleName, _enumPlusBracket] =\n            parentType.path.split(\"__\");\n        //result should be SomeModule::EnumName.variantName\n\n        return JSON.stringify(\n            `${moduleName}::${enumName}.${variantDetails.variantName}`\n        );\n    }\n\n    mkEnumVariantAccessors(\n        enumDetails: fullEnumTypeDetails,\n        isDatum: boolean,\n        isActivity: boolean,\n        isNested?: \"isNested\"\n    ) {\n        const accessors = Object.keys(enumDetails.variants)\n            .map((variantName) => {\n                const variantDetails = enumDetails.variants[variantName];\n                const fieldCount = variantDetails.fieldCount;\n                const normalType = isDatum ? \"InlineTxOutputDatum\" : \"UplcData\";\n\n                if (fieldCount === 0) {\n                    const enumPathExpr = this.getEnumPathExpr(variantDetails);\n                    return (\n                        `/**\\n` +\n                        ` * (property getter): ${normalType} for ***${enumPathExpr}***\\n` +\n                        ` * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#${variantDetails.typeSchema.tag}***\\n` +\n                        ` */\\n` +\n                        `    get ${variantName}() {\\n` +\n                        `        const uplc = this.mkUplcData({ ${variantName}: {} }, \\n` +\n                        `            ${enumPathExpr});\\n` +\n                        (isDatum\n                            ? `        return makeInlineTxOutputDatum(uplc);\\n`\n                            : `        return uplc;\\n`) +\n                        `    } /* tagOnly variant accessor */`\n                    );\n                } else if (fieldCount === 1) {\n                    return this.mkSingleFieldVariantAccessor(\n                        enumDetails,\n                        variantDetails,\n                        variantName,\n                        isDatum,\n                        isActivity,\n                        isNested\n                    );\n                } else {\n                    return this.mkMultiFieldVariantAccessor(\n                        enumDetails,\n                        variantDetails,\n                        variantName,\n                        isDatum,\n                        isActivity,\n                        isNested\n                    );\n                }\n            })\n            .join(\"\\n\\n\");\n        return accessors;\n    }\n\n    private mkMultiFieldVariantAccessor(\n        enumTypeDetails: fullEnumTypeDetails,\n        variantDetails: variantTypeDetails<dataBridgeTypeInfo>,\n        variantName: string,\n        isDatum: boolean = this.datumTypeName === enumTypeDetails.enumName,\n        isActivity: boolean = this.redeemerTypeName ===\n            enumTypeDetails.enumName,\n        isNested?: \"isNested\"\n    ) {\n        function mkFieldType(fieldName: string, indent = 2): string {\n            const oneField = variantDetails.fields[fieldName];\n            let thatType = oneField.permissiveType;\n            if (\"permissiveTypeName\" in oneField) {\n                thatType = oneField.permissiveTypeName;\n            }\n            return (\n                `    `.repeat(indent) + `${fieldName}: ${thatType}`.trimEnd()\n            );\n        }\n        function unfilteredFields(indent = 2) {\n            return Object.keys(variantDetails.fields)\n                .map((x) => mkFieldType(x, indent))\n                .join(\",\\n\");\n        }\n        const { permissiveTypeName } = variantDetails;\n        const enumPathExpr = this.getEnumPathExpr(variantDetails);\n        const returnType = isActivity\n            ? \"isActivity\"\n            : isDatum\n            ? `InlineTxOutputDatum`\n            : \"UplcData\";\n        if (\"seed\" == Object.keys(variantDetails.fields)[0] && !isDatum) {\n            // && isSeededActivity\n            function filteredFields(\n                indent = 2,\n                callback = mkFieldType,\n                joiner = \",\\n\"\n            ) {\n                return Object.keys(variantDetails.fields)\n                    .filter((fieldName) => fieldName !== \"seed\")\n                    .map((x) => callback(x, indent))\n                    .join(joiner);\n            }\n\n            const activitySummary = `     * generates ${\n                isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n            } UplcData for ***${enumPathExpr}***, \\n`;\n\n            return (\n                `    /**\\n` +\n                activitySummary +\n                `     * given a transaction-context ***with a seed utxo*** and other field details\\n` +\n                `     * @remarks\\n` +\n                `     * See the \\`tcxWithSeedUtxo()\\` method in your contract's off-chain StellarContracts subclass \\n` +\n                `     * to create a context satisfying \\`hasSeed\\`.\\n` +\n                `     * See \\`$seeded$${variantName}}\\` for use in a context\\n` +\n                `     * providing an implicit seed utxo. \\n` +\n                (isNested\n                    ? `    * ### Nested activity: \\n` +\n                      `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                      `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                      `    * a complete wrapper for this inner activity detail.\\n`\n                    : \"\") +\n                `     */\\n` +\n                `    ${variantName}(value: hasSeed, fields: { \\n${filteredFields(\n                    2\n                )} \\n` +\n                `    } ) : ${returnType}\\n` +\n                `    /**\\n` +\n                `     * generates ${\n                    isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n                } UplcData for ***${enumPathExpr}*** \\n` +\n                `     * with raw seed details included in fields.\\n` +\n                `     */\\n` +\n                `    ${variantName}(fields: ${permissiveTypeName} | {\\n${unfilteredFields(\n                    3\n                )}\\n    } ): ${returnType}\\n` +\n                `    ${variantName}(\\n` +\n                `        seedOrUf: hasSeed | ${permissiveTypeName}, \\n` +\n                `        filteredFields?: { \\n${filteredFields(3)}\\n` +\n                `    }) : ${returnType} {\\n` +\n                `        if (filteredFields) {\\n` +\n                `            const seedTxOutputId = this.getSeed(seedOrUf as hasSeed);\\n` +\n                `            const uplc = this.mkUplcData({\\n` +\n                `                ${variantName}: { seed: seedTxOutputId, ...filteredFields } \\n` +\n                `            }, ${enumPathExpr});\\n` +\n                `           return uplc;\\n` +\n                `        } else {\\n` +\n                `            const fields = seedOrUf as ${permissiveTypeName}; \\n` +\n                `           const uplc = this.mkUplcData({\\n` +\n                `                ${variantName}: fields \\n` +\n                `            }, ${enumPathExpr});\\n` +\n                `           return uplc;\\n` +\n                `        }\\n` +\n                `    } /*multiFieldVariant/seeded enum accessor*/ \\n\\n` +\n                `    /**\\n` +\n                activitySummary +\n                `     * @param fields - \\\\{ ` +\n                filteredFields(0, undefined, \", \").replace(/([<{}>])/g, \"\\\\$1\") +\n                ` \\\\}\\n` +\n                `     * @remarks\\n` +\n                `    * ### Seeded activity\\n` +\n                `    * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.\\n` +\n                `     * ### Activity contains implied seed\\n` +\n                `     * Creates a SeedActivity based on the provided args, reserving space for a seed to be \\n` +\n                `     * provided implicitly by a SeedActivity-supporting library function. \\n` +\n                `     *\\n` +\n                `     * ## Usage\\n` +\n                `     *   1. Call the \\`$seeded$${variantName}({ ` +\n                filteredFields(0, (fn) => fn, \", \") +\n                ` })\\`\\n ` +\n                `     *       method with the indicated (non-seed) details.\\n` +\n                `     *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's\\n` +\n                `     *       \\`mkTxnCreateRecord({activity})\\` method.\\n` +\n                (isNested\n                    ? `    * ## Nested activity: \\n` +\n                      `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                      `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                      `    * a complete wrapper for this inner activity detail.\\n`\n                    : \"\") +\n                `     */\\n` +\n                `    $seeded$${variantName} = impliedSeedActivityMaker(this, \\n` +\n                `        this.${variantName} as (value: hasSeed, fields: { \\n${filteredFields(\n                    3\n                )} \\n` +\n                `        } ) => ${returnType}\\n` +\n                `    )\\n` +\n                `    /* coda: seeded helper in same multiFieldVariant/seeded */\\n`\n            );\n        }\n        return (\n            `    /**\\n` +\n            `     * generates ${\n                isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n            } ${\n                isDatum ? \"InlineTxOutputDatum\" : \"UplcData\"\n            } for ***${enumPathExpr}***\\n` +\n            `     * @remarks - ***${permissiveTypeName}*** is the same as the expanded field-types.\\n` +\n            (isNested\n                ? `    * ### Nested activity: \\n` +\n                  `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                  `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                  `    * a complete wrapper for this inner activity detail.\\n`\n                : \"\") +\n            `     */\\n` +\n            `    ${variantName}(fields: ${permissiveTypeName} | { \\n` +\n            unfilteredFields() +\n            `\\n` +\n            `    }) : ${returnType} {\\n` +\n            `        const uplc = this.mkUplcData({\\n` +\n            `            ${variantName}: fields \\n` +\n            `        }, ${enumPathExpr});\\n` +\n            (isDatum\n                ? `        return makeInlineTxOutputDatum(uplc);\\n`\n                : `       return uplc;\\n`) +\n            `    } /*multiFieldVariant enum accessor*/`\n        );\n    }\n\n    private mkSingleFieldVariantAccessor(\n        enumTypeDetails: fullEnumTypeDetails,\n        variantDetails: variantTypeDetails<dataBridgeTypeInfo>,\n        variantName: string,\n        isDatum: boolean = this.datumTypeName === enumTypeDetails.enumName,\n        isActivity: boolean = this.redeemerTypeName ===\n            enumTypeDetails.enumName,\n        isNested?: \"isNested\"\n    ) {\n        const fieldName = Object.keys(variantDetails.fields)[0];\n        const oneField = variantDetails.fields[fieldName];\n        const enumName =\n            variantDetails.dataType.asEnumMemberType?.parentType.name;\n        const enumPathExpr = this.getEnumPathExpr(variantDetails);\n\n        const returnType = isActivity\n            ? \"isActivity\"\n            : isDatum\n            ? \"InlineTxOutputDatum\"\n            : \"UplcData\";\n\n        if (\"enum\" == oneField.typeSchema.kind) {\n            return this.mkNestedEnumAccessor(\n                enumTypeDetails,\n                variantDetails,\n                variantName,\n                fieldName,\n                oneField,\n                isActivity\n            );\n        }\n        if (\"seed\" == fieldName && !isDatum) {\n            // && isSeededActivity\n            return (\n                `    /**\\n` +\n                `    * generates ${\n                    isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n                } UplcData for ***${enumPathExpr}***, \\n` +\n                `    * given a transaction-context (or direct arg) with a ***seed utxo*** \\n` +\n                `    * @remarks\\n` +\n                `    * ### Seeded activity\\n` +\n                `    * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.\\n` +\n                `    *  - to get a transaction context having the seed needed for this argument, \\n` +\n                `    *    see the \\`tcxWithSeedUtxo()\\` method in your contract's off-chain StellarContracts subclass.\\n` +\n                `    * - or see the {@link hasSeed} type for other ways to feed it with a TxOutputId.\\n` +\n                `    *  - in a context providing an implicit seed utxo, use \\n` +\n                `    *    the \\`$seeded$${variantName}}\\` variant of this activity instead\\n` +\n                `    *\\n ` +\n                (isNested\n                    ? `    * ## Nested activity: \\n` +\n                      `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                      `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                      `    * a complete wrapper for this inner activity detail.\\n`\n                    : \"\") +\n                `    */\\n` +\n                `    ${variantName}(thingWithSeed: hasSeed | ${oneField.permissiveType}) \\n` +\n                `    : ${returnType} {\\n` +\n                `        const seedTxOutputId = this.getSeed(thingWithSeed);\\n` +\n                (isNested\n                    ? `\\n        // piped through parent's uplc-encoder\\n`\n                    : \"\") +\n                `        const uplc = this.mkUplcData({ \\n` +\n                `           ${variantName}: seedTxOutputId\\n` +\n                `        },${enumPathExpr});  \\n` +\n                `        return uplc;\\n` +\n                `    }  /*singleField/seeded enum variant*/\\n\\n` +\n                `    /**\\n` +\n                `     * generates ${\n                    isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n                } UplcData for ***${enumPathExpr}***\\n` +\n                `     * @remarks\\n` +\n                `    * ### Seeded activity\\n` +\n                `    * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.\\n` +\n                `     * ### Activity contains implied seed\\n` +\n                `     * Creates a SeedActivity based on the provided args, reserving space for a seed to be \\n` +\n                `     * provided implicitly by a SeedActivity-supporting library function. \\n` +\n                `     * ## Usage\\n` +\n                `     * Access the activity-creator as a getter: \\`$seeded$${variantName}\\`\\n` +\n                `     *\\n` +\n                `     * Use the resulting activity-creator in a seed-providing context, such as the delegated-data-controller's\\n` +\n                `     * \\`mkTxnCreateRecord({activity, ...})\\` method.\\n` +\n                (isNested\n                    ? `    * ## Nested activity: \\n` +\n                      `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                      `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                      `    * a complete wrapper for this inner activity detail.\\n`\n                    : \"\") +\n                `     */\\n` +\n                `    get $seeded$${variantName}() {\\n`+\n                `        return impliedSeedActivityMaker(this,this.${variantName})() // called with no args needed\\n` +\n                `    } /* coda: seeded helper in same singleField/seeded enum variant*/\\n`\n            );\n        }\n        let thatType = oneField.permissiveType || \"\";\n        let expandedTypeNote = \"\";\n        if (\"permissiveTypeName\" in oneField) {\n            thatType = `${oneField.permissiveTypeName} | ${oneField.permissiveType}`;\n            expandedTypeNote = `     * @remarks - ***${oneField.permissiveTypeName}*** is the same as the expanded field-type.\\n`;\n        }\n        const argNameIsFieldName = fieldName;\n        return (\n            `    /**\\n` +\n            `     * generates ${\n                isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n            } ${\n                isDatum ? \"InlineTxOutputDatum\" : \"UplcData\"\n            } for ***${enumPathExpr}***\\n${expandedTypeNote}` +\n            (isNested\n                ? `    * ## Nested activity: \\n` +\n                  `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                  `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                  `    * a complete wrapper for this inner activity detail.\\n`\n                : \"\") +\n            `     */\\n` +\n            `    ${variantName}(\\n` +\n            `        ${argNameIsFieldName}: ${thatType.trimEnd()}\\n` +\n            `    ) : ${returnType} {\\n` +\n            `        const uplc = this.mkUplcData({ \\n` +\n            `           ${variantName}: ${argNameIsFieldName}\\n` +\n            `        }, ${enumPathExpr}); /*singleField enum variant*/\\n` +\n            (isDatum\n                ? `        return makeInlineTxOutputDatum(uplc);\\n`\n                : `       return uplc;\\n`) +\n            `    }`\n        );\n    }\n\n    includeNamedSchemas() {\n        const schemas = Object.entries(this.namedSchemas)\n            .map(([name, schema]) => {\n                const type =\n                    schema.kind === \"enum\"\n                        ? \"EnumTypeSchema\"\n                        : \"StructTypeSchema\";\n                return `export const ${name}Schema : ${type} = ${JSON.stringify(\n                    schema,\n                    null,\n                    4\n                )};`;\n            })\n            .join(\"\\n\\n\");\n        return schemas;\n    }\n\n    // gatherNonEnumDatumAccessors(datumTypeName: string) {\n    //     const details = this.datumTypeDetails as typeDetails;\n    //     const fields = Object.keys(details.fields).map(fieldName => {\n    //         return `${fieldName}: ${details.fields[fieldName].canonicalTypeName}`;\n    //     }).join(\", \");\n    //     return `get ${datumTypeName}() {\n    //         return this.toUplcData({ ${datumTypeName}: { ${fields} } });\n    //     }`;\n    // }\n}\n", "import type { CompileOptions } from \"@helios-lang/compiler\";\nimport type { InlineTxOutputDatum } from \"@helios-lang/ledger\";\nimport type { UplcProgramV2 } from \"@helios-lang/uplc\";\n\n/**\n * @public\n */\nexport type CompileOptionsForCachedHeliosProgram = CompileOptions & {\n    /**\n     * The timeout for waiting for another instance to finish compiling.\n     * Defaults to 30 seconds.\n     */\n    timeout?: number;\n};\n\n/**\n * @public\n */\nexport type anyUplcProgram = UplcProgramV2;\n// | UplcProgramV3;\n\nexport { \n    encodeUtf8 as textToBytes,\n    decodeUtf8 as bytesToText,\n} from \"@helios-lang/codec-utils\";\n\n/**\n * tuple expressing a token-name and count\n * @public\n **/\nexport type tokenNamesOrValuesEntry = [string | number[], bigint];\n/**\n * Tuple of byte-array, count, needed for Value creation on native tokens.\n * @public\n **/\nexport type valuesEntry = [number[], bigint];\n\n/**\n * @public\n */\nexport type InlineDatum = InlineTxOutputDatum\n\n"],
  "mappings": "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",
  "names": ["existsSync", "readFileSync", "path", "createFilter", "readFileSync", "path", "path", "path", "path", "filteredFields", "path", "readFileSync", "path", "existsSync", "createFilter", "options", "readFileSync"]
}
