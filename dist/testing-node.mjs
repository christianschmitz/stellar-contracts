import { bytesToHex, decodeUtf8, isValidUtf8, encodeUtf8, equalsBytes } from '@helios-lang/codec-utils';
import { makeByteArrayData, makeIntData } from '@helios-lang/uplc';
import { makeAddress, makeNetworkParamsHelper, makeTxOutput, makeValue, makeAssetClass, makeDummyAddress, makeTxOutputId, makeValidatorHash, makeMintingPolicyHash, makeInlineTxOutputDatum, makeAssets, makeTxInput, makeTxId, makeDummyMintingPolicyHash, DEFAULT_NETWORK_PARAMS, makeStakingAddress } from '@helios-lang/ledger';
import { encodeBech32, blake2b, generateBytes, mulberry32 } from '@helios-lang/crypto';
import { HeliosProgramWithCacheAPI } from '@donecollectively/stellar-contracts/HeliosProgramWithCacheAPI';
import { makeTxBuilder, makeWalletHelper, SECOND, makeEmulatorGenesisTx, makeEmulatorRegularTx, restoreRootPrivateKey, BIP39_DICT_EN, makeRootPrivateKey } from '@helios-lang/tx-utils';
import { makeCast } from '@helios-lang/contract-utils';
import { makeSource } from '@helios-lang/compiler-utils';

const heliosModule$a = {
  content: "\n\nmodule CapoMintHelpers\nimport {\n    mustFindInputRedeemer,\n    mkTv,\n    TODO,\n    REQT,\n    tvCharter\n} from StellarHeliosHelpers\n\nimport {tx, get_current_input} from ScriptContext\n\nimport {\n    getTxCharterData,\n    CapoCtx,\n    mkCapoCtx,\n    DelegateInput,\n    CapoDatum, \n    CapoActivity\n} from CapoHelpers\n\n\nimport {\n    RelativeDelegateLink,\n    AbstractDelegateActivitiesEnum,\n    DelegateLifecycleActivity\n} from CapoDelegateHelpers\n\nfunc hasSeedUtxo(tx: Tx, seedUtxo: TxOutputId\n    // , reason: String\n) -> Bool {\n    if (!tx.inputs.any( (input: TxInput) -> Bool {\n        input.output_id == seedUtxo\n    })) {\n        print(\" - expected seedUtxo: \");\n        print(seedUtxo.show());\n        print(\"\\n\");\n        // + \"\\n\"+seedUtxo.tx_id.show() + \" : \" +seedUtxo.index.show()\n        assert(false, \"missing expected seed input for minting\")\n        // +reason \n    };\n    print( \"  -- has seed -> ok\\n\");\n    true\n}\n\nfunc noOtherActivitiesSupported( _: AbstractDelegateActivitiesEnum) -> Bool {\n    print(\"yikes, expected the delegate to use activity DelegateLifecycleActivities:ReplacingMe or authorizingDelegate...\\n\");\n    print(\"   -- note: for other cases, a context-specific check via validateUutMinting's (\\n\"+\n      \"  ...\\n  checkMintDgtActivity: (AbstractDelegateActivitiesEnum) -> Bool)\\n\"+\n      \") option can be used to steer around this failure.\\n\");\n    assert(false, \"unexpected delegate activity\");\n    false\n}\n\nfunc requiresDelegateAuthorizingMint(\n    delegateLink: RelativeDelegateLink, \n    mph: MintingPolicyHash,     \n    extraMintDelegateRedeemerCheck: Bool = true,\n    checkMintDgtActivity: (AbstractDelegateActivitiesEnum) -> Bool = noOtherActivitiesSupported\n) -> Bool {\n    authzVal : Value = Value::new(AssetClass::new(mph, delegateLink.uutName.encode_utf8()), 1);\n    REQT(\"requires the charter's mint-delegate to authorize this mint activity\");\n    print(\"  -- finding input dgTkn: \" + delegateLink.uutName);\n\n    targetId: TxOutputId = tx.inputs.find_safe((i: TxInput) -> {\n        // print(\"   ?  in \"+i.value.show());\n        i.value.contains(authzVal) // find my authority token\n    }).switch{\n        Some{x} => x.output_id,\n        None => error(\"  ❌❌ missing dgTkn \"+delegateLink.uutName)\n    };\n    print (\"    -- ✅ ➡️  💁found dgTkn ^\");\n    spendsAuthorityUut : ScriptPurpose = tx.redeemers.find_key( \n        (purpose : ScriptPurpose) -> { purpose.switch{ \n            sp: Spending => {\n                // print (\"oid: \" + sp.output_id.show());\n                sp.output_id == targetId\n            }, \n            _ => false \n        } }\n    );\n\n    // r : Data = tx.redeemers.get(  // index redeemers by...\n    //     ScriptPurpose::new_spending(  // [spending, plus ...\n    //     );\n        //!!! Todo replace this with a return of Option[delegate-redeemer}?\n    err : String = \"dgTkn \"+delegateLink.uutName+\" not being spent as expected\"; // \"not spent with an authorizing activity!\")\n    maybeCheckedMintDelegateAuthority : Bool = tx.redeemers.get_safe(\n        spendsAuthorityUut\n    ).switch {\n        None => {\n            error(err)\n        },\n        Some{x} => {\n            activity = AbstractDelegateActivitiesEnum::from_data(x);\n            activity.switch {\n                DelegateLifecycleActivities{DLA} => {\n                    TODO(\"VERIFY we ---------------- don't need the funny redeemer-check skipping\");\n                    if (!extraMintDelegateRedeemerCheck) {\n                        print(\" vvv wherever it is, probably best it uses the checkMintDgtActivity option\");\n                        error(\"where is extraMintDelegateRedeemerCheck=false really needed?\")\n                        //     print(\"  -- ok, dgTkn spent\\n\");\n                        //     print(\"  ---- skip redeemer check\\n\");\n                        //     true\n                    };\n                    DLA.switch {\n                        ReplacingMe => {\n                            print(\"  -- ok, dgTkn spent\\n\");\n                            true\n                        },\n                        Retiring => error(\"DLA::Retiring can't mint!\"),\n                        ValidatingSettings => error(\"DLA::ValidatingSettings can't mint!\")\n                    }\n                },\n                _ => checkMintDgtActivity(activity)\n            }\n        }\n    };\n    delegateDidAuthorize = true; // otherwise, we'd have failed above.\n\n    // NOTE: DOESN'T CHECK that the AUTHORIZING DELEGATE is returned anywhere specific.\n    //    - it's not generally a minting responsibility (however, as an exception the bootstrap charter event DOES \n    //      actually check for valid delegate outputs).  All other cases should have the correct\n    //      delegate outputs checked (e.g. in the Capo's CharterData spend checker).\n    // maybeCheckDelegateOutput : Bool = if (!checkDelegateOutput) {\n    //     print(\"  -- skipping check for expected delegate output \");\n    //     true\n    // } else {\n    //     delegateLink.hasValidOutput(mph)        \n    // };\n    delegateDidAuthorize && maybeCheckedMintDelegateAuthority\n}\n\nfunc requiresMintDelegateApproval(\n    mph: MintingPolicyHash\n) -> Bool {\n    cctx : CapoCtx = mkCapoCtx(mph).withCharterRef();\n    print(\"Minter needs mintDgt + mint activity\\n\");\n    REQT(\"EXPECTS the application-specific mintDelegate to explicitly check and approve the full minted value\");\n    \n    // print (\"      ❇️  \"+ \n    //     tx.minted.get_policy(mph).to_list(\n    //         (b : ByteArray, i: Int) -> String { \n    //             i.show() + \"x \" + b.decode_utf8()\n    //         }\n    //     ).join(\" + \") \n    // + \"\\n\");\n\n    print(\"    -- ^ e.g. assert(tx.minted.get_policy(mph) == expectedMintedValue);\\n\");\n    print(\"    ---- (if it's only responsible for one minting policy)\\n\");\n    // if (true) {\n        // todo: enforces minting invariants.\n        TODO(\"must enforce minting invariants\");\n    // }; \n\n    mintDgtInput : DelegateInput = cctx.requiresMintDelegateInput();\n    mintDgtActivity : AbstractDelegateActivitiesEnum = mintDgtInput.genericDelegateActivity();\n\n\n    // TODO restore this: mintDgtInput.requiresValidOutput() && \n    mintDgtActivity.switch {\n        CapoLifecycleActivities{CLA} => CLA.switch {\n            CreatingDelegate => {\n                TODO( \"make this obsolete: generic creatingDelegate (use queuePendingChange and committingPendingChanges in sequence)\");\n                // print(\"  -- minter wants mintDgt + CapoLifecycle (delegate-creation)\\n\");\n\n                mintDgtInput.requiresValidOutput() && \n                true\n            },\n            queuePendingChange => {\n                print(\"  -- ok: mintDgt using CapoLifecycle.queuePendingChange)\\n\");\n                mintDgtInput.requiresValidOutput() && \n                true\n            },\n            forcingNewSpendDelegate => error(\"invalid forcingNewSpendDelegate activity on mintDgt (escape-hatch reserved for Minter/Capo pair)\"),\n            forcingNewMintDelegate => error(\"invalid forcingNewMintDelegate activity on mintDgt (escape-hatch reserved for Minter/Capo pair)\"),\n            _ => error(\"mint dgt can only approve CapoLifecycleActivities.queuePendingChange or non-CLA activities\")\n            // _ => error(\"no\")// ---- left as a compile-time error if any further variants are added \n        },\n        SpendingActivities => error(\"DelegateInput::SpendingActivity can't mint!\"),\n        DelegateLifecycleActivities{DLA} => {\n            DLA.switch {\n                ReplacingMe => {\n                    TODO( \"relay delegate installation sequence\" \n                        // \"the new delegate should be minted under CapoLifecycleActivities::CreatingDelegate, then installed \\n  ...without the minter's involvement, using its DelegateLifecycle::Installing activity\"\n                    );\n                    print(\"  -- TEMPORARY: the mint delegate is being replaced\\n\");\n                    true\n                },\n                Retiring => error(\"DLA::Retiring can't mint!\"),\n                ValidatingSettings => error(\"DLA::ValidatingSettings can't mint!\")\n            }\n        },\n        MintingActivities => {\n            print(\"  -- app-specific minting; trust mintDgt\\n\");\n            mintDgtInput.requiresValidOutput() && \n                true\n        },\n        BurningActivities => {\n            print(\"  -- app-specific burning; trust mintDgt\");\n            mintDgtInput.requiresValidOutput() && \n                true\n        },\n        CreatingDelegatedData => {\n            print(\"  -- mint for dgData; trust mintDgt\");            \n            mintDgtInput.requiresValidOutput() && \n                true\n        },\n        DeletingDelegatedData => {\n            print(\"  -- burn for dgData; trust mintDgt\");\n            mintDgtInput.requiresValidOutput() && \n                true\n        },\n        UpdatingDelegatedData => error(\"invalid mint-delegate activity for minting; UpdatingDelegatedDatum can't mint\"),\n        MultipleDelegateActivities{ma} => {\n            // assert(false && ma.length > 0, \"empty MultipleDelegateActivities\");\n            mintDgtInput.requiresValidOutput()\n            && ma.map(AbstractDelegateActivitiesEnum::from_data). all(\n                (mintDgtActivity: AbstractDelegateActivitiesEnum) -> Bool {\n                    mintDgtActivity.switch {\n                        CreatingDelegatedData => true, // short version of recursing the full check\n                        DeletingDelegatedData => true, // short version of recursing the full check\n                        MintingActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested MintingActivities invalid\"\n                        ),\n                        BurningActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested BurningActivities invalid\"\n                        ),\n                        MultipleDelegateActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested MultipleDelegateActivities invalid\"\n                        ),\n                        UpdatingDelegatedData => error(\n                            \"mintDgt: MultipleDelegateActivities: nested UpdatingDelegatedData invalid\"\n                        ),\n                        SpendingActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested SpendingActivities invalid\"\n                        ),\n                        CapoLifecycleActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested CapoLifecycleActivities invalid\"\n                        ),\n                        DelegateLifecycleActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested DelegateLifecycleActivities invalid\"\n                        )\n                    }\n                }\n            )\n        }\n    }\n\n\n    // requiresDelegateAuthorizingMint(\n    //     delegateLink: mintDgt, \n    //     mph: mph,\n    // )\n}\n\n//! pre-computes the hash-based suffix for a token name, returning\n//  a function that cheaply makes Uut names with any given purpose, \n// given the initial seed-txn details\nfunc mkUutTnFactory(\n    seed: TxOutputId\n) -> (String) -> String {\n\n    seedTxId : TxId = seed.tx_id;\n    seedIdx : Int = seed.index;\n\n\n    idxBytes : ByteArray = seedIdx.serialize();\n    // assert(idxBytes.length == 1, \"surprise!\");\n\n    //! yuck: un-CBOR...\n    rawTxId : ByteArray = seedTxId.serialize().slice(5,37);\n\n    txoInfo : ByteArray = if (idxBytes.length > 9) { \n        // allows 9 bytes to ensure we can support \n        // the largest possible cbor encoding of txo-index integers, \n        // even though we only expect integers < 256 currently\n        assert(false, \n            //\"expected cbor(txo index) to be at most 9 bytes, got cbor( index=\n            //  + seedIdx.show() + \" ).hex = \" + idxBytes.show()\n            \"cbor(txoId) len > 9 !!\"  \n        );\n        idxBytes // never used\n    } else {\n       ( rawTxId + \"@\".encode_utf8() )+ idxBytes\n    };\n    // assert(txoId.length == 34, \"txId + @ + int should be length 34\");\n    // print( \"******** txoId \" + txoId.show());\n\n    miniHash : ByteArray = txoInfo.blake2b().slice(0,6);\n    // assert(miniHash.length == 6, \"urgh.  slice 5? expected 12, got \"+ miniHash.length.show());\n\n    mhs: String = miniHash.show();\n\n    // returns a function computing a lightweight prefix + miniHash\n    (p: String) -> String {\n        p + \"-\" + mhs\n    }\n}\n\nfunc tnCip68nft222(tn : String) -> ByteArray{\n     #000de140 + tn.encode_utf8()\n}\n\nfunc tnCip68ref100(tn : String) -> ByteArray {\n    #000643b0 + tn.encode_utf8()\n}\n\n/**\n * ensures that shorter token-names are mentioned before longer ones\n * AND that lexographically smaller names are mentioned first.\n */\nfunc sortPolicyValues(k1 : ByteArray, _v1 : Int, k2 : ByteArray, _v2: Int) -> Bool {\n    if (k1.length < k2.length) { \n        true \n    } else {\n        k1 < k2\n    }\n}\n\n// checks all of the following:\n//  - there's an approving delegate (or we're bootstrapping)\n//  - the mint includes the seed UTXO\n//  - the mint matches the UUTs indicated by the list of purposes\nfunc validateUutMinting(\n    mph: MintingPolicyHash,\n    seed: TxOutputId,\n    purposes: []String,     \n    mkTokenName: (String) -> String = mkUutTnFactory(seed),\n    bootstrapCharter:Value = Value::ZERO,\n    otherMintedValue: Value = Value::ZERO,\n    needsMintDelegateApproval: Bool = true,\n    extraMintDelegateRedeemerCheck: Bool = true,\n    checkMintDgtActivity: (AbstractDelegateActivitiesEnum) -> Bool = noOtherActivitiesSupported\n) -> Bool {\n    isBootstrapping : Bool = !( bootstrapCharter.is_zero() );\n\n    delegateApproval : Bool = if ( isBootstrapping ) { \n        true \n    } else {\n        // not bootstrapping; must honor the mintDelegate's authority\n        CapoDatum::CharterData {\n            _spendDgt,\n            _spendInvariants,\n            _namedDelegates,\n            mintDgt, \n            _mintInvariants, \n            _govAuthority,\n            _manifest,\n            _pendingDelegates\n        } = getTxCharterData(mph);\n\n        if (needsMintDelegateApproval) {\n            //!!! todo: add explicit activity details in authorization\n                                    //!todo change this one\n            requiresDelegateAuthorizingMint(\n                delegateLink: mintDgt, \n                mph: mph, \n                extraMintDelegateRedeemerCheck: extraMintDelegateRedeemerCheck,\n                checkMintDgtActivity: checkMintDgtActivity\n            )\n        } else {\n            true\n        }\n    };\n\n\n    valueMinted: Value = tx.minted;\n\n    // idxBytes : ByteArray = seedIdx.bound_max(255).serialize();\n    // // assert(idxBytes.length == 1, \"surprise!\");\n\n    // //! yuck: un-CBOR...\n    // rawTxId : ByteArray = seedTxId.serialize().slice(5,37);\n\n    // txoId : ByteArray = (rawTxId + \"@\".encode_utf8() + idxBytes);\n    // assert(txoId.length == 34, \"txId + @ + int should be length 34\");\n    // // print( \"******** txoId \" + txoId.show());\n\n    // miniHash : ByteArray = txoId.blake2b().slice(0,6);\n    // // assert(miniHash.length == 6, \"urgh.  slice 5? expected 12, got \"+ miniHash.length.show());\n\n    // tokenName1 = purpose + \".\" + miniHash.show();\n\n    // print(\" purposes: \" + purposes.join(\", \"));\n    expectedValue : Value = bootstrapCharter + otherMintedValue + Value::sum(\n        purposes.sort((a:String, b:String) -> Bool { a != b }).map(\n            (purpose: String) -> Value {\n                // print(\"purpose: \" + purpose);\n                mkTv(mph, mkTokenName(purpose) /*, quantity=1 */)\n            }\n        )\n    );\n\n    if (! valueMinted.contains_policy(mph) ) {\n        mphStr = mph.show();\n        valStr = valueMinted.show();\n        print( \"  -- no mint from our policy \"+ mphStr);\n        print(valStr);\n        print( \"^^  value minted\");\n        error(\"❌❌ validateUutMinting(): no mint from our policy\")\n    };\n\n    // seedTxId = seed.tx_id.show();\n    // seedIdx = seed.index.show();\n    // print(\"\\n  -- uut-minting seed: \" + seedTxId + \"🔹#\"+seedIdx);\n\n    expectedValue.get_policy(mph).sort(sortPolicyValues).for_each( (tn : ByteArray, i: Int) -> {\n        tnStr = tn.decode_utf8();\n        print( \"    ℹ️ 🐞 expected: \"+ i.show() + \"x \" + tnStr )\n    });\n\n    actualThisPolicyMint = valueMinted.get_policy(mph);\n    // expectedMint : Map[ByteArray]Int = expectedValue.get_policy(mph);\n    if (true) {\n        actualThisPolicyMint.for_each( (tn : ByteArray, i: Int) -> {\n            tnStr = tn.decode_utf8();\n            print( \"    ℹ️ 🐞   actual: \" + i.show() + \"x \" + tnStr )\n        });\n        print(\"other policy values minted: \\n\");\n        print(Value::from_map(valueMinted.to_map().filter( (b:MintingPolicyHash, _ /* Map[ByteArray]Int */ ) -> Bool {\n            b != mph\n        })).show())\n    };\n\n    // _temp : []ByteArray = actualMint.fold( (l: []ByteArray, b : ByteArray, i: Int) -> {\n    //     l.find_safe((x : ByteArray) -> Bool { x == b }).switch{\n    //         None => l.prepend(b),\n    //         Some /*{x}*/ => error(\"UUT duplicate purpose \"\n    //             // +  x.decode_utf8()\n    //         )\n    //     }\n    // }, []ByteArray{});\n    // assert(true || (temp == temp), \"prevent unused var\");\n\n    \n\n    REQT(\"Ensures the mint for this policy-id is exactly the expected value\");\n    thisPolicyMintOK = actualThisPolicyMint == expectedValue.get_policy(mph).sort(sortPolicyValues);\n    assert(thisPolicyMintOK, \"mismatch in UUT mint\");\n    print(\"  -- this-policy mint ok\");\n    assert(hasSeedUtxo(tx, seed), \"no seed\"); //, \"UUT \"+purposes.join(\"+\")\n    print(\"  -- ok: has seed and expected this-policy mint value\");\n\n    otherPoliciesMintOk = if (!otherMintedValue.is_zero()) { true } else {\n        REQT(\"... with an additional mint-value indicated\");\n\n        remainingExpectedMint = if (expectedValue.contains_policy(mph)) {\n            Value::from_map(\n                expectedValue.to_map().delete(mph)\n            )\n        } else { expectedValue };\n\n        if (remainingExpectedMint.is_zero()) { true } else {\n            REQT(\"...with other-policy values expected: \");\n            print( remainingExpectedMint.show() + \"^ other-mint value expected\");\n            REQT(\"It should mint exactly the indicated token names\");\n            REQT(\"Doesn't constrain any mentioned policy's minting of any other tokens\");\n            remainingExpectedMint.to_map().for_each( \n                (otherMph: MintingPolicyHash, expectedTokensThisPolicy: Map[ByteArray]Int) -> {\n                    mintedThisPolicy : Map[ByteArray]Int = valueMinted.get_policy(otherMph);/* implicitly sorted already .sort(sortPolicyValues);*/\n\n                    expectedTokensThisPolicy. \n                    sort(sortPolicyValues).\n                    for_each( (tokenName: ByteArray, expectedCount: Int) -> {\n                        if(! mintedThisPolicy.get_safe(tokenName).\n                            switch {\n                                None => false,\n                                Some{actualCount} => actualCount == expectedCount\n                            }\n                        ) {\n                            tnString = tokenName.decode_utf8();\n                            error(\n                                \"❌❌ validateUutMinting(): wrong mint for \"+ otherMph.show() + \":\" + tnString\n                            )\n                        }}\n                    )\n                }\n            );\n            true\n        }\n        // ^^ any errors are thrown in here\n    };\n    assert(\n        otherPoliciesMintOk.trace(\"  -- other-expected-mints ok? \"), \n        \"unreachable exception: otherPoliciesMintOk\"\n    );\n\n    print(\" ✅ validateUutMinting:  ok!\\n\");\n\n    delegateApproval && thisPolicyMintOK && otherPoliciesMintOk \n}\n\nenum MinterActivity { \n    mintingCharter { // 0\n        owner: Address\n        //xxx withSettings: Bool\n        // we don't have a responsiblity to enforce delivery to the right location\n        // govAuthority: RelativeDelegateLink   // not needed \n    }\n    mintWithDelegateAuthorizing // 1 - delegate is handling all mints\n\n    // obsoleted by Capo lifecycle activity (queuePendingChange with role=MintInvariant)\n    addingMintInvariant { //2 \n        seed: TxOutputId\n    }\n\n    // obsoleted by Capo lifecycle activity (queuePendingChange with role=SpendInvariant)\n    addingSpendInvariant { //3\n        seed: TxOutputId\n    }\n\n    forcingNewMintDelegate { //4\n        seed: TxOutputId\n    }\n\n    CreatingNewSpendDelegate { //5\n        seed: TxOutputId\n        // when not forcing the new delegate, the old UUT will be replaced:\n        replacingUut: Option[ByteArray]\n    }\n\n}\n\n",
  project: "stellar-contracts",
  purpose: "module",
  name:  "src/CapoMintHelpers.hl", // source filename
  moduleName:  "CapoMintHelpers",
};

const heliosModule$9 = {
  content: "module CapoDelegateHelpers\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash,\n    get_cont_outputs\n} from ScriptContext\n\nimport {\n    AnyData,\n    mustFindInputRedeemer,\n    mkTv,\n    returnsValueToScript\n} from StellarHeliosHelpers\n\n// todo: add this to RelativeDelegateLink\nenum stakingKeyRequirement {\n    NoStakingKeyAllowed\n    StakingKeyRequired\n    SpecificStakeKeyRequired {\n        stakeCredential: StakingCredential\n    }\n}\n\n// use this activity at Redeemer zero, as enum Redeemer {\n//   DelegateLifecycleActivity { a: DelegateLifecycleActivity }}\n//   ... followed by app-specific redeemer variants\n// }\nenum DelegateLifecycleActivity {\n    ReplacingMe { // replaces this delegate with a different one\n        seed: TxOutputId\n        purpose: String\n    }\n    Retiring\n    ValidatingSettings\n}\n\nenum DelegateRole {\n    MintDgt\n    SpendDgt\n    MintInvariant\n    SpendInvariant\n    DgDataPolicy {\n        name: String\n    }\n    OtherNamedDgt {\n        name: String\n    }\n    BothMintAndSpendDgt\n    HandledByCapoOnly\n}\n\nenum ManifestActivity {\n    retiringEntry {\n        key: String\n    }\n    updatingEntry {\n        key: String  // must already exist\n        tokenName: ByteArray  // must reference or input new & old\n    }\n    addingEntry {\n        key: String  // must not exist\n        tokenName: ByteArray // must reference or input new & old\n    }\n    forkingThreadToken {\n        key: String // must mint new & create a clone of the existing token\n        newThreadCount: Int\n    }\n    burningThreadToken {\n        key: String // must burn the token\n        burnedThreadCount: Int // must match the count of the burned token\n    }\n}\n\nenum PendingDelegateAction {\n    Add {\n        seed: TxOutputId\n        purpose: String\n        idPrefix: String\n        // uutName: String\n        // delegateValidatorHash: Option[ValidatorHash]\n        // config: ByteArray\n    }\n    Remove\n    Replace {\n        seed: TxOutputId\n        purpose: String\n        idPrefix: String\n\n        // uutName: String\n        // delegateValidatorHash: Option[ValidatorHash]\n        // config: ByteArray\n\n        replacesDgt: AssetClass\n    }\n}\n\n// use this activity at Redeemer #1 CapoLifecycleActivities\nenum CapoLifecycleActivity {\n    CreatingDelegate {\n        seed: TxOutputId\n        purpose: String\n    }\n    queuePendingChange \n        // seed: TxOutputId\n        // purpose: String\n        // action: PendingDelegateAction\n\n        // role: DelegateRole\n        // name: Option[String]\n    // }\n    removePendingChange {\n        role: DelegateRole\n    }\n    commitPendingChanges\n    forcingNewSpendDelegate {\n        seed: TxOutputId\n        purpose: String //uut purpose \"spendDgt\"\n    }\n    forcingNewMintDelegate {\n        seed: TxOutputId\n        purpose: String //uut purpose \"mintDgt\"\n    }\n        // manifest-updating activities, ALWAYS at Enum position 5\n    // this is not application-specific.  It's placed into the delegation\n    // layer so that a spend-delegate's manifest-updating logic can be\n    // upgraded while leaving the Capo unchanged.\n    updatingManifest {\n        activity: ManifestActivity\n    }\n\n    \n}\n\n// use this enum to match any redeemer if you don't care about what other\n// variants may be in that delegate, but you know it has to be a delegate with the \n// universal delegate activities at constr#0\nenum AbstractDelegateActivitiesEnum {\n    CapoLifecycleActivities {\n        activity: CapoLifecycleActivity\n    }\n    DelegateLifecycleActivities {\n        activity: DelegateLifecycleActivity\n    }\n    SpendingActivities {\n        activity: Data\n    }\n    MintingActivities {\n        activity: Data\n    }\n    BurningActivities {\n        activity: Data\n    }\n\n    // allows for delegated-data minting activities to be checked generically,\n    // instead of having to create explicit minting/spending activities for each one.\n    // The mint/spend delegate can thus generically support any registered data-type,\n    // enforcing that right delegate is used but not needing to deal with specifics of \n    // their activities.  Requires a typeMap for to resolve dataType to the concrete delegate.\n\n    CreatingDelegatedData {\n        seed: TxOutputId\n        dataType: String\n        // id from seed\n    }\n    UpdatingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n    DeletingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n    MultipleDelegateActivities {\n        activities: []Data // actually a []DelegateActivitiesEnum\n    }\n}\nenum DgTknDisposition {\n    Returned\n    Created\n}\n\n// data stored in the Capo, representing basic delegate info\n//   about the connection to a delegate.  \nstruct RelativeDelegateLink {\n    uutName: String \n\n    // delegate links without a validator hash are \"arms-length\" delegates,\n    // which means they won't be checked for possible auto-upgrades \n    //  ... to new versions of their code.\n    // it also means that they won't be able to participate \n    //   ... in validation of configuration changes in the Capo.\n    delegateValidatorHash: Option[ValidatorHash]\n    config: ByteArray\n    // !!! todo ???  - for namedDelegates particularly\n    // stakingCred: stakingKeyRequirement\n\n    func getRedeemer(self,  input : TxInput)  -> AbstractDelegateActivitiesEnum {\n        assert( true || /* not executed */ self == self, \"no way s\");// avoid unused variable\n        AbstractDelegateActivitiesEnum::from_data( \n            mustFindInputRedeemer(input)\n        )\n    }\n\n    func tvAuthorityToken(self, mph: MintingPolicyHash) -> Value {\n        mkTv(mph, self.uutName)\n    }\n    func acAuthorityToken(self, mph: MintingPolicyHash) -> AssetClass {\n        AssetClass::new(mph, self.uutName.encode_utf8())\n    }\n\n    func getTv(self, mph: MintingPolicyHash) -> Value {\n        assert(false, \"deprecated getTv(); use RDL.tvAuthorityToken instead\");\n        mkTv(mph, self.uutName)\n    }\n    \n    func validatesUpdatedSettings(self,\n        inputs: []TxInput,\n        mph: MintingPolicyHash,\n        inputRequired: Bool\n    ) -> Option[Bool] {\n        self.hasDelegateInput( // fails if req'd input missing\n            inputs: inputs,\n            mph: mph,\n            required: inputRequired\n        ).switch {            \n            None => Option[Bool]::None, // clean \"not found but the caller indicated that's ok\"\n            Some{spendDelegateInput} => {\n                spendDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( \n                    mustFindInputRedeemer(spendDelegateInput)\n                ).switch {\n                    DelegateLifecycleActivities{a} => {\n                        a.switch {\n                            ValidatingSettings => self.hasValidOutput(mph),\n                            _ => error(\"delegate not ValidatingSettings: \"+ self.uutName)\n                        }\n                    },\n                    _ => error(\"no way n\") // throws if the redeemer isn't #0.\n                };\n\n                assert(spendDelegateIsValid, \"no way o\"); // it threw any error already\n                Option[Bool]::Some{spendDelegateIsValid}\n            }\n        }\n    }\n\n    func hasDelegateInput(self, \n        inputs: []TxInput, \n        mph: MintingPolicyHash,\n        required: Bool = true\n    ) -> Option[TxInput] {\n        uutName : String = self.uutName;\n        self.delegateValidatorHash.switch{\n            // when no special input is needed by the delegate, \n            None => {\n                if (required) {\n                    error(\"❌❌ ➡️ 💁 missing required input with dgTkn \" + uutName)\n                } else {\n                    Option[TxInput]::None\n                }\n            },\n            Some{vh} => {\n                needsAddrWithCred : SpendingCredential = SpendingCredential::new_validator(vh);\n                // if we arrived here, then we have a delegate that's supposed to be at a specific address.\n                // if we can't find an input with that address, it's an error condition.\n                // we need an input with this address, having the expected UUT.\n                expectedUut : Value = mkTv(mph, uutName);\n                print(\"  -- seeking input dgTkn: \"+ uutName);\n                inputs.find_safe((i: TxInput) -> Bool {\n                    i.address.credential == needsAddrWithCred &&\n                    i.value.contains(expectedUut)\n                }).switch {\n                    foundGood: Some => {\n                        print (\"  ✅ ➡️  💁 found ^ input dgTkn\" );\n                        foundGood\n                    },\n                    /* notFound: */ None => {\n                        if (required) {\n                            error(\"_❌ ➡️  💁 missing req'd input dgTkn (at script addr) \" + uutName)\n                        } else {\n                            print (\" <- 🚫 ➡️ 💁 no input with ^ dgTkn; not req'd; returning false\\n\");\n                            Option[TxInput]::None\n                        }\n                    }\n                }\n            }        \n        }\n    }\n    \n    // was requiresValidDelegateOutput \n    func hasValidOutput(\n        self, // delegateLink: RelativeDelegateLink, \n        mph: MintingPolicyHash, \n        required: Bool = true,\n        createdOrReturned: DgTknDisposition = DgTknDisposition::Returned\n    ) -> Bool {\n        RelativeDelegateLink{\n            uut,  \n            validatorHash, \n            _ /* configJson */\n        } = self;\n    \n        v : Value = mkTv(mph, uut);\n        cOrR : String = createdOrReturned.switch{\n            Returned => \"returned\",\n            Created => \"created\"\n        };\n        print(\" ⬅️ 🔎 💁 expect dgTkn \"+ cOrR + \": \"+ uut);\n        hasDelegate : Bool = validatorHash.switch{\n            Some{vh} => {\n                print( \"  ... ^ sent to validator: \"+vh.show()+\"\\n\");\n                tx.value_locked_by(vh).contains(v)\n            },\n            None => {\n                print(\"   (to anywhere)\");\n\n                tx.outputs.find_safe((o : TxOutput) -> Bool {\n                    o.value.contains(v)\n                }).switch{\n                    Some => true, \n                    None => false\n                }\n            }\n        };\n    \n        if (!hasDelegate && required) {\n            // this branch has no on-chain cost\n            // throws for a missing input \n            createdOrReturned.switch {\n                Created => error(\"⬅️ ❌ 💁 dgTkn not created: \"+ uut),\n                Returned => { // throws unless the right INPUT is                    \n                    _ = self.hasDelegateInput(tx.inputs, mph, true);\n                    error(\"⬅️ ❌ 💁 dgTkn not returned: \"+ uut )\n                }\n            }\n        } else {\n            // print(uut);\n            if (hasDelegate) {\n                print(\" ⬅️ ✅ 💁 ok:  ^ dgTkn has \"+cOrR+\" a valid output\\n\")\n            } else {\n                print(\" ⬅️ 🚫 💁 no delegate but not req'd; false\")\n            }\n        };\n        hasDelegate\n\n                    // self.hasDelegateInput(tx.inputs, mph, true).switch {\n                    //     Some => {\n                    //         // throws if it's spent, but not returned correctly:\n                    //         error(\"⬅️ ❌ 💁 dgTkn not returned: \"+ uut )\n                    //     },\n                    //     _ => error(\"no way p\")\n                    // }\n\n    }\n    \n    // config: Data\n}\n\n\nstruct PendingDelegateChange {\n    action: PendingDelegateAction\n    role: DelegateRole\n    // name: Option[String] // moved to DelegateRole variants for named delegates/dgDataPolicy\n    dgtLink: Option[RelativeDelegateLink]\n\n    func isValid(self) -> Bool {\n        self.role.switch {\n            BothMintAndSpendDgt => error(\n                \"DelegateRole::BothMintAndSpendDgt not applicable in a PendingDelegateChange struct\"\n            ),\n            _ => true\n        }\n    }\n}\n\nenum PendingCharterChange {\n    delegateChange {\n        change: PendingDelegateChange\n    }\n    otherManifestChange {\n        activity: ManifestActivity,\n        /**\n         * indicates delegates that are needed to validate a pending change\n         * @remarks\n         * not every manifest change has to be validated by delegates, \n         * ... but those that do can enforce:\n         *   (a) creating this list of delegates that must validate\n         *   (b) that the list becomes empty before the change is committed.\n         *   (c) OR that any remaining delegates are validating the committed data\n         * ... as part of the txn completing the change.\n         *\n         * This helps ensure that the change is validated by the right delegates,\n         *  ... without needing all the validation to be done in a single transaction\n         */ \n         remainingDelegateValidations: []DelegateRole\n    }\n}\n\n// data stored in isDelegate Datum (in the delegate's script)\n// ... links back to the capo info\nstruct DelegationDetail {\n    capoAddr: Address\n    mph: MintingPolicyHash\n    tn: ByteArray\n\n    func acAuthorityToken(self) -> AssetClass {\n        AssetClass::new(self.mph, self.tn)\n    }\n    func tvAuthorityToken(self) -> Value {\n        Value::new(\n            AssetClass::new(self.mph, self.tn), 1\n        )\n    }\n}\n\n// Delegates can define additional Datum in their enums,\n// but this first Datum is essential\nenum BASE_DELEGATE_Datum {\n    Cip68RefToken {  \n        cip68meta: AnyData\n        cip68version: Int\n        otherDetails: Data\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index and structure as Capo's DelegatedData\n    capoStoredData {\n        data: AnyData\n        version: Int\n        otherDetails: Data \n    }\n}\n\nfunc mustReturnValueToScript(\n    value : Value, \n    tokenName: ByteArray = #\n) -> Bool {\n    if (!returnsValueToScript( value)) {\n        print(\"failed matching value: \");\n        print(value.show());\n        print(\"\\n\");\n        error(\" ❌ dgTkn not returned: \" + tokenName.decode_utf8())\n        // error(\"the authZor token MUST be returned\")\n    } else { \n    true\n    }\n}\n\n//!!! call with existing delegate Datum.serialize()\nfunc unmodifiedDelegation(oldDD : ByteArray) -> Bool {\n    o : []TxOutput = get_cont_outputs();\n    //    print(\"::::::::::::::::::::::::::::::::: hi \"+o.head.datum.inline.serialize().show());\n\n    assert(o.head.datum.inline.serialize() == oldDD,\n    // \"delegation datum must not be modified\"\n    \"modified dgtDtm\"\n);\n    true\n    // MintDelegateDatum::IsDelegation{\n    //     ddNew, _\n    // } = MintDelegateDatum::from_data( \n        \n    // );\n\n    //! the datum must be unchanged.\n    // ddNew == dd \n}\n\nfunc requiresNoDelegateInput(\n    delegateLink: RelativeDelegateLink, \n    mph: MintingPolicyHash\n) -> Bool {\n    v : Value = mkTv(mph, delegateLink.uutName);\n    if (tx.inputs.any((i: TxInput) -> Bool {\n        i.value.contains(v)\n    })) {\n        error(\"must not have dgTkn input: \"+delegateLink.uutName)\n    } else {\n    print(\"ok: no dgTkn input: \");\n    print(delegateLink.uutName);\n    print(\"\\n\");\n    true\n    }\n}\n\n// just some convenience stuff to lead people to the right place\nstruct delegateLink_hasValidOutput_asMethod {\n    placeHolder: String \n}\n\n// func requiresValidDelegateOutput(\n//     delegateLink: delegateLink_hasValidOutput_asMethod,\n//     mph: MintingPolicyHash, \n//     required: Bool = true\n// ) -> Bool {\n         ///                  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n//     assert(false, \"replaced by delegateLink.hasValidOutput(...)\");\n//     assert(delegateLink==delegateLink, \"no way q\");\n//     assert(mph==mph, \"no\");\n//     assert(required==required, \"no way r\");\n//     true\n// }\n// :ladybug emoji: \"🐞xy\"\n\n// !!! this could be really nice but it's difficult to use it in practice.\n// type-aliasing would be amazing.\nenum SomeDelegateDatum[T] {\n    Cip68RefToken {  \n        // NOTE: this datum contains reference details for a user-facing token minted according to the cip-68 standard \n        //  - the asset name (in the Value of this UTXO) MUST be:  #000643b0 + tokenName\n        //     - this asset name can serve user-side tokens using the CIP-68 \"222\", \"333\" or other token types.\n        //     - the user-side asset name with its (222/333/etc) CIP-67 prefix and \n        //       ... its remaining tokenName will be matched to this asset name (#000643b0 +tokenName)\n        //       ... to locate this reference datum; this datum content will be interpreted\n        //       ... according to the semantics implied by the user-side asset-name prefix.\n        //\n        //  - The attached 'meta' field in this Datum variant contains the relevant data, depending on the token type\n        //    - for \"222\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"files\" :   // {mediaType, src (url), name?, ... otherFields)\n        //        - \"image\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //    - for \"333\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"ticker\" : String\n\n        //        - \"url\": String  // project URL\n        //        - \"logo\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //                    - it must have a mime type `image/png`, `image/jpeg` or `image/svg+xml`\n        //        - \"decimals\" : Int\n\n        meta: AnyData\n        version: Int\n        otherDetails: Data // can be Unit () or anything else\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index as Capo's DelegatedData\n    capoStoredData {\n        data: T\n        version: Int\n        otherDetails: Data \n    }\n\n    // func validateSettings(self, _settings: ProtocolSettings) -> Bool{\n    //   ... get the settings from the manifest via ccts\n    //     assert(false, \"not valid (stubbed)\");\n    //     // settings.serialize() != self.serialize() &&\n    //     true\n    // }    \n}\n",
  project: "stellar-contracts",
  purpose: "module",
  name:  "src/delegation/CapoDelegateHelpers.hl", // source filename
  moduleName:  "CapoDelegateHelpers",
};

const heliosModule$8 = {
  content: "module StellarHeliosHelpers\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash\n} from ScriptContext\n\n// keep this as-is.  Make RealnumSettingsValueV2 or something else if it needs to change\nstruct RealnumSettingsValueV1 {\n    name: String\n    microInt: Int // \"Real\" semantics, times 1_000_000\n}\n\nfunc didSign(a: Address) -> Bool {\n    pkh : PubKeyHash = a.credential.switch{\n        PubKey{h} => h,\n        Validator => error(\"trustee can't be a contract\")\n        // _ => error(\"trustee can't be a contract\")\n    };\n    // print(\"checking if trustee signed: \" + pkh.show());\n\n    tx.is_signed_by(pkh)\n}\n\nfunc TODO(task: String) -> () {\n    // 🟥  😳💦 red checkbox, face, sweat droplets\n    print(\"  🟥  😳💦  TODO: \" + task + \"\\n\")\n}\n\nfunc REQT(reqt: String, assertion : Bool=true) -> () {\n    // ❗red exclamation mark\n    print(\"❗ \"+ reqt);\n    assert(assertion, \"  ❌❌ ^ failed: \" + reqt)\n}\nfunc bREQT(reqt: String, assertion : Bool=true) -> Bool {\n    REQT(reqt, assertion);\n    true\n}\n\n//! represents the indicated token name as a Value\nfunc mkTv(\n    mph: MintingPolicyHash, \n    tn: String=\"\", \n    tnBytes: ByteArray=tn.encode_utf8(),\n    count : Int = 1\n) -> Value {\n    assert(tnBytes.length > 0, \"missing reqd tn or tnBytes\");\n    Value::new(\n        AssetClass::new(mph, tnBytes), \n        count\n    )\n}\n\n//! returns the charter-token from our minter, as a Value\nfunc tvCharter(mph: MintingPolicyHash)  -> Value {\n    mkTv(mph, \"charter\")\n}\n\nfunc spendsAndReturns(value : Value, input: TxInput) -> Bool {\n    input.value.contains(value) &&\n    tx.outputs.any( (txo : TxOutput) -> Bool {\n        txo.address == input.address &&\n        txo.value.contains(value)\n    } )\n}\n\nfunc returnsValueToScript(value : Value) -> Bool {\n    input : TxInput = get_current_input();\n    input.value.contains(value) &&\n    tx.outputs.any( (txo : TxOutput) -> Bool {\n        txo.address == input.address &&\n        txo.value.contains(value)\n    } )\n}\n\n\nfunc getOutputWithValue(v : Value) -> TxOutput {\n    tx.outputs.find((txo: TxOutput) -> { txo.value >= v })\n}\n\nstruct outputAndDatum[T] {\n    output: TxOutput\n    datum: T\n    rawData: Data\n}\n\nfunc getSingleAssetValue(input: TxInput) -> Value{\n    inputMap : Map[MintingPolicyHash]Map[ByteArray]Int = input.value.get_assets().to_map();\n    assert( inputMap.length == 1, \n        \"multiple assets\"\n        // \"getSingleAssetValue needs single-asset input\"\n    );\n\n    inputTokens : Map[ByteArray]Int = inputMap.head_value;\n    assert(inputTokens.length == 1, \n        \"multiple tokens\"\n        // \"getSingleAssetValue needs single-token input\"\n    );\n\n    input.value.get_assets()\n}\n\n// func outputDatum[T](newTxo : TxOutput) -> T {\n//     T::from_data(newTxo.datum.inline)\n// }\n\nfunc getOutputForInput(input: TxInput) -> TxOutput {\n    inputValue : Value = getSingleAssetValue(input);\n\n    getOutputWithValue(inputValue)\n}\n\n//! retrieves the redeemer for a specific input\nfunc mustFindInputRedeemer(\n    txInput: TxInput    \n) -> Data {\n    targetId : TxOutputId = txInput.output_id;\n    redeemers : Map[ScriptPurpose]Data = tx.redeemers;\n    spendsExpectedInput : ScriptPurpose = redeemers.find_key( \n        (purpose : ScriptPurpose) -> { purpose.switch{ \n            sp: Spending => {\n                // print (\"oid: \" + sp.output_id.show());\n                sp.output_id == targetId\n            }, \n            _ => false \n        } }\n    );\n    redeemers.get(spendsExpectedInput)\n}\n\n// XXX this doesn't work because using a field of this type\n//   causes the compiler to believe there would be two enum wrappers,\n//   one for this Solo variant, and another for the T type.\n// Instead, the off-chain code needs to construct the wrapper,\n// but the field needs to pretend there is no wrapper.\n\n// enum NestedTaggedStruct[T] {\n//     Solo{ thing: T }\n\n//     func unwrap(self) -> T {\n//         print(\"NestedTaggedStruct: unwrap\");\n\n//         self.switch {\n//             Solo{ thing } => {\n//                 print(\"NestedTaggedStruct: unwrapped thing\");\n//                 thing\n//             },\n//             _ => error(\"NestedTaggedStruct: unwrap: unknown variant\")\n//         }\n//     }\n// }\n \n// field-names style of struct, arbitrary & extensible\n// field list, can be interpreted by any script that defines a \n// field-names style of struct with its own fields & data types.\nstruct AnyData {\n    id: ByteArray \"@id\"  // same as the UUT name for this data\n    type: String \"tpe\"\n\n    // can have other fields; receiver will interpret their target types.\n}\n\nfunc fromCip68Wrapper(value: Data) -> Data {\n    value.switch {\n        // IntData, ByteArrayData, MapData, ListData and ConstrData\n        ConstrData{_anyIndex, fields} => {\n            fields.head.switch {\n                MapData => fields.head,\n                _ => error(\"bad cast from ConstrData{_, ...fields} to mStruct: first field must be a map\")\n            }\n        },\n        _ => error(\"bad cast to mStruct from non-ConstrData\")\n    }\n}\n",
  project: "stellar-contracts",
  purpose: "module",
  name:  "src/StellarHeliosHelpers.hl", // source filename
  moduleName:  "StellarHeliosHelpers",
};

const heliosModule$7 = {
  content: "module CapoHelpers \n\nimport {\n    mkTv,\n    tvCharter,\n    mustFindInputRedeemer,\n    outputAndDatum,\n    fromCip68Wrapper,\n    AnyData,\n    REQT,\n    TODO\n} from StellarHeliosHelpers\n\nimport {tx, get_current_input} from ScriptContext\n// import {\n//     TypeMap\n// } from TypeMapMetadata\n\nimport { \n    RelativeDelegateLink,\n    AbstractDelegateActivitiesEnum,\n    CapoLifecycleActivity,\n    DgTknDisposition as DgTkn,\n    DelegateRole,\n    PendingCharterChange    \n} from CapoDelegateHelpers\n\nenum UtxoSource {\n    RefInput\n    Input\n\n}\n\nenum dgd_DataSrc {\n    Unk\n    Input { utxo: TxInput }\n    Output { txo: TxOutput }\n    Both {\n        utxo: TxInput\n        txo: TxOutput\n    }\n    // Reference { ref: TxInput }\n}\n\nenum ManifestEntryType {\n    // the name (entry's key) is simply a reference to a specific token \n    // (typically a specific kind of dgData record \n    //  ...using application-specific convention)\n    NamedTokenRef \n    // the referenced token controls a specific type of dgData record,\n    // ... indicated by the entry's key.  With refCount, it inventories multiple \n    // ... thread tokens, each held by the delegate contract, for parallelism.\n    DgDataPolicy {\n        policyLink: RelativeDelegateLink\n        idPrefix: String\n        refCount: Int\n    }\n    // the referenced token inventories thread-tokens for a specific delegate role\n    //  ... the key is expected to match that delegate role (\n    //    mintDgt, spendDgt, mintInvar, spendInvar,\n    //    govDgt, or ‹name› of otherNamedDelegate)\n    // the first thread doesn't ever require a manifest entry,\n    // ... and the first forked thread makes an entry with refCount = 2\n    DelegateThreads {\n        role: DelegateRole \n        refCount: Int\n    }\n    // the referenced token is a merkle-root of a membership-proof-tree\n    MerkleMembership \n    // the referenced token is a merkle-root of a state-root-tree\n    MerkleStateRoot    \n}\n\n/*\n * The UtxoManifest is a data structure that references a set of UUTs\n * that are important to the operation of a Capo (and its family of contract \n * scripts).  It is used to maintain positive control over these operational\n * UUTs, inventorying them and giving every transaction a way to easily\n * reference their data for validation, operation, and reporting.\n *\n * A prime use-case for the capo's Manifest is for storing protocol-settings \n * data (\"settings\").  Any application will need its own defined data structures\n * for settings, but the \"settings\" key is reserved for this general purpose.\n * The protocol ensures that every collaborating script (\"delegate\") has a\n * chance to validate any new settings before the (updated settings or the \n * delegate, during installation) are activated.\n *\n * An additional case for manifest entries is for UUTs used as \"thread tokens\",\n * where multiple separate contract utxos are used to manage independent\n * threads of parallel operation for a single contract.  This provides a scalability\n * mechanism.\n */\nstruct CapoManifestEntry {\n    // key: String // redundant / same as its map-key\n    entryType: ManifestEntryType \"tpe\"\n    tokenName: ByteArray \"tn\"\n    mph: Option[MintingPolicyHash] // default = Capo's MPH\n    \n    func validate(self) -> Bool {\n        // 3 bytes plus encoding overhead\n        print(\"foo\".serialize().length.show() + \"<-- 3 chars has this serialized length\");\n        // assert(self.key.serialize().length > 5, \"key too short\");\n        // assert(\"settings\" == self.key, \"manifest only supports 'settings' for now\");\n\n        assert(self.tokenName.length > 0, \"no token name\");\n        // assert(self.refCount == 1, \"only one ref allowed for now\");\n        // assert(!self.isThreadToken, \"thread tokens not yet supported\");\n        self.mph.switch {\n            Some => error(\"custom mph not yet supported\"),\n            _ => true\n        }\n    }\n}\n\nfunc mkTokenShow(mph: MintingPolicyHash) -> (Value) -> String {\n    (v: Value) -> String {\n        others : String = Value::from_map(\n            v.get_assets().to_map().filter( (someMph: MintingPolicyHash, _) -> Bool {\n                mph != someMph\n            })\n        ).show();\n        ada : String = (\n            (\n                (0.0 + v.get_lovelace()) / 1_000.0\n            ).round() / 1_000.0\n        ).show() + \" ADA\";\n        mine : String = v.get_policy(mph).fold[[]String]( (previous: []String, tokenName: ByteArray, c: Int) -> []String {\n            []String{\n                c.show(), \"×💴 \", tokenName.decode_utf8()\n            } + previous\n        }, []String{}).join(\" + \");\n        // v.assets()\n\n        mine + \" + \" + ada  + others\n    }\n}\n\n/**************************************************************\n      ************************************************************\n      ************************************************************\n      *******************                      *******************\n      *******************                      *******************\n      *******************        CapoDatum     *******************\n      *******************                      *******************\n      *******************                      *******************\n      ************************************************************\n      ************************************************************\n      ************************************************************\n*/      \n\nenum CapoDatum {\n    CharterData {\n        spendDelegateLink: RelativeDelegateLink\n        spendInvariants: []RelativeDelegateLink\n        otherNamedDelegates: Map[String]RelativeDelegateLink\n        mintDelegateLink: RelativeDelegateLink\n        mintInvariants: []RelativeDelegateLink\n        govAuthorityLink: RelativeDelegateLink\n        manifest: Map[String]CapoManifestEntry\n        pendingChanges: []PendingCharterChange\n        // typeMapUut: Option[ByteArray]   // optional reference to a UUT having TypeMapInfo datum\n    }\n    ScriptReference\n    // settings are now just a distinguished case of delegated data\n    // ... for contracts that use settings,\n    // ... instead of being a special type of Datum\n    // SettingsData {\n    //     data:  Map[String]Data\n    // }\n\n    // same variant-index as delegate's capoStoredData:\n    DelegatedData {  // the Capo redirects control of these to the spend delegate\n        data: Map[String]Data // matches pattern of AnyData + other fields // the spend delegate may redirect control further, depending on what it sees in there\n        version: Int // for CIP-68 compatibility\n        otherDetails: Data // abstract additional info\n    }\n\n    func hasCharterRefInput(\n        self,\n        mph : MintingPolicyHash\n    ) -> Option[CapoDatum::CharterData] {\n        assert(false, \"deprecated use of hasCharterRefInput(); use CapoCtx instead.\");\n\n        assert( // avoid \"unused variable self\" error\n            true || ( /* never executed */\n                self.serialize() != mph.serialize()\n            ), \"never thrown\"\n        );\n        assert(false, \"unused?\"); // see standalone getRefCharterData()\n        \n        chVal : Value = tvCharter(mph);\n        hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };\n\n        tx.ref_inputs.find_safe(hasCharter).switch{\n            Some{txin} => Option[CapoDatum::CharterData]::Some{\n                CapoDatum::from_data( \n                    txin.datum.inline\n                ).switch{\n                    c : CharterData => c,\n                    _ => error(\"wrong enum\")\n                }\n            },\n            None => Option[CapoDatum::CharterData]::None\n        }\n    }\n\n    func countUpdatedThings(self, oldDatum: CapoDatum) -> Int {\n        self.switch {\n            CharterData{ \n                nextSpendDelegate, \n                nextSpendInvariants, \n                nextNamedDelegates, \n                nextMintDelegate, \n                nextMintInvariants, \n                nextGovDelegate, \n                nextManifest,\n                _nextPendinghanges\n            } => {\n                CharterData {\n                    oldSpendDelegate,\n                    oldSpendInvariants,\n                    oldNamedDelegates,\n                    oldMintDelegate,\n                    oldMintInvariants,\n                    oldGovDelegate,\n                    oldManifest,\n                    _oldPendingChanges\n                } = oldDatum;\n                changedSpendDgt : Bool = ( nextSpendDelegate.serialize() != oldSpendDelegate.serialize() );\n                changedSpendInvariants : Bool = ( nextSpendInvariants != oldSpendInvariants );\n                changedNamedDelegate : Bool = ( nextNamedDelegates.serialize() != oldNamedDelegates.serialize() );\n\n                changedMintDgt : Bool = ( nextMintDelegate.serialize() != oldMintDelegate.serialize() );    \n                changedMintInvariants : Bool =  ( nextMintInvariants != oldMintInvariants );\n                changedGovDelegate : Bool = ( nextGovDelegate.serialize() != oldGovDelegate.serialize() );\n                changedManifest : Bool = ( nextManifest.serialize() != oldManifest.serialize() );\n    \n                if ((changedSpendDgt).trace(\" -- spendDgt changed? \") ) { 1 } else { 0 } +\n                if ((changedSpendInvariants).trace(\" -- spendInvs changed? \") ) { 1 } else { 0 } +\n                if (changedNamedDelegate.trace(\" -- namedDgt changed? \") ) { 1 } else { 0 }+\n                if ((changedMintDgt).trace(\" -- mintDgt changed? \") ) { 1 } else { 0 } +\n                if ((changedMintInvariants).trace(\" -- mintInvs changed? \") ) { 1 } else { 0 } +\n                if ((changedGovDelegate).trace(\" -- govDgt changed? \")) { 1 } else { 0 } +\n                if ((changedManifest).trace(\" -- manifest changed? \") ) { 1 } else { 0 }\n            },\n            _ => error(\"only CharterData datum can count updated things\")\n        }\n    }\n\n    // func mustFindSettingsOutput(self, mph: MintingPolicyHash, inAddr: Address) -> outputAndDatum[CapoDatum::SettingsData] {\n    //     settingsVal : Value = mkTv(mph: mph, tnBytes: self.switch {\n    //         ct: CharterData => {\n    //             print( \" ⬅️ 🔎 finding settings output: \"+ ct.settingsUut.decode_utf8() + \"\\n\");\n    //             ct.settingsUut\n    //         },\n    //         _ => error(\"mustFindSettings - only valid on CharterData datum\")\n    //     });\n        \n    //     notFound = Option[outputAndDatum[CapoDatum::SettingsData]]::None;\n    //     foundSettings: []outputAndDatum[CapoDatum::SettingsData] = \n    //         tx.outputs.map_option[\n    //             outputAndDatum[CapoDatum::SettingsData]\n    //         ](\n    //              (output: TxOutput) -> Option[outputAndDatum[CapoDatum::SettingsData]] {\n    //                 if ( output.address != inAddr ) {\n    //                     // print(\"not the right address\");\n    //                     notFound\n    //                 } else {\n    //                     rawDatum : Data = output.datum.inline;\n    //                     CapoDatum::from_data(\n    //                         rawDatum\n    //                     ).switch {\n    //                         settings: SettingsData => {\n    //                             Option[\n    //                                 outputAndDatum[CapoDatum::SettingsData]\n    //                             ]::Some{\n    //                                 outputAndDatum[CapoDatum::SettingsData] {\n    //                                     output, settings, rawDatum\n    //                                 }\n    //                             }\n    //                         },\n    //                         _ => {\n    //                             // print(\"found non-SettingsData\");\n    //                             notFound\n    //                         }\n    //                     }\n    //                 }\n    //             }\n    //         );\n\n    //     assert(foundSettings.length < 2, \"too many settings outputs\") ;\n    //     assert(foundSettings.length == 1, \"no settings output\");\n\n    //     settingsOutput : TxOutput = foundSettings.head.output;\n    //     assert(\n    //         // already checked above.\n    //         // settingsOutput.address == charter.owner &&\n    //         settingsOutput.value.contains(settingsVal),\n    //             \"settings output not found in contract with expected UUT\"\n    //     );\n    //     assert(settingsVal.contains(settingsOutput.value.get_assets()), \n    //         \"excess value in settings output: \"+(settingsOutput.value - settingsVal).show()\n    //     );\n    //     print(\"\\n ⬅️ ✅ found CapoDatum::SettingsData\\n\");\n    //     foundSettings.head\n    //     // ^^ fails if there's no settings output to the right address\n\n    // }\n}\n\nenum cctx_CharterInputType {\n    Unk\n    RefInput { \n        datum: CapoDatum::CharterData\n        utxo: TxInput\n    }\n    Input { \n        datum: CapoDatum::CharterData \n        utxo: TxInput \n    }\n    // Minting {\n    //     datum: CapoDatum::CharterData\n    //     address: Address\n    // }\n}    \n\n/**************************************************************\n      ************************************************************\n      ************************************************************\n      *******************                      *******************\n      *******************                      *******************\n      *******************      CapoActivity    *******************\n      *******************                      *******************\n      *******************                      *******************\n      ************************************************************\n      ************************************************************\n      ************************************************************\n*/      \n\nenum CapoActivity {\n    capoLifecycleActivity { // variant 0 mostly delegated to spendDgt\n        activity: CapoLifecycleActivity\n    }\n    usingAuthority // variant 1\n    retiringRefScript // variant 2\n    addingSpendInvariant // variant 3\n    spendingDelegatedDatum // variant 4\n\n    // // possibly move this into CapoLifecycleActivity:\n    // updatingManifest { // variant 5 always delegated to spendDgt\n    //     activity: ManifestActivity\n    // }\n    updatingCharter // deprecated variant 5\n}\n\nfunc getRefCharterUtxo(mph : MintingPolicyHash) -> TxInput {\n    chVal : Value = tvCharter(mph);\n    hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };\n    print(\"getting ref_input for charter\\n\");\n    charterUtxo : TxInput = tx.ref_inputs.find_safe(hasCharter).switch{\n        Some{ch} => ch,\n        //!!! todo adjust this message: Missing required charter in ref_inputs\n        None => {\n            print(\"expected charter value\");\n            print(chVal.show());\n            print(\"\\n\");\n            error(\"Missing charter in required ref_inputs (use tcxWithCharterRef(tcx) in txn building functions)\")\n        }\n    };\n\n    charterUtxo\n}\n\nfunc getRefCharterData(mph : MintingPolicyHash) -> CapoDatum::CharterData {\n    charterUtxo : TxInput = getRefCharterUtxo(mph);\n    ctd : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n        charterUtxo.datum.inline\n    );\n\n    ctd\n}\n\n//! retrieves a required Capo Charter datum for the indicated minting-policy - \n// ... either from the txn's reference inputs  or inputs.\n// prefer mkCapoCtx.needsCharter() for \"get from anywhere\" semantics\n// and cctx.getCharterData() to get the datum\n//  (... or mkCapoCtx.withCharterRef() to require unchanged charter)\n//  (... or mkCapoCtx.withCharterInput() to require the charter to be spent & maybe updated)\nfunc getTxCharterData(\n    mph : MintingPolicyHash,\n    refInputs : []TxInput = tx.ref_inputs\n) -> CapoDatum::CharterData {\n    chVal : Value = tvCharter(mph);\n    hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };\n\n    charterUtxo : TxInput = refInputs.find_safe(hasCharter).switch{\n        Some{ch} => ch,\n        None => tx.inputs.find_safe(hasCharter).switch{\n            Some{ch} => ch,\n            None => error(\"Missing charter inputs / ref_inputs\")\n        }\n    };\n    ctd : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n        charterUtxo.datum.inline\n    );\n\n    ctd\n}\n\nfunc mustHaveGovAuthority(\n    mph : MintingPolicyHash,\n    charterData : CapoDatum::CharterData = getTxCharterData(mph)\n) -> Bool {\n    charterData.govAuthorityLink.hasValidOutput(mph)\n}\n\n/**************************************************************\n      ************************************************************\n      ************************************************************\n      *******************                      *******************\n      *******************                      *******************\n      *******************     DelegateInput    *******************\n      *******************                      *******************\n      *******************                      *******************\n      ************************************************************\n      ************************************************************\n      ************************************************************\n*/\n\n/**\n * A high-level helper for delegates, enabling various kinds of\n * validation and delegation-related operations.  Although this\n * is defined as related to an \"Input\", this object provides a gateway\n * for any script to involve that delegate policy in the abstract, by\n * virtue of having included that input in the transaction.\n * Callers should expect that the other policy will\n * do its responsibilities and may use this object to enforce that\n * the other policy is **triggered** in expected ways.\n */\nstruct DelegateInput {\n    link: RelativeDelegateLink\n    role: DelegateRole\n    idPrefix: Option[String]\n    input: Option[TxInput]\n    mph: MintingPolicyHash\n\n    func genericDelegateActivityAsData(self) -> Data {\n        i : TxInput = self.input.unwrap();\n        inputData : Data = mustFindInputRedeemer(i);\n        inputData.switch {\n            ConstrData{index, _fields} => {\n                // ladybug emoji: \"🐞\"\n                print(\"    --🐞 generic delegate activity at index \"+ index.show() )\n                // doesn't get optimized out:\n                // inpIdStr = i.output_id.tx_id.show() + \"🔹#\" + i.output_id.index.show();\n                // valStr = i.value.show();\n                // print(\"    ---- from input id:\" + inpIdStr + \" = \"+valStr)\n            } \n        };\n        inputData\n    }\n\n    func genericDelegateActivity(self) -> AbstractDelegateActivitiesEnum {\n        AbstractDelegateActivitiesEnum::from_data(\n            self.genericDelegateActivityAsData()\n        )\n    }    \n\n    /**\n     * Throws an error message including the delegation token id,\n     * if the assertion is false.\n     */\n     func assert(self, assertionOk : Bool, msg: String) -> () {\n        assert(true || /* never executed */ self.serialize() == self.serialize(), msg);\n        if(assertionOk) { assert(true, \"\" ) } else {\n            self.error(msg)\n        }\n     }\n\n    /**\n     * Throws an error message including the delegation token id.\n     */     \n    func error(self, msg: String) -> () {\n        assert(true || /* never executed */ self.serialize() == self.serialize(), msg);\n        // warning emoji: \"⚠️\"\n        print(\"⚠️ ⚠️ ⚠️ error executing policy for dgTkn: \");\n        print( mkTokenShow(self.mph)(\n                (self.input.unwrap().value)\n            )\n        );\n        print(\"\\n\");\n        assert(false, msg)\n    }\n\n    func withSpendingActivity(self) -> DelegateInput {\n        self.genericDelegateActivity().switch {\n            SpendingActivities => self,\n            _ => {\n                self.error(\"non-spend activity!\");\n                error(\"\")\n            }\n        }\n    }\n\n    func withMintingActivity(self) -> DelegateInput {\n        self.genericDelegateActivity().switch {\n            MintingActivities => self,\n            _ => {\n                self.error(\"non-mint activity!\"); \n                error(\"\") \n            }\n        }\n    }\n\n    func updatingManifest(self) -> DelegateInput {\n        self.role.switch {\n            SpendDgt => {\n                print(\"checking presence of SpendDgt: updatingManifest activity\");\n                self.genericDelegateActivity().switch {                    \n                    CapoLifecycleActivities{cla} => cla.switch {\n                        updatingManifest => self,\n                        _ => {\n                            self.error(\"not using required updatingManifest activity\");\n                            error(\"\") // unreachable\n                        }\n                    },\n                    _ => {\n                        self.error(\"updatingManifest: only valid for CapoLifecycleActivities\");\n                        error(\"unreachable\")\n                    }\n                }\n            },\n            _ => {\n                self.error(\"updatingManifest: only valid for SpendDgt\");\n                error(\"unreachable\")\n            }\n        }\n    }\n\n    func withUniqueSeededMintingActivity(self, seed: TxOutputId) -> DelegateInput {\n        // tnFactory : (String) -> String = mkUutTnFactory(seed);\n\n        REQT(\"withUniqSeededMinting: ensures the delegate is unchanged, so callers needn't.\");\n        self.genericDelegateActivity().switch {\n            MintingActivities{ma} => {\n                ma.switch {\n                    ConstrData{_index, fields} => {\n                        // assert(index==index, \"no way\"); // unused field can't be _\n                        assert(\n                            seed == TxOutputId::from_data(fields.get(0)),\n                            \"seed mismatch\"\n                        )\n                    },\n                    _ => error(\"no way\")\n                };\n                self.delegateUnchanged()\n            },\n            MultipleDelegateActivities{activities} => {\n                // can do one or more minting activities, but each one needs to be bound to a separate seed\n                assert(activities.length > 0, \"no minting activities found\");\n                foundWithThisSeed : []Data = activities.filter( (a : Data) -> Bool {\n                    AbstractDelegateActivitiesEnum::from_data(a).switch {\n                        MintingActivities{ma} => {\n                            ma.switch {\n                                ConstrData{index, fields} => {\n                                    assert(index==index, \"no way c\"); // unused field can't be _ in switch\n                                    seed == TxOutputId::from_data(fields.head) &&\n                                    true\n                                },\n                                _ => error(\"no way d\")\n                            }\n                        },\n                        _ => false\n                    }\n                });\n                REQT(\"one of the delegate multi-activities must be minting with this seed\");\n                self.assert(foundWithThisSeed.length > 0, \"no minting activity found for seed!\");\n                REQT(\"only one of a multi-activity for a given seed is allowed\");\n                self.assert(foundWithThisSeed.length == 1, \"multiple minting activities found for seed\");\n\n                self.delegateUnchanged()\n            },\n            _ => {\n                self.error(\"non-mint activity!\");\n                error(\"\")\n            }\n        }\n    }\n\n    func withUniqueDDSpendingActivity(self, recId: ByteArray) -> DelegateInput {\n        self.role.switch {\n            DgDataPolicy => print(\"ok, checking spending activity for a DgData Policy\"),\n            _ => error(\"withUniqueDDSpendingActivity: only valid for DgDataPolicy\")\n        };\n\n        REQT(\"withUniqueDDSpendingActivity: checks presence of delegated-data controller's spending activity for recId\");\n        strId : String = recId.decode_utf8();\n        print(\"    -- recId: \"+ strId);\n\n        TODO(\"TEST THIS v\");\n        REQT(\"spendDgt must be acting on the matching record-id\");\n        REQT(\"ensures the delegate is unchanged, so callers needn't also check that\"); \n\n        self.genericDelegateActivity().switch {\n            SpendingActivities{sa} => {\n                sa.switch {\n                    ConstrData{index, fields } => {\n                        assert(index==index, \"no way e\"); // unused field can't be _\n                        foundRecId: ByteArray = ByteArray::from_data(fields.head);\n                        if(recId != foundRecId) {\n                            print(\"  -- expected: Spending:\"+strId);\n                            print(\"  -- actual: Spending:\"+foundRecId.show());\n                            self.error(\"recId mismatch\")\n                        } else {\n                            print (\"  -- ok: DD controller spending activity for \"+strId)\n                        }\n                    },\n                    _ => error(\"no way f\")\n                };\n                self.delegateUnchanged()\n            },\n            MultipleDelegateActivities{activities} => {\n                print( \"    -- multiple activities found\\n\" );\n                self.assert(activities.length > 0, \"no spending activities found\");\n                // can do one or more spending activities, but each one needs to be bound to a separate recId\n                actsOnThisRecord : []Data = activities.filter( (a : Data) -> Bool {\n                    AbstractDelegateActivitiesEnum::from_data(a).switch {\n                        CreatingDelegatedData => {\n                            self.error(\n                                \"dgInput: withSpendingActivity: CreatingDelegatedData invalid\"\n                            );\n                            error(\"\")\n                        },\n                        UpdatingDelegatedData => {\n                            self.error(\n                                \"dgInput: withSpendingActivity: UpdatingDgData invalid; use a Spending variant in the delegated-data policy\"\n                            );\n                            error(\"\")\n                            // \" not the delegate controller's activities (use SpendingDelegatedData for that)\"\n                        },\n                        DeletingDelegatedData => {\n                            self.error(\n                                \"dgInput: withSpendingActivity: DeletingDelegatedData invalid\" \n                                // is only valid in context of a mintDgt- when destroying a data record\n                            );\n                            error(\"\")\n                        },\n                        SpendingActivities{sa} => {\n                            // assert(false && sa.serialize() == sa.serialize(), \"no way g\");\n                            // false\n                            sa.switch {\n                                ConstrData{index, fields} => {\n                                    assert(index==index, \"no way h\"); // unused field can't be _\n                                    foundRecId: ByteArray = ByteArray::from_data(fields.head);\n                                    if(recId != foundRecId) {\n                                        print(\"  -- expected: Spending: \"+strId);\n                                        print(\"\\n  -- actual: Spending: \"+foundRecId.show());\n                                        self.error(\"recId mismatch\");\n                                        error(\"\")\n                                    } else { true }\n                                },\n                                _ => {\n                                    self.error(\"wrong structure for spending activity\");\n                                    error(\"\")\n                                }\n                            }\n                        },\n                        \n                        _ => false\n                    }\n                });\n                REQT(\"one of the delegate data-controller multi-activities must treat this recId\");\n                self.assert(\n                    (actsOnThisRecord.length > 0).trace(\"dgt acting on this recId? \")\n                    , \"no spending activity found for recId: \"+strId\n                );\n                REQT(\"only one of a multi-activity for a given recId is allowed\");\n                self.assert(\n                    (actsOnThisRecord.length == 1).trace(\"exactly one activity? \")\n                    , \"multiple spending activities found for recId: \"+strId\n                );\n                self.delegateUnchanged()\n            },\n            _ => {\n                self.error(\"non-spend activity!\");\n                error(\"\")\n            }\n        }\n    }\n\n    func requiresValidOutput(self, createdOrReturned : DgTkn=DgTkn::Returned) -> Bool {\n        // TODO - would want this to be able to call our assert/error methods\n        self.link.hasValidOutput(\n            mph: self.mph, \n            required: true,\n            createdOrReturned: createdOrReturned\n        )\n    }\n\n    func getActivity[ACTIVITY](self) -> ACTIVITY {\n        ACTIVITY::from_data(\n            mustFindInputRedeemer(self.input.unwrap())\n        )\n    }\n\n    func getDatum[DATUM](self) -> DATUM {\n        DATUM::from_data(\n            self.input.unwrap().datum.inline\n        )\n    }\n\n    func delegateUnchanged(self) -> DelegateInput {\n        DelegateInput{link, _role, _idPrefix, input, mph} = self;\n\n        RelativeDelegateLink{\n            uut,\n            //  _ /* strategy */,\n            validatorHash,\n            _configJson\n        } = link;\n        targetValue : Value = mkTv(mph, uut);\n        returnedUnchanged : Bool = validatorHash.switch {\n            Some{vh} => {\n                // print(\" ⬅️ 🔎 💁 expect dgTkn \"+uut + \" sent to vh \" + vh.show());\n                self.assert(\n                    tx.value_locked_by(vh)   .\n                    contains(\n                        targetValue\n                    ), \n                    \"dgTkn not returned: \"+ uut\n                );\n                tx.outputs.find_safe((o : TxOutput) -> Bool {\n                    o.datum.serialize() == input.unwrap().datum.serialize()\n                }).switch {\n                    Some => {\n                        print(\" -- good, the dgTkn is unchanged: \"+uut);\n                        true\n                    }, \n                    None => {\n                        self.error(\"dgt modified\");\n                        error(\"\")\n                    }\n                }\n            },\n            None => {\n                self.error(\"unchOut - no vh\"); // this method not valid on non-contract delegate tokens\n                error(\"\")\n                // todo maybe make it valid by enforcing return to the input address?\n            }\n        };\n        assert(returnedUnchanged, \"no\"); // already thrown\n        assert(link.hasValidOutput(mph), \"no\"); // thrown inside the method\n\n        self\n    }\n    // syntax sugar.  Implied is that that any other function calls will trip errors,\n    func orFail(self) -> Bool {\n        // assert(true || /* never executed */ self.serialize() == self.serialize(), \"no way i\");\n        _t = self;\n        true\n    }\n}\n\n// func genericDelegateActivity(\n//     link: RelativeDelegateLink,\n//     input: TxInput\n// ) -> DelegateActivity[AbstractDelegateActivitiesEnum] {\n//     DelegateActivity[AbstractDelegateActivitiesEnum]::new{\n//         link,\n//         input,\n//         // datum: Option[DATUM]::None,\n//         activity: Option[AbstractDelegateActivitiesEnum]::None\n//     }\n// }\n\n\n/**************************************************************\n      ************************************************************\n      ************************************************************\n      *******************                      *******************\n      *******************                      *******************\n      *******************     DgDataDetails    *******************\n      *******************                      *******************\n      *******************                      *******************\n      ************************************************************\n      ************************************************************\n      ************************************************************\n*/      \n\n\nstruct DgDataDetails {\n    dataSrc: dgd_DataSrc\n    // filteredInputs: []TxInput\n    id: ByteArray\n    type: String\n    mph: MintingPolicyHash\n    // inputs: []TxInput\n\n    // see CapoCtx::updatingDgData(id)\n    func updating(id : ByteArray, input: TxInput, output : TxOutput, mph : MintingPolicyHash) -> DgDataDetails {\n        DgDataDetails{\n            dataSrc: dgd_DataSrc::Both{input, output},\n            id: id,\n            type: \"\",\n            mph: mph\n        }\n    }\n    \n    // see CapoCtx::creatingDgData(id)\n    func creating(id : ByteArray, output : TxOutput, mph : MintingPolicyHash\n    ) -> DgDataDetails {\n        DgDataDetails{\n            dataSrc: dgd_DataSrc::Output{output},\n            id: id,\n            type: \"\",\n            mph: mph\n        }\n    } \n\n    func uutValue(self) -> Value {\n        Value::new(\n            AssetClass::new(self.mph, self.id), \n            1\n        )\n    }\n\n    // func withOutput(id : ByteArray, input: []TxInput, output : TxOutput) -> DgDataDetails {\n    //     DgDataDetails{\n    //         dataSrc: dgd_DataSrc::Output{output},\n    //         // filteredInputs: []TxInput{},\n    //         id: id,\n    //         type: \"\"\n    //         // inputs: inputs\n    //     }\n    // }\n\n    // func withInput(self) -> DgDataDetails {\n    //     assert(self.id.length > 0, \"no id; try cctx.updatingDgDat (id)\");\n    //     self.dataSrc.switch {\n    //         Input => self,\n    //         Both => self,\n    //         _ => {\n    //             oneInput: []TxInput = self.filterInputs();\n    //             assert(1 == oneInput.length, \"yikes! too many inputs\");\n    //             dataSrc : dgd_DataSrc = self.dataSrc.switch {\n    //                 Unk => dgd_DataSrc::Input{oneInput.head},\n    //                 Output{txo} => dgd_DataSrc::Both{oneInput.head, txo},\n    //                 _ => error(\"no way j \") // already returned self\n    //             };\n\n    //             DgDataDetails{\n    //                 dataSrc: dataSrc,\n    //                    // filteredInputs: oneInput,\n    //                 id: self.id,\n    //                 type: self.type,\n    //                 inputs: self.inputs\n    //             }\n    //         }\n    //     }\n    // }\n\n    func input(self) -> TxInput {\n        // assert(1 == self.filteredInputs.length, \"use withId(id)\");\n        // assert(self.id.length > 0, \"use withId(id) or cctx.updatingDgData(id).withInput()\");\n\n        // self.inputs.head\n        self.dataSrc.switch {\n            Input{utxo} => utxo,\n            Both{utxo, _} => utxo,\n            _ => error(\"no input data; use findInput() first\")\n        }\n    }\n\n    func output(self) -> TxOutput {\n        self.dataSrc.switch {\n            Output{txo} => txo,\n            Both{_, txo} => txo,\n            _ => error(\"no output data\")\n        }\n    }\n\n    // doesn't work - something about the way the IR is generated?\n    //   - seems like it might be the list operations, \n    //   - or scoping of the fields of type []TxInput?\n    //\n    // func findInput(self) -> DgDataDetails {\n    //     self.dataSrc.switch {\n    //         Input => self,\n    //         Both => self,\n    //         _ => {\n    //             targetId : ByteArray = self.id;\n    //             isEmpty : Bool = targetId.length == 0;\n    //             print(\"finding input dgData id: \"+self.id.decode_utf8());\n    //             utxo: TxInput = self.inputs.find_safe( (txin : TxInput) -> Bool {\n    //                 rec : AnyData = AnyData::from_data(\n    //                     txin.datum.inline\n    //                 );\n    //                 rec.type.starts_with(self.type)\n    //                 && (isEmpty || rec.id == targetId)\n    //             }).switch {\n    //                 Some{x} => x,\n    //                 None => error(\"❌ no input dgData\")\n    //             };\n    //             newSrc: dgd_DataSrc = self.dataSrc.switch {\n    //                 Output{txo} => dgd_DataSrc::Both{utxo, txo},\n    //                 Unk => dgd_DataSrc::Input{utxo},\n    //                 _ => error(\"no way k\") // unreachable\n    //             };\n\n    //             DgDataDetails{\n    //                 dataSrc: newSrc,\n    //                 // filteredInputs: [utxo],\n    //                 id: self.id,\n    //                 type: self.type,\n    //                 inputs: self.inputs\n    //             }\n    //         }\n    //     }\n    // }\n\n\n    // func filterInputs(self) -> []TxInput {\n    //     self.inputs\n    //     // targetId : ByteArray = self.id;\n    //     // isEmpty : Bool = targetId.length == 0;\n    //     // self.inputs.filter( (txin : TxInput) -> Bool {\n    //     //     rec : AnyData = AnyData::from_data(\n    //     //         txin.datum.inline\n    //     //     );\n\n    //     //     rec.type.starts_with(self.type)\n    //     //     && (isEmpty || rec.id == targetId)\n    //     // })\n    // }\n\n    // func withFilteredInputs(self) -> DgDataDetails {\n    //     //!!! causes IR assertion error\n    //     // if (self.filteredInputs.is_empty()) {\n    //     // if (self.filteredInputs.length == 0) {\n    //     if(true) {\n    //             self\n    //         // DgDataDetails {\n    //         //     dataSrc: self.dataSrc,\n    //         //     filteredInputs: self.filterInputs(),\n    //         //     id: self.id,\n    //         //     type: self.type,\n    //         //     inputs: self.inputs\n    //         // }\n\n    //     // dataSrc: dgd_DataSrc\n    //     // filteredInputs: []TxInput\n    //     // id: ByteArray\n    //     // type: String\n    //     // inputs: []TxInput\n    \n    //     } else {\n    //         self\n    //     }\n    // }\n\n    func inputData(self) -> Data {\n        self.input().datum.inline.switch {\n            ConstrData{_, fields} => fields.head,\n            _ => error(\"expected ConstrData{mStruct} for DgData input\")\n        }\n        // self.dataSrc.switch {\n        //     Input{utxo} => utxo.datum.inline,\n        //     Both{utxo, _} => utxo.datum.inline,\n        //     _ => error(\"no input data\")\n        // }\n    }\n\n    func outputData(self) -> Data {\n        self.output().datum.inline.switch {\n            ConstrData{_, fields} => fields.head,\n            _ => error(\"expected ConstrData{mStruct} for DgData output\")\n        }\n\n        // self.dataSrc.switch {\n        //     Output{txo} => txo.datum.inline,\n        //     Both{_, txo} => txo.datum.inline,\n        //     _ => error(\"no output data\")\n        // }\n    }\n    \n    // func mustHaveUut(self, uut: String) -> Bool {\n    //     // todo\n    //     false\n    // }\n}\n\n/**************************************************************\n      ************************************************************\n      ************************************************************\n      *******************                      *******************\n      *******************                      *******************\n      *******************        CapoCtx       *******************\n      *******************                      *******************\n      *******************                      *******************\n      ************************************************************\n      ************************************************************\n      ************************************************************\n*/      \n\nstruct CapoCtx {\n    mph: MintingPolicyHash\n    charter: cctx_CharterInputType\n\n    func mkTv(self,\n        tn: ByteArray,\n        count : Int = 1\n    ) -> Value {\n        assert(tn.length > 0, \"missing reqd tn\");\n        Value::new(\n            AssetClass::new(self.mph, tn), \n            count\n        )\n    }\n\n    // use this or updatingDgData() instead of getDDOutput()\n    func creatingDgData(\n        self,\n        recId : String=\"\", \n        recIdBytes : ByteArray = recId.encode_utf8()\n    ) -> DgDataDetails {\n        output : TxOutput = self.delegatedTxOutput(recIdBytes);\n        DgDataDetails::creating(recIdBytes, output, self.mph)\n    }\n\n    func updatingDgData(\n        self,\n        recId : String=\"\", \n        recIdBytes : ByteArray = recId.encode_utf8()\n    ) -> DgDataDetails {\n        output : TxOutput = self.delegatedTxOutput(recIdBytes);\n        input : TxInput = self.delegatedDataTxInput(recIdBytes: recIdBytes);\n        DgDataDetails::updating(recIdBytes, input, output, self.mph)\n    }\n\n    func now(self, granularity: Duration = Duration::HOUR) -> Time {\n        validity : TimeRange = tx.time_range;\n        assert(true || /* never executed */ self.serialize() == self.serialize(), \"no way l\");\n        \n        assert(\n            validity.end - validity.start \n                <= granularity,\n            \"txn duration must be at most \"+granularity.show() + \"ms\"\n        );\n        validity.start\n    }\n    \n    func getCharterRedeemer(self) -> CapoActivity {\n        e : String = \"requires charter as input\";\n        self.charter.switch {\n            Unk => error(e),\n            RefInput => error(e),\n            Input{_, utxo} => {\n                activity : CapoActivity = CapoActivity::from_data(\n                    mustFindInputRedeemer(utxo)\n                );\n                // error-factory:\n                wrongActivity = () -> CapoActivity { \n                    if (true) { error(\"non-CharterData activity\") } else { \n                        // unreachable\n                        CapoActivity::usingAuthority\n                    } \n                };\n                // returns any activity valid for the CharterData utxo:\n                activity.switch {\n                    retiringRefScript => wrongActivity(),\n                    // updatingSettings => wrongActivity(),\n                    // retiringSettings => wrongActivity(),                    \n                    spendingDelegatedDatum => wrongActivity(),\n                    usingAuthority => activity,\n                    updatingCharter => activity, //todo: make this obsolete\n                    addingSpendInvariant => activity,\n                    capoLifecycleActivity => activity\n\n                    // _ => // leaving other potential variants out to generate compile errors if they're added\n                }\n            }\n        }\n    }\n\n    func findManifestEntry(self, key: String) -> Option[CapoManifestEntry] {\n        print(\"    -- looking for capo's manifest entry: \"+key);\n        charterData : CapoDatum::CharterData = self.getCharterData();\n        charterData.manifest.get_safe(key)\n    }\n\n    func mustFindManifestEntry(self, key: String) -> CapoManifestEntry {\n        self.findManifestEntry(key).switch {\n            Some{entry} => entry,\n            None => error(\"missing required manifest entry: \" + key)\n        }\n    }\n\n    func findManifestTokenName(self, key: String, required: Bool = true) -> Option[ByteArray] {\n        oe = self.findManifestEntry(key);\n        oe.switch {\n            None => {\n                assert(!required, \"missing required manifest entry: \" + key);\n                Option[ByteArray]::None\n            }, \n            Some{e} => Option[ByteArray]::Some{e.tokenName}\n        }\n    }\n\n    func getSettingsId(self, required : Bool = true) -> Option[ByteArray] {\n        self.findManifestTokenName(\"currentSettings\", required)\n    }\n\n    func getManifestedData(self, key: String,\n        which : UtxoSource = UtxoSource::RefInput\n    ) -> Data {\n        print(\"  -- finding manifest symbol \"+ key);\n        manifestEntry : CapoManifestEntry = self.mustFindManifestEntry(key);\n        tokenName : ByteArray = manifestEntry.tokenName;\n        manifestValue : Value = mkTv(mph: self.mph, tnBytes: tokenName);\n        tnStr = tokenName.decode_utf8();\n        print(\"     ... with input dgData token name: \"+ tnStr);\n        // print(\"     with value: \"+manifestValue.show()+\"\\n\");\n\n        inputs: []TxInput = which.switch {\n            RefInput => tx.ref_inputs,\n            Input => tx.inputs\n        };\n        utxo : TxInput = inputs.find_safe((txin : TxInput) -> Bool {\n            txin.value.contains(manifestValue)\n        }).switch{\n            Some{txin} => {\n                print (\"  ✅ ➡️  📀💁 found ^ input dgData utxo\" );\n                txin\n            },\n            None => {                \n                error(\n                    \"_❌ ➡️ 📀💁💣💥💣💥💣💥  missing expected '\"+key+\"' entry in the capo manifest ^^^ in \"+\n                    which.switch{RefInput => \"ref_inputs\", Input => \"inputs\"}+\n                    \"\\n   -- this really shouldn't happen unless the tx-builder is doing a very wrong thing\"\n                    // lifecycle management should always ensure a good linkage between\n                    // the capo's manifest entry and the matching utxo having that uut.\n                )\n            }\n        };\n\n        utxo.datum.inline.switch {\n            ConstrData{_, fields} => {\n                // print(\"utxo: \"+ utxo.output_id.show());\n                // print(\"manifested data fields = \"+fields.length.show());\n                fields.head.switch {\n                    MapData => {\n                        // print(\"mapData found\");\n                        fields.head\n                    },\n                    _ => error(\"expected MapData for manifested data: \"+ key)\n                }\n            },\n            _ => error(\"expected ConstrData{‹any›, mStruct} for manifested data: \"+ key)\n        }\n    }\n\n    func getNextManifestDatum[DATUM_TYPE](self, key: String) -> DATUM_TYPE {\n        DATUM_TYPE::from_data(\n            self.getNextManifestedDatumRaw(key)\n        )\n    }\n\n    func getNextManifestedDatumRaw(self, key: String) -> Data {\n        charterData : CapoDatum::CharterData = self.getCharterData();\n        manifestEntry : CapoManifestEntry = charterData.manifest.get_safe(key).switch{\n            Some{entry} => entry,\n            None => error(\"missing required manifest entry: \" + key)\n        };\n        manifestValue : Value = mkTv(mph: self.mph, tnBytes: manifestEntry.tokenName);\n        utxo : TxOutput = tx.outputs.find_safe((txo : TxOutput) -> Bool {\n            txo.value.contains(manifestValue)\n        }).switch{\n            Some{txo} => txo,\n            None => error(\"missing required '\"+key+\"' manifest entry in outputs\")\n        };\n\n        utxo.datum.inline.switch {\n            ConstrData{_, fields} => fields.head,\n            _ => error(\"expected ConstrData{mStruct} for manifested data: \"+ key)\n        }\n    }\n\n    // func getRefSettingsUtxo(self) -> TxInput {\n    //     charterData : CapoDatum::CharterData = self.getCharterData();\n    //     settingsValue : Value = mkTv(mph: self.mph, tnBytes: charterData.settingsUut);\n    //     hasSettings = (txin : TxInput) -> Bool { txin.value.contains(settingsValue) };\n\n    //     print(\"getting ref_input for settings\\n\");\n    //     settingsUtxo : TxInput =  tx.ref_inputs.find_safe(hasSettings).switch{\n    //         Some{s} => s,\n    //         //!!! todo adjust this message: Missing required charter in ref_inputs\n    //         None => error(\"Missing settings in required ref_inputs (use capo.addSettingsRef(tcx, 'refInput') in txn builder)\")\n    //     };\n    \n    //     settingsUtxo\n    // }\n\n    func requiresGovAuthority(self) -> CapoCtx {\n        REQT(\"it must have the Capo's govAuthority approval\");\n        \n        assert(\n            self.getCharterData().govAuthorityLink.hasValidOutput( \n                self.mph  \n            ), /*always true*/\n            \"no way m\"\n        ); \n\n        self\n    }\n\n    // func getSettings[SettingsTYPE](self) -> SettingsTYPE {\n    //     settings : TxInput = self.getRefSettingsUtxo();\n\n    //     SettingsTYPE::from_data(settings.datum.inline)\n    // }\n\n    func requiresNamedDelegateInput(self, dgtName: String) -> DelegateInput {\n        self.getCharterData().otherNamedDelegates.get_safe(dgtName).switch{\n            None => error(\"missing required delegate with name: \" + dgtName),\n\n            Some{dgtLink} => {\n                self.requiresDelegateInput(dgtLink, DelegateRole::OtherNamedDgt{dgtName})\n            }\n        }\n    }\n\n    func requiresDgDataPolicyInput(self, typeName: String, required: Bool = true) -> DelegateInput {\n        self.getCharterData().manifest.get_safe(typeName).switch{\n            None => error(\"missing required data policy with type: \" + typeName),\n            Some{entry} => {\n                ( dgtLink : RelativeDelegateLink, idPrefix: String ) = entry.entryType.switch {\n                    DgDataPolicy{policyLink, idPrefix, _refCount} => ( policyLink, idPrefix ),\n                    _ => error(\"manifest entry is not a data policy: \"+typeName)\n                };\n                REQT(\"requires the delegated-data policy for type=\"+typeName);\n                self.requiresDelegateInput(\n                    dgtLink, \n                    DelegateRole::DgDataPolicy{typeName}, \n                    required,\n                    Option[String]::Some{idPrefix}\n                )\n            }\n        }\n    }\n\n    func nowActingAsMintDgt(self, required: Bool = true) -> Bool {\n        input : TxInput = get_current_input();\n        isUsingMintDgt = input.value.contains(\n            self.getCharterData().mintDelegateLink.tvAuthorityToken(self.mph)\n        ).trace(\"    -- acting on mintDgt-* token right now? \");\n        // isMintDgt : Bool = (\n        //     self.requiresMintDelegateInput(required: required).input.switch {\n        //         Some{i} => i == input,\n        //         None => false\n        //     }\n        // ).trace(\"    -- acting on mintDgt-* right now? \");\n        assert(\n            isUsingMintDgt || !required\n            , \"not acting as mint delegate!\"\n        );\n        isUsingMintDgt\n    }\n\n    func nowActingAsSpendDgt(self, required: Bool = true) -> Bool {\n        input : TxInput = get_current_input();\n        isUsingSpendDgt = input.value.contains(\n            self.getCharterData().spendDelegateLink.tvAuthorityToken(self.mph)\n        ).trace(\"    -- acting on spendDgt-* token right now? \");\n        // isSpendDgt : Bool = (\n        //     self.requiresSpendDelegateInput(required: required).input.switch {\n        //         Some{i} => i == input,\n        //         None => false\n        //     }\n        // ).trace(\"    -- acting on spendDgt-* right now? \");\n        assert(\n             isUsingSpendDgt || !required\n            , \"not acting as spend delegate!\"\n        );\n        isUsingSpendDgt\n    }\n\n    func requiresMintDelegateInput(self, required: Bool = true) -> DelegateInput {\n        dgtLink : RelativeDelegateLink = self.getCharterData().mintDelegateLink;\n        self.requiresDelegateInput(\n            dgtLink: dgtLink, \n            role: DelegateRole::MintDgt,\n            required: required\n        )\n    }\n\n    func requiresSpendDelegateInput(self, required: Bool = true) -> DelegateInput {\n        dgtLink : RelativeDelegateLink = self.getCharterData().spendDelegateLink;\n\n        self.requiresDelegateInput(\n            dgtLink: dgtLink, \n            role: DelegateRole::SpendDgt,\n            required: required\n        )\n    }\n\n    // internal / low-level function\n    func getCharterData(self) -> CapoDatum::CharterData {\n        self.charter.switch {\n            RefInput{datum, _} => datum,\n            Input{datum, _} => datum,\n            _ => error(\"CapoCtx.getCharterData(): unknown charter strategy; use result of withCharterInput(), withCharterRef(), or needsCharter() to resolve charter datum first\")\n        }\n    }\n\n    func getNextCharterData(self) -> CapoDatum::CharterData {\n        self.charter.switch {\n            Input => {\n                charterData : CapoDatum::CharterData = CapoDatum::from_data(\n                    tx.outputs.find( (txo: TxOutput) -> Bool {\n                        txo.address == self.resolveCharterUtxo().address &&\n                        txo.value.contains(mkTv(self.mph, \"charter\"))\n                    }).datum.inline\n                );\n                charterData\n            },\n            _ => error(\"CapoCtx.getNextCharterData(): invalid except with charter strategy Input\")\n        }\n    }\n\n    func resolveCharterUtxo(self) -> TxInput {\n        self.charter.switch {\n            RefInput{_, utxo} => utxo,\n            Input{_, utxo} => utxo,\n            // Minting => error(\"can't get utxo during minting; be satisfied with the .address()!\"),\n            _ => error(\"CapoCtx.resolveCharterUtxo(): unknown charter strategy; use result of withCharterInput(), withCharterRef(), or needsCharter() to resolve charter utxo first\")\n        }\n    }\n\n    // internal / low-level function\n    func requiresDelegateInput(self, \n        dgtLink: RelativeDelegateLink, \n        role: DelegateRole,\n        required: Bool = true,\n        idPrefix: Option[String] = Option[String]::None\n    ) -> DelegateInput {\n        DelegateInput{\n            dgtLink,\n            role,\n            idPrefix,\n            dgtLink.hasDelegateInput(\n                inputs: tx.inputs, \n                mph: self.mph,\n                required: required\n            ),\n            self.mph\n        }\n    }\n\n    func address(self) -> Address {\n        addr : Address = self.resolveCharterUtxo().address;\n                // print(\"Capo addr: \" + addr.show());\n        addr    \n    }\n\n    func delegatedDataRef(self,\n        recId: String=\"\",\n        recIdBytes: ByteArray=recId.encode_utf8()\n    ) -> TxInput {\n        hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(\n            id: recIdBytes\n        );\n\n        recIdStr = recIdBytes.decode_utf8();\n        print(\"  -- expecting refDD \"+ recIdStr);\n        tx.ref_inputs.find_safe(hasDD).switch {\n            None => {\n                error(\"❌❌ 📎 ^ refDD: not found\\n\")\n            },\n            Some{txin} => {\n                print(\"✅ 📎 ^ refDD: ok\\n\");\n\n                txin\n            }\n        }\n    }\n\n    func delegatedDataTxInput(self, \n        recId: String=\"\",\n        recIdBytes: ByteArray=recId.encode_utf8()\n    ) -> TxInput {\n        hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(\n            id: recIdBytes\n        );\n\n        recIdStr = recIdBytes.decode_utf8();\n        print(\"  -- expecting inDD \" + recIdStr);\n\n        tx.inputs.find_safe(hasDD).switch {\n            None => {\n                error(\"❌❌ 📎 ^ inDD: not found\\n\")\n            },\n            Some{txin} => {\n                print(\"    ✅ 📎 ^ inDD: ok\\n\");\n\n                txin\n            }\n        }\n    }\n                \n    func mkDelegatedDataPredicate(self, typeName: String=\"\", id: ByteArray=#) -> (TxInput) -> Bool {\n        capoAddr : Address = self.address();\n        assert( \n            id.length > 0 \n            || typeName.serialize().length > 0, \n            \"data predicate must have id or typeName\"\n        );\n        (txin : TxInput) -> Bool {\n            if(txin.address == capoAddr) {\n                data : Data = txin.datum.inline;\n\n                CapoDatum::from_data(data).switch {\n                    DelegatedData => {\n                        x = AnyData::from_data(fromCip68Wrapper(data));\n                        true \n                        && (typeName == \"\" || x.type == typeName) \n                        && (id == # || x.id == id)\n                    },\n                    _ => false\n                }\n            } else { false }\n        }\n    }\n\n    func mkDelegatedDataOutputPredicate(self, typeName: String, id: ByteArray=#) -> (TxOutput) -> Bool {\n        capoAddr : Address = self.address();\n        // print(\"capoAddr: \"+ capoAddr.show());\n        // print(\"seeking type \"+ typeName);\n        (txo : TxOutput) -> Bool {\n            // print(\"txo.address: \"+ txo.address.show());\n            if(txo.address == capoAddr) {\n                data : Data = txo.datum.inline;\n                CapoDatum::from_data(data).switch {\n                    DelegatedData => {\n                        x : AnyData = AnyData::from_data(fromCip68Wrapper(data));\n                        // print( \"found type \" + x.type );\n                        // print( \"found id \" + x.id.decode_utf8() );\n                        // isMatch : Bool = \n                        x.type == typeName && (id == # || x.id == id)\n                        // print( \"isMatch: \" + isMatch.show() );\n                        // isMatch\n                    },\n                    _ => {\n                        // print (\"not DelegatedData\");\n                        false\n                    }\n                }\n            } else { \n                // print (\"not in capoAddr\");\n                false\n             }\n        }\n    }\n\n\n    // func toDelegatedData(self, typeName: String) -> (TxInput) -> Option[Data] {\n    //     capoAddr : Address = self.resolveCharterUtxo().address;\n    //     none : Option[Data]::None = Option[Data]::None;\n    //     (txin : TxInput) -> Option[Data] {\n    //         if(txin.address == capoAddr) {\n    //             data : Data = txin.datum.inline;\n    //             CapoDatum::from_data(data).switch {\n    //                 DelegatedData => {\n    //                     x : AnyData = AnyData::from_data(data);\n    //                     if (x.type == typeName) {\n    //                         Option[Data]::Some{data}\n    //                     } else {\n    //                         none\n    //                     }\n    //                 },\n    //                 _ => none\n    //             }\n    //         } else { none }\n    //     }\n    // }\n\n    // func foldDelegatedData_lazy[RT]( self, \n    //     typeName: String, \n    //     reducer: (\n    //         Data, () -> RT\n    //     ) -> RT, \n    //     final: RT\n    // ) -> RT {\n    //     // filter : (TxInput) -> Bool = self.delegatedDataFilter(typeName);\n    //     hasDD : (TxInput) -> Option[Data] = self.toDelegatedData(typeName);\n    //     // capoAddr : Address = self.resolveCharterUtxo().address;\n    //     tx.inputs.fold_lazy[RT](\n    //         (txin : TxInput, myNext: () -> RT) -> RT {\n    //             hasDD(txin).switch {\n    //                 Some{data} => reducer(data, myNext),\n    //                 None => myNext()\n    //             }\n    //         }, final\n    //     )\n    // }\n\n    // func filterDelegatedData(self, type: String, filter: (Data) -> Bool) -> []TxInput {\n    //     //NOT: hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);\n    //     // use toDelegatedData:\n        \n    //     hasDD : (TxInput) -> Option[Data] = self.mkDelegatedDataPredicate(type);\n    //     tx.inputs.filter( (txin : TxInput) -> Bool {\n    //         hasDD(txin).switch { \n    //             Some{data} => filter(data),\n    //             None => false\n    //         }\n    //     })\n    // }\n\n    // func findDelegatedData[T](self, \n    //     type: String, \n    //     transform: (Data) -> Option[T],\n    //     optional: Bool = false\n    // ) -> []T {\n    //     //not hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);\n    //     // use toDelegatedData:\n    //     hasDD : (TxInput) -> Option[Data] = self.toDelegatedData(type);\n    //     none : Option[T]::None = Option[T]::None;\n    //     result : []T = tx.inputs.map_option[T]( (txin : TxInput) -> Option[T] {\n    //         hasDD(txin).switch { \n    //             Some{data} => {\n    //                 transform(data)\n    //             },\n    //             None => none\n    //         }\n    //     });\n    //     if (!optional && (result.length == 0)) {\n    //         error(type + \": no match\")\n    //     };\n\n    //     result\n    // }\n\n    // func findDelegatedDataUtxos(self, \n    //     type: String, \n    //     filter: (Data, TxInput) -> Bool,\n    //     id: ByteArray=#,\n    //     optional: Bool = false\n    // ) -> []TxInput {\n    //     //not hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);\n    //     // use toDelegatedData:\n    //     hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(type, id);\n    //     none : Option[TxInput]::None = Option[TxInput]::None;\n    //     result : []TxInput = tx.inputs.map_option[TxInput]( (txin : TxInput) -> Option[TxInput]{\n    //         if (hasDD(txin)\n    //             Some{data} => {\n    //                 if (filter(data, txin)) {\n    //                     Option[TxInput]::Some{txin}\n    //                 } else {\n    //                     none\n    //                 }\n    //             },\n    //             None => none\n    //         }\n    //     });\n    //     if (!optional && (result.length == 0)) {\n    //         error(type + \": no match\")\n    //     };\n\n    //     result\n    // }\n\n    func mustOutputDelegatedData(self, newDataId : ByteArray, dataTypePurpose : String) -> Bool{\n        REQT(\"   -- validates that the new record is stored in the Capo address\");\n\n        dgData : Data = self.delegatedTxOutput(newDataId).datum.inline;\n        dgDatum : CapoDatum = CapoDatum::from_data(dgData);\n\n        REQT(\"   -- validates that the new record matches the type-name indicated in the dgDataPolicy manifest\");\n        dgDatum.switch {\n            DelegatedData => {\n                data : AnyData = AnyData::from_data(fromCip68Wrapper(dgData));\n                recIdStr = newDataId.decode_utf8();\n                if (data.id != newDataId) {\n                    print(\"  -- expected id: \"+recIdStr);\n                    actualIdStr = data.id.decode_utf8();\n                    error(\"❌❌ 📎 outDD: wrong id: \"+actualIdStr)\n                } else {\n                    if (data.type != dataTypePurpose) {\n                        print(\"  -- expected type: \"+ dataTypePurpose);\n                        error(\"❌❌ 📎 outDD: bad type: \"+data.type)\n                    } else {\n                        print(\"✅ 📎 outDD: ok: ^ outDD to Capo: \"+recIdStr);\n                        true\n                    }\n                }\n            },\n            _ => {\n                error(\"output not delegated data\")\n            }\n        }\n    }        \n\n    // func delegatedOutputData(self, \n    //     recId: ByteArray\n    // ) -> Data {\n    //     self.delegatedTxOutput(recId).datum.inline\n    // }\n\n    func delegatedTxOutput(self, \n        recId: ByteArray\n    ) -> TxOutput {\n        recIdStr = recId.decode_utf8();\n        self.internalHasDelegatedDataOutput(\n            mkTv(mph: self.mph, tnBytes: recId)\n        ).switch{\n            None => {\n                error(\"❌❌ 📎 ^ outDD: not found: \" + recIdStr)\n            },\n            Some{txout} => {\n                print(\"     ✅ 📎 ^ outDD: found \"+ recIdStr);\n                txout\n            }\n        }\n    }\n\n    func internalHasDelegatedDataOutput(\n        self, v : Value\n    ) -> Option[TxOutput] {\n        capoAddr : Address = self.address();\n\n        // print(\"       -- seeking txOutput \" + v.show());\n        // print(\"@addr\" + capoAddr.show());\n\n        tx.outputs.find_safe(\n            (txout : TxOutput) -> Bool {\n                // print(\"?? txOut\" + txout.value.show());\n                // print(\"@addr\" + txout.address.show());\n                true\n                && txout.value.contains(v)\n                    .trace(\"  -- output has value? \")\n                && (txout.address == capoAddr)\n                    .trace(\"     -- found output... is it at the right capoAddr? \")\n            }\n        )\n    }\n\n\n    // func XXXmustFindDelegatedDatum[T](self, mph: MintingPolicyHash, tnBytes: ByteArray, inAddr: Address) -> outputAndDatum[T] {\n    //     notFound = Option[outputAndDatum[T]]::None;\n    //     idTokenValue = mkTv(mph: mph, tnBytes: tnBytes);\n    //     print( \" ⬅️ 🔎 finding DelegatedData output: \"+ //xxx no decode in print! tnbBytes.decode_utf8() + \"\\n\");\n\n    //     foundDelegatedData: []outputAndDatum[T] = \n    //         tx.outputs.map_option[\n    //             outputAndDatum[T]\n    //         ](\n    //             (output: TxOutput) -> Option[outputAndDatum[T]] {\n    //                 if ( output.address != inAddr ) {\n    //                     notFound\n    //                 } else if (!output.value.contains(idTokenValue)) {\n    //                     notFound\n    //                 } else {\n    //                     rawDatum : Data = output.datum.inline;\n    //                     CapoDatum::from_data(\n    //                         rawDatum\n    //                     ).switch {\n    //                         dd: DelegatedData => {\n    //                             Option[\n    //                                 outputAndDatum[T]\n    //                             ]::Some{\n    //                                 outputAndDatum[T] {\n    //                                     output, dd, rawDatum\n    //                                 }\n    //                             }\n    //                         },\n    //                         _ => {\n    //                             notFound\n    //                         }\n    //                     }\n    //                 }\n    //             }\n    //         );\n    //     assert(foundDelegatedData.length < 2, \"too many delegated data outputs\") ;\n    //     assert(foundDelegatedData.length == 1, \"no delegated data output\");\n    //     assert(idTokenValue.contains(foundDelegatedData.value.get_assets()), \n    //         \"excess value in delegated-data output: \"+(settingsOutput.value - settingsVal).show()\n    //     );\n\n    //     print(\"\\n ⬅️ ✅ found DelegatedData\\n\");\n    //     foundDelegatedData.head\n    // }\n\n\n    \n    // doesn't care where the charter info comes from - refinput or input, both OK\n    func needsCharter(self) -> CapoCtx {\n        REQT(\"requires the charter to be available in the transaction (input or ref)\");\n\n        charter : cctx_CharterInputType = self.charter;\n        charter.switch {\n            RefInput => self,\n            Input => self,\n            Unk => {\n                CapoCtx{mph, _} = self;\n                chVal : Value = tvCharter(mph);\n                hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };\n\n                tx.ref_inputs.find_safe(hasCharter).switch{\n                    None => {\n                        print(\"CapoCtx needsCharter(): no charter ref; must be in inputs...\\n\");\n\n                        self.withCharterInput()\n                    },\n                    Some{charterUtxo} => {\n                        print(\"CapoCtx needsCharter(): found charter ref\\n\");\n\n                        datum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n                            charterUtxo.datum.inline\n                        );\n                        CapoCtx{mph, cctx_CharterInputType::RefInput{datum, charterUtxo}}\n                    }\n                }\n                // _ => self\n            }\n        }\n    }\n\n    func withCharterInput(self) -> CapoCtx {\n        REQT(\"requires the charter to be spent in the inputs\");\n\n        charter : cctx_CharterInputType = self.charter;\n        charter.switch {\n            Input => self,\n            RefInput => error(\"CapoCtx.withCharterInput(): charter is from ref!\"),\n            Unk => {\n                CapoCtx{mph, _} = self;\n\n                chVal : Value = tvCharter(mph);\n                hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };\n        \n                print(\"    -- CapoCtx finding charter in inputs\\n\");\n                charterUtxo: TxInput = tx.inputs.find_safe(hasCharter).switch{\n                    Some{ch} => ch,\n                    None => error(\"Missing required charter input\")\n                };\n                datum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n                    charterUtxo.datum.inline\n                );\n                // datum : CapoDatum::CharterData = getTxCharterData(self.mph);\n                CapoCtx{mph, cctx_CharterInputType::Input{datum, charterUtxo}}\n                // self.copy(charter: cctx_CharterInputType::Input{charterUtxo, datum})\n            }\n        }\n    }\n\n    // func nowMinting(self, address: Address, output: TxOutput) -> Bool {\n    //     self.charter.switch {\n    //         Input => error(\"CapoCtx.nowMinting(): charter is from inputs!\"),\n    //         RefInput => error(\"CapoCtx.nowMinting(): charter is from ref!\"),\n    //         Unk => {\n    //             CapoCtx{mph, _} = self;\n    //             datum: CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n    //                 output.datum.inline\n    //             );\n    //             CapoCtx{mph, cctx_CharterInputType::Minting{datum, address}}\n    //     }\n    // }\n\n    func withCharterRef(self) -> CapoCtx {\n        REQT(\"requires the charter to be referenced in the txn, but unspent\");\n\n        charter : cctx_CharterInputType = self.charter;\n        charter.switch {\n            RefInput => self,\n            Input => error(\"CapoCtx.withCharterRef(): charter is from inputs!\"),\n            Unk => {\n                CapoCtx{mph, _} = self;\n                utxo : TxInput = getRefCharterUtxo(mph);\n                datum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n                    utxo.datum.inline \n                );\n            \n                CapoCtx{mph, cctx_CharterInputType::RefInput{datum, utxo}}\n\n                // self.copy(charter: cctx_CharterInputType::RefInput{datum})\n            }\n        }\n    }\n\n    func allDelegatesAreValidatingSettings(self) -> Bool {\n        charterData = self.getCharterData();\n        mph = self.mph;\n        // REQT( \"gov authority must be present to update settings\");\n        // hasGovAuthority : Bool = mustHaveGovAuthority(\n        //     mph: mph,\n        //     charterData: charterData // already resolved\n        // );\n\n        CapoDatum::CharterData{\n            _spendDelegate,\n            spendInvariants,\n            otherNamedDelegates,\n            _mintDelegate,\n            mintInvariants,\n            govDelegate,\n            manifest,\n            _pendingDelegates\n        } = charterData;\n\n        // REQT(\"the current Settings must be spent and updated\");\n        // settingsDgtLink : RelativeDelegateLink = manifest.get_safe(\"settings\").switch {\n        //     None => error(\"'settings' delegate must be present to do updatingSettings activity\"),\n        //     Some{dgt} => dgt.dgDataPolicy.unwrap()\n        // };\n        \n        // //!!! note, this is a hard-coded version of requiring the settings policy script:\n        // settingsDgtInput = settingsDgtLink.hasDelegateInput(\n        //     inputs: tx.inputs,\n        //     mph: mph\n        // ).unwrap();\n        // settingsDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( \n        //     mustFindInputRedeemer(settingsDgtInput)\n        // ).switch {\n        //     SpendingActivities => true,\n        //     _ => error(\n        //         \"settings delegate must be updating the settings with its SpendingActivities variant\"\n        //     )\n        // };\n        // _nextSettings : Data = self.getNextManifestedDatumRaw(\"settings\");\n        // isUpdatingSettings : Bool = true;\n        \n        inputs: []TxInput = tx.inputs;\n        //!!! actually requiring delegates' SettingsValidation starts here.\n        REQT(\"   -- only the spend delegate calls this function\");\n        spendDelegateIsValidating : Bool = self.nowActingAsSpendDgt();\n        REQT(\"  -- spend delegate requires the other delegates validate (except mint delegate == same as spend delegate)\");\n\n        // govAuthority is checking the settings\n        REQT( \"govDelegate MAY contribute to settings validation\");\n        govDelegateMaybeValidating : Bool = \n            govDelegate.validatesUpdatedSettings(\n                inputs: inputs,\n                mph: mph,\n                inputRequired: false\n            ).switch{\n                Some => true,\n                None => {\n                    print(\"  -- govAuthority isn't a script-based validator; doesn't validate new settings\\n\");\n                    true\n                }\n            };\n        checkOneInvariant : (RelativeDelegateLink) -> Bool = \n        (oneDgt: RelativeDelegateLink) -> Bool {\n            REQT( \"invariant must validate settings\");\n            oneDgt.validatesUpdatedSettings(\n                inputs: inputs,\n                mph: mph,\n                inputRequired: true\n            ).unwrap()\n        };\n        // spendInvariants are checking the settings\n        REQT( \"spend invariants must validate settings\");\n        spendInvariantsAreValidating : Bool = spendInvariants.all( \n            checkOneInvariant\n        );\n        // mintInvariants are checking the settings\n        REQT( \"mint invariants must validate settings\");\n        mintInvariantsAreValidating : Bool = mintInvariants.all( \n            checkOneInvariant\n        );\n        REQT(\"dgDataControllers must validate settings\");\n        // dgDataControllers are checking the settings\n\n        dgDataPoliciesAreValidating :Bool = manifest.all( \n            (key: String, entry: CapoManifestEntry) -> Bool {\n                entry.entryType.switch{\n                    DgDataPolicy{policyLink, _idPrefix, _refCount} => {\n                        policyLink.validatesUpdatedSettings(\n                            inputs: inputs,\n                            mph: mph,\n                            inputRequired: true\n                        ).unwrap()\n                    },\n                    _ => {\n                        print(\"  -- ignoring manifest entry (not a data policy): \" + key);\n                        true\n                    }\n                }\n            }\n        );\n\n        // namedDelegates are checking the settings\n        REQT( \"named delegates must validate settings\");        \n        namedDelegatesAreValidating : Bool = otherNamedDelegates.fold( \n            REQT( \"  - each other-named-delegate must validate settings\");\n            (ok: Bool, key: String, dgt: RelativeDelegateLink) -> Bool {\n                print(\"  - other-named-delegate: \" + key);\n                print(\"\\n\");\n                ok && dgt.validatesUpdatedSettings(\n                    inputs: inputs,\n                    mph: mph,\n                    inputRequired: true\n                ).unwrap()\n            }, true\n        );\n\n        // hasGovAuthority &&\n        // settingsDelegateIsValid &&\n        // isUpdatingSettings &&\n        dgDataPoliciesAreValidating &&\n        spendDelegateIsValidating &&\n        govDelegateMaybeValidating &&\n        spendInvariantsAreValidating &&\n        mintInvariantsAreValidating &&\n        namedDelegatesAreValidating \n    }\n\n    func dgtRolesForLifecycleActivity(self, activity: CapoLifecycleActivity) -> DelegateRole {\n        assert(true || /*never executed*/ self == self, \"prevent unused var\");\n\n        activity.switch {\n            forcingNewSpendDelegate => error(\"the forcingNewSpendDelegate escape-hatch activity is always handled directly by the Capo\"),\n            forcingNewMintDelegate => error(\"the forcingNewMintDelegate escape-hatch activity is always handled directly by the Capo\"),\n\n            updatingManifest => {\n                REQT(\"... for updating the Capo manifest...\");\n                DelegateRole::SpendDgt\n            },\n\n            queuePendingChange => {\n                REQT(\"... for queuing a pending dgt-change...\");\n                DelegateRole::MintDgt\n            },\n            removePendingChange => {\n                REQT(\"... for removing a pending dgt-change entry...\");\n                DelegateRole::SpendDgt\n            },\n            commitPendingChanges => {\n                REQT(\"... for committing pending dgt-changes...\");\n                 DelegateRole::BothMintAndSpendDgt\n            },\n\n            CreatingDelegate => {\n                REQT(\"... for creating a new delegate (deprecated path)...\");\n                TODO(\"deprecate use of CLA::CreatingDelegate\");\n                DelegateRole::MintDgt\n            }\n\n            // we want explicit handling of each case; don't use a default match here.\n            // _ => error(\"DO NOT CATCH DEFAULT CASE HERE\")\n        }\n    }\n\n    // syntax sugar.  Implied is that that any other function calls will trip errors,\n    func orFail(self) -> Bool {\n        assert(true || /* never executed */ self.serialize() == self.serialize(), \"crazy talk\");\n        true\n    }\n    \n}\n\nfunc mkCapoCtx(mph: MintingPolicyHash) -> CapoCtx {\n    CapoCtx{\n        mph, cctx_CharterInputType::Unk\n    }\n}\n\n",
  project: "stellar-contracts",
  purpose: "module",
  name:  "src/CapoHelpers.hl", // source filename
  moduleName:  "CapoHelpers",
};

const heliosModule$6 = {
  content: "module TypeMapMetadata\n\n// a type definition for a schema\n\nstruct TypeInfo {\n    schemaVariety: String  // e.g. \"json-schema\"\n    schemaContent: String    \n}\n\nenum TypeRefImportDetails {\n    ImportType {  // imports external types and keeps their names\n        typeName: String // use \"*\" to import all types\n    }\n    ImportAs {  // imports a single external type with a local name\n        mapToRemoteNames: Map[String]String  // maps local names to remote names\n        // keys are LOCAL names.  Values are REMOTE names.\n    }\n}\n\nstruct TypeMapRef {\n    importDetails: TypeRefImportDetails  \"imp\"\n    utxoRef: Option[TxOutputId] \"utxo\"  // the referenced utxo is EXPECTED to have {typeMapFlag, TypeMapInfo}\n    variety: String \"trv\"// indicates RESOLUTION semantics for the referenced type-information.\n        // the variety MAY also indicate interpretation semantics for the referenced type-information.\n        // if variety  is \"CIP-123\", use the utxoRef here, and interpret the result as a {{}}-flagged CIP-123 TypeMapInfo\n        // other varieties MAY use the utxoRef, depending on their semantics\n        // other varieties MAY use the ref string to generically point to the external type\n    ref: String \"ref\"\n}\n\nstruct TypeMap {\n    localTypes: Map[String]TypeInfo\n    inheritFlag: String // = \"||\" ; may be the empty string if there are no inherited types\n    inherit: []TypeMapRef\n}\n",
  project: "stellar-contracts",
  purpose: "module",
  name:  "src/TypeMapMetadata.hl", // source filename
  moduleName:  "TypeMapMetadata",
};

const heliosModule$5 = {
  content: "spending Capo\n\n// needed in helios 0.13: defaults\nconst mph : MintingPolicyHash = MintingPolicyHash::new(#1234)\nconst rev : Int = 1\n\n// import {\n//     tvCharter\n// } from CapoHelpers\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash\n} from ScriptContext\n\nimport { \n    AbstractDelegateActivitiesEnum,\n    CapoLifecycleActivity,\n    DgTknDisposition as DgTkn,\n    requiresNoDelegateInput,    \n    RelativeDelegateLink\n} from CapoDelegateHelpers\n\nimport {\n    TODO,\n    REQT,\n    bREQT,\n    mustFindInputRedeemer,\n    outputAndDatum,\n    AnyData,\n    tvCharter,\n    mkTv,\n    didSign\n} from StellarHeliosHelpers\n\nimport {\n    getTxCharterData,\n    mkCapoCtx,\n    mkTokenShow,\n    mustHaveGovAuthority,\n    CapoDatum,\n    CapoActivity\n} from CapoHelpers\n\nimport {\n    mkUutTnFactory,\n    validateUutMinting\n} from CapoMintHelpers\n\n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nfunc requiresAuthorization(ctd: CapoDatum::CharterData) -> Bool {\n    ctd.govAuthorityLink.hasValidOutput(mph)\n}\n\nfunc getCharterOutput(tx: Tx) -> TxOutput {\n    charterTokenValue : Value = Value::new(\n        AssetClass::new(mph, \"charter\".encode_utf8()), \n        1\n    );\n\n    tx.outputs.find_safe(\n        (txo : TxOutput) -> Bool {\n            txo.value >= charterTokenValue\n        }\n    ).switch {\n        None => error(\"this could only happen if the charter token is burned.\"),\n        Some{o} => o\n    }\n}\n\nfunc preventCharterChange(datum: CapoDatum::CharterData) -> Bool {\n    charterOutput : TxOutput = getCharterOutput(tx);\n\n    cvh : ValidatorHash = get_current_validator_hash();\n    myself : SpendingCredential = SpendingCredential::new_validator(cvh);\n    if (charterOutput.address.credential != myself) {\n        error(\"charter token must be returned to the contract \")\n        // actual : String = charterOutput.address.credential.switch{\n        //     PubKey{pkh} => \"pkh:🔑#\" + pkh.show(),\n        //     Validator{vh} => \"val:📜#:\" + vh.show()\n        // };\n        // error(\n        //     \"charter token must be returned to the contract \" + cvh.show() +\n        //     \"... but was sent to \" +actual\n        // )\n    } else { \n        print(\"ok\\n\")\n    };\n\n    newDatum : CapoDatum = CapoDatum::from_data( \n        charterOutput.datum.inline\n    );\n    if (datum.serialize() != newDatum.serialize()) {\n        error(\"invalid update to charter settings\") \n    } else {\n        true\n    }\n}\n\nfunc checkpoint(s: String) -> Bool {\n    print(\"checkpoint: \" + s);\n    print(\"\\n\");\n    true\n}\n\nfunc main(datum: Data, activity: CapoActivity) -> Bool {\n    // now: Time = tx.time_range.start;\n    print(\"🚥❓Capo\\n\");\n\n    showMyTokens : (Value) -> String = mkTokenShow(mph);\n    input : TxInput = get_current_input();\n    print(\"  -- Capo: checks spend of \" + showMyTokens(input.value));\n    \n    capoDatum : CapoDatum = CapoDatum::from_data(datum);\n    allDatumSpecificChecks: Bool = capoDatum.switch {\n        // checks that unsupported activities for a datum are rejected promptly \n        // +special things we want to always guard against for specific Datum types:\n        ctd : CharterData => {\n            invalid : String = \"invalid activity on CharterData\";\n            activity.switch {\n                updatingCharter => true,  // more activity-checks happen below.\n                capoLifecycleActivity => true, // more checks below.\n                // addingSpendInvariant => error(\"todo: support spendInvariants\"),\n                // addingMintInvariant => error(\"todo: support mintInvariants\"),\n                spendingDelegatedDatum => error(invalid),\n                _ => {\n                    print(\"this charter activity isn't allowed to change the charter\");\n                    preventCharterChange(ctd)  // throws if bad                \n                    // ... plus activity-specific checks below.\n                }\n            }\n        },\n        // SettingsData => activity.switch {\n        //     updatingSettings => true,  // more checks below.\n        //     retiringSettings => error(\"there is no use case for this activity, unless it's part of a complete teardown\"),\n        //     _ => error(\"invalid activity on SettingsData\")\n        // },\n        ScriptReference => activity.switch {\n            retiringRefScript => true,\n            _ => error(\"invalid activity on ScriptReference\")            \n        },\n        DelegatedData => {\n            REQT(\"j6bmfv: all and ONLY DelegatedData datums must be spent with the Capo's spendingDelegatedDatum activity\");\n            // vvv part one of j6bmfv\n            activity.switch {\n                spendingDelegatedDatum => true,  // more checks below.\n                _ => error(\"invalid activity on DelegatedData\")\n            }\n        }\n        // maybe bring this back in v2\n        //, TypeMapInfo => activity.switch {\n        //     updatingTypeMap => true,\n        //     _ => error(\"invalid activity on TypeMapInfo\")\n        // }\n\n        // ❗no default case, to ensure that all variants are always covered.\n        // _ => true\n    };\n\n    // the normal case for validation is to use CapoDatum-specific checks.  \n    // however, this section allows activity-specific checks to be included, so extensions aren't painted into a corner.\n    allActivitySpecificChecks : Bool = activity.switch {\n        // checks for higher-frequency cases first\n        spendingDelegatedDatum => {\n            charterData : CapoDatum::CharterData = getTxCharterData(\n                mph: mph\n            );\n            // NOT all delegated-data policies need gov authority!\n            // hasGovAuthority = charterData.govAuthorityLink.hasValidOutput(mph);\n\n            // this is part two of j6bmfv\n            REQT(\"j6bmfv: all and ONLY DelegatedData datums must be spent with the Capo's spendingDelegatedDatum activity\");\n            print( \"  ...with activity spendingDelegatedDatum\\n\");\n            // check that the datum is a DelegatedData variant\n            datumId : ByteArray = capoDatum.switch{\n                DelegatedData => {\n                    datum.switch {\n                        ConstrData{_index, fields} => {\n                            AnyData::from_data(fields.head).id\n                        },\n                        _ => error(\"unreachable\")\n                    }\n                },\n                _ => {\n                    error(\n                        \"activity spendingDelegatedDatum used on mismatched datum type\"\n                    )\n                }\n            };\n            REQT(\"guards against updating a record if its id doesn't match its token-name\");\n            hasMatchingValue : Bool = input.value.contains(mkTv(mph: mph, tnBytes: datumId));\n                        \n\n            TODO(\"deal with DeletingDelegatedData activity (ensure spendDgt AND mintDgt do their parts)\");\n            // Note: CreatingDelegatedData activity doesn't involve the Capo at all; instead,\n            // the minter creates a UUT for the data, on authority of the mintDgt;\n            // ... and the mintDgt requires the presence of the corresponding dgDataPolicy (with its MintingActivity);\n            // ... then the dgDataPolicy checks the validity of the new data, and requires that\n            // ... the new data is created as a DelegatedData record in the Capo address.\n\n            cctx = mkCapoCtx(mph).needsCharter();\n            // ?? is this checking the same things as the rest of the code below?\n            checkThingOne = cctx.requiresSpendDelegateInput()\n                // .withUniqueDDSpendingActivity(datumId)\n                .requiresValidOutput();\n            TODO(\"VERIFY the above versus the below!\");\n\n            // the below stuff was already tested\n\n            spendDelegate: RelativeDelegateLink = charterData.spendDelegateLink;\n            \n            // consider allowing this as a refInput, with other stuff to enable more parallelism for populations\n            spendDelegateInput: TxInput = spendDelegate.hasDelegateInput(\n                //!!!!!! todo: audit for usages of hasDelegateInput - do we need to pass inputs as an arg?\n                inputs: tx.inputs,\n                mph: mph\n            ).unwrap();\n\n            delegateReturned: Bool = spendDelegate.hasValidOutput(mph).trace(\" -- delegate returned ok? \");\n\n            spendDgtInputRedeemer: Data = mustFindInputRedeemer(spendDelegateInput);\n            print(\"  -- vvvvv REDUNDANT checks for delegate activity (right?)\\n\");\n            getSpendingRecId : (Data) -> ByteArray = (dgSpendActivity : Data) -> ByteArray {\n                dgSpendActivity.switch {\n                    ConstrData{index, fields} => {\n                        assert(true || index==index, \"unreachable\"); // prevent unused variable warning\n                        fields.head.switch {\n                            ByteArrayData{recId} => {\n                                print(\"  -- found recId: \" + recId.show());\n                                recId\n                            },\n                            _ => error(\"spending activity must have a record-id as first field\")\n                        }\n                    },\n                    _ => error(\"unreachable\")\n                }\n            };\n            uniqMatchingSpendDgtActivity : Bool = AbstractDelegateActivitiesEnum::from_data(\n                spendDgtInputRedeemer\n            ).switch {\n                SpendingActivities{sa} => {\n                    assert(false,\n                        \"expected the Spend delegate to use *DelegatedData* activities\\n\"+\n                        \"  ... to describe the operations that are being performed by next-level \"+\n                        \"  ... DgData Policy delegates\"\n                    );\n                    // unwrap the abstract Data from sa, expecting an Enum \n                    // ... with a first data-field having the token-name \n                    // ... that matches with the delegated-data record `id`\n                    recId : ByteArray = getSpendingRecId(sa);\n                    assert(recId == datumId, \"spendDgt SpendingActivity must act on the correct record-id\");\n                    true\n                },\n                UpdatingDelegatedData{/*dataType*/ _ , recId} => {\n                    // todo: expect that this record-id matches the token in the current UTxO.\n                    assert(recId == datumId, \"spendDgt UpdDgData must act on the correct record-id\");\n                    print(\"  -- ok: activity matches data being updated\");\n                    true\n                },\n                MultipleDelegateActivities{activities} => {\n                    found: []Data = activities.filter(\n                        (act: Data) -> Bool {\n                            AbstractDelegateActivitiesEnum::from_data(act).switch {\n                                SpendingActivities{sa} => {                                    \n                                    // unwrap / check record-id\n                                    assert(false,\n                                        \"expected the Spend delegate to use *DelegatedData* activities\\n\"+\n                                        \"  ... to describe the operations that are being performed by next-level \"+\n                                        \"  ... DgData Policy delegates\"\n                                    );\n                                    recId : ByteArray = getSpendingRecId(sa);\n                                    recId == datumId\n                                },\n                                UpdatingDelegatedData{\n                                    /* dgDataType*/ _ , recId\n                                } => {\n                                    // verify token name match\n                                    recId == datumId\n                                },\n                                _ => false\n                            }\n                        }\n                    );\n                    TODO(\"TEST THIS v\");\n                    print(\"recId: \" + datumId.show());\n                    REQT(\"spendDgt must be acting on the matching record-id\");\n                    assert(  // fails a test having a spending activity, but on wrong recId\n                        ( found.length > 0 ).trace( \"found activity for this recId? \")\n                    , \"❗ no spend delegate activity on this dgData\");\n                    TODO(\"TEST THIS too v\");\n                    REQT(\"spendDgt fails with multiple activities for the same recId\");\n                    assert(  // fails a test having multiple spending activities on the same rec id\n                        (found.length == 1).trace(\"has exactly one matching activity? \")\n                        , \"❗IMPOSSIBLE (caught by DelegateInput.withDDSpendingActivity())\"+\n                            \" spend delegate tried to act in multiple ways on the same token\"\n                    );\n                    checkThingOne && true\n                },\n                _ => {\n                    spendDgtInputRedeemer.switch {\n                        ConstrData{index, fields} => {\n                            print(\"unexpected redeemer: \" + index.show() );\n                            print(\"\\n\");\n                            assert(true || /* never executed */ fields.length > 0, \"unreachable\");\n                            error(\"spend delegate not triggered with a Spending activity\")\n                        },\n                        _ => error(\"unreachable\")\n                    }\n                }\n            };\n            print(\"  -- ^^^^^ REDUNDANT checks for delegate activity\\n\");\n\n            true\n            && hasMatchingValue\n            && uniqMatchingSpendDgtActivity\n            && delegateReturned \n        },\n        updatingCharter => {\n            print( \"  ...with activity updatingCharter\\n\");\n            TODO(\"make this obsolete by implementing capoLifecycleActivity\");\n            charterOutput : TxOutput = getCharterOutput(tx);\n            newCtDatum = CapoDatum::CharterData::from_data( \n                charterOutput.datum.inline\n            );\n\n            oldCtDatum : CapoDatum::CharterData = capoDatum.switch {\n                octd: CharterData => octd,\n                _ => error(\"wrong use of updatingCharter action for non-CharterData datum\")                \n            };\n            CapoDatum::CharterData{                \n                spendDelegate, \n                spendInvariants,\n                otherNamedDelegates,\n                mintDelegate, \n                mintInvariants,\n                nextGovDelegate,\n                nextManifest,\n                nextPendingPolicies\n            } = newCtDatum;\n\n            CharterData{\n                oldSpendDelegate, \n                oldSpendInvariants, \n                oldOtherNamedDelegates,\n                oldMintDelegate, \n                oldMintInvariants,\n                oldGovDelegate,\n                oldManifest,\n                oldPendingPolicies\n                // oldTypeMapUut\n            } = capoDatum; // or oldCtDatum - same error result either way\n\n            mustNotModifyMintInvariants : Bool =  ( mintInvariants == oldMintInvariants );\n            mustNotModifySpendInvariants : Bool = ( spendInvariants == oldSpendInvariants );\n            mustNotModifyManifest : Bool = ( nextManifest.serialize() == oldManifest.serialize() );\n            unchangedGovDelegate : Bool = ( nextGovDelegate.serialize() == oldGovDelegate.serialize() );\n\n            hasNeededGovDelegate : Bool =  true ||\n            checkpoint(\"must be validated by existing govDelegate\") && \n            nextGovDelegate.hasValidOutput( mph) && (\n                unchangedGovDelegate || oldGovDelegate.hasDelegateInput( \n                    inputs: tx.inputs, \n                    mph: mph,\n                    required: true\n                ).switch {\n                    None => error(\"unreachable\"),\n                    Some => true\n                }\n            );\n\n            unchangedSpendDgt : Bool = ( spendDelegate.serialize() == oldSpendDelegate.serialize() );\n            unchangedMintDgt : Bool = ( mintDelegate.serialize() == oldMintDelegate.serialize() );\n            // print(\" oldMintDgt: \" + oldMintDelegate.serialize().show());\n            // print(\"\\n\");\n            // print(\" newMintDgt: \" + mintDelegate.serialize().show());\n            // print(\"\\n\");\n            \n            changedAnyNamedDelegate : Bool = ( otherNamedDelegates.serialize() != oldOtherNamedDelegates.serialize() );\n            mustNotChangePendingPolicies = (nextPendingPolicies.serialize() == oldPendingPolicies.serialize());\n            // mustNotModifySettings : Bool = ( settingsUut == oldSettingsUut );\n            // mustNotModifyTypeInfo : Bool = ( typeMapUut == oldTypeMapUut );\n\n            if (true) {\n                print(\"is spendDgt unchanged? \" + unchangedSpendDgt.show());\n                print(\"  - old: \"+ oldSpendDelegate.uutName + \" => \"+ \n                    oldSpendDelegate.delegateValidatorHash.switch{\n                        Some{v} => v.show(), None => \" (any addr)\"\n                });\n                oldSDConfigStr = oldSpendDelegate.config.decode_utf8();\n                print(\"       + cfg \" + oldSDConfigStr);\n                print(\"  - new: \"+ spendDelegate.uutName + \" => \"+ \n                    spendDelegate.delegateValidatorHash.switch{\n                        Some{v} => v.show(), None => \" (any addr)\"\n                });\n                newSDConfigStr = spendDelegate.config.decode_utf8();\n                print(\"       + cfg \" + newSDConfigStr);\n                // print(\" - old: \" + oldSpendDelegate.serialize().show());\n                // print(\" - new: \" + spendDelegate.serialize().show());\n\n                print(\" -- is mintDgt unchanged?  \" + unchangedMintDgt.show());\n                print(\"  - old: \"+ oldMintDelegate.uutName + \" => \"+ \n                    oldMintDelegate.delegateValidatorHash.switch{\n                        Some{v} => v.show(), None => \" (any addr)\"\n                });\n                oldMDConfigStr = oldMintDelegate.config.decode_utf8();\n                print(\"       + cfg \" + oldMDConfigStr);\n                print(\"  - new: \"+ mintDelegate.uutName + \" => \"+ \n                    mintDelegate.delegateValidatorHash.switch{\n                        Some{v} => v.show(), None => \" (any addr)\"\n                });\n                newMDConfigStr = mintDelegate.config.decode_utf8();\n                print(\"       + cfg \" + newMDConfigStr);\n                print(\"\")\n                // print(\" - old: \" + oldMintDelegate.serialize().show());\n                // print(\" - new: \" + mintDelegate.serialize().show());\n\n                // print(\" -- is config unchanged? \" + mustNotModifySettings.show());\n                // print(\"\\n  - old: \"+ oldSettingsUut.decode_utf8());\n                // print(\"\\n  - new: \"+ settingsUut.decode_utf8());\n                // print(\"\\n\")\n            };\n            // assert(mustNotModifySettings, \"cannot change settings uut\");\n            // assert(mustNotModifyTypeInfo, \"cannot change typeInfo uut\");\n\n\n            // the high-level use-cases that can update charter are all mutually exclusive.  Count them\n            // and ensure that only one is present.\n            countUpdatedThings : Int = newCtDatum.countUpdatedThings(capoDatum);\n                // if ((!unchangedGovDelegate).trace(\"\\n -- govDgt changed? \")) { 1 } else { 0 } +\n                // if ((!unchangedSpendDgt).trace(\"\\n -- spendDgt changed? \") ) { 1 } else { 0 } +\n                // if ((!unchangedMintDgt).trace(\"\\n -- mintDgt changed? \") ) { 1 } else { 0 } +\n                // if (changedAnyNamedDelegate.trace(\"\\n -- namedDgt changed? \") ) { 1 } else { 0 };\n\n            assert(countUpdatedThings == 1, \n                \"expected exactly one item updated in charter, got \"+countUpdatedThings.show() + \"\"\n            );            \n\n            // mustNotModifySettings &&\n            // mustNotModifyTypeInfo &&\n            hasNeededGovDelegate &&\n            bREQT(\"must not change the manifest\", \n                mustNotModifyManifest\n            ) &&\n            checkpoint(\"1\") &&\n            if (unchangedMintDgt) {\n                // unchanged mintDgt must not be included in the tx\n                checkpoint(\"2b\") &&\n                mintDelegate.hasDelegateInput(\n                    inputs: tx.inputs, \n                    mph: mph,\n                    required: false\n                ).switch {\n                    None => {\n                        // was requiresNoDelegateInput(mintDelegate, mph)\n                        //  - it's ok to have it not included.\n                        true\n                    },\n                    Some{mintDgtInput} => {\n                        delegateActivity: AbstractDelegateActivitiesEnum = \n                            mintDelegate.getRedeemer(mintDgtInput);\n                        print(\"mint delegate input found\\n\");\n                        delegateActivity.switch {\n                            CapoLifecycleActivities{CLA} => CLA.switch {\n                                CreatingDelegate => {\n                                    print(\"TEMPORARY: allowing delegate creation while **updatingCharter**\\n\");\n\n                                    TODO(\"move delegate-creation to be separate from updatingCharter\");\n                                    TODO(\" ?? use capo ActivatingXxxxDelegate activity when adopting delegate\");\n\n                                    mintDelegate.hasValidOutput(mph)\n                                },\n                                _ => error(\"must use capoLifecycleActivity directly in Capo, not with generic updatingSettings\")\n                                // no other variants exist (yet).\n                                // _ => error(\"invalid use of mint delegate during charter update\")\n                            },\n                            _ => error(\"invalid use of mint delegate during charter update\")\n                        }\n                    }\n                }\n            } else {\n                //  the new one has to go to the right place\n                REQT(\"the updated mintDgt token must be deposited to its own script address\");\n                mintDelegate.hasValidOutput(mph)\n            } && \n            if ( unchangedSpendDgt) {\n                // unchanged spendDgt must not be included in the tx\n                checkpoint(\"4b\") &&\n                requiresNoDelegateInput(spendDelegate, mph)\n            } else {\n                REQT(\"the updated spendDgt token must be deposited to its own script address\");\n                checkpoint(\"4a\") &&\n                spendDelegate.hasValidOutput(mph)\n            } &&\n            checkpoint(\"5\") &&\n            if (!changedAnyNamedDelegate) { true } else {\n                checkpoint(\"5b\") && \n                otherNamedDelegates.fold( (ok: Bool, name : String, dgt : RelativeDelegateLink) -> Bool {\n                    ok && \n                    oldOtherNamedDelegates.get_safe(name).switch {\n                        None => {\n                            print (\" - adopting named delegate: \" + name);\n                            print(\"\\n\");\n                            true\n                        },\n                        Some{oldDgt} => { \n                            if (oldDgt.serialize() == dgt.serialize()) {\n                               // unchanged named delegate must not be included in the tx\n                                requiresNoDelegateInput(dgt, mph)\n                            } else {\n                                TODO(\"the old named delegate must be retired, or be force-replaced (in a different activity?)\");\n                                //  the new one has to go to the right place\n                                dgt.hasValidOutput(\n                                    mph, required: true, \n                                    createdOrReturned: DgTkn::Created)\n                            }\n                        }\n                    }\n                }, true)\n            } &&\n            mustNotChangePendingPolicies &&\n            mustNotModifyMintInvariants &&\n            mustNotModifySpendInvariants &&\n            requiresAuthorization(oldCtDatum) &&\n            checkpoint(\"6\")\n        },\n        capoLifecycleActivity{myCLActivity} => {\n            print( \"  ...with activity capoLifecycleActivity\\n\");\n\n            oldCtDatum : CapoDatum::CharterData = capoDatum.switch {\n                octd: CharterData => octd,\n                _ => error(\"wrong use of updatingCharter action for non-CharterData datum\")                \n            };\n\n            charterOutput : TxOutput = getCharterOutput(tx);\n            newCtDatum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n                charterOutput.datum.inline\n            );\n            REQT(\"all capoLifecycleActivities require the govAuthority\");\n            cctx = mkCapoCtx(mph).\n                withCharterInput().\n                requiresGovAuthority();\n\n            myCLActivity.switch {\n                forcingNewMintDelegate{seed, purpose} => {\n                    // we handle it directly\n                    REQT(\"when forcingNewMintDelegate, ONLY the mintDelegate is updated\");\n                    assert(\n                        oldCtDatum.mintDelegateLink.serialize() != \n                        newCtDatum.mintDelegateLink.serialize(), \n                        \"must update mintDelegate\"\n                    );\n                    assert(\n                        oldCtDatum.countUpdatedThings(newCtDatum) == 1, \n                        \"must not update anything except mintDelegate\"\n                    );                    \n                    assert(oldCtDatum.mintDelegateLink.uutName != newCtDatum.mintDelegateLink.uutName,\n                        \"new mintDelegate token must be different from the old one\"\n                    );\n                    tnFactory = mkUutTnFactory(seed);\n                    REQT(\"the new mintDgt must have the new dgTkn\");\n                    expectedTn = tnFactory(purpose);\n                    assert(\n                        newCtDatum.mintDelegateLink.uutName == expectedTn,\n                        \"wrong mintDelegate token name '\"+ \n                            newCtDatum.mintDelegateLink.uutName +\n                            \"' added to charter; should be: \"+ expectedTn\n                    );\n\n                    REQT(\"the new mintDelegate must be present in its own script address\");\n                    newCtDatum.mintDelegateLink.hasValidOutput(mph, true, \n                        DgTkn::Created\n                    ) &&\n                    bREQT(\"Ensures the new mintDgt-* uut is minted with a seed\") &&\n                    validateUutMinting(\n                        mph: mph,\n                        seed: seed,\n                        purposes: []String{purpose},\n                        mkTokenName: tnFactory,\n                        needsMintDelegateApproval: false \n                    )\n                },\n                forcingNewSpendDelegate{seed, purpose} => {\n                    // we handle it directly\n                    REQT(\"when forcingNewSpendDelegate, ONLY the spendDelegate is updated\");\n                    assert(\n                        oldCtDatum.spendDelegateLink.serialize() != newCtDatum.spendDelegateLink.serialize(), \n                        \"must update spendDelegate\"\n                    );\n                    assert(\n                        oldCtDatum.countUpdatedThings(newCtDatum) == 1, \n                        \"must not update anything except spendDelegate\"\n                    );\n\n                    assert(oldCtDatum.spendDelegateLink.uutName != newCtDatum.spendDelegateLink.uutName,\n                        \"new spendDelegate token must be different from the old one\"\n                    );\n                    tnFactory = mkUutTnFactory(seed);\n                    REQT(\"the new spendDgt must have the new dgTkn\");\n                    expectedTn = tnFactory(purpose);\n                    assert(\n                        newCtDatum.spendDelegateLink.uutName == expectedTn,\n                        \"wrong spendDelegate token name '\"+ \n                            newCtDatum.spendDelegateLink.uutName +\n                            \"' added to charter; should be: \"+ expectedTn\n                    );\n\n\n                    REQT(\"the new spendDelegate must be present in its own script address\");\n                    newCtDatum.spendDelegateLink.hasValidOutput(mph, true, \n                        DgTkn::Created\n                    ) &&\n                    bREQT(\"Ensures the new spendDgt-* uut is minted with a seed\") &&\n                    validateUutMinting(\n                        mph: mph,\n                        seed: seed,\n                        purposes: []String{purpose},\n                        mkTokenName: tnFactory,\n                        needsMintDelegateApproval: false\n                    )\n                },\n                _ => {\n                    matchesActivity = (dgtActivity: AbstractDelegateActivitiesEnum) -> Bool {\n                        dgtActivity.switch {\n                            CapoLifecycleActivities{cla} => {\n                                bREQT(\n                                    \"  - the delegate's activity must match the capo's lifecycle activity\",\n                                    (cla == myCLActivity)\n                                )\n                            },\n                            _ => error(\"delegate must use CapoLifecycleActivities\")                            \n                        }\n                    };\n                    needsMintDgt = () -> Bool {\n                        REQT(\"  - enforces presence of the mint delegate\");\n                        mintDgt = cctx.requiresMintDelegateInput();\n                        assert(mintDgt.requiresValidOutput(), \"<-- that fails, this doesn't\");\n                        matchesActivity(mintDgt.genericDelegateActivity())\n                    };\n                    needsSpendDgt = () -> Bool {\n                        REQT(\"  - enforces presence of the spend delegate\");\n                        spendDgt = cctx.requiresSpendDelegateInput();\n                        assert(spendDgt.requiresValidOutput(), \"<-- that fails, this doesn't\");\n                        matchesActivity(spendDgt.genericDelegateActivity())\n                    };\n                    cctx.dgtRolesForLifecycleActivity(myCLActivity).switch {\n                        HandledByCapoOnly => error(\"unreachable\"),\n                        MintDgt => {\n                            needsMintDgt()\n                        },\n                        SpendDgt => {\n                            needsSpendDgt()\n                        },\n                        BothMintAndSpendDgt => {\n                            needsMintDgt() &&\n                            needsSpendDgt()\n                        },\n                        _ => error(\"dgtRolesForLifecycleActivity should indicate only mint/spend/both delegate-roles\")\n                    },\n\n                    TODO(\"review updatingManifest case\");\n                    // updatingManifest => {\n                    //     // the spend delegate must be triggered with its updatingManifest activity\n                    //     // (exactly the same as our updatingManifest)\n                    //     cctx.requiresSpendDelegateInput()\n                    //         .updatingManifest()\n                    //         .requiresValidOutput()\n                    // }, \n    \n                    // REQT(\"for normal lifecycle activities, the spendDelegate's activity must match the capo's lifecycle activity\");\n                    // assert(\n                    //     delegateCLActivity.serialize() == myCLActivity.serialize(),\n                    //     \"the spendDelegate's CapoLifecycleActivity must match the capo's\"\n                    // );\n                    true\n                }\n            }\n        },\n        retiringRefScript => {\n            print( \"  ...with activity retiringRefScript\\n\");\n            // the ref script is being spent:\n            isSpendingRefScript : Bool = capoDatum.switch{\n                ScriptReference => true,\n                _ => error(\"wrong use of retiringRefScript action for non-ScriptRef datum\")\n            };\n\n            hasGovAuthority : Bool = mustHaveGovAuthority(mph);\n\n            isSpendingRefScript && \n            hasGovAuthority &&\n            true\n            // no other constraints; the ref script could be re-created or\n            // replaced with a new one, or simply destroyed.\n        },\n\n        usingAuthority => {\n            print( \"  ...with activity usingAuthority\\n\");\n            capoDatum.switch {\n                 // throws if bad\n                ctd : CharterData => requiresAuthorization(ctd),\n                _ => error(\"wrong use of usingAuthority action for non-CharterData datum\")\n            }\n        },\n\n        // updatingSettings => {\n        //     // FUT: possibly move this to the spend-delegate layer\n        //     print( \"  ...with activity updatingSettings\\n\");\n        //     _isRelevantDatum : Bool = capoDatum.switch {\n        //         // SettingsData => true,\n        //         CharterData => true,\n        //         _ => error(\"wrong use of updatingSettings action; must use only on CharterData\")\n        //     };\n\n        //     // it requires the govAuthority to be present \n        //     REQT( \"gov authority must be present to update settings\");\n        //     hasGovAuthority : Bool = mustHaveGovAuthority(\n        //         mph: mph,\n        //         charterData: charterData // already resolved\n        //     );\n\n        //     CapoDatum::CharterData{\n        //         spendDelegate,\n        //         spendInvariants,\n        //         namedDelegates,\n        //         mintDelegate ,\n        //         mintInvariants,\n        //         govDelegate,\n        //         manifest\n        //     } = capoDatum;\n\n        //     REQT(\"the current Settings must be spent and updated\");\n        //     settingsDgtLink : RelativeDelegateLink = namedDelegates.get_safe(\"settings\").switch {\n        //         None => error(\"'settings' delegate must be present to do updatingSettings activity\"),\n        //         Some{dgt} => dgt\n        //     };\n\n        //     settingsDgtInput = settingsDgtLink.hasDelegateInput(\n        //         inputs: tx.inputs,\n        //         mph: mph\n        //     ).unwrap();\n        //     settingsDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( \n        //         mustFindInputRedeemer(settingsDgtInput)\n        //     ).switch {\n        //         SpendingActivities => true,\n        //         _ => assert(\"settings delegate must be updating the settings with its SpendingActivities variant\")\n        //     };\n        //     _nextSettings : Data = cctx.getNextManifestedDatumRaw(\"settings\");\n        //     isUpdatingSettings : Bool = true;\n\n        //     // ?? can we iterate inputs along with delegates, to reduce the overhead\n        //     //    ... of multiple passes over the tx inputs?\n        //     //  option 1: pay for iterating N inputs, \n        //     //    - times a switch{} for delegate-matching\n        //     //    -    ... and invariants-iteration\n        //     //    -    ... and namedDelegates-iteration\n        //     //    - Plus a \"is-anything-missing\" check over delegates/invariants/namedDelegates\n        //     // option 2: switch and iterate over delegates, invariants, namedDelegates\n        //     //    - times a switch for input-finding\n        //     //    - ... and no separate is-anything-missing checks.\n        //     // ^^^ option 2 has to be cheaper.\n\n        //     inputs: []TxInput = tx.inputs;\n\n        //     REQT( \"spend delegate must validate settings\");\n        //     spendDelegateIsValidating : Bool = \n        //         spendDelegate.validatesUpdatedSettings(\n        //             inputs: inputs,\n        //             mph: mph,\n        //             inputRequired: true\n        //         ).unwrap();\n\n        //     REQT(\"mint delegate must validate settings\");\n        //     mintDelegateIsValidating : Bool = \n        //         mintDelegate.validatesUpdatedSettings(\n        //             inputs: inputs,\n        //             mph: mph,\n        //             inputRequired: true\n        //         ).unwrap();\n\n        //     // govAuthority is checking the settings\n        //     REQT( \"govDelegate MAY contribute to settings validation\");\n        //     govDelegateMaybeValidating : Bool = \n        //         govDelegate.validatesUpdatedSettings(\n        //             inputs: inputs,\n        //             mph: mph,\n        //             inputRequired: false\n        //         ).switch{\n        //             Some => true,\n        //             None => {\n        //                 print(\"  -- govAuthority isn't a script-based validator; doesn't validate new settings\\n\");\n        //                 true\n        //             }\n        //         };\n        //     checkOneInvariant : (RelativeDelegateLink) -> Bool = \n        //     (oneDgt: RelativeDelegateLink) -> Bool {\n        //         REQT( \"invariant must validate settings\");\n        //         oneDgt.validatesUpdatedSettings(\n        //             inputs: inputs,\n        //             mph: mph,\n        //             inputRequired: true\n        //         ).unwrap()\n        //     };\n        //     // spendInvariants are checking the settings\n        //     REQT( \"spend invariants must validate settings\");\n        //     spendInvariantsAreValidating : Bool = spendInvariants.all( \n        //         checkOneInvariant\n        //     );\n        //     // mintInvariants are checking the settings\n        //     REQT( \"mint invariants must validate settings\");\n        //     mintInvariantsAreValidating : Bool = mintInvariants.all( \n        //         checkOneInvariant\n        //     );\n        //     // namedDelegates are checking the settings\n        //     REQT( \"named delegates must validate settings\");\n        //     namedDelegatesAreValidating : Bool = namedDelegates.fold( \n        //         REQT( \"  - each named delegate must validate settings\");\n        //         (ok: Bool, key: String, dgt: RelativeDelegateLink) -> Bool {\n        //             print(\"  - named delegate: \" + key);\n        //             print(\"\\n\");\n        //             ok && dgt.validatesUpdatedSettings(\n        //                 inputs: inputs,\n        //                 mph: mph,\n        //                 inputRequired: true\n        //             ).unwrap()\n        //         }, true\n        //     );\n\n        //     isRelevantDatum &&\n        //     settingsDelegateIsValid &&\n        //     isUpdatingSettings &&\n        //     spendDelegateIsValidating &&\n        //     mintDelegateIsValidating &&\n        //     govDelegateMaybeValidating &&\n        //     spendInvariantsAreValidating &&\n        //     mintInvariantsAreValidating &&\n        //     namedDelegatesAreValidating &&\n        //     hasGovAuthority\n        // },\n        // retiringSettings => {\n        //     print( \"  ...with activity retiringSettings\\n\");\n        //     error(\"implement me\")\n        // },\n        _ => error(\"unhandled activity\")\n    };\n\n    assert(allDatumSpecificChecks, \"some datum-check failed\");\n    assert(allActivitySpecificChecks, \"some redeeemer-check failed\");\n\n    //! retains mph in parameterization\n    assert(\n        ( allDatumSpecificChecks && allActivitySpecificChecks ) ||\n            // this should never execute (much less fail), yet it also shouldn't be optimized out.\n             mph.serialize() /* never */ == mph.serialize(), \n        \"unreachable\"\n    ); \n    print(\"\\n🚥🟢 Capo validator: ok!\\n\\n\");\n\n    allDatumSpecificChecks && \n    allActivitySpecificChecks\n    // tx.serialize() != datum.serialize()\n}\n",
  project: "stellar-contracts",
  purpose: "spending",
  name:  "src/DefaultCapo.hl", // source filename
  moduleName:  "Capo",
};

const defaultNoDefinedModuleName = "\u2039default-needs-override\u203A";
class HeliosScriptBundle {
  static isCapoBundle = false;
  capoBundle;
  isConcrete = false;
  /**
   * Constructs a base class for any Helios script bundle,
   * given the class for an application-specific CapoHeliosBundle.
   * @remarks
   * The resulting class provides its own CapoHeliosBundle instance
   * for independent use (specifically, for compiling this bundle using
   * the dependency libraries provided by the Capo bundle).
   */
  //
  //     * NOTE: the following is NOT needed for efficiency, and not implemented
  //     *, as the Capo
  //     * bundle referenced above should never need to be compiled via
  //     * `this.capoBundle.program`.
  //     *
  //     * XXX - For application runtime purposes, it can ALSO accept a
  //     * XXX - CapoHeliosBundle instance as a constructor argument,
  //     * XXX - enabling lower-overhead instantiation and re-use across
  //     * XXX - various bundles used within a single Capo,
  //     */
  static usingCapoBundleClass(c) {
    const cb = new c();
    const newClass = class aCapoBoundBundle extends HeliosScriptBundle {
      capoBundle = cb;
      constructor() {
        super();
      }
      isConcrete = true;
    };
    return newClass;
  }
  /**
   * optional attribute explicitly naming a type for the datum
   * @remarks
   * This can be used if needed for a contract whose entry point uses an abstract
   * type for the datum; the type-bridge & type-gen system will use this data type
   * instead of inferrring the type from the entry point.
   */
  datumTypeName;
  /**
   * optional attribute explicitly naming a type for the redeemer
   * @remarks
   * This can be used if needed for a contract whose entry point uses an abstract
   * type for the redeemer; the type-bridge & type-gen system will use this data type
   * instead of inferring the type from the entry point.
   */
  redeemerTypeName;
  constructor() {
  }
  // these should be unnecessary if we arrange the rollup plugin
  // ... to watch the underlying helios files for changes that would affect the bundle
  // checkDevReload() {
  //     const env = process.env.NODE_ENV;
  //     if (env !== "test" && env !== "development") {
  //         console.log("disabling module reloading in non-dev environment");
  //         return
  //     }
  //     this.reloadModule(this.main);
  //     for (const module of this.modules) {
  //         this.reloadModule(module)
  //     }
  // }
  // reloadModule(module: HeliosModuleSrc) {
  //     // treat module.name as a filename.
  //     // check if it can be opened as a file.
  //     // reassign module.content to the file's contents.
  //     if (existsSync(module.name)) {
  //         console.log(`bundle module load: ${module.name}`);
  //         const newContent = readFileSync(module.name, "utf8");
  //         if (module.content !== newContent) {
  //             console.log(`♻️ module reload: ${module.name}`);
  //             module.content = newContent;
  //         }
  //     }
  // }
  get main() {
    throw new Error(
      `${this.constructor.name}: get main() must be implemented in subclass`
    );
  }
  get modules() {
    return [];
  }
  get bridgeClassName() {
    const mName = this.moduleName || this.program.name;
    return `${mName}DataBridge`;
  }
  get moduleName() {
    return this.constructor.name.replace(/Bundle/, "").replace(/Helios/, "");
  }
  config = void 0;
  artifacts = null;
  async compiledScript(params) {
    if (this.artifacts) ;
    const script = this.program;
    console.log(`


        // pre-config: okay, should have what's needed
        // when already deployed, we shouldn't ever need to get here because
        // we should have the CBOR-encoded script instead.
        ...at ${this.constructor.name}::compileWithScriptParams()`);
    const t = (/* @__PURE__ */ new Date()).getTime();
    for (const [p, v] of Object.entries(params)) {
      script.changeParam(p, v);
    }
    console.log(
      `${this.moduleName} with params:`,
      script.entryPoint.paramsDetails()
    );
    const uplcProgram = this.program.compile({
      optimize: (this.config ?? {}).optimize ?? true
    });
    console.log(`compiled in ${( new Date()).getTime() - t}ms`);
    return uplcProgram;
  }
  _program;
  // _pct: number = 0
  get program() {
    if (this._program) {
      return this._program;
    }
    const ts1 = Date.now();
    let mName = this.moduleName;
    if (mName === defaultNoDefinedModuleName) {
      mName = "";
    }
    try {
      const p = new HeliosProgramWithCacheAPI(this.main, {
        moduleSources: this.modules,
        name: mName
        // it will fall back to the program name if this is empty
      });
      this._program = p;
      console.log(
        `\u{1F4E6} ${mName}: loaded & parsed: ${Date.now() - ts1}ms`
        // Hi!  Are you investigating a duplicate load of the same module?  🔥🔥🔥
        //   thanks! you're saving people 100ms at a time!
        // new Error("stack").stack
      );
      return p;
    } catch (e) {
      if (e.message.match(/invalid parameter name/)) {
        debugger;
        throw new Error(
          e.message + `
   ... this typically occurs when your StellarContract class (${this.constructor.name})
   ... can be missing a getContractScriptParamsUplc() method 
   ... to map from the configured settings to contract parameters`
        );
      }
      const [unsetConst, constName] = e.message.match(/used unset const '(.*?)'/) || [];
      if (unsetConst) {
        console.log(e.message);
        throw new Error(
          `${this.constructor.name}: missing required script param '${constName}' in static getDefaultParams() or getContractScriptParams()`
        );
      }
      if (!e.site) {
        console.error(
          `unexpected error while compiling helios program (or its imported module) 
> ${e.message}
Suggested: connect with debugger (we provided a debugging point already)
  ... and use 'break on caught exceptions' to analyze the error 
This likely indicates a problem in Helios' error reporting - 
   ... please provide a minimal reproducer as an issue report for repair!

` + e.stack.split("\n").slice(1).join("\n")
        );
        try {
          debugger;
          const try2 = new HeliosProgramWithCacheAPI(
            this.main,
            {
              moduleSources: this.modules,
              name: mName
              // it will fall back to the program name if this is empty
            }
          );
          console.warn("NOTE: no error thrown on second attempt");
        } catch (sameError) {
        }
      }
      debugger;
      const [_, notFoundModule] = e.message.match(/module '(.*)' not found/) || [];
      if (notFoundModule) {
        console.log(
          `${this.constructor.name} module '${notFoundModule}' not found; included modules:
` + this.modules.map((m) => {
            const pInfo = m.project ? ` [in ${m.project}]/` : "";
            return ` \u2022 ${m.moduleName}${pInfo}${m.name} (${m.content.length} bytes)`;
          }).join("\n")
        );
      }
      if (!e.site) {
        console.warn(
          "error thrown from helios doesn't have source site info; rethrowing it"
        );
        throw e;
      }
      const moduleName2 = e.site.file;
      const errorModule = [this.main, ...this.modules].find(
        (m) => m.name == moduleName2
      );
      const {
        project,
        moduleName,
        name: srcFilename = "\u2039unknown path to module\u203A",
        moreInfo
      } = errorModule || {};
      let errorInfo = "";
      try {
        import('fs').then(
          ({ statSync }) => {
            return statSync(srcFilename).isFile();
          }
        );
      } catch (e2) {
        const indent = " ".repeat(6);
        errorInfo = project ? `
${indent}Error found in project ${project}:${srcFilename}
${indent}- in module ${moduleName}:
${moreInfo}
${indent}  ... this can be caused by not providing correct types in a module specialization,
${indent}  ... or if your module definition doesn't include a correct path to your helios file
` : `
${indent}WARNING: the error was found in a Helios file that couldn't be resolved in your project
${indent}  ... this can be caused if your module definition doesn't include a correct path to your helios file
${indent}  ... (possibly in mkHeliosModule(heliosCode, 
${indent}    "${srcFilename}"
${indent})
`;
      }
      const { startLine, startColumn } = e.site;
      const t = new Error(errorInfo);
      const modifiedStack = t.stack.split("\n").slice(1).join("\n");
      debugger;
      const additionalErrors = (e.otherErrors || []).slice(1).map(
        (oe) => `       |         \u26A0\uFE0F  also: ${// (oe.message as string).replace(e.site.file, "")}`);
        oe.site.file == e.site.file ? oe.site.toString().replace(e.site.file + ":", "at ") + ": " + oe.originalMessage : oe.site.toString() + " - " + oe.originalMessage}`
      );
      const addlErrorText = additionalErrors.length ? ["", ...additionalErrors, "       v"].join("\n") : "";
      t.message = `${e.kind}: ${this.constructor.name}
${e.site.toString()} - ${e.originalMessage}${addlErrorText}
${errorInfo}`;
      t.stack = `${this.constructor.name}: ${e.message}
    at ${moduleName2} (${srcFilename}:${1 + startLine}:${1 + startColumn})
` + modifiedStack;
      throw t;
    }
  }
  isHeliosScriptBundle() {
    return true;
  }
  addTypeProxies() {
  }
  effectiveDatumTypeName() {
    return this.datumTypeName || this.locateDatumType()?.name || "\u2039unknown datum-type name\u203A";
  }
  locateDatumType() {
    let datumType;
    const program = this.program;
    const programName = program.name;
    const argTypes = program.entryPoint.mainArgTypes;
    const argCount = argTypes.length;
    if (argCount === 2) {
      datumType = argTypes[0];
    }
    if (this.datumTypeName) {
      datumType = program.entryPoint.userTypes[programName][this.datumTypeName];
      if (!datumType) {
        throw new Error(
          `${this.constructor.name}.datumTypeName=\`${this.datumTypeName}\` not found in userTypes of script program ${programName}`
        );
      }
    }
    return datumType;
  }
  locateRedeemerType() {
    const program = this.program;
    const argTypes = program.entryPoint.mainArgTypes;
    const argCount = argTypes.length;
    let redeemerType;
    if (argCount === 2) {
      redeemerType = argTypes[1];
    } else {
      redeemerType = argTypes[0];
    }
    if (this.redeemerTypeName) {
      const programName = program.name;
      redeemerType = program.entryPoint.userTypes[programName][this.redeemerTypeName];
      if (!redeemerType) {
        throw new Error(
          `${this.constructor.name}.redeemerTypeName=\`${this.redeemerTypeName}\` not found in userTypes of script program ${programName}`
        );
      }
    }
    return redeemerType;
  }
  getTopLevelTypes() {
    const types = {
      datum: this.locateDatumType(),
      redeemer: this.locateRedeemerType()
    };
    const program = this.program;
    const { userTypes } = program;
    const { mainModule } = program.entryPoint;
    const mainTypes = userTypes[mainModule.name.value];
    for (const [typeName, type] of Object.entries(mainTypes)) {
      const s = type.toSchema();
      if (s.kind == "struct") {
        types[typeName] = type;
      }
    }
    if (userTypes.specializedDelegate) {
      const specializationName = this.moduleName;
      const specializationTypes = userTypes[specializationName];
      if (!specializationTypes) {
        console.log(
          "NOTE:  debugging breakpoint available for more troubleshooting"
        );
        debugger;
        console.log(
          "NOTE: the module name for the delegate policy script must match bundle's moduleName"
        );
        throw new Error(
          `specialization types not found for ${this.moduleName} in program ${program.name}`
        );
      }
      for (const [typeName, type] of Object.entries(
        specializationTypes
      )) {
        const s = type.toSchema();
        if (s.kind == "struct") {
          types[typeName] = type;
        }
      }
    }
    return types;
  }
}

class CapoHeliosBundle extends HeliosScriptBundle {
  get main() {
    return heliosModule$5;
  }
  datumTypeName = "CapoDatum";
  capoBundle = this;
  // ???
  // todo: make types for these 
  // config? : any
  scripts;
  get bridgeClassName() {
    if (this.constructor === CapoHeliosBundle) {
      return "CapoDataBridge";
    }
    return this.constructor.name.replace("Helios", "").replace("Bundle", "") + "Bridge";
  }
  static isCapoBundle = true;
  get modules() {
    return [
      heliosModule$a,
      heliosModule$9,
      heliosModule$8,
      heliosModule$7,
      heliosModule$6
    ];
  }
}

function delegateLinkSerializer(key, value) {
  if (typeof value === "bigint") {
    return value.toString();
  } else if ("bytes" == key && Array.isArray(value)) {
    return bytesToHex(value);
  } else if (value?.kind == "Address") {
    return value.toString();
  } else if ("tn" == key && Array.isArray(value)) {
    return decodeUtf8(value);
  }
  if ("capo" == key)
    return void 0;
  if ("uh" == key)
    return '"\u2039utxo helper\u203A"';
  if ("capoBundle" == key)
    return '"\u2039capo bundle\u203A"';
  return value;
}
function uplcDataSerializer(key, value, depth = 0) {
  const indent = "    ".repeat(depth);
  const outdent = "    ".repeat(Math.max(0, depth - 1));
  if (typeof value === "bigint") {
    return `big\u2039${value.toString()}n\u203A`;
  } else if ("bytes" == key && Array.isArray(value)) {
    return abbreviatedDetailBytes(`bytes\u2039${value.length}\u203A`, value, 40);
  } else if ("string" == typeof value) {
    return `'${value}'`;
  } else if (value === null) {
    return `\u2039null\u203A`;
  } else if ("undefined" == typeof value) {
    return `\u2039und\u203A`;
  } else if (value.kind == "Address") {
    const a = value;
    const cbor = a.toCbor();
    return `\u2039${abbrevAddress(value)}\u203A = ` + abbreviatedDetailBytes(`cbor\u2039${cbor.length}\u203A:`, cbor, 99);
  } else if (value.kind == "ValidatorHash") {
    return abbreviatedDetailBytes(`script\u2039${value.bytes.length}\u203A`, value.bytes);
  } else if (value.kind == "MintingPolicyHash") {
    const v = value;
    return `mph\u2039${policyIdAsString(v)}\u203A`;
  } else if (value.kind == "TxOutputId") {
    return `\u2039txoid:${txOutputIdAsString(value, 8)}\u203A`;
  }
  if (value.rawData) {
    return uplcDataSerializer(key, value.rawData, Math.max(depth, 3));
  }
  if (value.kind == "int") {
    const v = value;
    return `IntData\u2039${v.value}\u203A`;
  }
  if (value.kind == "bytes") {
    const v = value;
    return abbreviatedDetailBytes(`ByteArray\u2039${v.bytes.length}\u203A`, v.bytes, 40);
  }
  if (value.kind == "Value") {
    return valueAsString(value);
  }
  if (value.kind == "Assets") {
    return `assets:\u2039${assetsAsString(value)}\u203A`;
  }
  if (value.kind)
    console.log("info: no special handling for KIND = ", value.kind);
  if ("tn" == key && Array.isArray(value)) {
    return decodeUtf8(value);
  } else if ("number" == typeof value) {
    return value.toString();
  } else if (value instanceof Map) {
    return `map\u2039${value.size}\u203A: ${uplcDataSerializer("", Object.fromEntries(value.entries()), Math.max(depth, 3))}`;
  } else if (Array.isArray(value) && value.length == 0) {
    return "[]";
  } else if (Array.isArray(value) && value.every((v) => typeof v === "number")) {
    return `${abbreviatedDetailBytes(`bytes\u2039${value.length}\u203A`, value, 40)}`;
  } else if (Array.isArray(value)) {
    const inner = value.map((v) => uplcDataSerializer("", v, Math.max(depth + 1, 3)));
    let extraNewLine2 = "";
    let usesOutdent2 = "";
    const multiLine2 = inner.map((s2) => {
      s2.trim().includes("\n");
      if (s2.length > 40) {
        extraNewLine2 = "\n";
        usesOutdent2 = outdent;
        return `${indent}${s2}`;
      }
      return s2;
    }).join(`, ${extraNewLine2}`);
    return `[ ${extraNewLine2}${multiLine2}${extraNewLine2}${usesOutdent2} ]`;
  }
  if (!value) {
    return JSON.stringify(value);
  }
  const keys = Object.keys(value);
  if (keys.length == 0) {
    return key ? "" : "{}";
  }
  if (keys.length == 1) {
    const singleKey = keys[0];
    const thisValue = value[singleKey];
    let inner = uplcDataSerializer("", thisValue, Math.max(depth, 3)) || "";
    if (Array.isArray(thisValue)) {
      if (!inner.length) {
        inner = "[ \u2039empty list\u203A ]";
      }
    } else {
      if (inner.length)
        inner = `{ ${inner} }`;
    }
    let s2 = `${singleKey}: ${inner}`;
    return s2;
  }
  let extraNewLine = "";
  let usesOutdent = "";
  let s = keys.map((k) => `${indent}${k}: ${uplcDataSerializer(k, value[k], Math.max(depth + 1, 2))}`);
  const multiLine = s.map((s2) => {
    if (s2.length > 40 && !s2.includes("\n")) {
      extraNewLine = "\n";
      usesOutdent = outdent;
      return `${s2}`;
    }
    return s2;
  }).join(`, ${extraNewLine}`);
  s = `${multiLine}${extraNewLine}${usesOutdent}`;
  if (key)
    return `{${extraNewLine}${s}}`;
  return `
${s}`;
}
function abbrevAddress(address) {
  return abbreviatedDetail(address.toString(), 12, false);
}
function abbreviatedDetailBytes(prefix, value, initLength = 8) {
  const hext = bytesToHex(value);
  value.length;
  const text = isValidUtf8(value) ? ` \u2039"${abbreviatedDetail(decodeUtf8(value), initLength)}"\u203A` : ``;
  if (value.length <= initLength)
    return `${prefix}${hext}${text}`;
  const checksumString = encodeBech32("_", value).slice(-4);
  return `${prefix}${hext.slice(0, initLength)}\u2026 \u2039${checksumString}\u203A${text}`;
}
function abbreviatedDetail(hext, initLength = 8, countOmitted = false) {
  if (process?.env?.EXPAND_DETAIL) {
    return hext;
  } else {
    if (hext.length <= initLength)
      return hext;
    const omittedCount = countOmitted ? hext.length - initLength - 4 : 0;
    let omittedString = countOmitted ? `\u2039\u2026${omittedCount}\u2026\u203A` : "\u2026";
    if (countOmitted && omittedCount < omittedString.length) {
      omittedString = hext.slice(initLength, -4);
    }
    return `${hext.slice(0, initLength)}${omittedString}${hext.slice(-4)}`;
  }
}

function hexToPrintableString(hexStr) {
  let result = "";
  for (let i = 0; i < hexStr.length; i += 2) {
    let hexChar = hexStr.substring(i, i + 2);
    let charCode = parseInt(hexChar, 16);
    if (charCode >= 32 && charCode <= 126) {
      result += String.fromCharCode(charCode);
    } else {
      result += `\u2039${hexChar}\u203A`;
    }
  }
  return result;
}
function displayTokenName(nameBytesOrString) {
  let nameString = "";
  let cip68Tag = "";
  let cip68TagHex = "";
  let nameBytesHex = "";
  let isCip68 = false;
  if (typeof nameBytesOrString === "string") {
    nameBytesHex = Buffer.from(encodeUtf8(nameBytesOrString)).toString(
      "hex"
    );
    nameString = nameBytesOrString;
  } else {
    nameBytesHex = Buffer.from(nameBytesOrString).toString("hex");
    nameString = stringToPrintableString(nameBytesOrString);
  }
  if (nameBytesHex.length >= 8) {
    if (nameBytesHex.substring(0, 1) === "0" && nameBytesHex.substring(7, 8) === "0") {
      cip68TagHex = nameBytesHex.substring(1, 5);
      nameBytesHex.substring(5, 7);
      cip68Tag = parseInt(cip68TagHex, 16).toString();
      nameString = stringToPrintableString(nameBytesOrString.slice(4));
      isCip68 = true;
    }
  }
  if (isCip68) {
    nameString = `\u2039cip68/${cip68Tag}\u203A${nameString}`;
  } else {
    nameString = stringToPrintableString(nameBytesOrString);
  }
  return nameString;
}
function stringToPrintableString(str) {
  if ("string" != typeof str) {
    try {
      return new TextDecoder("utf-8", { fatal: true }).decode(
        new Uint8Array(str)
      );
    } catch (e) {
      str = Buffer.from(str).toString("hex");
    }
  }
  let result = "";
  for (let i = 0; i < str.length; i++) {
    let charCode = str.charCodeAt(i);
    if (charCode >= 32 && charCode <= 126) {
      result += str[i];
    } else {
      result += `\u2039${charCode.toString(16)}\u203A`;
    }
  }
  return result;
}
function assetsAsString(a, joiner = "\n    ", showNegativeAsBurn, mintRedeemers) {
  const assets = a.assets;
  return (assets?.map(([policyId, tokenEntries], index) => {
    let redeemerInfo = mintRedeemers?.[index] || "";
    if (redeemerInfo) {
      redeemerInfo = `
        r = ${redeemerInfo} `;
    }
    const tokenString = tokenEntries.map(([nameBytes, count]) => {
      const nameString = displayTokenName(nameBytes);
      const negWarning = count < 1n ? showNegativeAsBurn ? "\u{1F525} " : " \u26A0\uFE0F NEGATIVE\u26A0\uFE0F" : "";
      const burned = count < 1 ? showNegativeAsBurn ? "- BURN \u{1F525} " : "" : "";
      return `${negWarning} ${count}\xD7\u{1F4B4} ${nameString} ${burned}`;
    }).join("+");
    return `\u2991${policyIdAsString(
      policyId
    )} ${tokenString} ${redeemerInfo}\u2992`;
  }) || []).join(joiner);
}
function policyIdAsString(p) {
  const pIdHex = p.toHex();
  const abbrev = abbreviatedDetail(pIdHex);
  return `\u{1F3E6} ${abbrev}`;
}
function lovelaceToAda(l) {
  const asNum = parseInt(l.toString());
  const ada = asNum && `${(Math.round(asNum / 1e3) / 1e3).toFixed(3)} ADA` || "";
  return ada;
}
function valueAsString(v) {
  const ada = lovelaceToAda(v.lovelace);
  const assets = assetsAsString(v.assets);
  return [ada, assets].filter((x) => !!x).join(" + ");
}
function txAsString(tx, networkParams) {
  const outputOrder = [
    ["body", "inputs"],
    ["body", "minted"],
    ["body", "outputs"],
    ["body", "refInputs"],
    ["witnesses", "redeemers"],
    ["body", "signers"],
    ["witnesses", "v2refScripts"],
    ["witnesses", "v2scripts"],
    ["witnesses", "nativeScripts"],
    ["body", "collateral"],
    ["body", "collateralReturn"],
    ["body", "scriptDataHash"],
    ["body", "metadataHash"],
    ["witnesses", "signatures"],
    ["witnesses", "datums"],
    ["body", "lastValidSlot"],
    ["body", "firstValidSlot"],
    ["body", "fee"]
  ];
  let details = "";
  if (!networkParams) {
    debugger;
    console.warn(
      new Error(`dumpAny: no networkParams; can't show txn size info!?!`)
    );
  }
  const seenRedeemers = /* @__PURE__ */ new Set();
  const allRedeemers = tx.witnesses.redeemers;
  let hasIndeterminate = false;
  const inputRedeemers = Object.fromEntries(
    allRedeemers.map((x, index) => {
      if (x.kind != "TxSpendingRedeemer")
        return void 0;
      const { inputIndex } = x;
      const isIndeterminate = inputIndex == -1;
      if (isIndeterminate)
        hasIndeterminate = true;
      const inpIndex = isIndeterminate ? `\u2039unk${index}\u203A` : inputIndex;
      if (!x.data)
        debugger;
      const showData = x.data.rawData ? uplcDataSerializer("", x.data.rawData) : x.data?.toString() || "\u2039no data\u203A";
      return [inpIndex, { r: x, display: showData }];
    }).filter((x) => !!x)
  );
  if (hasIndeterminate)
    inputRedeemers["hasIndeterminate"] = {
      r: void 0,
      display: "\u2039unk\u203A"
    };
  const mintRedeemers = Object.fromEntries(
    allRedeemers.map((x) => {
      if ("TxMintingRedeemer" != x.kind)
        return void 0;
      if ("number" != typeof x.policyIndex) {
        debugger;
        throw new Error(`non-mint redeemer here not yet supported`);
      }
      if (!x.data)
        debugger;
      const showData = (x.data.rawData ? uplcDataSerializer("", x.data.rawData) : x.data?.toString() || "\u2039no data\u203A") + "\n" + bytesToHex(x.data.toCbor());
      return [x.policyIndex, showData];
    }).filter((x) => !!x)
  );
  //!!! todo: improve interface of tx so useful things have a non-private api
  //!!! todo: get back to type-safety in this diagnostic suite
  for (const [where, x] of outputOrder) {
    let item = tx[where][x];
    let skipLabel = false;
    if (Array.isArray(item) && !item.length)
      continue;
    if (!item)
      continue;
    if ("inputs" == x) {
      item = `
  ${item.map((x2, i) => {
        const { r, display } = inputRedeemers[i] || inputRedeemers["hasIndeterminate"] || {};
        if (!display && x2.datum?.data)
          debugger;
        if (r)
          seenRedeemers.add(r);
        return txInputAsString(
          x2,
          /* unicode blue arrow right -> */
          `\u27A1\uFE0F  @${1 + i} `,
          i,
          display
          // || "‹failed to find redeemer info›"
        );
      }).join("\n  ")}`;
    }
    if ("refInputs" == x) {
      item = `
  ${item.map((x2) => txInputAsString(x2, "\u2139\uFE0F  ")).join("\n  ")}`;
    }
    if ("collateral" == x) {
      //!!! todo: group collateral with inputs and reflect it being spent either way,
      //!!! todo: move collateral to bottom with collateralReturn,
      item = item.map((x2) => txInputAsString(x2, "\u{1F52A}")).join("\n    ");
    }
    if ("minted" == x) {
      if (!item.assets.length) {
        continue;
      }
      item = `
   \u2747\uFE0F  ${assetsAsString(
        item,
        "\n   \u2747\uFE0F  ",
        "withBURN",
        mintRedeemers
      )}`;
    }
    if ("outputs" == x) {
      item = `
  ${item.map(
        (x2, i) => txOutputAsString(
          x2,
          `\u{1F539}${i} <-`
        )
      ).join("\n  ")}`;
    }
    if ("signers" == x) {
      item = item.map((x2) => {
        const hex = x2.toHex();
        return `\u{1F511}#${hex.slice(0, 6)}\u2026${hex.slice(-4)}`;
      });
    }
    if ("fee" == x) {
      item = parseInt(item);
      item = `${(Math.round(item / 1e3) / 1e3).toFixed(3)} ADA `;
    }
    if ("collateralReturn" == x) {
      skipLabel = true;
      item = `  ${txOutputAsString(
        item,
        `0  <- \u2753`
      )} conditional: collateral change (returned in case of txn failure)`;
    }
    if ("scriptDataHash" == x) {
      item = bytesToHex(item);
    }
    if ("datums" == x && !Object.entries(item || {}).length)
      continue;
    if ("signatures" == x) {
      if (!item)
        continue;
      item = item.map((s) => {
        const addr = makeAddress(true, s.pubKeyHash);
        const hashHex = s.pubKeyHash.toHex();
        return `\u{1F58A}\uFE0F ${addrAsString(addr)} = \u{1F511}\u2026${hashHex.slice(-4)}`;
      });
      if (item.length > 1)
        item.unshift("");
      item = item.join("\n    ");
    }
    if ("redeemers" == x) {
      if (!item)
        continue;
      //!!! todo: augment with mph when that's available from the Activity.
      item = item.map((x2) => {
        const indexInfo = x2.kind == "TxMintingRedeemer" ? `minting policy ${x2.policyIndex}` : `spend txin \u27A1\uFE0F  @${1 + x2.inputIndex}`;
        const showData = seenRedeemers.has(x2) ? "(see above)" : x2.data.fromData ? uplcDataSerializer("", x2.data.fromData) : x2.data.toString();
        return `\u{1F3E7}  ${indexInfo} ${showData}`;
      });
      if (item.length > 1)
        item.unshift("");
      item = item.join("\n    ");
    }
    if ("v2Scripts" == x) {
      if (!item)
        continue;
      item = item.map((s) => {
        try {
          const mph = s.mintingPolicyHash.toHex();
          return `\u{1F3E6} ${mph.slice(0, 8)}\u2026${mph.slice(-4)} (minting): ${s.serializeBytes().length} bytes`;
        } catch (e) {
          const vh = s.validatorHash;
          const vhh = vh.toHex();
          const addr = makeAddress(true, vh);
          return `\u{1F4DC} ${vhh.slice(0, 8)}\u2026${vhh.slice(
            -4
          )} (validator at ${addrAsString(addr)}): ${s.serializeBytes().length} bytes`;
        }
      });
      if (item.length > 1)
        item.unshift("");
      item = item.join("\n    ");
    }
    if ("v2RefScripts" == x) {
      item = `${item.length} - see refInputs`;
    }
    if (!item)
      continue;
    details += `${skipLabel ? "" : "  " + x + ": "}${item}
`;
  }
  try {
    details += `  txId: ${tx.id().toHex()}`;
    if (networkParams)
      details += `  

size: ${tx.toCbor().length} bytes`;
  } catch (e) {
    details = details + `(Tx not yet finalized!)`;
    if (networkParams)
      details += `
  - NOTE: can't determine txn size
`;
  }
  return details;
}
function txInputAsString(x, prefix = "-> ", index, redeemer) {
  const { output: oo } = x;
  const redeemerInfo = redeemer ? `
    r = ${redeemer}` : " \u2039no redeemer\u203A";
  const datumInfo = oo.datum?.kind == "InlineTxOutputDatum" ? datumSummary(oo.datum) : "";
  return `${prefix}${addrAsString(x.address)}${showRefScript(
    oo.refScript
  )} ${valueAsString(x.value)} ${datumInfo} = \u{1F4D6} ${txOutputIdAsString(
    x.id
  )}${redeemerInfo}`;
}
function utxosAsString(utxos, joiner = "\n", utxoDCache) {
  return utxos.map((u) => utxoAsString(u, " \u{1F4B5}", utxoDCache)).join(joiner);
}
function txOutputIdAsString(x, length = 8) {
  return txidAsString(x.txId, length) + `\u{1F539}#${x.index}`;
}
function txidAsString(x, length = 8) {
  const tid = x.toHex();
  return `${tid.slice(0, length)}\u2026${tid.slice(-4)}`;
}
function utxoAsString(x, prefix = "\u{1F4B5}", utxoDCache) {
  return ` \u{1F4D6} ${txOutputIdAsString(x.id)}: ${txOutputAsString(
    x.output,
    prefix,
    utxoDCache,
    x.id
  )}`;
}
function datumSummary(d) {
  if (!d)
    return "";
  const dh = d.hash.toHex();
  const dhss = `${dh.slice(0, 8)}\u2026${dh.slice(-4)}`;
  if (d.kind == "InlineTxOutputDatum") {
    const attachedData = d.data.rawData;
    if (attachedData) {
      return `
    d\u2039inline:${dhss} - ${uplcDataSerializer("", attachedData)}=${d.toCbor().length} bytes\u203A`;
    } else {
      return `d\u2039inline:${dhss} - ${d.toCbor().length} bytes\u203A`;
    }
  }
  return `d\u2039hash:${dhss}\u2026\u203A`;
}
function showRefScript(rs) {
  if (!rs)
    return "";
  const hash = rs.hash();
  const hh = bytesToHex(hash);
  const size = rs.toCbor().length;
  const rshInfo = `${hh.slice(0, 8)}\u2026${hh.slice(-4)}`;
  return ` \u2039\u{1F4C0} refScript\u{1F4DC} ${rshInfo}: ${size} bytes\u203A +`;
}
function txOutputAsString(x, prefix = "<-", utxoDCache, txoid) {
  if (utxoDCache && !txoid) {
    throw new Error(`txOutputAsString: must provide txoid when using cache`);
  }
  let cache = utxoDCache?.get(txoid);
  if (cache) {
    return `\u267B\uFE0F ${cache} (same as above)`;
  }
  cache = `${prefix} ${addrAsString(x.address)}${showRefScript(
    x.refScript
  )} ${valueAsString(x.value)}`;
  utxoDCache?.set(txoid, cache);
  return `${cache} ${datumSummary(x.datum)}`;
}
function addrAsString(address) {
  const bech32 = address.toString();
  return `${bech32.slice(0, 14)}\u2026${bech32.slice(-4)}`;
}
function errorMapAsString(em, prefix = "  ") {
  return Object.keys(em).map((k) => `in field ${prefix}${k}: ${JSON.stringify(em[k])}`).join("\n");
}
function byteArrayListAsString(items, joiner = "\n  ") {
  return "[\n  " + items.map((ba) => byteArrayAsString(ba)).join(joiner) + "\n]\n";
}
function byteArrayAsString(ba) {
  return hexToPrintableString(ba.toHex());
}
function dumpAny(x, networkParams, forJson = false) {
  if ("undefined" == typeof x)
    return "\u2039undefined\u203A";
  if (Array.isArray(x)) {
    if (!x.length)
      return "\u2039empty array\u203A";
    const firstItem = x[0];
    if ("number" == typeof firstItem) {
      return "num array: " + byteArrayListAsString([makeByteArrayData(x)]);
    }
    if (firstItem.kind == "TxOutput") {
      return "tx outputs: \n" + x.map((txo) => txOutputAsString(txo));
    }
    if (firstItem.kind == "TxInput") {
      return "utxos: \n" + utxosAsString(x);
    }
    if (firstItem.kind == "ByteArrayData") {
      return "byte array:\n" + byteArrayListAsString(x);
    }
    if ("object" == typeof firstItem) {
      debugger;
      if (firstItem instanceof Uint8Array) {
        return "byte array: " + byteArrayAsString(firstItem);
      }
      return `[` + x.map(
        (item) => JSON.stringify(item, betterJsonSerializer)
      ).join(", ") + `]`;
    }
    console.log("firstItem", firstItem);
    throw new Error(
      `dumpAny(): unsupported array type: ${typeof firstItem}`
    );
  }
  if ("bigint" == typeof x) {
    return x.toString();
  }
  if (x instanceof StellarTxnContext) {
    debugger;
    throw new Error(`use await build() and dump the result instead.`);
  }
  const xx = x;
  if (x.kind == "TxOutput") {
    return txOutputAsString(x);
  }
  if (xx.kind == "Tx") {
    return txAsString(xx, networkParams);
  }
  if (xx.kind == "TxOutputId") {
    return txOutputIdAsString(xx);
  }
  if (xx.kind == "TxId") {
    return txidAsString(xx);
  }
  if (xx.kind == "TxInput") {
    return utxoAsString(xx);
  }
  if (xx.kind == "Value") {
    return valueAsString(xx);
  }
  if (xx.kind == "Address") {
    return addrAsString(xx);
  }
  if (xx.kind == "MintingPolicyHash") {
    return policyIdAsString(xx);
  }
  if (forJson)
    return xx;
  if ("object" == typeof x) {
    return `{${Object.entries(x).map(
      ([k, v]) => `${k}: ${dumpAny(v, networkParams)}`
    ).join(",\n")}}`;
  }
  debugger;
  return "dumpAny(): unsupported type or library mismatch";
}
const betterJsonSerializer = (key, value) => {
  return dumpAny(value, void 0, true);
};
if ("undefined" == typeof window) {
  globalThis.peek = dumpAny;
} else {
  window.peek = dumpAny;
}

const _uutName = Symbol("uutName");
const maxUutName = 32;
class UutName {
  [_uutName];
  purpose;
  constructor(purpose, fullUutName) {
    this.purpose = purpose;
    if (Array.isArray(fullUutName)) {
      fullUutName = decodeUtf8(fullUutName);
    }
    if (fullUutName.length > maxUutName) {
      throw new Error(
        `uut name '${fullUutName}' exceeds max length of ${maxUutName}`
      );
    }
    this[_uutName] = fullUutName;
  }
  /**
   * the full uniquified name of this UUT
   * @remarks
   *
   * format: `purpose-‹...uniqifier...›`
   * @public
   **/
  get name() {
    return this[_uutName];
  }
  toString() {
    return this[_uutName];
  }
}

class UplcConsoleLogger {
  didStart = false;
  lines = [];
  lastMessage = "";
  lastReason;
  history = [];
  constructor() {
    this.logPrint = this.logPrint.bind(this);
    this.reset = this.reset.bind(this);
  }
  reset(reason) {
    this.lastMessage = "";
    this.lastReason = reason;
    if (reason == "build") {
      this.lines = [];
      return;
    }
    if (reason == "validate") {
      this.flush();
      return;
    }
  }
  // log(...msgs: string[]) {
  //     return this.logPrint(...msgs);
  // }
  // error(...msgs: string[]) {
  //     return this.logError(...msgs, "\n");
  // }
  // logPrintLn(...msgs: string[]) {
  //     return this.logPrint(...msgs, "\n");
  // }
  logPrint(message, site) {
    if ("string" != typeof message) {
      console.log("wtf");
    }
    if (message && message.at(-1) != "\n") {
      message += "\n";
    }
    this.lastMessage = message;
    this.lines.push(message);
    return this;
  }
  logError(message, stack) {
    debugger;
    this.logPrint("\n");
    this.logPrint(
      "-".repeat((process?.stdout?.columns || 65) - 8)
    );
    this.logPrint("--- \u26A0\uFE0F  ERROR: " + message.trimStart() + "\n");
    this.logPrint(
      "-".repeat((process?.stdout?.columns || 65) - 8) + "\n"
    );
  }
  // printlnFunction(msg) {
  //     console.log("                              ---- println")
  //     this.lines.push(msg);
  //     this.lines.push("\n");
  //     this.flushLines();
  // }
  toggler = 0;
  toggleDots() {
    this.toggler = 1 - this.toggler;
  }
  get isMine() {
    return true;
  }
  resetDots() {
    this.toggler = 0;
  }
  showDot() {
    const s = this.toggler ? "\u2502   \u250A " : "\u2502 \u25CF \u250A ";
    this.toggleDots();
    return s;
  }
  flushLines(footerString) {
    let content = [];
    const terminalWidth = process?.stdout?.columns || 65;
    const thisBatch = this.lines.join("").trimEnd();
    this.history.push(thisBatch);
    if (!this.didStart) {
      this.didStart = true;
      content.push("\u256D\u2508\u2508\u2508\u252C" + "\u2508".repeat(terminalWidth - 5));
      this.resetDots();
    } else if (this.lines.length) {
      content.push("\u251C\u2508\u2508\u2508\u253C" + "\u2508".repeat(terminalWidth - 5));
      this.resetDots();
    }
    for (const line of thisBatch.split("\n")) {
      content.push(`${this.showDot()}${line}`);
    }
    content.push(this.showDot());
    if (!this.toggler) {
      content.push(this.showDot());
    }
    if (footerString) {
      content.push(footerString);
    }
    console.log(content.join("\n"));
    this.lines = [];
  }
  finish() {
    this.flushLines(
      "\u2570\u2508\u2508\u2508\u2534" + "\u2508".repeat((process?.stdout?.columns || 65) - 5)
    );
    return this;
  }
  flush() {
    if (this.lines.length) {
      if (this.lastMessage.at(-1) != "\n") {
        this.lines.push("\n");
      }
      this.flushLines();
    }
    return this;
  }
  flushError(message = "") {
    if (this.lastMessage.at(-1) != "\n") {
      this.lines.push("\n");
    }
    if (message.at(-1) == "\n") {
      message = message.slice(0, -1);
    }
    const terminalWidth = process?.stdout?.columns || 65;
    if (message)
      this.logError(message);
    if (this.lines.length) {
      this.flushLines(
        "\u23BD\u23BC\u23BB\u23BA\u23BB\u23BA\u23BC\u23BC\u23BB\u23BA\u23BB\u23BD\u23BC\u23BA\u23BB\u23BB\u23BA\u23BC\u23BC\u23BB\u23BA".repeat((terminalWidth - 2) / 21)
      );
    }
    return this;
  }
}

//!!! if we could access the inputs and outputs in a building Tx,
const emptyUuts = Object.freeze({});
class StellarTxnContext {
  inputs = [];
  collateral;
  outputs = [];
  feeLimit;
  state;
  neededSigners = [];
  parentTcx;
  childReservedUtxos = [];
  txb;
  txnName = "";
  withName(name) {
    this.txnName = name;
    return this;
  }
  get wallet() {
    return this.setup.actorContext.wallet;
  }
  get uh() {
    return this.setup.uh;
  }
  get networkParams() {
    return this.setup.networkParams;
  }
  get actorContext() {
    return this.setup.actorContext;
  }
  /**
   * Provides a lightweight, NOT complete, serialization for presenting the transaction context
   * @remarks
   * Serves rendering of the transaction context in vitest
   * @internal
   */
  toJSON() {
    return {
      kind: "StellarTxnContext",
      state: !!this.state ? `{${Object.keys(this.state).join(", ")}}` : void 0,
      inputs: `[${this.inputs.length} inputs]`,
      outputs: `[${this.outputs.length} outputs]`,
      isBuilt: !!this._builtTx,
      hasParent: !!this.parentTcx,
      //@ts-expect-error
      addlTxns: this.state.addlTxns ? [
        //@ts-expect-error
        ...Object.keys(this.state.addlTxns || {})
      ] : void 0
    };
  }
  logger = new UplcConsoleLogger();
  constructor(setup, state = {}, parentTcx) {
    Object.defineProperty(this, "setup", {
      enumerable: false,
      value: setup
    });
    Object.defineProperty(this, "_builtTx", { enumerable: false });
    this.txb = makeTxBuilder({
      isMainnet: this.setup.isMainnet || false
    });
    this.state = {
      ...state,
      uuts: state.uuts || { ...emptyUuts }
    };
    this.parentTcx = parentTcx;
  }
  withParent(tcx) {
    this.parentTcx = tcx;
    return this;
  }
  get actorWallet() {
    return this.actorContext.wallet;
  }
  dump(tx) {
    const t = tx || this.builtTx;
    if (t instanceof Promise) {
      return t.then((tx2) => {
        return txAsString(tx2, this.setup.networkParams);
      });
    }
    return txAsString(t, this.setup.networkParams);
  }
  includeAddlTxn(txnName, txInfo) {
    const thisWithMoreType = this;
    if (thisWithMoreType.state.addlTxns?.[txnName]) {
      throw new Error(
        `addlTxns['${txnName}'] already included in this transaction`
      );
    }
    thisWithMoreType.state.addlTxns = {
      ...thisWithMoreType.state.addlTxns || {},
      [txnName]: txInfo
    };
    return thisWithMoreType;
  }
  mintTokens(...args) {
    const [policy, tokens, r = { redeemer: void 0 }] = args;
    const { redeemer } = r;
    if (this.txb.mintPolicyTokensUnsafe) {
      this.txb.mintPolicyTokensUnsafe(policy, tokens, redeemer);
    } else {
      this.txb.mintTokens(policy, tokens, redeemer);
    }
    return this;
  }
  getSeedAttrs() {
    const seedUtxo = this.state.seedUtxo;
    return { txId: seedUtxo.id.txId, idx: BigInt(seedUtxo.id.index) };
  }
  reservedUtxos() {
    return this.parentTcx ? this.parentTcx.reservedUtxos() : [
      ...this.inputs,
      this.collateral,
      ...this.childReservedUtxos
    ].filter((x) => !!x);
  }
  utxoNotReserved(u) {
    if (this.collateral?.isEqual(u))
      return void 0;
    if (this.inputs.find((i) => i.isEqual(u)))
      return void 0;
    return u;
  }
  addUut(uutName, ...names) {
    this.state.uuts = this.state.uuts || {};
    for (const name of names) {
      this.state.uuts[name] = uutName;
    }
    return this;
  }
  addState(key, value) {
    this.state[key] = value;
    return this;
  }
  addCollateral(collateral) {
    if (!collateral.value.assets.isZero()) {
      throw new Error(
        `invalid attempt to add non-pure-ADA utxo as collateral`
      );
    }
    this.collateral = collateral;
    this.txb.addCollateral(collateral);
    return this;
  }
  getSeedUtxoDetails() {
    const seedUtxo = this.state.seedUtxo;
    return {
      txId: seedUtxo.id.txId,
      idx: BigInt(seedUtxo.id.index)
    };
  }
  _txnTime;
  /**
   * Sets a future date for the transaction to be executed, returning the transaction context.  Call this before calling validFor().
   *
   * @remarks Returns the txn context.
   * Throws an error if the transaction already has a txnTime set.
   *
   * This method does not itself set the txn's validity interval.  You MUST combine it with
   * a call to validFor(), to set the txn's validity period.  The resulting transaction will
   * be valid from the moment set here until the end of the validity period set by validFor().
   *
   * This can be used anytime to construct a transaction valid in the future.  This is particularly useful
   * during test scenarios to verify time-sensitive behaviors.
   *
   * In the test environment, the network wil normally be advanced to this date
   * before executing the transaction, unless a different execution time is indicated.
   * Use the test helper's `submitTxnWithBlock(txn, {futureDate})` or `advanceNetworkTimeForTx()` methods, or args to
   * use-case-specific functions that those methods.
   */
  futureDate(date) {
    if (this._txnTime) {
      throw new Error(
        "txnTime already set; cannot set futureDate() after txnTime"
      );
    }
    const d = new Date(
      Number(this.slotToTime(this.timeToSlot(BigInt(date.getTime()))))
    );
    console.log("  \u23F0\u23F0 setting txnTime to ", d.toString());
    this._txnTime = d;
    return this;
  }
  assertNumber(obj, msg = "expected a number") {
    if (obj === void 0 || obj === null) {
      throw new Error(msg);
    } else if (typeof obj == "number") {
      return obj;
    } else {
      throw new Error(msg);
    }
  }
  /**
   * Calculates the time (in milliseconds in 01/01/1970) associated with a given slot number.
   * @param slot - Slot number
   */
  slotToTime(slot) {
    let secondsPerSlot = this.assertNumber(
      this.networkParams.secondsPerSlot
    );
    let lastSlot = BigInt(this.assertNumber(this.networkParams.refTipSlot));
    let lastTime = BigInt(this.assertNumber(this.networkParams.refTipTime));
    let slotDiff = slot - lastSlot;
    return lastTime + slotDiff * BigInt(secondsPerSlot * 1e3);
  }
  /**
   * Calculates the slot number associated with a given time.
   * @param time - Milliseconds since 1970
   */
  timeToSlot(time) {
    let secondsPerSlot = this.assertNumber(
      this.networkParams.secondsPerSlot
    );
    let lastSlot = BigInt(this.assertNumber(this.networkParams.refTipSlot));
    let lastTime = BigInt(this.assertNumber(this.networkParams.refTipTime));
    let timeDiff = time - lastTime;
    return lastSlot + BigInt(Math.round(Number(timeDiff) / (1e3 * secondsPerSlot)));
  }
  /**
   * Identifies the time at which the current transaction is expected to be executed.
   * Use this attribute in any transaction-building code that sets date/time values
   * for the transaction.
   * Honors any futureDate() setting or uses the current time if none has been set.
   */
  get txnTime() {
    if (this._txnTime)
      return this._txnTime;
    const d = new Date(
      Number(
        this.slotToTime(this.timeToSlot(BigInt((/* @__PURE__ */ new Date()).getTime())))
      )
    );
    console.log("\u23F0\u23F0setting txnTime to ", d.toString());
    return this._txnTime = d;
  }
  /**
   * Sets an on-chain validity period for the transaction, in miilliseconds
   *
   * @remarks if futureDate() has been set on the transaction, that
   * date will be used as the starting point for the validity period.
   *
   * Returns the transaction context for chaining.
   *
   * @param durationMs - the total validity duration for the transaction.  On-chain
   *  checks using CapoCtx `now(granularity)` can enforce this duration
   */
  validFor(durationMs) {
    const startMoment = this.txnTime.getTime();
    if (this.txb.validFromTime) {
      this.txb.validFromTime(new Date(startMoment)).validToTime(new Date(startMoment + durationMs));
    } else {
      this.txb.validFrom(new Date(startMoment)).validTo(new Date(startMoment + durationMs));
    }
    return this;
  }
  txRefInputs = [];
  /**
   * adds a reference input to the transaction context
   * @remarks
   *
   * idempotent version of helios addRefInput()
   *
   * @public
   **/
  addRefInput(...inputArgs) {
    const input = inputArgs[0];
    if (this.txRefInputs.find((v) => v.id.isEqual(input.id))) {
      console.warn("suppressing second add of refInput");
      return this;
    }
    this.txRefInputs.push(input);
    const v2sBefore = this.txb.v2Scripts;
    this.txb.refer(input);
    const v2sAfter = this.txb.v2Scripts;
    if (v2sAfter.length > v2sBefore.length) {
      console.log("       --- addRefInput added a script to tx.scripts");
    }
    return this;
  }
  /**
   * @deprecated - use addRefInput() instead.
   */
  addRefInputs(...args) {
    throw new Error(`deprecated`);
  }
  addInput(input, r) {
    if (r && !r.redeemer) {
      console.log("activity without redeemer tag: ", r);
      throw new Error(
        `addInput() redeemer must match the isActivity type {redeemer: \u2039activity\u203A}
`
        // JSON.stringify(r, delegateLinkSerializer)
      );
    }
    if (input.address.pubKeyHash)
      this.neededSigners.push(input.address);
    this.inputs.push(input);
    if (this.parentTcx) {
      this.parentTcx.childReservedUtxos.push(input);
    }
    try {
      this.txb.spendUnsafe(input, r?.redeemer);
    } catch (e) {
      debugger;
      throw new Error(
        `addInput: ${e.message}
   ...TODO: dump partial txn from txb above.  Failed TxInput:
` + dumpAny(input)
      );
    }
    return this;
  }
  addOutput(output) {
    try {
      this.txb.addOutput(output);
      this.outputs.push(output);
    } catch (e) {
      console.log(
        "Error adding output to txn: \n  | inputs:\n  | " + utxosAsString(this.inputs, "\n  | ") + "\n  | " + dumpAny(this.outputs).split("\n").join("\n  |   ") + "\n... in context of partial tx above: failed adding output: \n  |  ",
        dumpAny(output),
        "\n" + e.message,
        "\n   (see thrown stack trace below)"
      );
      e.message = `addOutput: ${e.message}
   ...see logged details above`;
      throw e;
    }
    return this;
  }
  attachScript(...args) {
    throw new Error(
      `use addScriptProgram(), increasing the txn size, if you don't have a referenceScript.
Use <capo>.txnAttachScriptOrRefScript() to use a referenceScript when available.`
    );
  }
  /**
   * Adds a UPLC program to the transaction context, increasing the transaction size.
   * @remarks
   * Use the Capo's `txnAttachScriptOrRefScript()` method to use a referenceScript
   * when available. That method uses a fallback approach adding the script to the
   * transaction if needed.
   */
  addScriptProgram(...args) {
    this.txb.attachUplcProgram(...args);
    return this;
  }
  wasModified() {
    this.txb.wasModified();
  }
  _builtTx;
  get builtTx() {
    if (!this._builtTx) {
      return this._builtTx = this.build().then(({ tx }) => {
        return this._builtTx = tx;
      });
    }
    return this._builtTx;
  }
  async addSignature(wallet) {
    const builtTx = await this.builtTx;
    const sig = await wallet.signTx(builtTx);
    builtTx.addSignature(sig[0]);
  }
  async findAnySpareUtxos() {
    const mightNeedFees = 3500000n;
    const toSortInfo = this.uh.mkUtxoSortInfo(mightNeedFees);
    const notReserved = this.utxoNotReserved.bind(this) || ((u) => u);
    const uh = this.uh;
    return this.wallet.utxos.then((utxos) => {
      const allSpares = utxos.filter(notReserved).map(toSortInfo).filter(uh.utxoIsSufficient).sort(uh.utxoSortSmallerAndPureADA);
      if (allSpares.reduce(uh.reduceUtxosCountAdaOnly, 0) > 0) {
        return allSpares.filter(uh.utxoIsPureADA).map(uh.sortInfoBackToUtxo);
      }
      return allSpares.map(uh.sortInfoBackToUtxo);
    });
  }
  async findChangeAddr() {
    const wallet = this.actorContext.wallet;
    if (!wallet) {
      throw new Error(
        `\u26A0\uFE0F  ${this.constructor.name}: no this.actorContext.wallet; can't get required change address!`
      );
    }
    let unused = (await wallet.unusedAddresses).at(0);
    if (!unused)
      unused = (await wallet.usedAddresses).at(-1);
    if (!unused)
      throw new Error(
        `\u26A0\uFE0F  ${this.constructor.name}: can't find a good change address!`
      );
    return unused;
  }
  async build({
    signers = [],
    addlTxInfo = {
      description: this.txnName ? ": " + this.txnName : ""
    },
    beforeValidate
  } = {}) {
    console.timeStamp?.(`submit() txn ${this.txnName}`);
    console.log("tcx build() @top");
    let { description } = addlTxInfo;
    if (description && !description.match(/^:/)) {
      description = ": " + description;
    }
    const {
      actorContext: { wallet }
    } = this;
    let walletMustSign = false;
    let tx;
    const logger = this.logger;
    if (wallet || signers.length) {
      console.timeStamp?.(`submit(): findChangeAddr()`);
      const changeAddress = await this.findChangeAddr();
      console.timeStamp?.(`submit(): findAnySpareUtxos()`);
      const spares = await this.findAnySpareUtxos();
      const willSign = [...signers, ...this.neededSigners].map(
        (addr) => addr.era == "Shelley" && addr.spendingCredential.kind == "PubKeyHash" ? addr.spendingCredential : void 0
      ).filter((pkh) => !!pkh).flat(1);
      console.timeStamp?.(`submit(): addSIgners()`);
      this.txb.addSigners(...willSign);
      const wHelper = wallet && makeWalletHelper(wallet);
      if (wallet && wHelper) {
        for (const a of willSign) {
          if (!await wHelper.isOwnAddress(a))
            continue;
          walletMustSign = true;
          break;
        }
        if (!walletMustSign) {
          const inputs = this.txb.inputs;
          if (!inputs)
            throw new Error(`no inputs in txn`);
          for (const input of inputs) {
            if (!await wHelper.isOwnAddress(input.address))
              continue;
            this.neededSigners.push(input.address);
            walletMustSign = true;
            const pubKeyHash = input.address.pubKeyHash;
            if (pubKeyHash) {
              this.txb.addSigners(pubKeyHash);
            }
            break;
          }
        }
      }
      let capturedCosts = { total: { cpu: 0n, mem: 0n } };
      try {
        tx = await this.txb.buildUnsafe({
          changeAddress,
          spareUtxos: spares,
          networkParams: this.networkParams,
          logOptions: logger,
          beforeValidate,
          modifyExBudget: (txi, purpose, index, costs) => {
            capturedCosts.total.cpu += costs.cpu;
            capturedCosts.total.mem += costs.mem;
            if ("minting" == purpose)
              purpose = "minting ";
            capturedCosts[`${purpose} @${1 + index}`] = costs;
            return costs;
          }
        });
        this.txb.validToTime;
      } catch (e) {
        logger.logError(`txn build failed: ${e.message}`);
        if (tx)
          logger.logPrint(dumpAny(tx));
        logger.logError(
          `  (it shouldn't be possible for buildUnsafe to be throwing errors!)`
        );
        logger.flushError();
        debugger;
        throw e;
      }
      if (tx.hasValidationError) {
        const e = tx.hasValidationError;
        let heliosStack = e.stack?.split("\n") || void 0;
        heliosStack = heliosStack?.map((line) => {
          if (line.match(/<helios>@at/)) {
            line = line.replace(
              /<helios>@at /,
              "   ... in helios function "
            ).replace(
              /, \[(.*)\],/,
              (_, bracketed) => ``
              // ` with scope [\n        ${
              //     bracketed.replace(/, /g, ",\n        ")
              // }\n      ]`
            );
          }
          return line;
        });
        debugger;
        const scriptContext = "string" == typeof e ? void 0 : e.scriptContext;
        logger.logError(
          `tx validation failure: 
  ${//@ts-expect-error
          tx.hasValidationError.message || tx.hasValidationError}
` + (heliosStack?.join("\n") || "")
        );
        logger.flush();
        const ctxCbor = scriptContext?.toCbor();
        const cborHex = ctxCbor ? bytesToHex(ctxCbor) : "";
        console.log(
          cborHex ? "------------------- failed ScriptContext as cbor-hex -------------------\n" + cborHex + "\n" : "",
          "------------------- failed tx as cbor-hex -------------------\n" + bytesToHex(tx.toCbor()),
          "\n------------------^ failed tx details ^------------------"
        );
      }
      return {
        tx,
        willSign,
        walletMustSign,
        wallet,
        wHelper,
        costs: capturedCosts
      };
    } else {
      throw new Error("no 'actorContext.wallet'; can't make  a txn");
    }
  }
  log(...msgs) {
    if (msgs.length > 1) {
      debugger;
      throw new Error(`no multi-arg log() calls`);
    }
    this.logger.logPrint(msgs[0]);
    return this;
  }
  flush() {
    this.logger.flush();
    return this;
  }
  finish() {
    this.logger.finish();
    return this;
  }
  /**
   * Submits the current transaction and any additional transactions in the context.
   * @remarks
   * To submit only the current transaction, use the `submit()` method.
   * 
   * The signers array can be used to add additional signers to the transaction, and 
   * is passed through to the submit() for the current txn only; it is not used for
   * any additional transactions.
   * 
   * The beforeSubmit, onSubmitted callbacks are used for each additional transaction.
   * 
   * beforeSubmit can be used to notify the user of the transaction about to be submitted,
   * and can also be used to add additional signers to the transaction or otherwise modify 
   * it (by returning the modified transaction).
   * 
   * onSubmitted can be used to notify the user that the transaction has been submitted,
   * or for logging or any other post-submission processing.
   */
  async submitAll(options = {}) {
    return this.submit(options).then(() => {
      if (this.state.addlTxns) {
        return this.submitAddlTxns();
      }
    });
  }
  /**
   * Submits only the current transaction.  
   * @remarks
   * To also submit additional transactions, use the `submitAll()` method.
   */
  async submit({
    signers = [],
    addlTxInfo = {
      description: this.txnName ? ": " + this.txnName : ""
    },
    expectError,
    beforeError,
    beforeValidate
  } = {}) {
    const { logger } = this;
    const {
      tx,
      willSign,
      walletMustSign,
      wallet,
      wHelper,
      costs = {
        total: { cpu: 0n, mem: 0n }
      }
    } = await this.build({
      signers,
      addlTxInfo,
      beforeValidate
    });
    const { description } = addlTxInfo;
    const errMsg = tx.hasValidationError && tx.hasValidationError.toString();
    if (errMsg) {
      logger.logPrint(`\u26A0\uFE0F  txn validation failed: ${errMsg}
`);
      logger.logPrint(this.dump(tx));
      this.emitCostDetails(tx, costs);
      logger.flush();
      if (beforeError) {
        await beforeError(tx);
      }
      logger.logError(`FAILED submitting tx: ${description}`);
      logger.logPrint(errMsg);
      if (expectError) {
        logger.logPrint(
          `

\u{1F4A3}\u{1F389} \u{1F4A3}\u{1F389} \u{1F389} \u{1F389} transaction failed (as expected)`
        );
      }
      logger.flushError();
      if (errMsg.match(
        /multi:Minting: only dgData activities ok in mintDgt/
      )) {
        console.log(
          `\u26A0\uFE0F  mint delegate for multiple activities should be given delegated-data activities, not the activities of the delegate`
        );
      }
      debugger;
      throw new Error(errMsg);
    }
    for (const pkh of willSign) {
      if (!pkh)
        continue;
      if (tx.body.signers.find((s) => pkh.isEqual(s)))
        continue;
      throw new Error(
        `incontheeivable! all signers should have been added to the builder above`
      );
    }
    if (walletMustSign) {
      console.timeStamp?.(`submit(): wallet.signTx()`);
      const walletSign = wallet.signTx(tx);
      const sigs = await walletSign.catch((e) => {
        logger.logError("signing via wallet failed: " + e.message);
        logger.logPrint(this.dump(tx));
        logger.flushError();
        return null;
      });
      console.timeStamp?.(`submit(): tx.addSignatures()`);
      if (sigs) {
        //! doesn't need to re-verify a sig it just collected
        tx.addSignatures(sigs, false);
      } else {
        throw new Error(`wallet signing failed`);
      }
    }
    logger.logPrint(`tx transcript: ${description}
`);
    logger.logPrint(this.dump(tx));
    this.emitCostDetails(tx, costs);
    logger.flush();
    console.timeStamp?.(`submit(): to net/wallet`);
    const promises = [
      //@ts-expect-error on non-standard submitTx() in emulator
      this.setup.network.submitTx(tx, logger).catch((e) => {
        if ("currentSlot" in this.setup.network && e.message.match(/or slot out of range/)) {
          this.checkTxValidityDetails(tx);
        }
        console.warn(
          "\u26A0\uFE0F  submitting via helios Network failed: ",
          e.message
        );
        debugger;
        throw e;
      })
    ];
    if (wallet) {
      if (!this.setup.isTest) {
        promises.push(
          wallet.submitTx(tx).catch((e) => {
            console.log(
              "\u26A0\uFE0F  submitting via wallet failed: ",
              e.message
            );
            debugger;
            throw e;
          })
        );
      }
    }
    const anySuccess = Promise.any(promises);
    try {
      await anySuccess;
    } catch (e) {
      logger.logError(
        `submitting tx failed: ${description}: ${e.message}`
      );
      logger.flushError();
    }
    return anySuccess.then((r) => {
      console.timeStamp?.(`submit(): success`);
      logger.logPrint(`


\u{1F389}\u{1F389} tx submitted: ${description} \u{1F389}\u{1F389}`);
      logger.finish();
      return r;
    });
  }
  emitCostDetails(tx, costs) {
    const { logger } = this;
    const {
      maxTxExCpu,
      maxTxExMem,
      maxTxSize,
      //@ts-expect-error on our synthetic attributes
      origMaxTxSize = maxTxSize,
      //@ts-expect-error on our synthetic attributes
      origMaxTxExMem = maxTxExMem,
      //@ts-expect-error on our synthetic attributes
      origMaxTxExCpu = maxTxExCpu,
      exCpuFeePerUnit,
      exMemFeePerUnit,
      txFeePerByte,
      txFeeFixed
    } = this.networkParams;
    const oMaxSize = origMaxTxSize;
    const oMaxMem = origMaxTxExMem;
    const oMaxCpu = origMaxTxExCpu;
    const { total, ...otherCosts } = costs;
    const txSize = tx.calcSize();
    const txFee = Number(tx.calcMinFee(this.networkParams));
    const cpuFee = Number(total.cpu) * exCpuFeePerUnit;
    const memFee = Number(total.mem) * exMemFeePerUnit;
    const sizeFee = txSize * txFeePerByte;
    const nCpu = Number(total.cpu);
    const nMem = Number(total.mem);
    if (nCpu > oMaxCpu || nMem > oMaxMem || txSize > oMaxSize) {
      logger.logPrint(
        `\u{1F525}\u{1F525}\u{1F525}\u{1F525}  THIS TX EXCEEDS default (overridden in test env) limits on network params  \u{1F525}\u{1F525}\u{1F525}\u{1F525}
  -- cpu ${nCpu} = ${(100 * nCpu / oMaxCpu).toFixed(1)}% of ${oMaxCpu} (patched to ${maxTxExCpu})
  -- mem ${nMem} = ${(100 * nMem / oMaxMem).toFixed(1)}% of ${oMaxMem} (patched to ${maxTxExMem})
  -- tx size ${txSize} = ${(100 * txSize / oMaxSize).toFixed(1)}% of ${oMaxSize} (patched to ${maxTxSize})
`
      );
    }
    const scriptBreakdown = Object.keys(otherCosts).length > 0 ? `
    -- per script (with % blame for actual costs):` + Object.entries(otherCosts).map(
      ([key, { cpu, mem }]) => `
      -- ${key}: cpu ${lovelaceToAda(
        Number(cpu) * exCpuFeePerUnit
      )} = ${(Number(cpu) / Number(total.cpu) * 100).toFixed(1)}%, mem ${lovelaceToAda(
        Number(mem) * exMemFeePerUnit
      )} = ${(Number(mem) / Number(total.mem) * 100).toFixed(1)}%`
    ).join("") : "";
    logger.logPrint(
      `costs: 
  -- scripting costs
    -- cpu units ${total.cpu} = ${lovelaceToAda(cpuFee)} (${(Number(1000n * total.cpu / BigInt(oMaxCpu)) / 10).toFixed(1)}% of cpu limit/tx)
    -- memory units ${total.mem} = ${lovelaceToAda(memFee)} (${(Number(1000n * total.mem / BigInt(oMaxMem)) / 10).toFixed(1)}% of mem limit/tx)` + scriptBreakdown + `
  -- tx size ${txSize} (${(Number(1e3 * txSize / oMaxSize) / 10).toFixed(
        1
      )}% of tx size limit) = ${lovelaceToAda(sizeFee)}
  -- fixed fee = ${lovelaceToAda(txFeeFixed)}
  -- remainder ${lovelaceToAda(
        txFee - cpuFee - memFee - sizeFee - txFeeFixed
      )} is for refScripts/etc`
    );
  }
  get currentSlot() {
    return makeNetworkParamsHelper(this.networkParams).timeToSlot(
      this.setup.network.now
    );
  }
  checkTxValidityDetails(tx) {
    tx.body;
    function getAttr(x) {
      const qq = tx.body[x];
      if (!qq) {
        throw new Error(`no ${x} in tx.body: `);
      }
      return qq;
    }
    const validFrom = getAttr("firstValidSlot");
    const validTo = getAttr("lastValidSlot");
    debugger;
    const { currentSlot } = this;
    const diff1 = validFrom - currentSlot;
    const diff2 = validTo - currentSlot;
    const disp1 = diff1 > 0 ? `NOT VALID for +${diff1}s` : `${diff2 > 0 ? "starting" : "was valid"} ${diff1}s ago`;
    const disp2 = diff2 > 0 ? `${diff1 > 0 ? "would be " : ""}VALID until now +${diff2}s` : `EXPIRED ${0 - diff2}s ago`;
    console.log(
      `  \u26A0\uFE0F  slot validity issue?
    - validFrom: ${validFrom} - ${disp1}
    - validTo: ${validTo} - ${disp2}
    - current: ${currentSlot}
`
    );
  }
  /**
   * Executes additional transactions indicated by an existing transaction
   * @remarks
   *
   * During the off-chain txn-creation process, additional transactions may be
   * queued for execution.  This method is used to execute those transactions,
   * along with any chained transactions they may trigger.
   * @param tcx - the prior txn context having the additional txns to execute
   * @param callback - an optional async callback that you can use to notify a user, or to log the results of the additional txns
   * @public
   **/
  async submitAddlTxns(callbacks) {
    const { addlTxns } = this.state;
    if (!addlTxns)
      return;
    return this.submitTxnChain({
      ...callbacks,
      txns: Object.values(addlTxns)
    });
  }
  /**
   * Submits a list of transactions, without executing any chained/nested txns.
   * @remarks
   * use submitTxnChain() to submit a list of txns with chaining
   */
  async submitTxns(txns, callbacks) {
    for (const [txName, addlTxInfo] of Object.entries(txns)) {
      const { txName: txName2, description } = addlTxInfo;
      console.log("  -- before: " + description);
      const tcx = "function" == typeof addlTxInfo.tcx ? await addlTxInfo.tcx() : addlTxInfo.tcx;
      if ("undefined" == typeof tcx) {
        throw new Error(`no txn provided for addlTx ${txName2}`);
      }
      addlTxInfo.tcx = tcx;
      const replacementTcx = callbacks?.beforeSubmit && await callbacks.beforeSubmit({
        ...addlTxInfo,
        tcx
      }) || tcx;
      if (false === replacementTcx) {
        console.log("callback cancelled txn: ", txName2);
        continue;
      }
      if (replacementTcx !== true && replacementTcx !== tcx) {
        console.log(
          `callback replaced txn ${txName2} with a different txn: `,
          dumpAny(replacementTcx)
        );
      }
      const effectiveTcx = true === replacementTcx ? tcx : replacementTcx || tcx;
      if (!effectiveTcx)
        debugger;
      await effectiveTcx.submit({
        addlTxInfo
        // just for its description.
      });
      if (callbacks?.onSubmitted) {
        await callbacks.onSubmitted(addlTxInfo);
      }
    }
  }
  /**
   * To add a script to the transaction context, use `attachScript`
   *
   * @deprecated - invalid method name; use `addScriptProgram()` or capo's `txnAttachScriptOrRefScript()` method
   **/
  addScript() {
  }
  async submitTxnChain(options = {
    //@ts-expect-error because the type of this context doesn't
    //   guarantee the presence of addlTxns.  But it might be there!
    txns: this.state.addlTxns || []
  }) {
    const addlTxns = this.state.addlTxns;
    const newTxns = options.txns || addlTxns || [];
    let chainedTxns = [];
    const hookedCallbacks = {
      // txns,  // see newTxns
      beforeSubmit: (txinfo) => {
        this.setup.network.tick?.(1);
        options.beforeSubmit?.(txinfo);
      },
      onSubmitted: (txinfo) => {
        const more = txinfo.tcx?.state?.addlTxns || {};
        console.log("  \u2705 " + txinfo.description);
        const moreTxns = Object.values(more);
        if (moreTxns.length) {
          chainedTxns.push(...moreTxns);
          console.log(
            " + chained txns: \n" + moreTxns.map((t2) => `   \u{1F7E9} ${t2.description}
`).join("")
          );
        }
        this.setup.network.tick?.(1);
      }
    };
    let chainDepth = 0;
    const isolatedTcx = new StellarTxnContext(this.setup);
    console.log(
      "at d=0: submitting addl txns: \n" + newTxns.map((t2) => `  \u{1F7E9} ${t2.description}
`).join("")
    );
    const t = isolatedTcx.submitTxns(newTxns, hookedCallbacks);
    const allPromises = [];
    chainDepth = 1;
    allPromises.push(t);
    await t;
    while (chainedTxns.length) {
      const nextChain = [];
      chainDepth++;
      for (const { tcx } of chainedTxns) {
        const { addlTxns: nestedAddlTxns } = tcx.state || {};
        if (!nestedAddlTxns)
          continue;
        nextChain.push(...Object.values(nestedAddlTxns));
      }
      console.log(
        ` \u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}
submitting ${chainedTxns.length} transactions at depth ${chainDepth}`
      );
      console.log(
        chainedTxns.map((t3) => `  \u{1F7E9} ${t3.description}
`).join("")
      );
      const t2 = isolatedTcx.submitTxns(chainedTxns, hookedCallbacks);
      allPromises.push(t2);
      await t2;
      console.log(
        "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubmitted transactions at depth " + chainDepth
      );
      chainedTxns = nextChain;
    }
    return Promise.all(allPromises);
  }
}

class UtxoHelper {
  strella;
  setup;
  constructor(setup, strella) {
    this.setup = setup;
    if (!setup.uxtoDisplayCache) {
      setup.uxtoDisplayCache = /* @__PURE__ */ new Map();
    }
    this.strella = strella;
  }
  get networkParams() {
    return this.setup.networkParams;
  }
  get wallet() {
    return this.setup.actorContext.wallet;
  }
  get network() {
    return this.setup.network;
  }
  /**
   * Filters out utxos having non-ada tokens
   * @internal
   */
  hasOnlyAda(value, tcx, u) {
    const toSortInfo = this.mkUtxoSortInfo(value.lovelace);
    const found = [u].map(toSortInfo).filter(this.utxoIsSufficient).filter(this.utxoIsPureADA).map(this.sortInfoBackToUtxo).at(0);
    return found;
  }
  /**
   * Sorts utxos by size, with pure-ADA utxos preferred over others.
   * @internal
   */
  utxoSortSmallerAndPureADA({ free: free1, minAdaAmount: r1 }, { free: free2, minAdaAmount: r2 }) {
    {
      //! primary: treats pure-ada utxos as always better
      if (!r1 && r2) {
        return -1;
      }
      if (r1 && !r2) {
        return 1;
      }
    }
    //! secondary: smaller utxos are more preferred than larger ones
    if (free2 > free1)
      return -1;
    if (free2 < free1)
      return 1;
    return 0;
  }
  /**
   * Filters out utxos that are not sufficient to cover the minimum ADA amount established in
   * the utxo sort info in {@link UtxoHelper.mkUtxoSortInfo | mkUtxoSortInfo(min, max?)}.  Use in a filter() call.
   * @internal
   */
  utxoIsSufficient({ sufficient }) {
    return !!sufficient;
  }
  /**
   * Filters out utxos that have non-ADA tokens, given a utxo sort info object.  Use in a filter() call.
   * @internal
   */
  utxoIsPureADA({ u }) {
    return u.value.assets.isZero() ? u : void 0;
  }
  /**
   * transforms utxo sort info back to just the utxo.
   * @internal
   */
  sortInfoBackToUtxo({ u }) {
    return u;
  }
  /**
   * Creates a function that creates sort-info details for a utxo, given a minimum ADA amount
   * and an optional maximum ADA amount.
   * @internal
   **/
  mkUtxoSortInfo(min, max) {
    return (u) => {
      const minAdaAmount = u.value.assets.isZero() ? BigInt(0) : (() => {
        const dummy = makeTxOutput(
          u.output.address,
          makeValue(0, u.output.value.assets)
        );
        dummy.correctLovelace(this.networkParams);
        return dummy.value.lovelace;
      })();
      const free = u.value.lovelace - minAdaAmount;
      const sufficient = free > min && (max ? free < max : true);
      const t = { u, sufficient, free, minAdaAmount };
      return t;
    };
  }
  /**
   * accumulates the count of utxos, but only if the utxo is ADA-only.  Use in a reduce() call.
   **/
  reduceUtxosCountAdaOnly(c, { minAdaAmount }) {
    return c + (minAdaAmount ? 0 : 1);
  }
  hasToken(something, value, tokenName, quantity) {
    if (something.kind == "TxOutput")
      return this.outputHasToken(
        something,
        value,
        tokenName,
        quantity
      ) && something || void 0;
    if (something.kind == "TxInput")
      return this.utxoHasToken(
        something,
        value,
        tokenName,
        quantity
      ) && something || void 0;
    if (something.kind == "Assets")
      return this.assetsHasToken(
        something,
        value,
        tokenName,
        quantity
      ) && something || void 0;
    throw new Error("unexpected");
  }
  utxoHasToken(u, value, tokenName, quantity) {
    return this.outputHasToken(u.output, value, tokenName, quantity) && u;
  }
  inputHasToken(i, value, tokenName, quantity) {
    return this.outputHasToken(i.output, value, tokenName, quantity) && i;
  }
  assetsHasToken(a, vOrMph, tokenName, quantity) {
    const v = vOrMph.kind == "MintingPolicyHash" ? this.mkAssetValue(vOrMph, tokenName, quantity) : vOrMph;
    return a.isGreaterOrEqual(v.assets);
  }
  outputHasToken(o, vOrMph, tokenName, quantity) {
    const isValue = vOrMph.kind == "Value";
    if (!isValue) {
      if (!tokenName || !quantity) {
        throw new Error(
          `missing required tokenName/quantity (or use a Value in arg2`
        );
      }
    }
    const v = isValue ? vOrMph : makeValue(vOrMph, tokenName, quantity);
    return o.value.isGreaterOrEqual(v);
  }
  /**
   * @deprecated - use helios `makeValue()` instead
   */
  mkAssetValue(mph, tokenName, count = 1n) {
    const v = makeValue(
      mph,
      tokenName,
      count
      // ...other mph / token-map pairs
    );
    return v;
  }
  findSmallestUnusedUtxo(lovelace, utxos, tcx) {
    const value = makeValue(lovelace);
    const toSortInfo = this.mkUtxoSortInfo(value.lovelace);
    const found = utxos.map(toSortInfo).filter(this.utxoIsPureADA).filter(this.utxoIsSufficient).filter((uInfo) => {
      if (!tcx)
        return true;
      return !!tcx?.utxoNotReserved(uInfo.u);
    }).sort(this.utxoSortSmallerAndPureADA).map(this.sortInfoBackToUtxo);
    console.log("smallest utxos: ", utxosAsString(found));
    const chosen = found.at(0);
    return chosen;
  }
  /**
   * creates a filtering function, currently for TxInput-filtering only.
   * with the optional tcx argument, utxo's already reserved
   *  ... in that transaction context will be skipped.
   * @public
   */
  mkValuePredicate(lovelace, tcx) {
    const value = makeValue(lovelace);
    const predicate = _adaPredicate.bind(this, tcx);
    predicate.predicateValue = value;
    return predicate;
    function _adaPredicate(tcx2, utxo) {
      return this.hasOnlyAda(value, tcx2, utxo);
    }
  }
  /**
   * Creates an asset class for the given token name, for the indicated minting policy
   */
  acAuthorityToken(tokenName, mph) {
    let ourMph = mph;
    if (!ourMph) {
      if (!this.strella) {
        throw new Error(
          `no contract available for resolving minting policy hash; provide to acAuthorityToken or use a UtxoHelper having a strella prop`
        );
      }
      ourMph = this.strella.mintingPolicyHash;
    }
    if (!ourMph) {
      throw new Error(`no minting policy hash available`);
    }
    return makeAssetClass(ourMph, tokenName);
  }
  /**
   * Creates a Value object representing a token with a minimum lovelace amount
   * making it valid for output in a utxo.
   * @public
   */
  mkMinTv(mph, tokenName, count = 1n) {
    const tnBytes = Array.isArray(tokenName) ? tokenName : encodeUtf8(tokenName.toString());
    return this.mkMinAssetValue(mph, tnBytes, count);
  }
  mkMinAssetValue(mph, tokenName, count = 1n) {
    const v = makeValue(mph, tokenName, count);
    const dummyAddr = makeDummyAddress(false);
    const txo = makeTxOutput(dummyAddr, v);
    txo.correctLovelace(this.networkParams);
    return txo.value;
  }
  tokenAsValue(tokenName, count = 1n) {
    throw new Error(`only implemented by Capo`);
  }
  mkTokenPredicate(specifier, quantOrTokenName, quantity) {
    let mph;
    let tokenName;
    //!!! todo: support (AssetClass, quantity) input form
    if (!specifier)
      throw new Error(
        `missing required Value or MintingPolicyHash or UutName (or uut-name as byte-array) in arg1`
      );
    _tokenPredicate.bind(this);
    const isValue = specifier.kind == "Value";
    const isTokenNameOnly = "string" === typeof specifier || Array.isArray(specifier) && "number" === typeof specifier[0];
    const isUut = specifier instanceof UutName;
    if (isValue) {
      const v2 = specifier;
      const t = _tokenPredicate.bind(this, v2);
      t.predicateValue = v2;
      return t;
    } else if (isUut || isTokenNameOnly) {
      const tn = specifier;
      const quant = quantOrTokenName ? BigInt(quantOrTokenName) : 1n;
      const mph2 = this.strella.mph;
      if (!mph2) {
        throw new Error(
          `this helper doesn't have a capo contract to resolve minting policy hash; specify the mph explicitly`
        );
      }
      const tnBytes = isUut ? encodeUtf8(tn.toString()) : Array.isArray(tn) ? tn : encodeUtf8(tn);
      const tv = makeValue(
        mph2,
        tnBytes,
        quant
        // quantity if any
      );
      const t = _tokenPredicate.bind(this, tv);
      t.predicateValue = tv;
      return t;
    } else if (specifier.kind == "MintingPolicyHash") {
      mph = specifier;
      if ("string" !== typeof quantOrTokenName)
        throw new Error(
          `with minting policy hash, token-name must be a string (or ByteArray support is TODO)`
        );
      tokenName = quantOrTokenName;
      quantity = quantity || 1n;
      const tv = this.mkAssetValue(mph, tokenName, quantity);
      const t = _tokenPredicate.bind(this, tv);
      t.predicateValue = tv;
      return t;
    } else if (specifier.kind == "AssetClass") {
      const s = specifier;
      mph = s.mph;
      if (!quantOrTokenName)
        quantOrTokenName = 1n;
      if ("bigint" !== typeof quantOrTokenName)
        throw new Error(
          `with AssetClass, the second arg must be a bigint like 3n, or omitted`
        );
      quantity = quantOrTokenName;
      const tv = makeValue(0n, [[mph, [[s.tokenName, quantity]]]]);
      const t = _tokenPredicate.bind(this, tv);
      t.predicateValue = tv;
      return t;
    } else {
      throw new Error(
        `wrong token specifier (need Value, MPH+tokenName, or AssetClass`
      );
    }
    function _tokenPredicate(v2, something) {
      return this.hasToken(something, v2);
    }
  }
  /**
   * adds the values of the given TxInputs
   */
  totalValue(utxos) {
    return utxos.reduce((v, u) => {
      return v.add(u.value);
    }, makeValue(0n));
  }
  /**
   * Creates a Value object representing a token with the given name and quantity
   * @deprecated - Use `helios' makeValue()` instead.
   * @remarks
   * This method doesn't include any lovelace in the Value object.
   * use mkMinAssetValue() to include the minimum lovelace for storing that token in its own utxo
   * @param tokenName - the name of the token
   * @param quantity - the quantity of the token
   * @param mph - the minting policy hash of the token
   * @public
   **/
  mkTokenValue(tokenName, quantity, mph) {
    return makeValue(mph, tokenName, quantity);
  }
  /**
   * Creates a Value having enough lovelace to store the indicated token
   * @deprecated - Use {@link UtxoHelper.mkMinAssetValue | mkMinAssetValue(mph, tokenName, quantity)} instead.
   * @remarks
   * This is equivalent to mkTokenValue() with an extra min-utxo calculation
   * @public
   **/
  mkMinTokenValue(tokenName, quantity, mph) {
    return this.mkMinAssetValue(mph, tokenName, quantity);
  }
  /**
   * Locates a utxo in the current actor's wallet that matches the provided token predicate
   * @public
   */
  async findActorUtxo(name, predicate) {
    const wallet = this.wallet;
    const utxos = await wallet.utxos;
    return this.hasUtxo(name, predicate, { wallet, utxos });
  }
  /**
   * Try finding a utxo matching a predicate
   * @remarks
   * Filters the provided list of utxos to find the first one that matches the predicate.
   *
   * Skips any utxos that are already being spent in the provided transaction context.
   * Skips any utxos that are marked as collateral in the wallet.
   *
   * @public
   **/
  async hasUtxo(semanticName, predicate, {
    // address,
    wallet,
    exceptInTcx,
    utxos,
    required
  }) {
    const collateral = (wallet ? await wallet.collateral : [])[0];
    const notCollateral = utxos.filter((u) => !collateral?.isEqual(u));
    const filtered = exceptInTcx ? notCollateral.filter(
      exceptInTcx.utxoNotReserved.bind(exceptInTcx)
    ) : notCollateral;
    const joiner = "\n   \u{1F50E}  ";
    const detail = (
      // true ||
      globalThis.utxoDump ? "\n  from set: " + joiner + utxosAsString(filtered, joiner) : `(${filtered.length} candidates; set globalThis.utxoDump to see details)`
    );
    console.log(
      `  \u{1F50E} finding '${semanticName}' utxo${exceptInTcx ? " (not already being spent in txn)" : ""} ${detail}`
      // ...(exceptInTcx && filterUtxos?.length
      //     ? [
      //           "\n  ... after filtering out:\n ",
      //           utxosAsString(exceptInTcx.reservedUtxos(), "\n  "),
      //       ]
      //     : [])
    );
    const found = filtered.find(predicate);
    if (found) {
      console.log("   \u{1F388}found" + utxosAsString([found], void 0, this.setup.uxtoDisplayCache));
    } else {
      if (exceptInTcx) {
        const alreadyInTcx = exceptInTcx.inputs.find(predicate);
        if (alreadyInTcx) {
          console.log(
            `
  um... value ${dumpAny(
              predicate.predicateValue
            )} not found. 
     ${dumpAny(alreadyInTcx)}
  FYI, it seems this ^^ current txn input already has the target value. 
    NOTE: You may want to adjust your dAPI to create an explicit fail-if-already-present semantic
    ... or, alternatively, to allow this token to authenticate multiple transaction elements
    ... by using explicitly idempotent 'addOrReuse' semantics, with details stored in tcx.state

  ... go with care, and ask the community for help if you're unsure
  )` + (required ? "\nBTW, here is that txn as of this time: " + await alreadyInTcx.dump() + "\n\n \u{1F441}\uFE0F   \u{1F441}\uFE0F \u{1F441}\uFE0F ^^^^^^^ More details about the utxo search failure above ^^^^^^^ \u{1F441}\uFE0F \u{1F441}\uFE0F   \u{1F441}\uFE0F" : "")
          );
          return void 0;
        }
      }
    }
    return found;
  }
  async mustFindActorUtxo(name, predicate, hintOrExcept, hint) {
    const wallet = this.wallet;
    const isTcx = hintOrExcept instanceof StellarTxnContext;
    const exceptInTcx = isTcx ? hintOrExcept : void 0;
    const extraErrorHint = isTcx ? hint : "string" == typeof hintOrExcept ? hintOrExcept : void 0;
    return this.mustFindUtxo(
      name,
      predicate,
      {
        wallet,
        exceptInTcx
      },
      extraErrorHint
    );
  }
  async mustFindUtxo(semanticName, predicate, searchScope, extraErrorHint = "") {
    const wallet = searchScope.wallet;
    const address = searchScope.address;
    const exceptInTcx = searchScope.exceptInTcx;
    const utxos = address ? await this.network.getUtxos(address) : await wallet.utxos;
    const found = await this.hasUtxo(semanticName, predicate, {
      address,
      wallet,
      exceptInTcx,
      utxos,
      required: true
    });
    if (!found) {
      const walletAddr = wallet ? (
        //@ts-ignore - sorry typescript, address sometimes is present on a SimpleWallet in test environment
        wallet.address || await wallet.usedAddresses
      ) : void 0;
      if (!globalThis.utxoDump) {
        console.log(
          // warning emoji: "⚠️"
          " \u26A0\uFE0F find failed in candidate",
          dumpAny(utxos)
        );
      }
      throw new Error(
        this.utxoSearchError(
          semanticName,
          searchScope,
          extraErrorHint,
          walletAddr
        )
      );
    }
    return found;
  }
  utxoSearchError(semanticName, searchScope, extraErrorHint, walletAddresses) {
    const where = searchScope.address ? `searched in address ${searchScope.address.toString()}
` : ``;
    const wAddrs = Array.isArray(walletAddresses) ? walletAddresses : walletAddresses ? [walletAddresses] : [];
    let more = wAddrs.length ? wAddrs.map((x) => dumpAny(x) + ` = ${x.toString()}`).join("\n") : "";
    if (wAddrs.length > 1) {
      more = "\n  ... wallet addrs:\n";
    } else {
      more = wAddrs.length ? `
  ... in wallet addr: ${more}` : "";
    }
    if (extraErrorHint)
      more += "\n";
    return `${this.constructor.name}: '${semanticName}' utxo not found ${more}  ... ${extraErrorHint || "sorry, no extra clues available"}${where}
  ... see further logged details above`;
  }
  toUtxoId(u) {
    return `${u.id.txId.toHex()}@${u.id.index}`;
  }
}

class SeedActivity {
  constructor(host, factoryFunc, arg) {
    this.host = host;
    this.factoryFunc = factoryFunc;
    this.arg = arg;
  }
  arg;
  mkRedeemer(seedFrom) {
    return this.factoryFunc.call(this.host, seedFrom, this.arg);
  }
}
function impliedSeedActivityMaker(host, factoryFunc) {
  const makesActivityWithImplicitSeedAndArgs = (arg) => {
    const seedActivity = new SeedActivity(host, factoryFunc, arg);
    return seedActivity;
  };
  return makesActivityWithImplicitSeedAndArgs;
}
function getSeed(arg) {
  if (arg.kind == "TxOutputId")
    return arg;
  if (arg instanceof StellarTxnContext) {
    const { txId, idx } = arg.getSeedUtxoDetails();
    return makeTxOutputId(txId, idx);
  }
  if (arg.idx && arg.txId) {
    const attr = arg;
    return makeTxOutputId(attr.txId, attr.idx);
  }
  const txoIdLike = arg;
  return makeTxOutputId(txoIdLike);
}

const rawDataBridgeProxy = new Proxy({}, {
  apply(_, THIS, [x]) {
    if (!THIS.isCallable)
      throw new Error(`dataBridge ${THIS.constructor.name} is not callable`);
    return THIS["\u1C7A\u1C7Acast"].toUplcData(x);
  }
});
function dataBridgeProxyBase() {
}
dataBridgeProxyBase.prototype = rawDataBridgeProxy;
class DataBridge extends dataBridgeProxyBase {
  "\u1C7A\u1C7Aschema";
  isActivity;
  isNested;
  // relaxed protected so that GenericDelegateBridge and specific bridges don't have to
  //   use an inheritance relationship.  Can add that kind of inheritance and make this protected again.
  "\u1C7A\u1C7Acast";
  isCallable = false;
  mkData = (x) => this["\u1C7A\u1C7Acast"].toUplcData(x);
  readData = (x) => this["\u1C7A\u1C7Acast"].fromUplcData(x);
  constructor(options = {}) {
    super();
    this["\u1C7A\u1C7Aschema"] = void 0;
    this["\u1C7A\u1C7Acast"] = void 0;
    const { isActivity, isNested } = options;
    this.isActivity = isActivity || false;
    this.isNested = isNested || false;
  }
  // 
  // declare activity: DataBridge | ((...args:any) => UplcData)
  // declare  datum: DataBridge | ((...args:any) => UplcData)
  // // get datum() {
  // //     throw new Error(`each dataBridge makes its own datum`)
  // // }
  getSeed(arg) {
    return getSeed(arg);
  }
  redirectTo;
  mkDataVia(redirectionCallback) {
    if (!this.isNested) {
      throw new Error(`dataMaker ${this.constructor.name}: redirectTo is only valid for nested enums`);
    }
    this.redirectTo = redirectionCallback;
  }
  get isEnum() {
    return "enum" === this["\u1C7A\u1C7Aschema"].kind;
  }
  getTypeSchema() {
    if (!this["\u1C7A\u1C7Aschema"]) {
      this["\u1C7A\u1C7Aschema"] = "placeholder";
      this["\u1C7A\u1C7Acast"] = makeCast(this["\u1C7A\u1C7Aschema"], {
        isMainnet: true,
        unwrapSingleFieldEnumVariants: true
      });
    }
    return this["\u1C7A\u1C7Aschema"];
  }
  // usesRedeemerWrapper : boolean = false
  // toUplc(x: any) {
  //     return this.ᱺᱺcast.toUplcData(x)
  // }
  // get __typeName() : string {
  //     return "someTypeName" // this.__typeDetails.dataType.name
  //     // //@ts-expect-error not all schemas have names
  //     // const {name=""} = this.ᱺᱺschema!
  //     // if (!name) {
  //     //     throw new Error(`can't get typeName for unnamed type: ${this.__schema!.kind}`)
  //     // }
  //     // return name
  // }
}
class ContractDataBridge {
  static isAbstract = true;
  isAbstract = true;
  constructor() {
  }
  readData(x) {
    if (!this.datum)
      throw new Error(`no datum on this dataBridge`);
    return this.datum.readData(x);
  }
}
class DataBridgeReaderClass {
}

var __defProp$6 = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorateClass$6 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$6(target, key, result);
  return result;
};
let configuredNetwork = void 0;
function isUplcData(x) {
  return "kind" in x && "toCbor" in x;
}
const Activity = {
  /**
   * Decorates a partial-transaction function that spends a contract-locked UTxO using a specific activity ("redeemer")
   * @remarks
   *
   * activity-linked transaction-partial functions must follow the txn\{...\}
   * and active-verb ("ing") naming conventions.  `txnRetiringDelegation`,
   * `txnModifyingVote` and `txnWithdrawingStake` would be examples
   * of function names following this guidance.
   *
   * @public
   **/
  partialTxn(proto, thingName, descriptor) {
    needsActiveVerb(thingName);
    return partialTxn(proto, thingName, descriptor);
  },
  /**
   * Decorates a factory-function for creating tagged redeemer data for a specific on-chain activity
   * @remarks
   *
   * The factory function should follow an active-verb convention by including "ing" in
   * the name of the factory function
   *
   * Its leading prefix should also match one of 'activity', 'burn', or 'mint'.  These
   * conventions don't affect the way the activity is verified on-chain, but they
   * provide guard-rails for naming consistency.
   * @public
   **/
  redeemer(proto, thingName, descriptor) {
    const isActivity = thingName.match(/^activity[A-Z]/);
    const isBurn = thingName.match(/^burn[A-Z]/);
    thingName.match(/^mint[A-Z]/);
    if (!isActivity && !isBurn) {
      throw new Error(
        `@Activity.redeemer: ${thingName}: name should start with '(activity|burn|mint)[A-Z]...'`
      );
    }
    needsActiveVerb(
      thingName,
      /* show workaround offer */
      true
    );
    return Activity.redeemerData(proto, thingName, descriptor);
  },
  redeemerData(proto, thingName, descriptor) {
    //!!! todo: registry and cross-checking for missing redeeming methods
    //!!! todo: develop more patterns of "redeemer uses an input of a certain mph/value"
    return descriptor;
  }
};
function needsActiveVerb(thingName, okWorkaround) {
  if (!thingName.match(/ing/)) {
    const orWorkaround = okWorkaround && "(or work around with @Activity.redeemerData instead)";
    throw new Error(
      `Activity: ${thingName}: name should have 'ing' in it ${orWorkaround}`
    );
  }
  if (thingName.match(/^ing/)) {
    throw new Error(
      `Activity: ${thingName}: name shouldn't start with 'ing'`
    );
  }
}
function datum(proto, thingName, descriptor) {
  if (!thingName.match(/^mkDatum/)) {
    throw new Error(
      `@datum factory: ${thingName}: name should start with 'mkDatum...'`
    );
  }
  return descriptor;
}
function txn(proto, thingName, descriptor) {
  if (!thingName.match(/^mkTxn/)) {
    throw new Error(
      `@txn factory: ${thingName}: name should start with 'mkTxn...'`
    );
  }
  return descriptor;
}
function partialTxn(proto, thingName, descriptor) {
  if (!thingName.match(/^txn[A-Z]/)) {
    let help = "";
    if (thingName.match(/^mkTxn/)) {
      help = `
  ... or, for transaction initiation with mkTxn, you might try @txn instead. `;
    }
    throw new Error(
      `@partialTxn factory: ${thingName}: should start with 'txn[A-Z]...'${help}`
    );
  }
  return descriptor;
}
async function findInputsInWallets(v, searchIn, network) {
  const { wallets, addresses } = searchIn;
  const lovelaceOnly = v.assets.isZero();
  console.warn("finding inputs", {
    lovelaceOnly
  });
  for (const w of wallets) {
    const [a] = await w.usedAddresses;
    console.log("finding funds in wallet", a.toString().substring(0, 18));
    const utxos = await w.utxos;
    for (const u of utxos) {
      if (lovelaceOnly) {
        if (u.value.assets.isZero() && u.value.lovelace >= v.lovelace) {
          return u;
        }
        console.log("  - too small; skipping ", u.value.dump());
      } else {
        if (u.value.isGreaterOrEqual(v)) {
          return u;
        }
      }
    }
  }
  if (lovelaceOnly) {
    throw new Error(
      `no ADA is present except those on token bundles.  TODO: findFreeLovelaceWithTokens`
    );
  }
  //!!! todo: allow getting free ada from a contract address?
  if (addresses) {
    for (const a of addresses) {
      const utxos = await network.getUtxos(a);
      for (const u of utxos) {
        if (u.value.isGreaterOrEqual(v)) {
          return u;
        }
      }
    }
  }
  throw new Error(
    `None of these wallets${addresses && " or addresses" || ""} have the needed tokens`
  );
}
const isInternalConstructor = Symbol("internalConstructor");
class StellarContract {
  //! it has scriptProgram: a parameterized instance of the contract
  //  ... with specific `parameters` assigned.
  // bundle?: HeliosScriptBundle;
  configIn;
  partialConfig;
  contractParams;
  setup;
  network;
  networkParams;
  actorContext;
  // isTest?: boolean
  static get defaultParams() {
    return {};
  }
  static parseConfig(rawJsonConfig) {
    throw new Error(
      `Stellar contract subclasses should define their own static parseConfig where needed to enable connection from a specific dApp to a specific Stellar Contract.`
    );
  }
  /** each StellarContracts subclass needs to provide a scriptBundle class.
   * @remarks
   * Your script bundle MUST be defined in a separate file using a convention of
   * `‹scriptName›.hlb.ts`, and exported as a default class.  It should inherit
   * from HeliosScriptBundle or one of its subclasses.  Stellar Contracts processes
   * this file, analyzes the on-chain types defined in your Helios sources, and generates
   * Typescript types and a data-bridging class for your script.
   *
   * Once the data-bridge class is generated, you should import it into your contract
   * module and assign it to your `dataBridgeClass` attribute.
   */
  scriptBundle() {
    throw new Error(
      `${this.constructor.name}: missing required implementation of scriptBundle()
...each Stellar Contract must provide a scriptBundle() method. 
It should return an instance of a class defined in a *.hlb.js file.  At minimum:

    export default class MyScriptBundle extends HeliosScriptBundle {

    }

We'll generate types for that .js file, based on the types in your Helios sources.
Your scriptBundle() method can \`return new MyScriptBundle();\``
    );
  }
  /**
   * the dataBridgeClass attribute MUST be defined for any bundle having a datum type
   *  - this is the bridge class for converting from off-chain data types to on-chain data
   *  - it provides convenient, type-safe interfaces for doing that
   *
   * @remarks
   * Minters don't have datum, so they don't need to define this attribute.  However,
   * note that ***mint delegates*** do in fact have datum types. If you are defining
   * a custom delegate of that kind, you will need to define this attribute.
   */
  dataBridgeClass = void 0;
  /**
   * The `onchain` object provides access to all bridging capabilities for this contract script.
   * @remarks
   * Its nested attributes include:
   *  - `types` - a collection of all the on-chain types defined in the script, with data-creation helpers for each
   *  - `activity` - a creation helper for the activities/redeemers defined in the script
   *
   * Scripts that use datum types (not including minters) will also have:
   *  - `datum` - a data-creation helper for the datum type of the script
   *  - `readDatum` - a data-reading helper for the datum type of the script
   *
   * ### Low-level type access
   * For low-level access (it's likely you don't need to use this) for on-chain types, the `reader` attribute (aka `offchain`) exists: .
   *  - `reader` - a collection of data-reading helpers for the on-chain types, given UPLC data known to be of that type
   */
  get onchain() {
    return this.getOnchainBridge();
  }
  /**
   * The `offchain` object provides access to readers for the on-chain types of this contract script.
   * @remarks
   * Its nested attributes include all the on-chain types defined in the script, with data-reading helpers for each.
   * This is useful for reading on-chain data in off-chain code.
   *
   * ### Warning: low-level typed-data access!
   *
   * Note that these readers will work properly with UPLC data known to be of the correct type.  If you
   * encounter errors related to these results, it's likely you are using the wrong reader for the data you
   * have in hand.
   *
   * For the typical use-case of reading the datum type from a UTxO held in the contract, this is not a problem,
   * and note that the `readDatum` helper provides a shortcut for this most-common use-case.
   *
   * If you're not sure what you're doing, it's likely that this is not the right tool for your job.
   */
  get offchain() {
    return this.getOnchainBridge().reader;
  }
  get reader() {
    return this.getOnchainBridge().reader;
  }
  get activity() {
    const bridge = this.onchain;
    return bridge.activity;
  }
  /**
   * Converts UPLC from an on-chain datum object to a typed off-chain datum object.
   *
   * Given a **utxo with a datum of the contract's datum type**, this method will convert the UPLC datum
   * to a typed off-chain datum object.
   *
   * ### Standard WARNING
   *
   * If the datum's structure is not of the expected type, this method MAY throw an error, or it might
   * return data that can cause problems somewhere else in your code.  That won't happen if you're
   * following the guidance above.
   */
  get newReadDatum() {
    const bridge = this.getOnchainBridge();
    const { readDatum } = bridge;
    if (!readDatum) {
      throw new Error(
        `${this.constructor.name}: this contract script doesn't use datum`
      );
    }
    return readDatum;
  }
  _bundle;
  getBundle() {
    if (!this._bundle) {
      this._bundle = this.scriptBundle();
    }
    return this._bundle;
  }
  /**
   * Provides access to the script's activities with type-safe structures needed by the validator script.
   *
   * @remarks - the **redeemer** data (needed by the contract script) is defined as one or
   * more activity-types (e.g. in a struct, or an enum as indicated in the type of the last argument to
   * the validator function).
   *   - See below for more about ***setup & type-generation*** if your editor doesn't  provide auto-complete for
   *    the activities.
   *
   * ### A terminology note: Activities and Redeemers
   *
   * Although the conventional terminology of "redeemer" is universally well-known
   * in the Cardano developer community, we find that defining one or more **activities**,
   * with their associated ***redeemer data***, provides an effective semantic model offering
   * better clarity and intution.
   *
   * Each type of contract activity corresponds to an enum variant in the contract script.
   * For each of those variants, its redeemer data contextualizes the behavior of the requested
   * transaction.  A non-enum redeemer-type implies that there is only one type of activity.
   *
   * Any data not present in the transaction inputs or outputs, but needed for
   * specificity of the requested activity, can only be provided through these activity details.
   * If that material is like a "claim ticket", it would match the "redeemer" type of labeling.
   *
   * Activity data can include any kinds of details needed by the validator: settings for what it
   * is doing, options for how it is being done, or what remaining information the validator may
   * need, to verify the task is being completed according to protocol.  Transactions containing
   * a variety of inputs and output, each potential candidates for an activity, can use the activity
   * details to resolve ambiguity so the validator easily acts on the correct items.
   *
   * ### Setup and Type generation
   * #### Step 1: create your script **`.hlb.ts`**
   * With a defined script bundle, `import YourScriptNameBundle from "./YourBundleName.hlb.js"`
   * to your StellarContracts class module, and define a `scriptBundle() { return new YourScriptNameBundle() }` or
   * similar method in that class.
   *
   * This results in a generated **`.typeInfo.ts`** and **`.bridge.ts`** with complete
   * typescript bindings for your on-chain script (trouble? check Plugin setup below).
   *
   * #### Step 2: Import the generated bridge class
   * Using the generated .bridge file:
   * > `import YourScriptNameDataBridge from "./YourBundleName.bridge.js"`
   *
   * ... and set the `dataBridgeClass` property in your class:
   *
   * >    `dataBridgeClass = YourScriptNameDataBridge`
   *
   * ### Plugin Setup
   *
   * The activity types should be available through type-safe auto-complete in your editor.  If not,
   * you may need to install and configure the Stellar Contracts rollup plugins for importing .hl
   * files and generating .d.ts for your .hlb.ts files.  See the Stellar Contracts development
   * guide for additional details.
   *
   */
  // get activity(): findActivityType<this> {
  //     const bridge = this.onchain;
  //     // each specific bridge has to have an activity type, but this code can't
  //     // introspect that type.  It could be a getter OR a method, and Typescript can only
  //     // be told it is one, or the other, concretely.
  //     // findActivityType() does probe for the specific type for specific contracts,
  //     // at the **interface** level, but this code has no visibility of that.
  //     //x@ts-expect-error accessing it in this way
  //     const { activity } = bridge
  //     return activity as any
  // }
  // /**
  //  * Redirect for intuitive developers having a 'redeemer' habit
  //  *
  //  * @deprecated - We recommend using `activity` instead of `redeemer`
  //  */
  // get redeemer(): findActivityType<this> {
  //     return this.activity;
  // }
  /**
   * Provides access to the script's defined on-chain types, using a fluent
   * API for type-safe generation of data conforming to on-chain data formats & types.
   * @remarks
   *
   */
  _dataBridge;
  // get mkDatum() : findDatumType<this> {
  //     //x@ts-expect-error probing for presence
  //     if (!this.onchain?.datum) throw new Error(`${this.constructor.name}: no datum is used on this type of script`);
  //     //@ts-expect-error probing for presence
  //     return this.onchain.datum;
  // }
  getOnchainBridge() {
    if ("undefined" == typeof this._dataBridge) {
      const { dataBridgeClass } = this;
      if (!dataBridgeClass) {
        if (this.usesContractScript) {
          throw new Error(
            `${this._bundle?.moduleName || this.constructor.name}: each contract script needs a dataBridgeClass = dataBridge\u2039YourScriptName\u203A
  ... this dataBridge class is generated by heliosRollupTypeGen 
  ... and imported (\`import dataBridge\u2039something\u203A from "./\u2039yourScriptName\u203A.bridge.js"\`)
      This critical class converts between off-chain and on-chain typed data

Note: if you haven't customized the mint AND spend delegates for your Capo, 
  ... you might want to define both of those roles using a single 
  ... subclass of the BasicMintDelegate. That fixes the most common 
  ... first-time setup problems of this kind.`
          );
        } else {
          console.log(
            `${this.constructor.name} dataBridgeClass = NONE`
          );
          this._dataBridge = void 0;
          return null;
        }
      }
      const datumType = this.getBundle().locateDatumType();
      try {
        this._dataBridge = new dataBridgeClass(
          this.getBundle()
        );
      } catch (e) {
        console.error(e);
        debugger;
      }
      if (datumType) {
        console.log(
          `${this.constructor.name} dataBridgeClass = `,
          dataBridgeClass.name
        );
        if (!this._dataBridge.datum) {
          console.warn(
            `${this.constructor.name}: dataBridgeClass must define a datum accessor.  This is likely a code-generation problem.`
          );
        }
      }
      if (!this._dataBridge.activity) {
        console.warn(
          `${this.constructor.name}: dataBridgeClass must define an activity accessor.  This is likely a code-generation problem.`
        );
      }
      return this._dataBridge;
    }
    if (!this._dataBridge) {
      throw new Error(
        `${this.constructor.name}: this contract script doesn't have a dataBridgeClass defined`
      );
    }
    return this._dataBridge;
  }
  ADA(n) {
    const bn = "number" == typeof n ? BigInt(Math.round(1e6 * n)) : BigInt(1e6) * n;
    return bn;
  }
  get isConnected() {
    return !!this.wallet;
  }
  /**
   * returns the wallet connection used by the current actor
   * @remarks
   *
   * Throws an error if the strella contract facade has not been initialized with a wallet in settings.actorContext
   * @public
   **/
  get wallet() {
    if (!this.actorContext.wallet)
      throw new Error(this.missingActorError);
    return this.actorContext.wallet;
  }
  get missingActorError() {
    return `Wallet not connected to Stellar Contract '${this.constructor.name}'`;
  }
  //! can transform input configuration to contract script params
  //! by default, all the config keys are used as script params
  getContractScriptParamsUplc(config) {
    throw new Error(
      `${this.constructor.name} must implement getContractScriptParamsUplc`
    );
  }
  delegateReqdAddress() {
    return this.address;
  }
  delegateAddrHint() {
    return void 0;
  }
  walletNetworkCheck;
  /**
   * Factory function for a configured instance of the contract
   * @remarks
   *
   * Due to boring details of initialization order, this factory function is needed
   * for creating a new instance of the contract.
   * @param args - setup and configuration details
   * @public
   **/
  static async createWith(args) {
    const Class = this;
    const { setup, config, partialConfig } = args;
    const c = new Class(setup, isInternalConstructor);
    return c.init(args);
  }
  /**
   * obsolete public constructor.  Use the createWith() factory function instead.
   *
   * @public
   **/
  constructor(setup, internal) {
    this.setup = setup;
    this._utxoHelper = new UtxoHelper(this.setup, this);
    if (internal !== isInternalConstructor) {
      throw new Error(
        `StellarContract: use createWith() factory function`
      );
    }
    const { network, networkParams, isTest, isMainnet, actorContext } = setup;
    this.actorContext = actorContext;
    this.network = network;
    this.networkParams = networkParams;
  }
  async init(args) {
    const { isMainnet, actorContext } = this.setup;
    const chosenNetwork = isMainnet ? "mainnet" : "testnet";
    if ("undefined" !== typeof configuredNetwork) {
      if (configuredNetwork != chosenNetwork) {
        console.warn(
          `Possible CONFLICT:  previously configured as ${configuredNetwork}, while this setup indicates ${chosenNetwork}
   ... are you or the user switching between networks?`
        );
      }
    }
    configuredNetwork = chosenNetwork;
    if (actorContext.wallet) {
      const isMain = await actorContext.wallet.isMainnet();
      const foundNetwork = isMain ? "mainnet" : "testnet";
      if (foundNetwork !== chosenNetwork) {
        throw new Error(
          `wallet on ${foundNetwork} doesn't match network from setup`
        );
      }
      this.actorContext = actorContext;
    }
    const { config, partialConfig } = args;
    if (config) {
      this.configIn = config;
      debugger;
      this.contractParams = this.getContractScriptParamsUplc(config);
      await this.compileWithScriptParams();
    } else {
      debugger;
      this.partialConfig = partialConfig;
    }
    if (this.usesContractScript) {
      if (!this.getBundle()) {
        throw new Error(
          `${this.constructor.name}: missing required this.bundle for contract class`
        );
      } else if (!this.getBundle().isHeliosScriptBundle()) {
        throw new Error(
          `${this.constructor.name}: this.bundle must be a HeliosScriptBundle; got ${this.getBundle().constructor.name}`
        );
      } else {
        console.log(this.program.name, "bundle loaded");
      }
    }
    return this;
  }
  compiledScript;
  // initialized in loadProgramScript
  usesContractScript = true;
  get datumType() {
    return this.onChainDatumType;
  }
  /**
   * @internal
   **/
  get purpose() {
    const purpose = this.program.purpose;
    if (!purpose)
      return "non-script";
    return purpose;
  }
  get validatorHash() {
    const { vh } = this._cache;
    if (vh)
      return vh;
    const nvh = this.compiledScript.hash();
    return this._cache.vh = makeValidatorHash(nvh);
  }
  //  todo: stakingAddress?: Address or credential or whatever;
  get address() {
    const { addr } = this._cache;
    if (addr)
      return addr;
    console.log(this.constructor.name, "caching addr");
    console.log(
      "TODO TODO TODO - ensure each contract can indicate the right stake part of its address"
    );
    console.log("and that the onchain part also supports it");
    const nAddr = makeAddress(
      this.setup.isMainnet || false,
      this.validatorHash
    );
    return this._cache.addr = nAddr;
  }
  get mintingPolicyHash() {
    if ("minting" != this.purpose)
      return void 0;
    const { mph } = this._cache;
    if (mph)
      return mph;
    const nMph = makeMintingPolicyHash(this.compiledScript.hash());
    return this._cache.mph = nMph;
  }
  get identity() {
    const { identity } = this._cache;
    if (identity)
      return identity;
    console.log(this.constructor.name, "identity", identity || "none");
    let result;
    if ("minting" == this.purpose) {
      const b32 = this.mintingPolicyHash.toString();
      //!!! todo: verify bech32 checksum isn't messed up by this:
      result = b32.replace(/^asset/, "mph");
    } else {
      result = this.address.toString();
    }
    return this._cache.identity = result;
  }
  //! searches the network for utxos stored in the contract,
  //  returning those whose datum hash is the same as the input datum
  async outputsSentToDatum(datum2) {
    await this.network.getUtxos(this.address);
    throw new Error(`unused`);
  }
  // non-activity partial
  txnKeepValue(tcx, value, datum2) {
    tcx.addOutput(makeTxOutput(this.address, value, datum2));
    return tcx;
  }
  async addStrellaWithConfig(TargetClass, config) {
    const args = {
      config,
      setup: this.setup
    };
    const strella = await TargetClass.createWith(args);
    return strella;
  }
  // async findDatum(d: Datum | DatumHash): Promise<TxInput[]>;
  // async findDatum(predicate: utxoPredicate): Promise<TxInput[]>;
  // async findDatum(d: Datum | DatumHash | utxoPredicate): Promise<TxInput[]> {
  //     let targetHash: DatumHash | undefined =
  //         d instanceof Datum
  //             ? d.hash
  //             : d instanceof DatumHash
  //             ? d
  //             : undefined;
  //     let predicate =
  //         "function" === typeof d
  //             ? d
  //             : (u: TxInput) => {
  //                   const match =
  //                       u.origOutput?.datum?.hash.hex == targetHash?.hex;
  //                   console.log(
  //                       txOutputAsString(
  //                           u.origOutput,
  //                           `    ${match ? "✅ matched " : "❌ no match"}`
  //                       )
  //                   );
  //                   return !!match;
  //               };
  //     //prettier-ignore
  //     console.log(
  //         `finding utxo with datum ${
  //             targetHash?.hex.substring(0,12)
  //         }... in wallet`,
  //         this.address.toBech32().substring(0,18)
  //     );
  //     const heldUtxos = await this.network.getUtxos(this.address);
  //     console.log(`    - found ${heldUtxos.length} utxo:`);
  //     return heldUtxos.filter(predicate);
  // }
  /**
   * Returns all the types exposed by the contract script
   * @remarks
   *
   * Passed directly from Helios; property names match contract's defined type names
   *
   * @public
   **/
  get onChainTypes() {
    const scriptNamespace = this.program.name;
    return this.program.userTypes[scriptNamespace];
  }
  /**
   * identifies the enum used for the script Datum
   * @remarks
   *
   * Override this if your contract script uses a type name other than Datum.
   * @public
   **/
  get scriptDatumName() {
    return "Datum";
  }
  /**
   * The on-chain type for datum
   * @remarks
   *
   * This getter provides a class, representing the on-chain enum used for attaching
   * data (or data hashes) to contract utxos the returned type (and its enum variants)
   * are suitable for off-chain txn-creation override `get scriptDatumName()` if
   * needed to match your contract script.
   * @public
   **/
  get onChainDatumType() {
    return this.getBundle().locateDatumType();
  }
  /**
   * identifies the enum used for activities (redeemers) in the Helios script
   * @remarks
   *
   * Override this if your contract script uses a type name other than Activity.
   * @public
   **/
  get scriptActivitiesName() {
    return "Activity";
  }
  getSeed(arg) {
    return getSeed(arg);
  }
  /**
   * returns the on-chain type for activities ("redeemers")
   * @remarks
   *
   * Use mustGetActivityName() instead, to get the type for a specific activity.
   *
   * returns the on-chain enum used for spending contract utxos or for different use-cases of minting (in a minting script).
   * the returned type (and its enum variants) are suitable for off-chain txn-creation
   * override `get onChainActivitiesName()` if needed to match your contract script.
   * @public
   **/
  get onChainActivitiesType() {
    const { scriptActivitiesName: onChainActivitiesName } = this;
    if (!this._bundle)
      throw new Error(`no scriptProgram`);
    const scriptNamespace = this.program.name;
    const {
      [scriptNamespace]: { [onChainActivitiesName]: ActivitiesType }
    } = this.program.userTypes;
    return ActivitiesType;
  }
  /**
   * @deprecated - see {@link StellarContract.activityVariantToUplc|this.activityVariantToUplc(variant, data)} instead
   * Retrieves an on-chain type for a specific named activity ("redeemer")
   * @remarks
   *
   * Cross-checks the requested name against the available activities in the script.
   * Throws a helpful error if the requested activity name isn't present.'
   *
   * @param activityName - the name of the requested activity
   * @public
   **/
  mustGetActivity(activityName) {
    const ocat = this.onChainActivitiesType;
    return this.mustGetEnumVariant(ocat, activityName);
  }
  /**
   * asserts the presence of the indicated activity name in the on-chain script
   * @remarks
   * The activity name is expected to be found in the script's redeemer enum
   */
  mustHaveActivity(activityName) {
    const ocat = this.onChainActivitiesType;
    if (!(activityName in ocat.typeMembers)) {
      throw new Error(
        `${this.constructor.name}: missing required on-chain activity: ${activityName}`
      );
    }
    return this.mustGetEnumVariant(ocat, activityName);
  }
  activityRedeemer(activityName, data) {
    const activities = this.onChainActivitiesType;
    return {
      redeemer: this.typeToUplc(activities, {
        [activityName]: data
      })
    };
  }
  activityVariantToUplc(activityName, data) {
    const activities = this.onChainActivitiesType;
    return this.typeToUplc(activities, {
      [activityName]: data
    });
  }
  mustGetEnumVariant(enumType, variantName) {
    const { [variantName]: variantType } = enumType.typeMembers;
    if (!variantType) {
      const variantNames = [];
      for (const [name, _] of Object.entries(enumType.typeMembers)) {
        debugger;
        if (isUplcData(enumType[name].prototype)) {
          console.warn(
            "\n".repeat(8) + "------------------------ check enum variant name",
            name
          );
          debugger;
          variantNames.push(name);
        } else {
          debugger;
          throw new Error(
            "variant names only available via HeliosData : ("
          );
        }
      }
      debugger;
      //!!! TODO
      throw new Error(
        `$${this.constructor.name}: activity/enum-variant name mismatch in ${enumType.name}: variant '${variantName}' unknown
 ... variants in this enum: ${variantNames.join(", ")}`
      );
    }
    return variantType.asEnumMemberType;
  }
  inlineDatum(datumName, data) {
    return makeInlineTxOutputDatum(
      this.typeToUplc(this.onChainDatumType, {
        [datumName]: data
      })
    );
  }
  typeToUplc(type, data, path = "") {
    const schema = type.toSchema();
    const cast = makeCast(schema, {
      isMainnet: this.setup.isMainnet || false,
      unwrapSingleFieldEnumVariants: true
    });
    return cast.toUplcData(data, path);
  }
  paramsToUplc(params) {
    const namespace = this.program.name;
    const { paramTypes } = this.program;
    return Object.fromEntries(
      Object.entries(params).map(([paramName, data]) => {
        const fullName = `${namespace}::${paramName}`;
        const thatType = paramTypes[fullName];
        if (!thatType) {
          const availableParams = Object.entries(
            paramTypes
          ).reduce((acc, [k, v]) => {
            const [ns, name] = k.split("::");
            if (!acc[ns])
              acc[ns] = [];
            acc[ns].push(name);
            return acc;
          }, {});
          const availableScriptParams = Object.entries(
            availableParams
          ).map(
            ([ns, names]) => `  ${ns}::{${names.join(", ")}}`
          ).join("\n");
          if (paramName == "0") {
            throw new Error(
              `numeric param name is probably wrong`
            );
          }
          if (paramName = "addrHint") {
            return void 0;
          }
          throw new Error(
            `invalid script-parameter '${paramName}' in namespace '${namespace}' 
  ... expected one of: ${availableScriptParams}`
          );
        }
        return [
          fullName,
          this.typeToUplc(thatType, data, `params[${fullName}]`)
        ];
      }).filter((x) => !!x)
    );
  }
  get program() {
    if (this._cache.program)
      return this._cache.program;
    const program = this.getBundle().program;
    return this._cache.program = program;
  }
  // async readDatum<
  //     DPROPS extends anyDatumProps,
  //     adapterType extends DatumAdapter<DPROPS, any> | undefined = undefined
  // >(
  //     datumNameOrAdapter: string | adapterType,
  //     datum: InlineDatum,
  //     ignoreOtherTypes?: "ignoreOtherTypes"
  // ): Promise<
  //     | (adapterType extends DatumAdapter<any, any> ? adapterType : DPROPS)
  //     | undefined
  // > {
  //     throw new Error(`obsolete?`);
  //     const ts1 = Date.now();
  //     const hasAdapter = datumNameOrAdapter instanceof DatumAdapter;
  //     const datumName: string = hasAdapter
  //         ? datumNameOrAdapter.datumName
  //         : (datumNameOrAdapter as string);
  //     const scriptDatumType = this.onChainDatumType;
  //     const thisDatumType = scriptDatumType.typeMembers[datumName];
  //     if (!thisDatumType) throw new Error(`invalid datumName ${datumName}`);
  //     const cast = new Cast(scriptDatumType.toSchema(), {
  //         isMainnet: this.setup.isMainnet || false,
  //     });
  //     const parsedData = (cast.fromUplcData(datum.data) as any)[
  //         datumName
  //     ] as DPROPS;
  //     const ts2 = Date.now();
  //     // throw new Error(`todo: parse some datum here`);
  //     // // console.log(` ----- read datum ${datumName}`)
  //     // if (!datum.isInline())
  //     //     throw new Error(
  //     //         `datum must be an InlineDatum to be readable using readDatum()`
  //     //     );
  //     // let ts2;
  //     // const rawParsedData = (await this.readUplcDatum(
  //     //     thisDatumType,
  //     //     datum.data!,
  //     //     ignoreOtherTypes
  //     // )
  //     //     .catch((e) => {
  //     //         if (e.message?.match(/expected constrData/)) return undefined;
  //     //         throw e;
  //     //     })
  //     //     .finally(() => {
  //     //         ts2 = Date.now();
  //     //         const elapsed = ts2 - ts1;
  //     //         if (elapsed > 10) {
  //     //             console.log(
  //     //                 `    -- readUplcDatum ${datumName} took ${ts2 - ts1}ms`
  //     //             );
  //     //         }
  //     //     })) as DPROPS | undefined;
  //     // if (!rawParsedData) return undefined;
  //     if (hasAdapter) {
  //         debugger; // ??? vvv
  //         const adapted = datumNameOrAdapter.fromOnchainDatum(parsedData);
  //         const ts3 = Date.now();
  //         const elapsed = ts3 - ts1;
  //         if (elapsed > 10) {
  //             console.log(`    -- adapter ${datumName} took ${ts3 - ts2}ms`);
  //             console.log(
  //                 `  ⏱ readDatum ${datumName} took ${ts3 - ts1}ms total`
  //             );
  //         }
  //         console.log(
  //             JSON.parse(JSON.stringify(adapted, betterJsonSerializer, 2))
  //         );
  //         return adapted;
  //     }
  //     return parsedData as any;
  // }
  // private async readUplcStructList(uplcType: any, uplcData: ListData) {
  //     const { fieldNames, instanceMembers } = uplcType as any;
  //     if (uplcType.fieldNames?.length == 1) {
  //         const fn = fieldNames[0];
  //         const singleFieldStruct = {
  //             [fn]: await this.readUplcField(
  //                 fn,
  //                 instanceMembers[fn],
  //                 uplcData
  //             ),
  //         };
  //         return singleFieldStruct;
  //     }
  //     const nestedFieldList = uplcData.list;
  //     return Object.fromEntries(
  //         await Promise.all(
  //             fieldNames.map(async (fn: string, i: number) => {
  //                 const fieldData = nestedFieldList[i];
  //                 const fieldType = instanceMembers[fn];
  //                 // console.log(` ----- read struct field ${fn}`)
  //                 const value = await this.readUplcField(
  //                     fn,
  //                     fieldType,
  //                     fieldData
  //                 );
  //                 // console.log(` <----- struct field ${fn}`, value);
  //                 return [fn, value];
  //             })
  //         )
  //     );
  // }
  // private async readUplcEnumVariant(
  //     uplcType: any,
  //     enumDataDef: any,
  //     uplcData: ConstrData & UplcData
  // ) {
  //     const fieldNames: string[] = enumDataDef.fieldNames;
  //     const { fields } = uplcData;
  //     return Object.fromEntries(
  //         await Promise.all(
  //             fieldNames.map(async (fn, i) => {
  //                 const fieldData = fields[i];
  //                 const fieldType = enumDataDef.fields[i].type;
  //                 const value = await this.readUplcField(
  //                     fn,
  //                     fieldType,
  //                     fieldData
  //                 ).catch((nestedError) => {
  //                     console.warn(
  //                         "error parsing nested data inside enum variant",
  //                         { fn, fieldType, fieldData }
  //                     );
  //                     debugger;
  //                     throw nestedError;
  //                 });
  //                 return [fn, value];
  //             })
  //         )
  //     );
  // }
  // private async readUplcDatum(
  //     uplcType: any,
  //     uplcData: UplcData,
  //     ignoreOther?: "ignoreOtherTypes"
  // ) {
  //     const { fieldNames, instanceMembers } = uplcType as any;
  //     if (!fieldNames) {
  //         const enumVariant = uplcType.prototype._enumVariantStatement;
  //         if (enumVariant) {
  //             //@ts-expect-error because TS doesn't grok ConstrData here
  //             const foundIndex = uplcData.index;
  //             const { dataDefinition: enumDataDef, constrIndex } =
  //                 enumVariant;
  //             if (!(uplcData instanceof ConstrData)) {
  //                 throw new Error(
  //                     `uplcData mismatch - no constrData, expected constData#${constrIndex}`
  //                 );
  //             }
  //             if (!(foundIndex == constrIndex)) {
  //                 if (ignoreOther) return undefined;
  //                 throw new Error(
  //                     `uplcData expected constrData#${constrIndex}, got #${foundIndex}`
  //                 );
  //             }
  //             const t = this.readUplcEnumVariant(
  //                 uplcType,
  //                 enumDataDef,
  //                 uplcData
  //             );
  //             return t; // caller can deal with catching the error
  //         }
  //         throw new Error(
  //             `can't determine how to parse UplcDatum without 'fieldNames'.  Tried enum`
  //         );
  //     }
  //     // const heliosTypes = Object.fromEntries(
  //     //     fieldNames.map((fn) => {
  //     //         return [fn, instanceMembers[fn].name];
  //     //     })
  //     // );
  //     // const inputTypes = Object.fromEntries(
  //     //     fieldNames.map((fn) => {
  //     //         return [fn, instanceMembers[fn].typeDetails.inputType];
  //     //     })
  //     // );
  //     // const outputTypes = Object.fromEntries(
  //     //     fieldNames.map((fn) => {
  //     //         debugger
  //     //         return [fn, instanceMembers[fn].typeDetails.outputType];
  //     //     })
  //     // );
  //     return Object.fromEntries(
  //         await Promise.all(
  //             fieldNames.map(async (fn, i) => {
  //                 let current;
  //                 //@ts-expect-error
  //                 const uplcDataField = uplcData.fields[i];
  //                 const fieldType = instanceMembers[fn];
  //                 // console.log(` ----- read field ${fn}`)
  //                 current = await this.readUplcField(
  //                     fn,
  //                     fieldType,
  //                     uplcDataField
  //                 );
  //                 return [fn, current];
  //             })
  //         )
  //     );
  // }
  // async readTypedUplcMapData(fn: string, uplcMap, valueType) {
  //     const t = Object.fromEntries(
  //         await Promise.all(
  //             uplcMap.map.map(async ([keyThingy, vThingy]) => {
  //                 // const key = keyThingy.string;
  //                 const key = helios.bytesToText(keyThingy.bytes);
  //                 return [
  //                     key,
  //                     await this.readUplcField(
  //                         `${fn}.[${key}]`,
  //                         valueType,
  //                         vThingy
  //                     ),
  //                 ];
  //             })
  //         )
  //     );
  //     // if (uplcMap.map.length > 0) debugger
  //     return t;
  // }
  // private async readUplcField(
  //     fn: string,
  //     fieldType: any,
  //     uplcDataField: any
  // ) {
  //     let value;
  //     const { offChainType } = fieldType;
  //     const isMapData = uplcDataField instanceof helios.MapData;
  //     try {
  //         let internalType;
  //         try {
  //             internalType = fieldType.typeDetails?.internalType.type;
  //             if ("Struct" == internalType) {
  //                 if (isMapData) {
  //                     value = await this.readOtherUplcType(
  //                         fn,
  //                         uplcDataField,
  //                         fieldType
  //                     );
  //                     return value;
  //                 } else {
  //                     value = await this.readUplcStructList(
  //                         fieldType,
  //                         uplcDataField
  //                     );
  //                     // console.log(`  <-- field value`, value)
  //                     return value;
  //                 }
  //             }
  //         } catch (e) {}
  //         value = fieldType.uplcToJs(uplcDataField);
  //         if (value.then) value = await value;
  //         if (internalType) {
  //             if (
  //                 "Enum" === internalType &&
  //                 0 === uplcDataField.fields.length
  //             ) {
  //                 return (value = Object.keys(value)[0]);
  //             }
  //         } else if (typeof value === "string") {
  //             return value;
  //         } else {
  //             console.log(
  //                 "no internal type for special post-uplc-to-JS handling at",
  //                 fn
  //             );
  //             debugger;
  //             return value;
  //         }
  //     } catch (e: any) {
  //         if (e.message?.match(/doesn't support converting from Uplc/)) {
  //             if (!offChainType) {
  //                 return this.readOtherUplcType(fn, uplcDataField, fieldType);
  //             }
  //             try {
  //                 value = await offChainType.fromUplcData(uplcDataField);
  //                 if (value && "some" in value) value = value.some;
  //                 if (value && "string" in value) value = value.string;
  //                 if (isMapData) {
  //                     const { valueType } =
  //                         fieldType.typeDetails.internalType;
  //                     // Map[String]SomethingSpecific?
  //                     return this.readTypedUplcMapData(
  //                         fn,
  //                         uplcDataField,
  //                         fieldType.instanceMembers.head_value
  //                     );
  //                 }
  //             } catch (e: any) {
  //                 console.error(`datum: field ${fn}: ${e.message}`);
  //                 // console.log({outputTypes, fieldNames, offChainTypes, inputTypes, heliosTypes, thisDatumType});
  //                 debugger;
  //                 throw e;
  //             }
  //         } else {
  //             throw e;
  //         }
  //     }
  //     // console.log(`  <-- field value`, value)
  //     return value;
  // }
  // async readOtherUplcType(fn: string, uplcDataField: any, fieldType: any) {
  //     if (uplcDataField instanceof helios.IntData) {
  //         return uplcDataField.value;
  //     }
  //     if (uplcDataField instanceof helios.ListData) {
  //         const entries = [];
  //         const promises = uplcDataField.list.map((item, i) => {
  //             const readOne = this.readOtherUplcType(
  //                 `${fn}.[${i}]`,
  //                 item,
  //                 undefined
  //             );
  //             return readOne;
  //         });
  //         const gotList = Promise.all(promises).catch((e) => {
  //             console.error(
  //                 `datum: field ${fn}: error reading list`,
  //                 e,
  //                 "\n   ",
  //                 { uplcDataField, fieldType }
  //             );
  //             debugger;
  //             throw e;
  //         });
  //         return gotList;
  //     }
  //     if (uplcDataField instanceof helios.IntData) {
  //         return uplcDataField.value;
  //     }
  //     if (uplcDataField instanceof helios.ByteArrayData) {
  //         return uplcDataField.bytes;
  //     }
  //     // it unwraps an existential type tag (#242) providing CIP-68 struct compatibility,
  //     // to return the inner details' key/value pairs as a JS object.
  //     if (uplcDataField instanceof helios.ConstrData) {
  //         //@ts-expect-error
  //         const { index } = uplcDataField;
  //         let fieldName = `‹constr#${index}›`;
  //         if (index == 242) {
  //             fieldName = "‹cip68›";
  //             if (
  //                 // prettier-ignore
  //                 //@ts-expect-error
  //                 (uplcDataField.fields.length != 1 || uplcDataField.fields.length != 3) &&
  //                 !(uplcDataField.fields[0] instanceof helios.MapData
  //             )
  //             ) {
  //                 console.log(
  //                     "CIP68 wrapper: expected MapData, got ",
  //                     uplcDataField
  //                 );
  //                 debugger;
  //                 throw new Error(
  //                     `datum error at ${fn} existential ConstrData(#242) must wrap a single field of MapData, or a triplet with Map, Version, Any`
  //                 );
  //             }
  //         }
  //         if (!uplcDataField.fields.length) {
  //             // console.log(`datum: field ${fn}: empty ConstrData`, {
  //             //     fieldType,
  //             //     uplcDataField,
  //             // });
  //             // enum variant without any nested data.  That's ok!!!
  //             return uplcDataField; // return `variant #${index}`;
  //         }
  //         return this.readOtherUplcType(
  //             `${fn}.${fieldName}`,
  //             uplcDataField.fields[0],
  //             undefined
  //         );
  //     }
  //     if (uplcDataField instanceof helios.MapData) {
  //         const entries: Record<string, any> = {};
  //         for (const [k, v] of uplcDataField["map"]) {
  //             let parsedKey: string;
  //             try {
  //                 parsedKey = helios.bytesToText(k.bytes);
  //             } catch (e) {
  //                 parsedKey = k.hex;
  //             }
  //             // type of value??
  //             entries[parsedKey] = await this.readOtherUplcType(
  //                 `${fn}.‹map›@${parsedKey}`,
  //                 v,
  //                 undefined
  //             );
  //         }
  //         return entries;
  //     }
  //     console.log(`datum: field ${fn}: no offChainType, no internalType`, {
  //         fieldType,
  //         uplcDataField,
  //     });
  //     debugger;
  //     return uplcDataField;
  // }
  _utxoHelper;
  /**
   * Provides access to a UtxoHelper instance
   */
  get utxoHelper() {
    return this._utxoHelper;
  }
  /**
   * Provides access to a UtxoHelper instance
   * @remarks - same as utxoHelper, but with a shorter name
   */
  get uh() {
    return this._utxoHelper;
  }
  /**
   * @deprecated - use `tcx.submit()` instead.
   */
  async submit(tcx, {
    signers = [],
    addlTxInfo = {
      description: tcx.txnName ? ": " + tcx.txnName : ""
    }
  } = {}) {
    console.warn("deprecated: use tcx.submit() instead");
    return tcx.submit({ signers, addlTxInfo });
  }
  //!!! todo: implement more and/or test me:
  // async findFreeLovelaceWithTokens(v: Value, w: Wallet) {
  // it.todo("helps find spare lovelace in tokens");
  // it.todo("will help harvest spare lovelace in the future if minUtxo is changed");
  //     const utxos = await w.utxos;
  //     const lovelaceOnly = v.assets.isZero();
  //     //! it finds free lovelace in token bundles, if it can't find free lovelace otherwise
  //     if (lovelaceOnly) {
  //         let maxFree: TxInput, minToken: TxInput;
  //         let minPolicyCount = Infinity;
  //         for (const u of utxos) {
  //             const policies = u.value.assets.mintingPolicies.length;
  //             if (policies < minPolicyCount) {
  //                 minPolicyCount = policies;
  //                 minToken = u;
  //             }
  //             const free =
  //                 u.value.lovelace -
  //                 u.origOutput.calcMinLovelace(this.networkParams);
  //             //@ts-ignore
  //             if (!maxFree) {
  //                 maxFree = u;
  //             } else if (free > maxFree!.value.lovelace) {
  //                 maxFree = u;
  //             }
  //         }
  //     }
  // }
  _cache = {};
  optimize = true;
  async compileWithScriptParams() {
    if (this.compiledScript) {
      console.warn(
        "compileWithScriptParams() called after script compilation already done"
      );
      debugger;
    }
    if (!this.usesContractScript)
      return;
    if (!this.contractParams) {
      throw new Error(`contractParams not set`);
    }
    const bundle = this.getBundle();
    this.compiledScript = await bundle.compiledScript(this.contractParams);
    console.log(`       \u2705 ${this.constructor.name} ready`);
    this._cache = {};
  }
  async mustFindMyUtxo(semanticName, predicate, hintOrExcept, hint) {
    const { address } = this;
    const isTcx = hintOrExcept instanceof StellarTxnContext;
    const exceptInTcx = isTcx ? hintOrExcept : void 0;
    const extraErrorHint = isTcx ? hint : "string" == typeof hintOrExcept ? hintOrExcept : void 0;
    return this.utxoHelper.mustFindUtxo(
      semanticName,
      predicate,
      { address, exceptInTcx },
      extraErrorHint
    );
  }
  mkTcx(tcxOrName, name) {
    const tcx = tcxOrName instanceof StellarTxnContext ? tcxOrName : new StellarTxnContext(this.setup).withName(name || "");
    const effectiveName = tcxOrName instanceof StellarTxnContext ? name : tcxOrName;
    if (effectiveName && !tcx.txnName)
      return tcx.withName(effectiveName);
    return tcx;
  }
  /**
   * Finds a free seed-utxo from the user wallet, and adds it to the transaction
   * @remarks
   *
   * Accepts a transaction context that may already have a seed.  Returns a typed
   * tcx with hasSeedUtxo type.
   *
   * The seedUtxo will be consumed in the transaction, so it can never be used
   * again; its value will be returned to the user wallet.
   *
   * The seedUtxo is needed for UUT minting, and the transaction is typed with
   * the presence of that seed (found in tcx.state.seedUtxo).
   *
   * If a seedUtxo is already present in the transaction context, no additional seedUtxo
   * will be added.
   *
   * If a seedUtxo is provided as an argument, that utxo must already be present
   * in the transaction inputs; the state will be updated to reference it.
   *
   * @public
   *
   **/
  async tcxWithSeedUtxo(tcx = new StellarTxnContext(this.setup), seedUtxo) {
    if (
      //prettier-ignore
      //@ts-expect-error on this type probe
      tcx.state && tcx.state.seedUtxo
    ) {
      return tcx;
    }
    if (seedUtxo) {
      let tcx2 = tcx;
      if (!tcx.inputs.find((utxo) => utxo.isEqual(seedUtxo))) {
        tcx2 = tcx2.addInput(seedUtxo);
      }
      tcx2.state.seedUtxo = seedUtxo;
      return tcx2;
    } else {
      const newSeedUtxo = await this.findUutSeedUtxo([], tcx);
      const tcx2 = tcx.addInput(newSeedUtxo);
      tcx2.state.seedUtxo = newSeedUtxo;
      return tcx2;
    }
  }
  async findUutSeedUtxo(uutPurposes, tcx) {
    //!!! make it big enough to serve minUtxo for the new UUT(s)
    const uh = this.utxoHelper;
    const uutSeed = uh.mkValuePredicate(BigInt(42e6), tcx);
    return uh.mustFindActorUtxo(
      `seed-for-uut ${uutPurposes.join("+")}`,
      uutSeed,
      tcx
    );
  }
}
__decorateClass$6([
  partialTxn
], StellarContract.prototype, "txnKeepValue", 1);

function mkUutValuesEntries(uuts) {
  const uutNs = Array.isArray(uuts) ? uuts : Object.values(uuts);
  const uniqs = [];
  for (const un of uutNs) {
    if (!uniqs.includes(un))
      uniqs.push(un);
  }
  return uniqs.map((uut) => mkValuesEntry(uut.name, BigInt(1)));
}
function mkValuesEntry(tokenName, count) {
  const tnBytes = Array.isArray(tokenName) ? tokenName : encodeUtf8(tokenName);
  return [tnBytes, count];
}
function mkTv(mph, tokenName, count = 1n) {
  const v = makeValue(
    0,
    makeAssets([[mph, [mkValuesEntry(tokenName, count)]]])
  );
  return v;
}

const heliosModule$4 = {
  content: "spending BasicDelegate\n\nconst rev : Int = 1\nconst instance : ByteArray = #67656e6572616c // -> \"general\"\nconst delegateName : String // = \"💩  noName Delegate : ( \"\nconst isMintDelegate : Bool = false\nconst isSpendDelegate : Bool = false\nconst isDgDataPolicy : Bool = false\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash\n} from ScriptContext\n\nimport {\n    DelegateRole,\n    DelegationDetail,\n    DgTknDisposition as DgTkn,\n    ManifestActivity,\n    PendingCharterChange,\n    PendingDelegateChange,\n    PendingDelegateAction,\n    RelativeDelegateLink\n} from CapoDelegateHelpers\n\n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nimport {\n    getTxCharterData,\n    mkCapoCtx,\n    CapoCtx,\n    mkTokenShow,\n    CapoDatum,\n    CapoManifestEntry,\n    ManifestEntryType\n    // CapoActivity\n} from CapoHelpers\n\nimport {\n    mkUutTnFactory,\n    validateUutMinting\n} from CapoMintHelpers\n\nimport {\n    fromCip68Wrapper,\n    outputAndDatum,\n    returnsValueToScript,\n    TODO,\n    REQT,\n    bREQT\n    // tvCharter\n} from StellarHeliosHelpers\n\nimport {\n    DelegateActivity,\n    DelegateDatum,\n    BurningActivity,\n    MintingActivity,\n    SpendingActivity\n} from specializedDelegate\n\n// formerly was in Capo core contract script\n// func allDelegatesAreValidatingSettings() -> Bool {\n//         // print( \"  ...with activity updatingSettings\\n\");\n//         // _isRelevantDatum : Bool = capoDatum.switch {\n//         //     // SettingsData => true,\n//         //     CharterData => true,\n//         //     _ => error(\"wrong use of updatingSettings action; must use only on CharterData\")\n//         // };\n//         // !!! move to SettingsDelegate?  or keep as a baseline check?\n//         // it requires the govAuthority to be present \n//         REQT( \"gov authority must be present to update settings\");\n//         hasGovAuthority : Bool = mustHaveGovAuthority(\n//             mph: mph,\n//             charterData: charterData // already resolved\n//         );\n\n//         CapoDatum::CharterData{\n//             spendDelegate,\n//             spendInvariants,\n//             otherNamedDelegates,\n//             mintDelegate,\n//             mintInvariants,\n//             govDelegate,\n//             manifest\n//         } = capoDatum;\n\n//         //!!! note, this is a hard-coded version of requiring the settings policy script:\n//         REQT(\"the current Settings must be spent and updated\");\n//         settingsDgtLink : RelativeDelegateLink = otherNamedDelegates.get_safe(\"settingsPol\").switch {\n//             None => error(\"'settings' delegate must be present to do updatingSettings activity\"),\n//             Some{dgt} => dgt\n//         };\n\n//         settingsDgtInput = settingsDgtLink.hasDelegateInput(\n//             inputs: tx.inputs,\n//             mph: mph\n//         ).unwrap();\n//         settingsDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( \n//             mustFindInputRedeemer(settingsDgtInput)\n//         ).switch {\n//             SpendingActivities => true,\n//             _ => assert(\"settings delegate must be updating the settings with its SpendingActivities variant\")\n//         };\n//         _nextSettings : Data = cctx.getNextManifestedDatumRaw(\"settings\");\n//         isUpdatingSettings : Bool = true;\n        \n//         inputs: []TxInput = tx.inputs;\n\n//         //!!! actually requiring delegates' SettingsValidation starts here.\n//         REQT( \"spend delegate must validate settings (wait, that's myself.  Call validate directly?\");\n\n//         spendDelegateIsValidating : Bool = \n//             spendDelegate.validatesUpdatedSettings(\n//                 inputs: inputs,\n//                 mph: mph,\n//                 inputRequired: true\n//             ).unwrap();\n\n//         REQT(\"mint delegate must validate settings\");\n//         mintDelegateIsValidating : Bool = \n//             mintDelegate.validatesUpdatedSettings(\n//                 inputs: inputs,\n//                 mph: mph,\n//                 inputRequired: true\n//             ).unwrap();\n\n//         // govAuthority is checking the settings\n//         REQT( \"govDelegate MAY contribute to settings validation\");\n//         govDelegateMaybeValidating : Bool = \n//             govDelegate.validatesUpdatedSettings(\n//                 inputs: inputs,\n//                 mph: mph,\n//                 inputRequired: false\n//             ).switch{\n//                 Some => true,\n//                 None => {\n//                     print(\"  -- govAuthority isn't a script-based validator; doesn't validate new settings\\n\");\n//                     true\n//                 }\n//             };\n//         checkOneInvariant : (RelativeDelegateLink) -> Bool = \n//         (oneDgt: RelativeDelegateLink) -> Bool {\n//             REQT( \"invariant must validate settings\");\n//             oneDgt.validatesUpdatedSettings(\n//                 inputs: inputs,\n//                 mph: mph,\n//                 inputRequired: true\n//             ).unwrap()\n//         };\n//         // spendInvariants are checking the settings\n//         REQT( \"spend invariants must validate settings\");\n//         spendInvariantsAreValidating : Bool = spendInvariants.all( \n//             checkOneInvariant\n//         );\n//         // mintInvariants are checking the settings\n//         REQT( \"mint invariants must validate settings\");\n//         mintInvariantsAreValidating : Bool = mintInvariants.all( \n//             checkOneInvariant\n//         );\n//         // namedDelegates are checking the settings\n//         REQT( \"named delegates must validate settings\");\n//         namedDelegatesAreValidating : Bool = otherNamedDelegates.fold( \n//             REQT( \"  - each named delegate must validate settings\");\n//             (ok: Bool, key: String, dgt: RelativeDelegateLink) -> Bool {\n//                 print(\"  - named delegate: \" + key);\n//                 print(\"\\n\");\n//                 ok && dgt.validatesUpdatedSettings(\n//                     inputs: inputs,\n//                     mph: mph,\n//                     inputRequired: true\n//                 ).unwrap()\n//             }, true\n//         );\n\n//         isRelevantDatum &&\n//         settingsDelegateIsValid &&\n//         isUpdatingSettings &&\n//         spendDelegateIsValidating &&\n//         mintDelegateIsValidating &&\n//         govDelegateMaybeValidating &&\n//         spendInvariantsAreValidating &&\n//         mintInvariantsAreValidating &&\n//         namedDelegatesAreValidating &&\n//         hasGovAuthority\n// }\n\nfunc main(mdd: DelegateDatum, activity: DelegateActivity) -> Bool {\n    print(\" 🚥❓delegate: \"+delegateName + \"\\n\");\n\n    // input = get_current_input();\n    result :Bool = mdd.switch{\n        //! performs essential checks of policy for spending the minting delegate's authority token \"mintDgt-*\"\n        // ... it also calls any additionalDelegateValidation() defined in a specialized minting delegate,\n        // ... governing the minting of application-specific tokens (including UUTs, fungible tokens, \n        // ... or other sorts of tokens under our minting policy).\n        //! Ditto, for our spendDgt-* token, for governing the spend of any utxos in the Capo address.\n        capoStoredData => error(\"Data Delegates must never store the capoStoredData variant in the script; used only for data-structuring capo-stored utxo datum\"),\n        // todo: ensure that the utxo-creation path also does not store IsDelegatedData variants in the script\n\n        //! This code path is also used for other authority-bearing tokens in other specialized delegates,\n        //  ... such as named delegates that the mintDgt- or spendDgt- policies defer to.\n        //  ... each of those cases has separate execution through this base logic, with specialization \n        //  ... applicable for each (see references to \"nowActingAs\").\n        isD : IsDelegation{dd} => {\n            // MintDelegateDatum::IsDelegation{dd, cfg} = isD;\n            showMyTokens : (Value) -> String = mkTokenShow(dd.mph);\n            myDgTkn = showMyTokens(get_current_input().value);\n            print(\"  -- is spending dgTkn \"+ myDgTkn);\n\n            activity.switch {\n                MultipleDelegateActivities{activities} => {\n                    // NOTE: the Capo ensures that each SPENT UTxO is addressed by EXACTLY ONE SpendDgt activity.\n                    // When executed in a mint/spend delegate, the policy below ensures \n                    // ... that each requested activity is matched by a UTxO in the transaction, \n                    // ... guaranteeing 1:1 coverage of activities & UTxOs.\n\n                    // Those are executed in parts (one set of activities applicable to mintDgt-* token,\n                    //   ... and the other governed by a spendDgt-* token.  It is common that the exact\n                    //   ... same contract script executes both, unless it has a special need to\n                    //   ... separate the code for those two; regardless, each is enforced in\n                    //   ... a separate execution (different utxos, different activity/redeemer each).\n\n                    // For now, only *DelegatedData activities are valid in mint/spend multi-activities.\n\n                    // Special: DeletingDelegatedDatum requires a Spend validation as well as a Burn validation,\n                    //   ... so it will be present in both the mintDgt and spendDgt multi-activities.\n\n                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();\n\n                    activities.all( (rawActivity: Data) -> Bool {\n                        a : DelegateActivity = DelegateActivity::from_data(rawActivity);\n\n                        if (isMintDelegate && cctx.nowActingAsMintDgt(required: false)) {\n                            // probably can't fail here:\n                            // assert(isMintDelegate, \"ack! non-MintDelegate can't act as mintDgt\");\n                            print(\"  -- mintDgt checking multi-activity\");\n                            REQT(\"in the mint delegate, only {Create,Delete}DelegatedData activities are valid in multi-activities\");\n                            a.switch {\n                                // in the Mint and Spend delegates, these nested activities are expected to re-delegate \n                                // to delegated-data controllers, which will use Mint/Spend/Burn activities on the data-controller tokens.\n                                CreatingDelegatedData/*{TxOutputId{seedTxn, seedIdx}, dataTypePurpose} */=> {\n                                    // Note: CreatingDelegatedData activity doesn't involve the Capo at all!\n                                    // Instead, the minter creates a UUT for the data, on authority of the mintDgt;\n                                    // ... and the mintDgt requires the presence of the corresponding dgDataPolicy (with its MintingActivity);\n                                    // ... then the dgDataPolicy checks the validity of the new data, and requires that\n                                    // ... the new data is created as a DelegatedData record in the Capo address.\n\n                                    // assert(isMintDelegate && cctx.nowActingAsMintDgt(),\n                                    //     \"CreatingDelegatedData only ok in mintDgt\"\n                                    //     // \" ... use MintingActivities in a delegated-data controller\"\n                                    // );\n                                    // recursion checks for the needed input/output and DgDataController MintingActivity                                \n                                    main(mdd, a)\n                                },\n                                DeletingDelegatedData => {\n                                    // assert(isMintDelegate, \"DeletingDelegatedData only ok in mintDgt\" ); // \" ... use BurningActivities in a delegated-data controller\"\n                                    // cctx.nowActingAsMintDgt() &&\n    \n                                    // recursion checks for the needed input/burn                                \n                                    main(mdd, a)\n                                },\n                                UpdatingDelegatedData => error(\n                                    \"UpdatingDelegatedData only ok at level-1 spendDgt\"\n                                ),\n                                DelegateLifecycleActivities => error(\"multi:DelegateLifecycleActivities not ok\"),\n                                CapoLifecycleActivities => error(\"multi:CapoLifecycleActivities not ok\"),\n                                MultipleDelegateActivities => error(\"multi:multi: nesting not ok\"),\n    \n                                _ => error(\"multi:non-minting activities are invalid for mintDgt\")\n                            }\n                        } else if (isSpendDelegate && cctx.nowActingAsSpendDgt(required: false)) {\n                            // probably can't fail here:\n                            // assert(isSpendDelegate, \"ack! non-SpendDelegate can't act as spendDgt\");\n                            print(\"  -- spendDgt checking multi-activity\");\n                            REQT(\"in the spend delegate, only {Updating,Deleting}DelegatedData activities are valid in multi-activities\");\n                            a.switch {\n                                // in the Mint and Spend delegates, these nested activities are expected re-delegate to delegated-data controllers,\n                                // which will use Mint/Spend/Burn activities on the data-controller tokens.\n                                UpdatingDelegatedData{_typeName, _recId} => {\n                                    assert(isSpendDelegate && cctx.nowActingAsSpendDgt(),\n                                        \"UpdatingDelegatedData only ok at level-1 spendDgt\"\n                                        // \" ... a delegated-data-controller will use one of its SpendingActivities to govern capoStoredData's spend\"\n                                    );\n                                    // the recursion always checks for the input-datum, so we\n                                    // don't need to check it here.\n                                    // _inputDD = cctx.delegatedDataTxInput(recIdBytes: recId);\n                                    main(mdd, a)\n                                },\n                                CreatingDelegatedData => error(\n                                    \"CreatingDelegatedData only ok in mintDgt\"\n                                ),\n                                DeletingDelegatedData => {\n                                    error(\"TODO: validate spending the datum for burn\")\n                                },\n                                DelegateLifecycleActivities => error(\"multi:DelegateLifecycleActivities not ok\"),\n                                CapoLifecycleActivities => error(\"multi:CapoLifecycleActivities not ok\"),\n                                MultipleDelegateActivities => error(\"multi:multi: nesting not ok\"),\n                                _ => error(\"multi: non-spending activities are invalid for spendDgt\")\n                            }\n                        } else {\n                            assert(!isMintDelegate && !isSpendDelegate, \"ack! delegated-data policy can't be a mint/spend delegate\");\n                            TODO(\"assert isDgDataPolicy\"); // assert(isDgDataPolicy, \"invalid use of multiActivity by non-DgDataPolicy\");\n                            print(\"  -- dgDataPolicy checking multi-activity\");\n                            // WHEN this code is supporting a DgDataPolicy (with its own specializedDelegate module),\n                            //   the multi-activity expects Minting/Spending/Burning activities, not *DelegatedData activities.\n                            REQT(\"in DgDataPolicy, only Minting/Burning/Spending activities are valid\");\n                            a.switch {\n                                UpdatingDelegatedData => error(\n                                    \"UpdatingDelegatedData only ok at level-1 spendDgt (use a SpendingActivity in dgDataPolicy)\"\n                                ),\n                                CreatingDelegatedData => error(\n                                    \"CreatingDelegatedData only ok in mintDgt (use a MintingActivity in dgDataPolicy)\"\n                                ),\n                                DeletingDelegatedData => error(\n                                    \"DeletingDelegatedData only ok at mint/spend dgt (use BurningActivity in dgDataPolicy)\"\n                                ),\n                                // in the delegated-data controllers, we have to support these multi-activities.\n                                // this will pass through the individual activity to be individually validated by the specialized delegate \n                                // module that governs the data-controller's UUT, in its additionalDelegateValidation() function.\n                                SpendingActivities => main(mdd, a),\n                                MintingActivities => main(mdd, a),\n                                BurningActivities => {\n                                    assert(false, \"TODO: support multi:BurningActivities for dgDataPolicy or other delegate\") ;\n                                    main(mdd, a)\n                                },\n                                DelegateLifecycleActivities => error(\"multi:DelegateLifecycleActivities not ok\"),\n                                CapoLifecycleActivities => error(\"multi:CapoLifecycleActivities not ok\"),\n                                MultipleDelegateActivities => error(\"multi:multi: nesting not ok\")\n                                // _ => error(\"multi: invalid other activity for non-mint/spend delegate\")\n                            }\n                        }\n                    })\n                },\n                //   guards that the authority token is returned to this script.\n                // specialized minting delegates should likely perform additional checks.\n                DelegateLifecycleActivities{innerActivity} => innerActivity.switch {\n                    // reassigning the authority token to a new minting delegate\n                    ReplacingMe{seed, purpose} => {\n                        // should burn the old UUT, mint the new UUT, and update the Charter\n                        // with the new mint authority\n\n                        //xxx -   tx.minted.get_safe( dd.acAuthorityToken() ) == 0 &&\n                        //xxx -   !returnsValueToScript( dd.tvAuthorityToken())\n\n                        BURNED: Int = -1;\n                        otherMintedValue: Value = Value::new(\n                            AssetClass::new(dd.mph, dd.tn), \n                            BURNED\n                        );\n                    \n                        tnStr : String = dd.tn.decode_utf8();\n                        print(\"checking ReplacingMe on \"+purpose + \": \"+ tnStr);\n                        REQT(\"needs the charter to be approving the the new mint-delegate\");\n                        TODO(\"  ^^^ should queue the new delegate in pendingChanges\");\n\n                        cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterInput();\n                        isUpdatingCharter : Bool = cctx.getCharterRedeemer().switch {\n                            // THE CHARTER UPDATE ITSELF WILL CHECK THAT THERE'S A VALID DELEGATE OUTPUT FOR THE NEW DELEGATE\n                            updatingCharter => true,\n                            _ => false\n                        };\n\n                        isMintingOk : Bool = validateUutMinting(\n                            mph: dd.mph,\n                            seed: seed,\n                            purposes: []String{purpose}, \n                            otherMintedValue: otherMintedValue,\n                            needsMintDelegateApproval: false,\n                            extraMintDelegateRedeemerCheck: false\n                        );\n\n                        isMintingOk && isUpdatingCharter\n\n                    },\n\n                    // the token is being burned, retiring the authority token for this minting delegate\n                    // as a result, this minting delegate will no longer be consulted.  This could be combined\n                    // with the creation of a new minting delegate with a new authority token, registered\n                    // with the Capo in place of this one (or Reassigning could be used for such a case).\n                    // If there is no replacement minting delegate, then the Capo will not be able to perform \n                    // any further minting activities.\n                    //\n                    // Retiring is not suitable for authorizing token-burning.\n                    Retiring => {\n                        tx.minted.get(dd.acAuthorityToken()) == -1\n                    },\n\n                    ValidatingSettings => {\n                        _charter : CapoDatum::CharterData = getTxCharterData(dd.mph);\n\n                        // each application-specific delegate must validate the settings\n                        // for itself?\n                        // OR: import the settings type, and trigger the validation here\n                        // ... so delegate authors can have fewer hoops to jump through\n                        TODO(\"import settings from delegate and validate them\");\n\n                        // _foundSettings = ProtocolSettings::from_data(cctx.getManifestedData(\"settings\"));\n\n                        //xxx foundSettings : outputAndDatum[CapoDatum::SettingsData] = \n                        //xxx     charter.mustFindSettingsOutput(dd.mph, dd.capoAddr);\n                        //xxx customSettings = fromCip68Wrapper[ProtocolSettings](foundSettings.rawData);\n\n                        // print(\"\\n\" + delegateName + \": delegate TRYING TO VALIDATE SETTINGS\\n\");\n                        // validated : Bool = customSettings.validate();\n                        // print(\"HURRAY\\n\");\n\n                        // TODO: also validate any typeMap (can do this later and adopt the new delegate \n                        // into the Capo when this code is written)\n\n                        assert( false && \n                            // validated && \n                            // isValid : Bool = \n                            //     ((isTest && throwIfBadSettings(mdd, settings)) || true) &&\n                            //     mdd.validateSettings(settings);\n                            // isValid\n                            true,\n                            \"ValidateSettings temporarily disabled\"\n                        );\n                        false\n                    }\n                },\n                CapoLifecycleActivities{dCLA} => {\n                    REQT(\"... with any CapoLifecycle activity: \");\n                    cctx = mkCapoCtx(dd.mph).\n                        withCharterInput().\n                        requiresGovAuthority();                    \n\n                    // wantsRole : DelegateRole = CLA.switch {\n                    //     forcingNewSpendDelegate => error(\"the forcingNewSpendDelegate escape-hatch activity is always handled directly by the Capo\"),\n                    //     forcingNewMintDelegate => error(\"the forcingNewMintDelegate escape-hatch activity is always handled directly by the Capo\"),\n                    //     removePendingChange => DelegateRole::SpendDgt,\n                    //     commitPendingChanges => DelegateRole::BothMintAndSpendDgt,\n                    //     updatingManifest => DelegateRole::SpendDgt,\n\n                    //     CreatingDelegate => {\n                    //         TODO(\"deprecate use of CLA::CreatingDelegate\");\n                    //         DelegateRole::MintDgt\n                    //     },\n\n                    //     queuePendingChange => DelegateRole::BothMintAndSpendDgt\n                    //     // we want explicit handling of each case; don't use a default match here.\n                    //     // _ => error(\"DO NOT CATCH DEFAULT CASE HERE\")\n                    // };\n                    // wantsRole.switch {\n                    neededRole = cctx.dgtRolesForLifecycleActivity(dCLA);\n                    myCurrentRole : DelegateRole = neededRole.switch {\n                        HandledByCapoOnly => {\n                            error(\"delegate invoked with invalid escape-hatch activity (always handled directly by the Capo)\")\n                        },\n                        SpendDgt => {\n                            REQT(\n                                \"... this Capo lifecycle activity is only valid on spend delegate\",\n                                isSpendDelegate \n                            );\n                            assert(cctx.nowActingAsSpendDgt(), \"<----- that can fail, this can't\");                            \n                            print(\"  -- ok: spendDgt checking CapoLifecycleActivity\");\n                            neededRole\n                        },\n                        MintDgt => {\n                            REQT(\n                                \"... this Capo lifecycle activity is only valid on mint delegate\",\n                                isMintDelegate\n                            );\n                            assert(cctx.nowActingAsMintDgt(), \"<----- that can fail, this can't\");\n                            print(\"  -- ok: mintDgt checking CapoLifecycleActivity\");\n                            neededRole\n                        },\n                        BothMintAndSpendDgt => {\n                            REQT(\"It EXPECTS the Capo to enforce the presence of the mintDgt (to check the right mint) and spendDgt (to validate the charter-update logic)\");\n                            // REQT(\"  ... it needs the mintDgt to check mints & burns\");// the new dgTkn creation\");\n                            // REQT(\"  ... it uses the spendDgt to verify the correct charterData update\");\n                            if (cctx.nowActingAsMintDgt(required:false)) {\n                                DelegateRole::MintDgt\n                            } else if (cctx.nowActingAsSpendDgt(required:false)) {\n                                DelegateRole::SpendDgt\n                            } else {\n                                error(\"this Capo lifecycle activity is only valid on mint/spend delegate, not \"+ delegateName)\n                            }\n                        },\n                        _ => error(\"no way k\") // unreachable\n                    };\n\n                    // the Capo policy already requires that this activity is identical\n                    // to the capo's own triggered lifecycle activity, given that the\n                    // capoLifecycleActivity is what's involved on that end.  We\n                    // ensure that is true here:\n                    REQT(\"requires the Capo's CharterData activity to match this delegate's activity\");\n                    cctx.getCharterRedeemer().switch {\n                        capoLifecycleActivity{cCLA} => {\n                            assert(\n                                cCLA == dCLA,\n                                \"activity mismatch with Capo's CharterData activity\"\n                            );\n                            print(\"  -- ok, CharterData capoLifecycleActivity matches ours\\n\")\n\n                        },\n                        updatingCharter => {\n                            dCLA.switch {\n                                CreatingDelegate => {\n                                    print(\"ok, Capo:updatingCharter works for now with CreatingDelegate\\n\")\n                                },\n                                _ => error(\"when Capo is UpdatingCharter, the mintDelegate must be CreatingDelegate\")\n                            }\n                        },\n                        _ => error(\"this activity must match the capo's own CharterData activity\")\n                    };\n\n                    dCLA.switch {\n                        // the mint delegate is validating a mint that CREATES A NEW DELEGATE\n                        // FOR APPLICATION-SPECIFIC PURPOSES. This can affect the structure of the Capo\n                        // it defers to the specialized minting delegate, if any; the unspecialized mint delegate\n                        // rejects all delegate-creation.\n                        CreatingDelegate{seed, purpose} => {\n                            // print(\"🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞 !!!!!!!!!!!!!!!!!!! todo: fix this\\n\");\n                            // assert(false, \"obsolete CLA::CreatingDelegate?\");\n                            TODO(\"XXX it should output the new delegate token to the Capo as a PendingDelegate datum\");\n                            REQT(\"validates creation of UUT for the new delegate, aligned to the purpose indicated\");\n\n                            mkTn = mkUutTnFactory(seed);\n                            myCurrentRole.switch {\n                                MintDgt => {\n                                    REQT(\n                                        \"validates the new delegate's UUT is minted\"\n                                    );\n                                    if (validateUutMinting(\n                                        mph: dd.mph,\n                                        seed: seed,\n                                        purposes: []String{purpose},\n                                        // otherMintedValue: ()\n                                        mkTokenName: mkTn,\n                                        // WE ARE the mint delegate.\n                                        needsMintDelegateApproval: false \n                                    )) {\n                                        print(\"  -- ok, minted the new delegate's UUT\\n\") \n                                    };\n                                    REQT(\n                                        \"the UUT must have the right disposition (is it checked somewhere else?!?)\"\n                                    );\n                                    cctx.getNextCharterData().otherNamedDelegates.get_safe(purpose).switch {\n                                        None => error(\"the new delegate is not present in the Capo's named-delegates list\"),\n                                        Some{dgtLink} => {\n                                            assert(dgtLink.uutName == mkTn(purpose), \"uutName mismatch\");\n\n                                            dgtLink.hasValidOutput(\n                                                mph: dd.mph, \n                                                required: true,\n                                                createdOrReturned: DgTkn::Created\n                                            )\n                                        }\n                                    }\n                                },\n                                _ => error(\"unreachable wrong role for CreatingDelegate\")\n                            }\n                        },\n                        queuePendingChange => {\n                            REQT(\"... for the addingPendingDgt activity:\");\n\n                            charterData : CapoDatum::CharterData = cctx.getCharterData();\n\n                            REQT(\"The new pending-delegate action is found at the head of the new change-list\");\n                            oldPendingChanges = charterData.pendingChanges;\n                            nextCharterData = cctx.getNextCharterData();\n                            nextChangeList = nextCharterData.pendingChanges;\n                            newChange = nextChangeList.head;\n\n                            TODO(\"support otherManifestChange here\");\n                            PendingCharterChange::delegateChange{\n                                PendingDelegateChange{\n                                    action, // PendingDelegateAction\n                                    role, // : DelegateRole\n                                    OdgtLink //: Option[RelativeDelegateLink]\n                                }\n                            } = newChange;\n                            name = role.switch {\n                                DgDataPolicy{dgtName} => dgtName,\n                                _ => error(\"only DgDataPolicy is yet supported in queuePendingChange\")\n                            };\n\n                            action.switch {\n                                Remove => {\n                                    print(\"   -- another delegate-role check would be redundant.\");\n\n                                    myCurrentRole.switch {\n                                        SpendDgt => {\n                                            REQT(\"verifies that the delegate queued for removal is present in the Capo's charterData\");\n                                            error(\"implement me\")\n                                        },\n                                        _ => error(\"unreachable\")\n                                    }\n                                }, \n                                _ => assert(true, \"no way l\")\n\n                            };\n\n\n\n                            REQT(\"the remainder of the change-list should be unchanged\");\n                            assert(\n                                nextChangeList.tail == oldPendingChanges, \n                                \"invalid update of pendingChanges; the new action must be prepended to the existing list.\"\n                            );\n                            (\n                                seed: TxOutputId, \n                                purpose: String,\n                                pendingActionIdPrefix: String\n                                // uutName: String, \n                                // dvh : Option[ValidatorHash], \n                                // config : ByteArray\n                            ) = action.switch { \n                                Remove => error(\"unreachable\"), \n                                Add{seed, purpose, idPrefix} => {\n                                    (seed, purpose, idPrefix) \n                                },\n                                Replace{seed, purpose, idPrefix, _replacesDgt } => { \n                                    (seed, purpose, idPrefix ) \n                                }\n                            };\n\n                            possibleMintDgtVerifications : Bool = myCurrentRole.switch {\n                                SpendDgt => /* no-op */ true,\n                                MintDgt => bREQT(\n                                    \"(general) the mintDgt checks everything about the mint\"\n                                ) && action.switch {\n                                    Remove => {\n                                        role.switch {\n                                            MintDgt => error(\"cannot Remove role: MintDgt\"),\n                                            SpendDgt => error(\"cannot Remove role: SpendDgt\"),\n                                            MintInvariant => error(\"cannot Remove role: MintInvariant\"),\n                                            SpendInvariant => error(\"cannot Remove role: SpendInvariant\"),\n                                            DgDataPolicy => {\n                                                assert(false, \"todo\")\n                                            },\n                                            OtherNamedDgt => {\n                                                assert(false, \"todo\")\n                                            },\n                                            BothMintAndSpendDgt => error(\n                                                \"DelegateRole::BothMintAndSpend not applicable in queuePendingChange activity\"\n                                            )\n                                        };\n                                        REQT(\"doesn't allow a Remove to duplicate an Add or Replace or Remove entry\");\n                                        TODO(\"^^^\");\n\n                                        assert(false, \"what else should be checked here?\");\n                                        false\n                                    },\n                                    _ => { // Replace or Add\n                                        if(false/*redundant*/) { assert(cctx.nowActingAsMintDgt(), \"<----- that can fail, this can't\") };\n\n                                        mkTokenName = mkUutTnFactory(seed);\n                                        dgTknName = mkTokenName(purpose);\n                        \n                                        mintedDgTkn = bREQT(\"the new delegate is created with the indicated authority token\")\n                                        && validateUutMinting(\n                                            mph: dd.mph,\n                                            seed: seed,\n                                            // \"dgtPol\", until/unless we get fancy like \"settingsPol\", \"reqtsPol\", \"mktSalePol\", etc:\n                                            purposes: []String{purpose}, \n                                            // otherMintedValue: ()\n                                            mkTokenName: mkUutTnFactory(seed),\n                                            // WE ARE the mint delegate.\n                                            needsMintDelegateApproval: false \n                                        );\n                                        \n                                        REQT(\"The new policy-token must match the seed\");\n                                        dgtLink = OdgtLink.switch {\n                                            None => error(\"missing required delegate link in pending dgt change\"),\n                                            Some{dl} => dl\n                                        };\n                                        assert(\n                                            dgtLink.uutName == dgTknName,\n                                            \"uutName mismatch; expected \"+dgTknName+\" but found \"+dgtLink.uutName\n                                        );\n\n                                        delegateTakesOwnership = bREQT(\"the new policy-delegate-script must take ownership of the dgTkn\",\n                                            dgtLink.hasValidOutput(\n                                                mph: dd.mph, \n                                                required: true,\n                                                createdOrReturned: DgTkn::Created\n                                        ));\n\n                                        possibleExtraReplacementCheck = action.switch {\n                                            Replace => {\n                                                REQT(\"Replace: the queued change must match the idPrefix of the current delegate \");\n                                                TODO(\"VALIDATE this through a unit-test ^\");\n                                                charterData.manifest.get_safe(name).switch {\n                                                    Some{dde} => {\n                                                        CapoManifestEntry{entryType, _tn, _mph} = dde;\n                                                        entryType.switch {\n                                                            DgDataPolicy{_polLink, idPrefix, _refCount} => {\n                                                                REQT(\"expects the queued idPrefix to match the existing policy's idPrefix\");\n                                                                print(\"   -- expected: \" + idPrefix);\n                                                                print(\"   --     actual:\"+pendingActionIdPrefix);\n                                                                assert(\n                                                                    idPrefix == pendingActionIdPrefix,\n                                                                    \"idPrefix mismatch\"\n                                                                )\n                                                            },\n                                                            _ => error(\"invalid Replace; the matching manifest entry for '\"+name+\"' isn't a DgDataPolicy.\")\n                                                        }\n                                                    },\n                                                    None => error(\"no existing dgDataPolicy found with key: \"+name)\n                                                };\n                                                true\n                                            },\n                                            _ => true\n                                        };\n                                        mintedDgTkn && delegateTakesOwnership && possibleExtraReplacementCheck\n                                    }\n                                },\n                                _ => error(\"unreachable\") // other DelegateRoles \n                            }; // -> possibleMintDgtVerifications\n\n                            otherPossibleVerifications : Bool = myCurrentRole.switch { \n                                SpendDgt => /* no-op */ error(\n                                    \"this block had been run by spendDgt, but\\n\"+\n                                    \"... it's much cheaper to let the MintDgt do it ...\\n\"+\n                                    \"... since it's already involved anyway\"\n                                ),\n                                MintDgt => {\n                                    // REQT(\"(general) the spendDgt checks everything about the charterData update\");\n\n                                    REQT(\"doesn't allow a queued change to duplicate any other pending entry for the same delegate name\");\n                                    isNotADuplicate = charterData.pendingChanges.all( \n                                        (pdChange: PendingCharterChange) -> Bool {\n                                            pdChange.switch {\n                                                delegateChange{\n                                                    PendingDelegateChange{_pendingAction, pendingRole, _odgtLink}\n                                                } => {\n                                                    pendingRole.switch {\n                                                        DgDataPolicy{changingDgtName} => {\n                                                            changingDgtName != name\n                                                        },\n                                                        _ => error(\"only DgDataPolicy is yet supported in queuePendingChange\")\n                                                    }\n                                                },\n                                                _ => error(\"otherManifestChange not yet supported\")\n                                            }\n                                    });\n                                    assert(isNotADuplicate, \"already has a pending change for this delegate: \"+name);\n\n                                    possibleReplacementIsCorrect: Bool = action.switch {\n                                        Remove => error(\"unreachable\"),\n                                        Add => true, // doesn't need to replace anything\n                                        Replace{_seed, _purpose, _recPrefix, acExistingDgt} => { \n                                            REQT(\"... when queuing a replacement delegate: \");\n                                            REQT(\"invariants cannot be replaced\");\n                                            role.switch {\n                                                MintInvariant => error(\"cannot Replace role: MintInvariant\"),\n                                                SpendInvariant => error(\"cannot Replace role: SpendInvariant\"),\n                                                HandledByCapoOnly => error(\"HandledByCapoOnly role is not applicable in delegate context\"),\n                                                _ => print(\"  -- ok (not trying to replace an invariant)\")\n                                            };\n\n                                            mkSome = (ac: AssetClass) -> Option[AssetClass] { Option[AssetClass]::Some{ac} };\n                                            REQT(\"the PendingDelegateAction's role + replacesDgt must match the existing delegate's authority token\");\n                                            replacesDgTkn : Option[AssetClass] = role.switch {\n                                                MintDgt => mkSome(charterData.mintDelegateLink.acAuthorityToken(dd.mph)),\n                                                SpendDgt => mkSome(charterData.spendDelegateLink.acAuthorityToken(dd.mph)),\n                                                DgDataPolicy => {\n                                                    REQT(\"to Replace a dgDataPolicy, the named policy must be present in the Capo manifest\");\n                                                    error(\"todo: get authority-token for this dgDataPolicy\")\n\n                                                },\n                                                OtherNamedDgt => {\n                                                    REQT(\"to Replace a named delegate, the named delegate must already be present\");\n                                                    error(\"todo: get authority-token for this named delegate\")\n                                                },\n                                                BothMintAndSpendDgt => error(\n                                                    \"DelegateRole::BothMintAndSpend not applicable in queuePendingChange activity\"\n                                                ),\n                                                MintInvariant => error(\"unreachable\"),\n                                                SpendInvariant => error(\"unreachable\"),\n                                                HandledByCapoOnly => error(\"unreachable\")\n                                            };\n                                            assert(\n                                                acExistingDgt == replacesDgTkn.unwrap(),\n                                                \"the current \"+role.switch{\n                                                    MintDgt => \"mint\", SpendDgt => \"spend\", \n                                                    DgDataPolicy => \"dgDataPolicy\", OtherNamedDgt => \"named\",\n                                                    _ => \"‹incontheeiieivable›\"\n                                                }+\" delegate's authority token doesn't match \"+acExistingDgt.show()\n                                            );\n\n                                            true\n                                        } \n                                    }; // -> possibleReplacementIsCorrect\n\n                                    true\n                                    && isNotADuplicate \n                                    && possibleReplacementIsCorrect\n                                }, \n                                _ => error(\"unreachable\") // other DelegateRoles \n                            }; // -> possibleSpendDgtVerifications\n                                                 \n                            true\n                            && possibleMintDgtVerifications \n                            && otherPossibleVerifications\n                        },\n                        removePendingChange{_role} => {\n                            // this code-path is only found in the spend-delegate\n                            TODO(\"implement removePendDgt\");\n                            REQT(\"allows the removal of a queued pending-delegate-change that can't be completed\");\n                            assert(false, \"not yet implemented\");\n                            false\n                        },\n                        commitPendingChanges => {\n                            // this code-path has one leg in the spend-delegate\n                            // and one leg in the mint-delegate\n                            REQT(\"invariants cannot be replaced\");\n                            pendingChangesList : []PendingCharterChange = cctx.getCharterData().pendingChanges;\n                            previousManifest : Map[String]CapoManifestEntry = cctx.getCharterData().manifest;\n                            nextCharterData = cctx.getNextCharterData();\n                            nextManifest : Map[String]CapoManifestEntry = nextCharterData.manifest;\n\n                            assert(\n                                bREQT(\"the next-changes list must be empty\") &&\n                                nextCharterData.pendingChanges.length == 0,\n                                \"pendingChanges must be emptied\"\n                            );\n\n                            if (cctx.nowActingAsSpendDgt(required: false)) {\n                                REQT(\"spendDgt: committing pending delegates: validates that all the pending delegates are installed\");\n                                // the pending changes are moved into the nextManifest\n\n                                // walks through the pending changes and next-manifest entries\n                                // ... and also holds a temporary picture of previous-manifest entries.\n                                //  - verifies that each next change is reflected in the next-manifest's next entry\n                                //  - verifies at the end that the remainder of the next-manifest-tail (after verifying changes added in its \"head\" section) \n                                //    ... contains all the entries expected (from the previous-manifest-remainder,\n                                //    ...   == previous-manifest, when no Remove/Replace actions are present);\n                                //  - verifies that any Removed entries are missing from the next-manifest-map\n                                //    ... while removing them from the previous-manifest-remainder's \"expected remaining entries\"\n                                //  - verifies any Replaced entries have been added at the next-manifest's next entry\n                                //    ... AND that they're removed from the remainder of the next-manifest-map,\n                                //    ... while removing them from the \"expected remaining entries\" in the previous-manifest-remainder.\n                                // At the end, it verifies that the two remaining partial-maps are identical.\n                                (\n                                    prevManifestRemainder, nextManifestRemainder: Map[String]CapoManifestEntry\n                                ) = pendingChangesList.fold2[ Map[String]CapoManifestEntry, Map[String]CapoManifestEntry ]( \n                                    (\n                                        prevManifestRemainder : Map[String]CapoManifestEntry, \n                                        nextCMEs: Map[String]CapoManifestEntry, \n                                        pcChange: PendingCharterChange\n                                    ) -> ( Map[String]CapoManifestEntry, Map[String]CapoManifestEntry ) {\n                                        pdChange : PendingDelegateChange = pcChange.switch {\n                                            delegateChange{dgtChange} => dgtChange,\n                                            otherManifestChange => error(\"otherManifestChange not yet supported\")\n                                        };\n                                        pendingTypeName = pdChange.role.switch {\n                                            DgDataPolicy{typeName} => {\n                                                print(\"  -- ok: DgDataPolicy in commitPendingChanges\");\n                                                typeName\n                                            },\n                                            _ => error(\"invalid delegate-change role (for now) in commitPendingChanges\")\n                                        };\n                                        //void\n                                        pdChange.action.switch {\n                                            Remove => {\n                                                REQT(\"dgt-change: Remove: verifies that the delegate queued for removal is now removed from the Capo manifest\");\n                                                nextCMEs.get_safe(pendingTypeName).switch { \n                                                    Some => error(\n                                                        \"queued Remove failed: name still present in next-manifest item: \"+ \n                                                        pendingTypeName\n                                                    )\n                                                }\n                                            },\n                                            _ => {\n                                                REQT(\"verifies that added & replaced entries are present in the updated map (at its next position)\");\n                                                if (nextCMEs.length == 0) {\n                                                    error(\"queued Add/Replace failed: no more items in next-manifest map\")\n                                                };\n                                                ( CME_key : String, CapoManifestEntry{ME_type, _tn, _mph} ) = nextCMEs.head;\n                                                ManifestEntryType::DgDataPolicy{ME_policyLink, ME_idPrefix, refCount} = ME_type;\n                                                TODO(\"support minting multiple threads of a dgDataPolicy\");\n                                                assert(refCount == 1, \"refCount must be 1 when adding a new dgDataPolicy\");\n                                                assert(pendingTypeName == CME_key,\n                                                    \"queued change: name mismatch with next-manifest item\"\n                                                );\n                                                assert(ME_policyLink == pdChange.dgtLink.unwrap(),\n                                                    \"queued change: policyLink mismatch with next-manifest item\"\n                                                );\n\n                                                nextIdPrefix = pdChange.action.switch {\n                                                    Replace{_,_,idPrefix,_} => {\n                                                        REQT(\"Replace: verifies that the next-manifest no longer has the replaced entry\");\n\n                                                        nextManifest.tail.get_safe(pendingTypeName).switch {\n                                                            Some => error(\n                                                                \"queued Replace failed: duplicate name remaining in next-manifest map: \"+ \n                                                                pendingTypeName\n                                                            )\n                                                        };\n                                                        idPrefix\n                                                    },\n                                                    Add{_,_,idPrefix} => idPrefix,\n                                                    _ => error( \"unreachable\")\n                                                };\n                                                print(\"     vv @entry: \"+CME_key);\n                                                REQT(\"  -- @each manifest entry: next-manifest's idPrefix must match the queued change\");\n                                                assert(nextIdPrefix == ME_idPrefix,\n                                                    \"idPrefix mismatch with next-manifest's dgDataPolicy\"\n                                                )\n                                            }\n                                        }; // void assertions; all needed checks are done ^^^^\n\n                                        // traverses to next state for the reducer:\n                                        pdChange.action.switch {\n                                            Add => {\n                                                ( prevManifestRemainder, nextCMEs.tail )\n                                            },\n                                            _ => { // Remove, Replace => {\n                                                ( prevManifestRemainder.delete(pendingTypeName), nextCMEs.tail )\n                                            }\n                                        }\n                                    }, // reducer\n                                    previousManifest, // init1\n                                    nextManifest // init2\n                                );\n                                nextManifestRemainder == prevManifestRemainder\n                            } // spendDgt\n                            else if (cctx.nowActingAsMintDgt(required: false)) {\n                                REQT(\"mintDgt: committing pending delegates: validates that all the removed dgTkns are burned\");\n                                \n                                REQT(\"the txn must have all the expected burns\");\n                                observedTokenBurn = if( tx.minted.contains_policy(dd.mph) ) {\n                                    minted = tx.minted;\n                                    if (minted.to_map().length > 1) {\n                                        error(\"currently supporting only one minting policy being burned in the tx\")\n                                    };\n                                    tx.minted.get_policy(dd.mph)\n                                } else {\n                                    Map[ByteArray]Int{} // no burns expected\n                                };\n\n                                remainingMint: Map[ByteArray]Int = pendingChangesList.fold[ Map[ByteArray]Int ]( \n                                    (burning: Map[ByteArray]Int, pcChange: PendingCharterChange) -> Map[ByteArray]Int {\n                                        REQT(\"EXPECTS the spendDgt to check details of Replace activities\");\n                                        // ignores the dgtLink details if present in a Replace activity\n                                        pdChange : PendingDelegateChange = pcChange.switch {\n                                            delegateChange{dgtChange} => dgtChange,\n                                            otherManifestChange => error(\"otherManifestChange not yet supported\")\n                                        };\n                                        pdChange.role.switch {\n                                            DgDataPolicy{typeName} => {\n                                                print(\"  -- ok: DgDataPolicy in commitPendingChanges\");\n                                                PendingDelegateChange{action, role, _dgtLinkMaybe} = pdChange;\n                                                REQT(\"each pending change must have a name, which must be found in the current manifest\");\n                                                print( \"     -- ok: name\");\n                                                role.switch {\n                                                    DgDataPolicy => print(\"  -- ok: DgDataPolicy role\"),\n                                                    _ => error(\"delegate changes only recognize DgDataPolicy role for now\")\n                                                };\n                                                action.switch {\n                                                    Add => {\n                                                        // doesn't accumulate any expected mints or burns for Add \n                                                        // (the mint happens in a previous transaction while queueing the change\n                                                        burning\n                                                    },\n                                                    _ => { // Replace, Remove => {\n                                                        REQT(\"verifies that a delegate queued for removal or replacement is burned\");\n                                                        previousManifest.get_safe(typeName).switch {\n                                                            None => error(\"queued Remove failed: not present in previous-manifest map: \"+ typeName),\n                                                            Some{CapoManifestEntry{ME_type, tn, mph}} => {\n                                                                mph.switch {\n                                                                    Some => {\n                                                                        print( \"    -- TODO: manifest entry with other-mph: allow optional burn\");\n                                                                        // doesn't accumulate any additional expected burns\n                                                                        burning\n                                                                    },\n                                                                    _ => {\n                                                                        ManifestEntryType::DgDataPolicy{_ME_policyLink, _ME_recPrefix, refCount} = ME_type;\n                                                                        tnStr = tn.decode_utf8();\n                                                                        burning.get_safe(tn).switch {\n                                                                            None => error(\"queued Remove/Replace failed: no burn, or double-burn: \"+ tnStr),\n                                                                            Some{burningCount} => {\n                                                                                print(\"    -- ok: BURN 🔥\"+ burningCount.show() + \"×💴 \"+ tnStr);\n                                                                                if (0 - refCount != burningCount) { // negative = burning\n                                                                                    error(\"queued Remove/Replace failed: expected burn of \" + \n                                                                                        refCount.show() + \"×💴 \"+ tnStr\n                                                                                    )\n                                                                                };\n                                                                                burning.delete(tn)\n                                                                            } // burningCount\n                                                                        } // check burn quantity\n                                                                    }\n                                                                } // mph\n                                                            }\n                                                        }\n                                                    } // Remove/Replace\n                                                } // action\n                                            }, // DgDataPolicy\n                                            _ => error(\"invalid delegate-change role (for now) in commitPendingChanges\")\n                                        } // role\n                                    },  // reducer\n                                    observedTokenBurn // initial value\n                                );\n\n                                REQT(\"requires all the burns of our policy-id to be accounted for\");\n                                assert(remainingMint.length == 0, \n                                    \"extra burns found in the transaction: \\n\"+remainingMint.show());\n                                true\n                            } /* mintDgt */ \n                            else {\n                                error(\"unreachable? not mintDgt or spendDgt\")\n                            }\n                        }, // commitPendingChanges\n\n                        updatingManifest{manifestActivity} => {\n                            REQT(\"doesn't allow updating anything except the manifest\");\n                            manifestActivity.switch{\n                                retiringEntry{_key} => {\n                                    assert(false, \"TODO: support retirement activity\");\n                                    REQT(\"doesn't remove a dgDataPolicy entry from the manifest (use queuePendingChange instead)\");\n                                    REQT(\"removes the indicated key from the manifest\");\n                                    REQT(\"delegates MUST be allowed to validate that this doesn't drop something they need\")\n                                },\n                                updatingEntry{_key, _tokenName} => {\n                                    TODO(\"if delegates need a hook to validate that the updte is acceptable, that might be enforced here\");\n                                    assert(false, \"TODO: support updatingEntry activity\");\n                                    REQT(\"the indicated token MUST be referenced in the transaction\")\n                                },\n                                addingEntry{key, tokenName} => {\n                                    charterData : CapoDatum::CharterData = cctx.getCharterData();\n                                    nextCharterData = cctx.getNextCharterData();\n                                    REQT(\"the indicated token MUST be referenced in the transaction\");\n                                    _refInput = cctx.delegatedDataRef(recIdBytes: tokenName);\n\n                                    REQT(\"the new entry MUST be found in the new manifest\");\n                                    nextCharterData.manifest.get_safe(key).switch {\n                                        None => error(\"the new manifest entry is missing: \"+key),\n                                        Some{CapoManifestEntry{entryType, tn, mph}} => {\n                                            print(\"   -- ok, found the manifest entry for \"+ key);\n                                            REQT(\"the new entry must have the right token-name\");\n                                            assert(tn == tokenName, \"token-name mismatch\");\n                                            mph.switch { Some => error(\"other-mph not yet supported\") };\n                                            entryType.switch {\n                                                NamedTokenRef => print(\"   -- ok: matching name, with NamedTokenRef added in updatingManifest\"),\n                                                _ => error(\"addingEntry: the new manifest entry must be a NamedTokenRef for now\")                                                \n                                            }\n                                        }\n                                    };\n                                    REQT(\"the remainder of the manifest must be unchanged\");\n                                    // NOTE if you're troubleshooting a txn-building functoin, that the order \n                                    //   of elements is significant.\n                                    assert(charterData.manifest == nextCharterData.manifest.delete(key),\n                                        \"manifest modified in an unexpected way\"\n                                    );\n                                    print(\"  -- ok! new manifest as expected\")\n                                },\n                                forkingThreadToken{_key, _newThreadCount} => {\n                                    assert(cctx.nowActingAsMintDgt(), \"<----- that can fail, this can't\");\n                                    assert(false, \"TODO: support forkingThreadToken activity\");\n                                    REQT(\"the indicated token MUST be referenced in the transaction\");\n                                    REQT(\"validates that another copy of the token name is minted\");\n                                    REQT(\"when the key is a DgDataPolicy, the existing manifest entry is updated\");\n                                    REQT(\"for mint/spend delegates and otherNamedDelegates, a new manifest entry is created with refCount=1+newThreadCount, if it doesn't exist\");\n                                    REQT(\"when the manifest already has the entry, the refCount is incremented by newThreadCount\")\n\n                                }\n                            }; // void assertions;\n                            true\n                        },\n                        forcingNewMintDelegate => {\n                            REQT(\"a forced delegate change is an escape-hatch only involving the minter and the Capo\");\n                            error(\"the mint/spend delegate never is involved when the minter is instructed to force a new delegate\")\n                        },\n                        forcingNewSpendDelegate => {\n                            REQT(\"a forced delegate change is an escape-hatch only involving the minter and the Capo\");\n                            error(\"the mint/spend delegate never is involved when the spender is instructed to force a new delegate\")\n                        }\n                    } && if (true) { \n                        print(\"BasicDelegate harness deferring to specialization for CapoLifecycleActivities\\n\");\n                        true\n                    } else { false }\n                },\n\n                // NOTE: this is a mint delegate activity on the mintDgt-* token,\n                // ... used only in a Capo's MINT delegate.  Once the specialized mint delegate includes\n                // ... the delegated-data controller's UUT through the re-delegation pattern,\n                // ... the delegated-data controller  picks up the thread of enforcement, via Its specialized \n                // ... delegate module's additionalDelegateValidation(), by handling the \n                // ... MintingActivities variant indicated in the *Ctrl-* token's activity/redeemer.  \n                // It can be tricky to recognize that this code module serves the mint delegate, \n                // ... and that it ALSO serves the data-controller delegate separately, in that completely different\n                // ... context and using its separate specialization module.\n                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, \n                // ... while processing different tokens for each zone of authority/responsibility.\n                CreatingDelegatedData{seed, dataTypePurpose} => {\n                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();\n                    REQT(\"context: CreatingDelegatedData\");\n                    assert(isMintDelegate && cctx.nowActingAsMintDgt(), \"<---- fails in there, not here\");\n\n                    REQT(\"  -- ensures the data-controller is invoked with its minting activity for the indicated recId\");\n                    policyDelegateInput = cctx.\n                        requiresDgDataPolicyInput(dataTypePurpose);\n\n                    tnFactory : (String) -> String = mkUutTnFactory(seed);\n                    purpose = policyDelegateInput.idPrefix.unwrap();\n                    newDataId : ByteArray = tnFactory( purpose ).encode_utf8();\n                    // as a mint delegate, we should see to it that any minting does play by the rules\n                    //   ... however, this module is generic, so we can only perform generic checks here.\n                    //   ... we additionally call application-provided validation (provided by a specialization)\n                    //       (we haven't fully implemented generic data-controller registration, so that's a key limitation for now)\n                    // xxx WE are the mint delegate : ) -  cctx.requiresMintDelegateInput().requiresValidOutput() \n                    // this needs to be done by the speciization for now\n                    // && cctx.requiresDelegatedDataController(dataTypePurpose).requiresDataMinting()                    \n\n                    // dgDataPolicy = cctx.findManifestEntry(dataTypePurpose).switch {\n                    //     None => error(\n                    //         \"can't create delegatedData without a matching '\"+\n                    //         dataTypePurpose+\"' dgDataPolicy entry in the capo manifest\"),\n                    //     Some{mEntry} => {\n                    //         mEntry.entryType.switch {\n                    //             DgDataPolicy{policyLink, _refCount} => policyLink,\n                    //             _ => error(\n                    //                 \"can't create delegatedData type '\"+\n                    //                 dataTypePurpose+\n                    //                 \"'; its Capo manifest entry is not a DgDataPolicy\"\n                    //             )\n                    //         }\n                    //     }\n                    // };\n\n                    true\n                    && validateUutMinting(\n                        mph: dd.mph,\n                        seed: seed,\n                        purposes: []String{purpose},\n                        // otherMintedValue: ()\n                        mkTokenName: tnFactory,\n                        // WE ARE the mint delegate.\n                        needsMintDelegateApproval: false \n                    // ).trace(\n                    //     \" ✅ checked basic UUT minting \"\n                    )\n                    && bREQT(\"it outputs the new delegated-data record to the Capo address\")\n                    && cctx.mustOutputDelegatedData(\n                        newDataId, dataTypePurpose\n                    )\n                    && bREQT(\"ensures the data-controller is invoked with ONE minting activity for the indicated recId\")\n                    && policyDelegateInput.\n                        withUniqueSeededMintingActivity(seed).\n                        orFail()\n\n                    // assert(false, \"^^^ does it implement the generic data-controller re-delegation convention? ^^\");\n\n                },\n                // This is a Spend delegate activity on the spendDgt-* token, \n                // ... used within a Capo's SPEND delegate (which code may also govern \n                // ... its mintDgt- token, under separate utxo cover).\n                // Once the specialized spend delegate includes the delegated-data controller UUT through the re-delegation pattern,\n                // ... the spend delegate's specialized module picks up the thread of enforcement via its\n                // ... additionalDelegateValidation(), by handling the SpendingActivities variant indicated in the *Pol-* token's activity/redeemer.\n                // That controller activity may alternatively be a MultiActivity, one of whose nested activities provides \n                // ... the needed SpendingActivities variant.\n                // It can be tricky to recognize that this code module serves the spend delegate and the mint delegate,\n                // ... and that it ALSO serves the data-controller delegate separately, in that completely different context \n                // ... and using its separate specialization module.\n                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, \n                // ... while processing different tokens for each zone of authority/responsibility.\n                UpdatingDelegatedData{dDataType, recId} => {\n                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();\n                    assert(cctx.nowActingAsSpendDgt(), \"<---- fails in there, not here\");\n                    REQT(\"EXPECTS j6bmfv: all and ONLY DelegatedData datums must be spent with the Capo's spendingDelegatedData activity\");\n\n                    REQT(\"implements a generic data-controller re-delegation convention based on the capo's manifest (those with type= DgDataPolicy)\");\n\n                    REQT(\"ensures the data-controller is invoked with ONE spending activity for the indicated recId\");\n                    assert( cctx.\n                        requiresDgDataPolicyInput(dDataType).\n                        withUniqueDDSpendingActivity(recId).\n                        orFail(),\n                         \"^^^ those can fail, this assert won't.\"\n                    );\n\n                    inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);\n                    assert(inputDD == inputDD, \"no way m\");\n                    // ^^ same as vv\n                    // hasDDofType : (TxInput) -> Bool = cctx.mkDelegatedDataPredicate(dDataType);\n                    // simply finding the input is enough to imply that the that those utxos are spend-governed by the Capo \n                    // ... which at j6bmfv, explicitly requires the token that leads to this code path\n                    // ddInputs : []TxInput = ctx.tx.inputs.filter(hasDDofType);\n                    // assert(ddInputs.length == 1, \"extra DD input(s)\");\n\n\n                    if (\"settings\" == dDataType) {\n                        curSettingsId = cctx.getSettingsId(required: true).unwrap();\n                        TODO(\n                            \"when updating the current Capo settings, the delegates must all \"+\n                            \"have a chance to ensure the settings are valid for their needs\"\n\n                            // NOTE that requiring all policies to validate the settings update\n                            // in a single transaction carries a risk of requiring a transaction that\n                            // will be over-limit in some dimension.  To address this, the data structure\n                            // for a pending update should be able to include a list of policies that\n                            // haven't yet validated the settings; each one can validate and remove itself\n                            // from the list; then, the commit can happen when the list becomes empty.\n\n                            // ... as a special case, a single transaction that commits the changes AND\n                            // involves all the remaining policies from the list doing the validation can\n                            // be used to commit the changes, reducing transaction count needed to \n                            // complete the update.\n                        );\n                        if( false ) {\n                            if (curSettingsId == recId) {\n                                print(\" -> \");\n                                assert(\n                                    // fails if the delegates aren't all validating settings:\n                                    cctx.allDelegatesAreValidatingSettings(),\n                                    // can't fail:\n                                    \"no way jose\"\n                                );\n                                print( \" <- \")\n                            } else {\n                                recIdStr = recId.decode_utf8();\n                                curSettingsIdStr = curSettingsId.decode_utf8();\n                                print(\"  -- NOTE: updating \"+ recIdStr +\", which isn't currentSettings=\"+curSettingsIdStr)\n                            }\n                        }\n                    };\n\n                    cctx.mustOutputDelegatedData(recId, dDataType).trace(\"  -- did output delegated data? \")\n                    && true\n                },\n\n                DeletingDelegatedData {_dataType, recId} => {\n                    cctx : CapoCtx = mkCapoCtx(dd.mph).withCharterRef();\n\n                    REQT(\"this code is triggered by both the mintDgt and spendDgt, with each doing their parts of the job\");\n                    REQT(\"the spendDgt allows the spending of the utxo\");\n                    REQT(\"the mintDgt requires the burning of its UUT\");\n                    REQT(\"it must not delete a record that's still referenced by the Capo manifest\");\n                    REQT(\"a matching manifest entry has to be changed or removed prior to deletion\");\n\n                    _inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);\n                    // the mintDelegate should be triggered with \n                    TODO(\"verify the input was found ^\");\n\n                    assert(false, \"Delete not supported yet\");\n\n                    TODO(\"implement the generic data-controller re-delegation convention here\");\n                    TODO(\"ensure that the right delegate is consulted with its BurningActivities.*\");\n\n                    cctx.nowActingAsMintDgt() &&\n                    false\n                },\n                // We made these explicit so they're functionally required of every specialized delegate.\n                // All of the mint/spend/burn activities must be handled by the specialized delegate.  \n                // Note that this code module is generic, so it can't know the internal semantics of those activities,\n                // ... or even what their nested variants will be.  It's up to the specialization to handle them.\n                // Each of these indicates plural \"activities\", but they're actually each an individual, discrete, single activity\n                // ... with an Enum allowing ONE of various possible specialization-specific activities at that spot.\n                // ... MultipleActivities would be used to express \"it does multiple separate activities on different utxos\")\n                SpendingActivities => true, // handled by the specialized delegate\n                MintingActivities => true,  // handled by the specialized delegate\n                BurningActivities => true // handled by the specialized delegate\n            } && if (activity.additionalDelegateValidation(isD)) {\n                print (\"delegate: \"+ delegateName + \": additionalDelegateValidation ok!\\n\");\n                true\n            } else {\n                error(\"delegate: \"+ delegateName + \": additionalDelegateValidation returned false (without any thrown error)\")\n            }\n        },\n        _ => {\n            // to trigger an invalid redeemer, call this function\n            kaboomInvalidRedeemer = () -> {  error(\"wrong Actvy/dtm\") }; // Activity custom datum must not use Activities reserved for IsDelegation datum.\") };\n\n            activity.switch{\n                DelegateLifecycleActivities => kaboomInvalidRedeemer(), \n                CapoLifecycleActivities => kaboomInvalidRedeemer(),\n                _ => activity.otherDatumValidation(mdd)\n            }\n        }\n    };\n\n    print (\"🚥🟢 delegate: \"+ delegateName + \": ok!\\n\");\n\n    result\n}\n",
  project: "stellar-contracts",
  purpose: "spending",
  name:  "src/delegation/BasicDelegate.hl", // source filename
  moduleName:  "BasicDelegate",
};

const USING_EXTENSION = Symbol("USING_EXTENSION");
class CapoDelegateBundle extends HeliosScriptBundle {
  isConcrete = false;
  /**
   * Creates a CapoDelegateBundle subclass based on a specific CapoHeliosBundle class
   */
  static usingCapoBundleClass(c) {
    const cb = new c();
    const newClass = class aCapoBoundBundle extends this {
      capoBundle = cb;
      constructor() {
        super(USING_EXTENSION);
      }
      isConcrete = true;
    };
    return newClass;
  }
  constructor(isUsingExtension) {
    if (!isUsingExtension) {
      throw new Error(
        "CapoDelegateBundle is abstract; create your base class like this:\n class \u2039YourBundle\u203A extends CapoDelegateBundle.usingCapoBundleClass(\u2039some CapoHeliosBundleClass \u203A) {\n     ... \n}"
      );
    }
    super();
  }
  // constructor(public capoBundle: CapoHeliosBundle) {
  //     super();
  // }
  get main() {
    return heliosModule$4;
  }
  get moduleName() {
    const specialDgt = this.specializedDelegateModule;
    if (!specialDgt.moduleName) {
      throw new Error(
        "specializedDelegate module must have a moduleName"
      );
    }
    return specialDgt.moduleName;
  }
  /**
   * A list of modules always available for import in the delegate policy script
   */
  implicitIncludedModules() {
    return [
      "CapoMintHelpers",
      "CapoDelegateHelpers",
      "StellarHeliosHelpers",
      "CapoHelpers"
    ];
  }
  /**
   * specifies a list module names to be included in the build for this delegate
   * @remarks
   * Each of these modules MUST be
   * provided by the CapoHeliosBundle (`get modules()`) used to create this delegate.
   * By default, CapoMintHelpers, CapoDelegateHelpers, StellarHeliosHelpers and CapoHelpers
   * are available for import to the delegate policy script.  
   * 
   * For Capos with augmented module-lists, this method is used to make any of those additional
   * modules available to the delegate policy bundle.
   * 
   */
  includeFromCapoModules() {
    return [];
  }
  get modules() {
    const specialDgt = this.specializedDelegateModule;
    const delegateWrapper = this.mkDelegateWrapper(specialDgt.moduleName);
    const includeList = [
      ...this.implicitIncludedModules(),
      ...this.includeFromCapoModules()
    ];
    const capoIncludedModules = this.capoBundle.modules.filter((x) => includeList.includes(x.moduleName));
    console.log("INCLUDE: ", {
      includeList,
      included: includeList.length,
      capoIncludedModules: capoIncludedModules.length
    });
    debugger;
    return [
      ...capoIncludedModules,
      delegateWrapper,
      this.specializedDelegateModule
    ];
  }
  mkDelegateWrapper(moduleName) {
    const indent = " ".repeat(8);
    const src = `module specializedDelegate
import {
    DelegateActivity,
    DelegateDatum,
    BurningActivity,
    MintingActivity,
    SpendingActivity
} from ${moduleName}
`;
    return makeSource(src, {
      name: `generatedSpecializedDelegateModule`,
      project: "stellar-contracts",
      moreInfo: `${indent}- wraps ${moduleName} provided by ${this.constructor.name}
${indent}  (generated by stellar-contracts:src/delegation/ContractBasedDelegate.ts:mkDelegateWrapper())`
    });
  }
}

const heliosModule$3 = {
  content: "minting CapoMinter\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash,\n    get_current_minting_policy_hash,\n    get_cont_outputs\n} from ScriptContext\n\nimport { \n    hasSeedUtxo, \n    mkUutTnFactory,\n    requiresMintDelegateApproval,\n    validateUutMinting, \n    MinterActivity\n} from CapoMintHelpers\n\nimport {\n    CapoDatum,\n    CapoActivity,\n    getRefCharterUtxo,\n    mkCapoCtx\n} from CapoHelpers\n\nimport {\n    DgTknDisposition as DgTkn,\n    RelativeDelegateLink\n} from CapoDelegateHelpers\n\nimport {\n    mustFindInputRedeemer,\n    REQT,\n    TODO,\n    mkTv,\n    outputAndDatum,\n    tvCharter\n} from StellarHeliosHelpers\n\n// seed parameters provide uniqueness for the script validator hash:\nconst seedTxn : TxId = TxId::new(#1234)\nconst seedIndex : Int = 42\nconst rev : Int = 1\n\nfunc hasContractSeedUtxo(tx: Tx) -> Bool {\n    REQT(\"verifies that the provided seed utxo is being spent, providing uniqueness assurances for the minting-script's seed parameters\");\n\n    hasSeedUtxo(tx, TxOutputId::new(seedTxn, seedIndex))\n}\n\nfunc main(r : MinterActivity) -> Bool {\n    mph: MintingPolicyHash = get_current_minting_policy_hash();\n    value_minted: Value = tx.minted;\n    assert(true || (/* never evaluated */ rev.serialize() == rev.serialize()), \"no\");\n    assert(true || (/* never evaluated */ seedTxn.serialize() == seedTxn.serialize()), \"no\");\n    print(\" 🚥❓ Capo minter: policy id: \" + get_current_minting_policy_hash().show());\n\n    ok : Bool = r.switch {\n        charter: mintingCharter => {\n            charterVal : Value = mkTv(mph, \"charter\");\n\n            // these must be sorted BY LENGTH FIRST, then lexicographically\n            //   (actually byte-wise, but ~same diff)\n            // settingsTnBase: String = \"set\";\n            authTnBase : String = \"capoGov\";\n            mintDgtTnBase : String = \"mintDgt\";  \n            spendDgtTnBase: String = \"spendDgt\";\n            purposes = []String{\n                // settingsTnBase,\n                authTnBase, \n                mintDgtTnBase, \n                spendDgtTnBase\n            };\n            // settingsDgtTnBase: String = \"settingsDgt\"\n            // if (charter.withSettings) purposes = purposes + []String{ settingsDgtTnBase, \"settings\" }\n\n            print(\"  -- creating Capo charter\");\n            REQT(\"must mint the charter token\");\n            assert(value_minted >= charterVal,\n                \"charter token not minted\");\n\n            hasSeed: Bool = hasContractSeedUtxo(tx);\n            minterSeed: TxOutputId = TxOutputId::new(seedTxn, seedIndex);\n            mkUutName: (String) -> String = mkUutTnFactory(\n                minterSeed  \n            );\n            REQT(\"must mint uuts for mintDgt, spendDgt, and govAuth using the same seed\");\n            mintsUuts: Bool = validateUutMinting(\n                mph: mph,\n                seed: minterSeed,\n                purposes: purposes, \n                mkTokenName: mkUutName,\n                bootstrapCharter: charterVal\n            );\n            REQT(\"must deposit the charter token to the new Capo address\");\n            charterOutput: TxOutput = tx.outputs.find( (output: TxOutput) -> Bool {\n                output.address == charter.owner &&\n                    output.value.contains(charterVal)\n            });\n            // ^^ fails if there's no charter output to the right address\n\n            // print(\"defaultMinter @C\");\n            rawCharterData : Data = charterOutput.datum.inline;\n            charterData = CapoDatum::CharterData::from_data(rawCharterData);\n            CharterData{\n                spendDgt, \n                spendInvariants,\n                namedDelegates,\n                mintDgt, \n                mintInvariants, \n                authDgt,\n                manifest,\n                pendingDelegates\n            } = charterData;\n            // settings are not essential to a Capo.\n            // ... some Capos could use settings, and it would be\n            // ... up to its mint/spend delegate to enforce their presence.\n            // Also, their verification by other delegates, in case of updating\n            // the settings.  This gives settings a slightly special role,\n            // but much less than the special status they had when Settings\n            // were a separate datum type.\n\n            REQT(\"the new charter must not have any mint invariants, spend invariants, manifest entry or pending-delegate-actions\");\n            // once we have burned down the test backlog a bit, we can add these in:\n            assert(mintInvariants.length == 0, \"no mint invariants allowed at charter creation\");\n            assert(spendInvariants.length == 0, \"no spend invariants allowed at charter creation\");\n            assert(manifest.length == 0, \"no UUTs allowed at charter creation\");\n            assert(pendingDelegates.length == 0, \"no pending delegates allowed at charter creation\");\n\n            REQT(\"the new charter must have mintDgt, spendDgt, and authDgt tokens, each deposited to their separate script addresses\");\n            print(\"  -- checking for required delegates\\n\");\n            hasGoodDelegates : Bool = true &&\n                authDgt.hasValidOutput(mph, true, DgTkn::Created) &&\n                mintDgt.hasValidOutput(mph, true, DgTkn::Created) &&\n                spendDgt.hasValidOutput(mph, true, DgTkn::Created) &&\n                true;\n\n                // if (charter.withSettings) {\n                //     REQT(\"when 'withSettings' is true, there must be a settings-policy delegate created\");\n                //     assert(namedDelegates.length == 1, \"only settingsDgt allowed at charter creation\");\n                    \n                //     settingsDgt = namedDelegates.get_safe(\"settingsPolicy\").switch {\n                //         None => error(\"missing required named delegate 'settingsPolicy'\"),\n                //         Some{dgt} => dgt\n                //     };\n                //     settingsDgt.hasValidOutput(mph, true, DgTkn::Created)\n\n                //     REQT(\"with settings, there must be a settings datum stored in the Capo\");\n                //     cctx = mkCapoCtx(mph).nowMinting(charter.owner, charterOutput);\n                //     foundSettingsOutput : TxOutput = cctx.delegatedOutputData(\n                //         mkUutName(settingsTnBase)\n                //     );\n                \n                //     // tx.outputs.find_safe( (output: TxOutput) -> Bool {\n                //     //     output.address == charter.owner &&\n                //     //         output.value.contains(mkTv(mph, mkUutName(settingsTnBase))\n                //     // }).switch {\n                //     //     None => error(\"missing required settings data\"),\n                //     //     Some{output} => output\n                //     // };\n                                    \n                //     outputAndDatum[CapoDatum::DelegatedData] = \n                //         charterData.mustFindSettingsOutput(mph: mph, inAddr: charter.owner);\n                //     assert(foundSettings == foundSettings, \"no way, no\");\n\n                //     true\n                // } else { \n                //     assert(namedDelegates.length == 0, \"no named delegates allowed at charter creation\");\n                //     true\n                //  };\n\n            assert(namedDelegates.length == 0, \"no named delegates allowed at charter creation\");\n\n\n            print(\"\\n  -- hasSeed: \" + hasSeed.show());\n            print(\"\\n  -- mintsUuts: \" + mintsUuts.show());\n            print(\"\\n  -- hasGoodDelegates: \" + hasGoodDelegates.show());\n        \n            true\n            && hasGoodDelegates \n            && mintsUuts \n            && hasSeed\n        },\n\n        // ------------------------- MOST MINTING ACTIVITIES USE THIS CODE PATH --------------------\n        mintWithDelegateAuthorizing => {\n            print(\"mintWithDelegateAuthorizing\\n\");\n            requiresMintDelegateApproval(mph)\n            // -------------------------  ^^^ deferring to the Capo's current minting delegate --------------------\n        },\n        _ => {\n            cctx = mkCapoCtx(mph).withCharterInput();\n            r.switch {\n                mintingCharter => error(\"unreachable\"),\n                mintWithDelegateAuthorizing => error(\"unreachable\"),\n                addingMintInvariant{_seed} => {\n                    print(\"checking for addingMintInvariant\\n\");\n                    assert(false, \"should be handled by the mintDelegate!\");\n                    false\n                },\n\n                addingSpendInvariant{_seed} => {\n                    print(\"checking for addingSpendInvariant\\n\");\n                    assert(false, \"should be handled by the mintDelegate!\");\n                    false\n                },\n\n                forcingNewMintDelegate{seed} => {\n                    print(\"checking for forcingNewMintDelegate\\n\");\n                    badCharterActivity = \"when forcingNewMintDelegate, capo charter must be spent with its capoLifecycleActivity.forcingNewMintDelegate activity\";\n                    REQT(\"Ensures the Capo charter is also forcingNewMintDelegate\");\n                    cctx.getCharterRedeemer().switch {\n                        capoLifecycleActivity{activity} => activity.switch {\n                            forcingNewMintDelegate{seedToCapo, purpose} => {\n                                print(\"WARNING: capo lifecycle activity is forcing a new mint-delegate with its Escape-hatch activity\");\n                                print(\"NOTE: the normal lifecycle is to use minter:mintWithDelegateAuthorizing, \\n\"+\n                                    \"  ... which defers to the Capo's current minting delegate and allows \\n\"+\n                                    \"  ... queuePendingChange(role: MintDgt) to queue the new mint delegate for installation\"\n                                );\n                                REQT(\"Ensures the new mintDgt-* uut is minted with a seed\");\n                                assert(seed == seedToCapo, \"seed mismatch:\"+\n                                    \"\\n  - Capo activity seed: \"+seedToCapo.show()+\n                                    \"\\n  - Minter seed: \"+seed.show()\n                                );\n                                assert(\"mintDgt\" == purpose, \"wrong Capo purpose '\"+purpose+\"'; should be 'mintDgt'\");\n                                validateUutMinting(\n                                    mph: mph,\n                                    seed: seed,\n                                    purposes: []String{purpose},\n                                    // forcing the new dgt; don't involve the current mintDgt\n                                    needsMintDelegateApproval: false \n                                )\n                            }, \n                            _ => error(badCharterActivity)\n                            \n                            // queuePendingChange{capoActivitySeed, purpose, role, name} => {\n                            //     assert(purpose == \"mintDgt\", \"wrong purpose\");\n                            //     role.switch {\n                            //         MintDgt => {\n                            //             print(\"ok: capo lifecycle activity is adding a (pending) mint-delegate\");\n                            //             true\n                            //         }, \n                            //         _ => error(\"wrong role in capo lifecycle activity\")\n                            //     }\n                            // }\n                        },\n                        _ => error(badCharterActivity)\n                    }\n                },\n\n                CreatingNewSpendDelegate{seed, replaceExisting} => {\n                    print(\"checking for CreatingNewSpendDelegate\\n\");\n\n                    needsCapoForcedInstall = replaceExisting.switch {\n                        Some => false,\n                        None => true\n                    };\n\n                    otherMintedValue : Value = replaceExisting.switch {\n                        Some{oldTokenName} => {\n                            BURNED: Int = -1;\n                            Value::new(\n                                AssetClass::new(mph, oldTokenName), \n                                BURNED\n                            )\n                        },\n                        None => Value::ZERO\n                    };\n                    mkTokenName = mkUutTnFactory(seed);\n                    spendDgtTn = mkTokenName(\"spendDgt\");\n\n                    hasCapoApproval = if (!needsCapoForcedInstall) {\n                        cctx.getCharterRedeemer().switch {\n                            updatingCharter => {\n                                TODO(\"the minter should see that the new spend delegate is QUEUED for installation by the Capo\");\n                                TODO(\"this essential logic vvvv will move to the installation moment\");\n                                REQT(\"the updated charter must reference the new spend delegate\");\n                                RelativeDelegateLink{uutName, _dvh, _config} = cctx.getNextCharterData().spendDelegateLink;\n                                print(\"expected uutName: \"+uutName);\n                                print(\"spendDgtTn in charter: \"+spendDgtTn);\n                                assert(uutName == spendDgtTn, \"new spend delegate not referenced in updated charter\");\n                                \n                                REQT(\"EXPECTS the Capo to validate that only the one thing is updated, and that the new UUT is deposited where it's expected\");\n                                true\n                            },\n                            // capoLifecycleActivity{activity} => activity.switch {                                \n                            // queuePendingChange{capoActivitySeed, purpose, role, name} => {\n                            //     assert(!replaceExisting, \"queuePendingChange can't use replaceExisting option\");\n\n                            //     assert(purpose == \"spendDgt\", \"wrong purpose\");\n                            //     role.switch {\n                            //         SpendDgt => {\n                            //             print(\"ok: capo lifecycle activity is adding a (pending) spend-delegate\");\n                            //             true\n                            //         }, \n                            //         _ => error(\"wrong role in capo lifecycle activity\")\n                            //     }\n                            // },\n                            _ => error(\"capo charter must be spent with its updatingCharter activity\")\n                        }\n                    } else {\n                        REQT(\"When the old dgTkn isn't replaced, it ensures the Capo charter is also forcingNewSpendDelegate\");\n                        badCharterActivity = \"when forcingNewSpendDelegate, capo charter must be spent with its capoLifecycleActivity.forcingNewSpendDelegate activity\";\n                        cctx.getCharterRedeemer().switch {\n                            capoLifecycleActivity{activity} => activity.switch {\n                                forcingNewSpendDelegate{seedToCapo, purpose} => {\n                                    print(\"WARNING: capo lifecycle activity is forcing a spend-delegate with its Escape-hatch activity\");\n                                    print(\"NOTE: the normal lifecycle is to use minter:mintWithDelegateAuthorizing, \\n\"+\n                                        \"  ... which defers to the Capo's current minting delegate and allows \\n\"+\n                                        \"  ... queuePendingChange(role: SpendDgt) to queue the new spend delegate for installation\"\n                                    );\n\n                                    REQT(\"Ensures the Capo activity's seed matches the minter's seed\");\n                                    assert(seed == seedToCapo, \"seed mismatch: \"\n                                        + \"\\n  - Capo activity seed: \" + seedToCapo.show()\n                                        + \"\\n  - Minter seed: \" + seed.show()\n                                    );\n                                    assert(\"spendDgt\" == purpose, \"wrong Capo purpose '\"+purpose+\"'; should be 'spendDgt'\");\n                                    true\n                                },\n                                _ => error(badCharterActivity)\n                            },\n                            _ => error(badCharterActivity)\n                        }\n                    };\n\n                    REQT(\"Ensures the new spendDgt-* uut is uniquely minted using the seed\");\n                    didMintUuts = validateUutMinting(\n                        mph: mph,\n                        seed: seed,\n                        purposes: []String{ \"spendDgt\" },\n                        mkTokenName: mkTokenName,\n                        otherMintedValue: otherMintedValue,\n                        // forcing the new dgt; don't involve the current mintDgt\n                        needsMintDelegateApproval: false \n                    );\n\n                    didMintUuts && hasCapoApproval\n                }        \n            }\n            // _ => true // don't catch other variants, for complete coverage above.\n        }\n    };\n\n    // print(\"defaultMinter: minting value: \" + value_minted.show());\n    print(\"\\n\\n🚥🟢 Capo minter: ok!\\n\");\n    // assert(false, \"barfola\");\n    ok\n}\n\n",
  project: "stellar-contracts",
  purpose: "minting",
  name:  "src/minting/CapoMinter.hl", // source filename
  moduleName:  "CapoMinter",
};

class CapoMinterBundle extends HeliosScriptBundle.usingCapoBundleClass(CapoHeliosBundle) {
  // // no datum types in this script
  // declare Activity: makesUplcActivityEnumData<MinterActivityLike>;
  // constructor(capoBundle: CapoHeliosBundle) {
  //     super();
  //     this.capoBundle = capoBundle;
  // }
  get main() {
    return heliosModule$3;
  }
  get modules() {
    return [...this.capoBundle.modules];
  }
}

class EnumBridge extends DataBridge {
  constructor(options = {}) {
    super(options);
  }
  // the uplcReturnType provides type clues, mainly for editor support
  // and compile-time type-checking.  
  mkUplcData(value, enumPathExpr) {
    if (this.redirectTo) {
      return this.redirectTo(value);
    }
    const uplc = this["\u1C7A\u1C7Acast"].toUplcData(value, enumPathExpr);
    uplc.toString();
    bytesToHex(uplc.toCbor());
    uplc.dataPath = enumPathExpr;
    if (this.isActivity) {
      return {
        redeemer: uplc
      };
    } else {
      return uplc;
    }
  }
}

class CapoMinterDataBridge extends ContractDataBridge {
  static isAbstract = false;
  isAbstract = false;
  datum = void 0;
  // no datum type defined for this bundle (minter / rewards script)
  /**
   * generates UplcData for the activity type (***MinterActivity***) for the `CapoMinter` script
   */
  activity = new MinterActivityHelper({ isActivity: true });
  // activityAccessor/enum
  MinterActivity = this.activity;
  reader = new CapoMinterDataBridgeReader(this);
  /**
   * accessors for all the types defined in the `CapoMinter` script
   * @remarks - these accessors are used to generate UplcData for each type
   */
  types = {
    /**
     * generates UplcData for the enum type ***MinterActivity*** for the `CapoMinter` script
     */
    MinterActivity: new MinterActivityHelper(),
    /**
     * generates UplcData for the enum type ***RelativeDelegateLink*** for the `CapoMinter` script
     */
    RelativeDelegateLink: (fields) => {
      return this["\u1C7A\u1C7ARelativeDelegateLinkCast"].toUplcData(fields);
    }
  };
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ARelativeDelegateLinkCast" = makeCast(
    RelativeDelegateLinkSchema$3,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
}
class CapoMinterDataBridgeReader extends DataBridgeReaderClass {
  constructor(bridge) {
    super();
    this.bridge = bridge;
  }
  /**
      * reads UplcData *known to fit the **MinterActivity*** enum type,
      * for the CapoMinter script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  MinterActivity(d) {
    const typeHelper = this.bridge.types.MinterActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **RelativeDelegateLink*** struct type,
      * for the CapoMinter script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  RelativeDelegateLink(d) {
    const cast = this.bridge["\u1C7A\u1C7ARelativeDelegateLinkCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
}
class MinterActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    MinterActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoMintHelpers::MinterActivity.mintingCharter"***
   */
  mintingCharter(owner) {
    const uplc = this.mkUplcData({
      mintingCharter: owner
    }, "CapoMintHelpers::MinterActivity.mintingCharter");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoMintHelpers::MinterActivity.mintWithDelegateAuthorizing"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get mintWithDelegateAuthorizing() {
    const uplc = this.mkUplcData(
      { mintWithDelegateAuthorizing: {} },
      "CapoMintHelpers::MinterActivity.mintWithDelegateAuthorizing"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
  * generates isActivity/redeemer wrapper with UplcData for ***"CapoMintHelpers::MinterActivity.addingMintInvariant"***, 
  * given a transaction-context (or direct arg) with a ***seed utxo*** 
  * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
  *  - to get a transaction context having the seed needed for this argument, 
  *    see the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.
  * - or see the {@link hasSeed} type for other ways to feed it with a TxOutputId.
  *  - in a context providing an implicit seed utxo, use 
  *    the `$seeded$addingMintInvariant}` variant of this activity instead
  *
   */
  addingMintInvariant(thingWithSeed) {
    const seedTxOutputId = this.getSeed(thingWithSeed);
    const uplc = this.mkUplcData({
      addingMintInvariant: seedTxOutputId
    }, "CapoMintHelpers::MinterActivity.addingMintInvariant");
    return uplc;
  }
  /*singleField/seeded enum variant*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoMintHelpers::MinterActivity.addingMintInvariant"***
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   * ## Usage
   * Access the activity-creator as a getter: `$seeded$addingMintInvariant`
   *
   * Use the resulting activity-creator in a seed-providing context, such as the delegated-data-controller's
   * `mkTxnCreateRecord({activity, ...})` method.
   */
  get $seeded$addingMintInvariant() {
    return impliedSeedActivityMaker(this, this.addingMintInvariant)();
  }
  /* coda: seeded helper in same singleField/seeded enum variant*/
  /**
  * generates isActivity/redeemer wrapper with UplcData for ***"CapoMintHelpers::MinterActivity.addingSpendInvariant"***, 
  * given a transaction-context (or direct arg) with a ***seed utxo*** 
  * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
  *  - to get a transaction context having the seed needed for this argument, 
  *    see the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.
  * - or see the {@link hasSeed} type for other ways to feed it with a TxOutputId.
  *  - in a context providing an implicit seed utxo, use 
  *    the `$seeded$addingSpendInvariant}` variant of this activity instead
  *
   */
  addingSpendInvariant(thingWithSeed) {
    const seedTxOutputId = this.getSeed(thingWithSeed);
    const uplc = this.mkUplcData({
      addingSpendInvariant: seedTxOutputId
    }, "CapoMintHelpers::MinterActivity.addingSpendInvariant");
    return uplc;
  }
  /*singleField/seeded enum variant*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoMintHelpers::MinterActivity.addingSpendInvariant"***
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   * ## Usage
   * Access the activity-creator as a getter: `$seeded$addingSpendInvariant`
   *
   * Use the resulting activity-creator in a seed-providing context, such as the delegated-data-controller's
   * `mkTxnCreateRecord({activity, ...})` method.
   */
  get $seeded$addingSpendInvariant() {
    return impliedSeedActivityMaker(this, this.addingSpendInvariant)();
  }
  /* coda: seeded helper in same singleField/seeded enum variant*/
  /**
  * generates isActivity/redeemer wrapper with UplcData for ***"CapoMintHelpers::MinterActivity.forcingNewMintDelegate"***, 
  * given a transaction-context (or direct arg) with a ***seed utxo*** 
  * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
  *  - to get a transaction context having the seed needed for this argument, 
  *    see the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.
  * - or see the {@link hasSeed} type for other ways to feed it with a TxOutputId.
  *  - in a context providing an implicit seed utxo, use 
  *    the `$seeded$forcingNewMintDelegate}` variant of this activity instead
  *
   */
  forcingNewMintDelegate(thingWithSeed) {
    const seedTxOutputId = this.getSeed(thingWithSeed);
    const uplc = this.mkUplcData({
      forcingNewMintDelegate: seedTxOutputId
    }, "CapoMintHelpers::MinterActivity.forcingNewMintDelegate");
    return uplc;
  }
  /*singleField/seeded enum variant*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoMintHelpers::MinterActivity.forcingNewMintDelegate"***
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   * ## Usage
   * Access the activity-creator as a getter: `$seeded$forcingNewMintDelegate`
   *
   * Use the resulting activity-creator in a seed-providing context, such as the delegated-data-controller's
   * `mkTxnCreateRecord({activity, ...})` method.
   */
  get $seeded$forcingNewMintDelegate() {
    return impliedSeedActivityMaker(this, this.forcingNewMintDelegate)();
  }
  CreatingNewSpendDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        CreatingNewSpendDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoMintHelpers::MinterActivity.CreatingNewSpendDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        CreatingNewSpendDelegate: fields
      }, "CapoMintHelpers::MinterActivity.CreatingNewSpendDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoMintHelpers::MinterActivity.CreatingNewSpendDelegate"***, 
   * @param fields - \{ replacingUut: number[] | undefined \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$CreatingNewSpendDelegate({ replacingUut })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$CreatingNewSpendDelegate = impliedSeedActivityMaker(
    this,
    this.CreatingNewSpendDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
}
const MinterActivitySchema = {
  "kind": "enum",
  "name": "MinterActivity",
  "id": "__module__CapoMintHelpers__MinterActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoMintHelpers__MinterActivity[]__mintingCharter",
      "name": "mintingCharter",
      "fieldTypes": [
        {
          "name": "owner",
          "type": {
            "kind": "internal",
            "name": "Address"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoMintHelpers__MinterActivity[]__mintWithDelegateAuthorizing",
      "name": "mintWithDelegateAuthorizing",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoMintHelpers__MinterActivity[]__addingMintInvariant",
      "name": "addingMintInvariant",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoMintHelpers__MinterActivity[]__addingSpendInvariant",
      "name": "addingSpendInvariant",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoMintHelpers__MinterActivity[]__forcingNewMintDelegate",
      "name": "forcingNewMintDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 5,
      "id": "__module__CapoMintHelpers__MinterActivity[]__CreatingNewSpendDelegate",
      "name": "CreatingNewSpendDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "replacingUut",
          "type": {
            "kind": "option",
            "someType": {
              "kind": "internal",
              "name": "ByteArray"
            }
          }
        }
      ]
    }
  ]
};
const RelativeDelegateLinkSchema$3 = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
  "name": "RelativeDelegateLink",
  "fieldTypes": [
    {
      "name": "uutName",
      "type": {
        "kind": "internal",
        "name": "String"
      }
    },
    {
      "name": "delegateValidatorHash",
      "type": {
        "kind": "option",
        "someType": {
          "kind": "internal",
          "name": "ValidatorHash"
        }
      }
    },
    {
      "name": "config",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      }
    }
  ]
};

var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorateClass$5 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$5(target, key, result);
  return result;
};
class CapoMinter extends StellarContract {
  currentRev = 1n;
  scriptBundle() {
    return new CapoMinterBundle();
  }
  /**
   * the data bridge for this minter is fixed to one particular type
   */
  dataBridgeClass = CapoMinterDataBridge;
  get onchain() {
    return this.getOnchainBridge();
  }
  // get offchain(): mustFindConcreteContractBridgeType<this>["reader"] {
  //     return super.offchain as any;
  // }
  // get reader(): mustFindConcreteContractBridgeType<this>["reader"] {
  //     return super.offchain as any;
  // }
  get activity() {
    const bridge = this.onchain;
    return bridge.activity;
  }
  // get mkDatum(): mustFindDatumType<Capo<any>> {
  //     return this.onchain.datum;
  // }
  // mkBundleWithCapo<T extends HeliosScriptBundle>(BundleClass: new (capo: CapoHeliosBundle) => T) : T {
  //     const { capo } = this.configIn || this.partialConfig || {};
  //     if (!capo)
  //         throw new Error(
  //             `missing capo in config or partial-config for ${this.constructor.name}`
  //         );
  //     const capoBundle = capo.getBundle() as CapoHeliosBundle;
  //     const t = new BundleClass(capoBundle);
  //     return t
  // }
  getContractScriptParamsUplc(config) {
    const { seedIndex, seedTxn, rev = this.currentRev } = config;
    return this.paramsToUplc({
      rev,
      seedIndex,
      seedTxn
    });
  }
  get scriptActivitiesName() {
    return "MinterActivity";
  }
  activityMintingCharter(ownerInfo) {
    return this.activityRedeemer("mintingCharter", ownerInfo);
  }
  activityMintWithDelegateAuthorizing() {
    return this.activityRedeemer("mintWithDelegateAuthorizing");
  }
  activityAddingMintInvariant(seedFrom) {
    const seed = this.getSeed(seedFrom);
    return this.activityRedeemer("addingMintInvariant", { seed });
  }
  activityAddingSpendInvariant(seedFrom) {
    const seed = this.getSeed(seedFrom);
    return this.activityRedeemer("addingSpendInvariant", { seed });
  }
  activityForcingNewMintDelegate(seedFrom) {
    console.warn(
      "NOTE: REPLACING THE MINT DELEGATE USING A DIRECT MINTER ACTIVITY\nTHIS IS NOT THE RECOMMENDED PATH - prefer using the existing mint delegate's ReplacingMe activity'"
    );
    const seed = this.getSeed(seedFrom);
    return this.activityRedeemer("forcingNewMintDelegate", { seed });
  }
  activityForcingNewSpendDelegate(seedFrom, replacingUut) {
    const seed = this.getSeed(seedFrom);
    return this.activityRedeemer("forcingNewSpendDelegate", {
      seed,
      replacingUut
    });
  }
  //! overrides base getter type with undefined not being allowed
  get mintingPolicyHash() {
    return super.mintingPolicyHash;
  }
  get charterTokenAsValuesEntry() {
    return mkValuesEntry("charter", BigInt(1));
  }
  tvCharter() {
    const { mintingPolicyHash } = this;
    const v = makeValue(
      0,
      makeAssets([[mintingPolicyHash, [this.charterTokenAsValuesEntry]]])
    );
    return v;
  }
  get charterTokenAsValue() {
    console.warn(
      "deprecated use of `get minter.charterTokenAsValue`; use tvCharter() instead"
    );
    return this.tvCharter();
  }
  async txnMintingCharter(tcx, {
    owner,
    capoGov,
    mintDelegate,
    spendDelegate
  }) {
    //!!! todo: can we expect capoGov & mintDgt in tcx.state.uuts? and update the type constraint here?
    const charterVE = this.charterTokenAsValuesEntry;
    const capoGovVE = mkValuesEntry(capoGov.name, BigInt(1));
    const mintDgtVE = mkValuesEntry(mintDelegate.name, BigInt(1));
    const spendDgtVE = mkValuesEntry(spendDelegate.name, BigInt(1));
    const values = [
      charterVE,
      // settingsUutVE,
      capoGovVE,
      mintDgtVE,
      spendDgtVE
    ];
    const activity = this.activity.mintingCharter(owner);
    return tcx.addScriptProgram(
      this.compiledScript
    ).mintTokens(
      this.mintingPolicyHash,
      values,
      activity
    );
  }
  attachScript(tcx, useRefScript = true) {
    return this.configIn.capo.txnAttachScriptOrRefScript(
      tcx,
      this.compiledScript,
      useRefScript
    );
  }
  async txnMintingWithoutDelegate(tcx, vEntries, minterActivity) {
    return (await this.attachScript(tcx)).mintTokens(
      this.mintingPolicyHash,
      vEntries,
      minterActivity
    );
  }
  async txnMintWithDelegateAuthorizing(tcx, vEntries, mintDelegate, mintDgtRedeemer, skipReturningDelegate) {
    const { capo } = this.configIn;
    const md = mintDelegate || await capo.getMintDelegate();
    const tcx1 = await capo.tcxWithCharterRef(tcx);
    await md.txnGrantAuthority(
      tcx1,
      mintDgtRedeemer,
      skipReturningDelegate
    );
    return (await this.attachScript(tcx)).mintTokens(
      this.mintingPolicyHash,
      vEntries,
      this.activityMintWithDelegateAuthorizing()
    );
  }
}
__decorateClass$5([
  Activity.redeemer
], CapoMinter.prototype, "activityMintingCharter", 1);
__decorateClass$5([
  Activity.redeemer
], CapoMinter.prototype, "activityMintWithDelegateAuthorizing", 1);
__decorateClass$5([
  Activity.redeemer
], CapoMinter.prototype, "activityAddingMintInvariant", 1);
__decorateClass$5([
  Activity.redeemer
], CapoMinter.prototype, "activityAddingSpendInvariant", 1);
__decorateClass$5([
  Activity.redeemer
], CapoMinter.prototype, "activityForcingNewMintDelegate", 1);
__decorateClass$5([
  Activity.redeemer
], CapoMinter.prototype, "activityForcingNewSpendDelegate", 1);
__decorateClass$5([
  Activity.partialTxn
], CapoMinter.prototype, "txnMintingCharter", 1);
__decorateClass$5([
  Activity.partialTxn
], CapoMinter.prototype, "txnMintingWithoutDelegate", 1);
__decorateClass$5([
  Activity.partialTxn
], CapoMinter.prototype, "txnMintWithDelegateAuthorizing", 1);

const TODO = Symbol("needs to be implemented");
function hasReqts(reqtsMap) {
  return reqtsMap;
}
hasReqts.TODO = TODO;

class StellarDelegate extends StellarContract {
  static currentRev = 1n;
  static get defaultParams() {
    return { rev: this.currentRev };
  }
  /**
   * Finds and adds the delegate's authority token to the transaction
   * @remarks
   *
   * calls the delegate-specific DelegateAddsAuthorityToken() method,
   * with the uut found by DelegateMustFindAuthorityToken().
   *
   * returns the token back to the contract using {@link StellarDelegate.txnReceiveAuthorityToken | txnReceiveAuthorityToken() }
   * @param tcx - transaction context
   * @public
   **/
  async txnGrantAuthority(tcx, redeemer, skipReturningDelegate) {
    const label = `${this.constructor.name} authority`;
    const uutxo = await this.DelegateMustFindAuthorityToken(tcx, label);
    const useMinTv = true;
    const authorityVal = this.tvAuthorityToken(useMinTv);
    console.log(
      `   ------- delegate '${label}' grants authority with ${dumpAny(
        authorityVal,
        this.networkParams
      )}`
    );
    try {
      const tcx2 = await this.DelegateAddsAuthorityToken(
        tcx,
        uutxo,
        redeemer
      );
      if (skipReturningDelegate)
        return tcx2;
      return this.txnReceiveAuthorityToken(tcx2, authorityVal, uutxo);
    } catch (error) {
      if (error.message.match(/input already added/)) {
        throw new Error(
          `Delegate ${label}: already added: ${dumpAny(
            authorityVal,
            this.networkParams
          )}`
        );
      }
      throw error;
    }
  }
  /**
   * Finds the authority token and adds it to the transaction, tagged for retirement
   * @public
   * @remarks
   * Doesn't return the token back to the contract.
   **/
  async txnRetireAuthorityToken(tcx) {
    const uutxo = await this.DelegateMustFindAuthorityToken(
      tcx,
      `${this.constructor.name} authority`
    );
    return this.DelegateRetiresAuthorityToken(tcx, uutxo);
  }
  mkAuthorityTokenPredicate() {
    return this.uh.mkTokenPredicate(this.tvAuthorityToken());
  }
  get authorityTokenName() {
    return this.configIn.tn;
  }
  tvAuthorityToken(useMinTv = false) {
    if (!this.configIn)
      throw new Error(`must be instantiated with a configIn`);
    const {
      mph,
      tn
      // reqdAddress,  // removed
    } = this.configIn;
    if (useMinTv)
      return this.uh.mkMinTv(mph, tn);
    return mkTv(mph, tn);
  }
  get delegateValidatorHash() {
    return void 0;
  }
  /**
   * Captures requirements as data
   * @remarks
   *
   * see reqts structure
   * @public
   **/
  delegateRequirements() {
    return hasReqts({
      "provides an interface for providing arms-length proof of authority to any other contract": {
        purpose: "to decouple authority administration from its effects",
        details: [
          "Any contract can create a UUT for use with an authority policy.",
          "By depositing that UUT to the authority contract, it can delegate completely",
          "  ... all the implementation details for administration of the authority itself.",
          "It can then focus on implementing the effects of authority, requiring only ",
          "  ... that the correct UUT has been spent, to indicate that the authority is granted.",
          "The authority contract can have its own internal details ",
          "A subclass of this authority policy may provide additional administrative dynamics."
        ],
        mech: [],
        requires: [
          "implementations SHOULD positively govern spend of the UUT",
          "implementations MUST provide an essential interface for transaction-building"
        ]
      },
      "implementations SHOULD positively govern spend of the UUT": {
        purpose: "for sufficient assurance of desirable safeguards",
        details: [
          "A subclass of the GenericAuthority should take care of guarding the UUT's spend",
          "  ... in whatever way is appropriate for its use-case"
        ],
        mech: [],
        requires: []
      },
      "implementations MUST provide an essential interface for transaction-building": {
        purpose: "enabling a strategy-agnostic interface for making transactions using any supported strategy-variant",
        details: [
          "Subclasses MUST implement the interface methods",
          "  ... in whatever way is good for its use-case.",
          "An interface method whose requirement is marked with 'MAY/SHOULD' behavior, ",
          "  ... MUST still implement the method satisfying the interface, ",
          "  ... but MAY throw an UnsupportedAction error, to indicate that",
          "  ... the strategy variant has no meaningful action to perform ",
          "  ... that would serve the method's purpose"
        ],
        mech: [],
        requires: [
          //!!! todo: cross-check these requirements for completeness
          //  ... and for accuracy
          "requires a txnReceiveAuthorityToken(tcx, delegateAddr, fromFoundUtxo?)",
          "requires a mustFindAuthorityToken(tcx)",
          "requires a txnGrantAuthority(tcx, delegateAddr, fromFoundUtxo)",
          "requires txnRetireCred(tcx, fromFoundUtxo)"
        ]
      },
      "requires a txnReceiveAuthorityToken(tcx, delegateAddr, fromFoundUtxo?)": {
        purpose: "to deposit the authority token (back) to the delegated destination",
        details: [
          "impls MUST implement txnReceiveAuthorityToken",
          "Each implemented subclass can use it's own style to match its strategy & mechanism",
          "This is used both for the original deposit and for returning the token during a grant-of-authority"
        ],
        mech: [
          "impls MUST create a UTxO depositing the indicated token-name into the delegated destination.",
          "impls should normally preserve the datum from an already-present sourceUtxo"
        ],
        requires: []
      },
      "requires a mustFindAuthorityToken(tcx)": {
        purpose: "to locate the given authority token",
        details: [
          "allows different strategies for finding the UTxO having the authority token",
          "impls MAY use details seen in the txn context to find the indicated token"
        ],
        mech: [
          "impls MUST resolve the indicated token to a specific UTxO or throw an informative error"
        ]
      },
      "requires a txnGrantAuthority(tcx, delegateAddr, fromFoundUtxo)": {
        purpose: "to use the delegated authority",
        details: [
          "Adds the indicated utxo to the transaction with appropriate activity/redeemer",
          "Contracts needing the authority within a transaction can rely on the presence of this spent authority",
          "Impls can EXPECT the token will be returned via txnReceiveAuthorityToken",
          "a contract-backed impl SHOULD enforce the expected return in its on-chain code"
        ],
        mech: [
          "the base AuthorityPolicy MUST call txnReceiveAuthorityToken() with the token's sourceUtxo"
        ]
      },
      "requires txnRetireCred(tcx, fromFoundUtxo)": {
        purpose: "to allow burning the authority token",
        details: [
          "Adds the indicated utxo to the transaction with appropriate activity/redeemer",
          "  ... allowing the token to be burned by the minting policy.",
          "Impls SHOULD ensure any other UTXOs it may hold do not become inaccessible as a result"
        ],
        mech: [
          "impls MUST add the token to the txn if it can be retired",
          "if the token cannot be retired, by appropriate policy, it SHOULD throw an informative error"
        ]
      }
    });
  }
}

class DelegateConfigNeeded extends Error {
  errors;
  availableDgtNames;
  constructor(message, options) {
    super(message);
    const { errors, availableDgtNames } = options;
    if (errors)
      this.errors = errors;
    if (availableDgtNames)
      this.availableDgtNames = availableDgtNames;
  }
}
function delegateRoles(delegateMap) {
  return delegateMap;
}
function defineRole(delegateType, delegateClass, config, uutBaseName) {
  return {
    delegateType,
    delegateClass,
    config,
    uutPurpose: uutBaseName || delegateType
  };
}
//!!! todo: develop this further to allow easily enhancing a parent role-definition
//! a map of delegate selections needed for a transaction
//! a single delegate selection, where a person chooses

var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorateClass$4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$4(target, key, result);
  return result;
};
class ContractBasedDelegate extends StellarDelegate {
  static currentRev = 1n;
  /**
   * Configures the matching parameter name in the on-chain script, indicating
   * that this delegate serves the Capo by enforcing policy for spending the Capo's utxos.
   * @remarks
   * Not used for any mint delegate.  Howeever, a mint delegate class can instead provide a true isMintAndSpendDelegate,
   *...  if a single script controls both the mintDgt-* and spendDgt-* tokens/delegation roles for your Capo.
   *
   * DO NOT enable this attribute for second-level delegates, such as named delegates or delegated-data controllers.
   * The base on-chain delegate script recognizes this conditional role and enforces that its generic delegated-data activities
   * are used only in the context the Capo's main spend delegate, re-delegating to the data-controller which
   * can't use those generic activities, but instead implements its user-facing txns as variants of its SpendingActivities enum.
   */
  get isSpendDelegate() {
    return false;
  }
  get delegateName() {
    throw new Error(
      `${this.constructor.name}: missing required get delegateName() : string`
    );
  }
  // dataBridgeClass = CapoDataBridge;
  get onchain() {
    return this.getOnchainBridge();
  }
  get offchain() {
    return super.offchain;
  }
  get reader() {
    return super.offchain;
  }
  // get activity(): IFISNEVER<
  //     mustFindActivityType<this>, 
  //     IFISNEVER<findActivityType<this>, 
  //         ContractDataBridge["activity"]
  //     >
  // > {
  get activity() {
    const bridge = this.onchain;
    return bridge.activity;
  }
  get mkDatum() {
    return this.onchain.datum;
  }
  get newReadDatum() {
    const bridge = this.getOnchainBridge();
    const { readDatum } = bridge;
    if (!readDatum) {
      throw new Error(
        `${this.constructor.name}: this contract script doesn't use datum`
      );
    }
    return readDatum;
  }
  get capo() {
    return this.configIn?.capo;
  }
  // mkBundleWithCapo<T extends HeliosScriptBundle>(BundleClass: new (capo: CapoHeliosBundle) => T) : T {
  //     const { capo } = this.configIn || this.partialConfig || {};
  //     if (!capo)
  //         throw new Error(
  //             `missing capo in config or partial-config for ${this.constructor.name}`
  //         );
  //     const capoBundle = capo.getBundle() as CapoHeliosBundle;
  //     return new BundleClass(capoBundle);
  // }
  scriptBundle() {
    throw new Error(
      `${this.constructor.name}: missing required implementation of scriptBundle()

Each contract-based delegate must provide a scriptBundle() method.
It should return an instance of a class defined in a *.hlb.ts file.  At minimum:

    import {YourAppCapo} from "./YourAppCapo.js";

    import SomeSpecializedDelegate from "./YourSpecializedDelegate.hl";

    export default class SomeDelegateBundle extends CapoDelegateBundle.using(YourAppCapo) {
        get specializedDelegateModule() { return SomeSpecializedDelegate; }
    }

We'll generate an additional .typeInfo.ts, based on the types in your Helios sources,
  ... and a .bridge.ts with generated data-conversion code for bridging between off-chain  ... and on-chain data encoding.Your scriptBundle() method can \`return new SomeDelegateBundle()\``
    );
  }
  get scriptDatumName() {
    return "DelegateDatum";
  }
  get scriptActivitiesName() {
    return "DelegateActivity";
  }
  static get defaultParams() {
    const params = {
      rev: this.currentRev,
      isSpendDelegate: this.prototype.isSpendDelegate
    };
    return params;
  }
  static mkDelegateWithArgs(a) {
  }
  getContractScriptParamsUplc(config) {
    const {
      capoAddr,
      mph,
      tn,
      capo,
      ...otherConfig
    } = config;
    debugger;
    return this.paramsToUplc({
      ...otherConfig,
      delegateName: this.delegateName
    });
  }
  tcxWithCharterRef(tcx) {
    return this.capo.tcxWithCharterRef(tcx);
  }
  // tcxWithSettingsRef<TCX extends StellarTxnContext | hasSettingsRef>(
  //     tcx: TCX
  // ) {
  //     return this.capo.tcxWithSettingsRef(tcx);
  // }
  /**
   * Adds a mint-delegate-specific authority token to the txn output
   * @remarks
   *
   * Implements {@link StellarDelegate.txnReceiveAuthorityToken | txnReceiveAuthorityToken() }.
   *
   * Uses {@link ContractBasedDelegate.mkDelegationDatum | mkDelegationDatum()} to make the inline Datum for the output.
   * @see {@link StellarDelegate.txnReceiveAuthorityToken | baseline txnReceiveAuthorityToken()'s doc }
   * @public
   **/
  async txnReceiveAuthorityToken(tcx, tokenValue, fromFoundUtxo) {
    const datum2 = this.mkDelegationDatum(fromFoundUtxo);
    const newOutput = makeTxOutput(this.address, tokenValue, datum2);
    return tcx.addOutput(newOutput);
  }
  mkDelegationDatum(txin) {
    if (txin)
      return txin.output.datum;
    const { capoAddr, mph, tn, ..._otherCfgSettings } = this.configIn;
    return this.mkDatum.IsDelegation({
      capoAddr,
      mph,
      tn
    });
  }
  activityReplacingMe({
    seed,
    purpose
  }) {
    throw new Error(`deprecated: explicit activity helper`);
  }
  mkDelegateLifecycleActivity(delegateActivityName, args) {
    throw new Error(`deprecated: explicit activity helper`);
  }
  mkCapoLifecycleActivity(capoLifecycleActivityName, {
    seed,
    purpose,
    ...otherArgs
  }) {
    throw new Error(`deprecated: explicit activity helper`);
  }
  /**
   * Creates a reedemer for the indicated spending activity name
   **/
  mkSpendingActivity(spendingActivityName, args) {
    throw new Error(`deprecated: explicit activity helper`);
  }
  mkSeedlessMintingActivity(mintingActivityName, args) {
    const { MintingActivity } = this.onChainTypes;
    this.mustGetEnumVariant(
      MintingActivity,
      mintingActivityName
    );
    throw new Error(`mkSeedlessMintingActivity: deprecated`);
  }
  mkSeededMintingActivity(mintingActivityName, args) {
    const { MintingActivity } = this.onChainTypes;
    this.mustGetEnumVariant(
      MintingActivity,
      mintingActivityName
    );
    throw new Error(`mkSeededMintingActivity: deprecated`);
  }
  activityRetiring() {
    throw new Error(`deprecated: explicit activity helper`);
  }
  activityValidatingSettings() {
    throw new Error(`deprecated: explicit activity helper`);
  }
  // @Activity.redeemer
  activityMultipleDelegateActivities(...activities) {
    throw new Error(`deprecated: explicit activity helper`);
  }
  activityDeletingDelegatedData(recId) {
    throw new Error(`deprecated: explicit activity helper`);
  }
  mkDatumIsDelegation(dd) {
    this.onChainTypes;
    throw new Error(`deprecated: explicit datum helper`);
  }
  /**
   * returns the ValidatorHash of the delegate script, if relevant
   * @public
   * @remarks
   *
   * A delegate that doesn't use an on-chain validator should override this method and return undefined.
   **/
  get delegateValidatorHash() {
    if (!this.validatorHash) {
      throw new Error(
        `${this.constructor.name}: address doesn't use a validator hash!
  ... if that's by design, you may wish to override 'get delegateValidatorHash()'`
      );
    }
    return this.validatorHash;
  }
  /**
   * {@inheritdoc StellarDelegate.DelegateMustFindAuthorityToken}
   **/
  async DelegateMustFindAuthorityToken(tcx, label) {
    return this.mustFindMyUtxo(
      `${label}: ${decodeUtf8(this.configIn.tn)}`,
      this.uh.mkTokenPredicate(this.tvAuthorityToken()),
      "this delegate strategy might need to override txnMustFindAuthorityToken()"
    );
  }
  /**
   * Adds the delegate's authority token to a transaction
   * @public
   * @remarks
   * Given a delegate already configured by a Capo, this method implements
   * transaction-building logic needed to include the UUT into the `tcx`.
   * the `utxo` is discovered by {@link StellarDelegate.DelegateMustFindAuthorityToken | DelegateMustFindAuthorityToken() }
   *
   * The off-chain code shouldn't need to check the details; it can simply
   * arrange the details properly and spend the delegate's authority token,
   * using this method.
   *
   * ### Reliance on this delegate
   *
   * Other contract scripts can rely on the delegate script to have validated its
   * on-chain policy and enforced its own "return to the delegate script" logic.
   *
   * ### Enforcing on-chain policy
   *
   * When spending the authority token in this way, the delegate's authority is typically
   * narrowly scoped, and it's expected that the delegate's on-chain script validates that
   * those parts of the transaction detail should be authorized, in accordance with the
   * delegate's core purpose/responsbility - i.e. that the txn does all of what the delegate
   * expects, and none of what it shouldn't do in that department.
   *
   * The on-chain code SHOULD typically enforce:
   *  * that the token is spent with an application-specific redeemer variant of its
   *     MintingActivity or SpendingActivitie.
   *
   *  * that the authority token is returned to the contract with its datum unchanged
   *  * that any other tokens it may also hold in the same UTxO do not become
   *     inaccessible as a result of the transactions - perhaps by requiring them to be
   *     returned together with the authority token.
   *
   * It MAY enforce additional requirements as well.
   *
   * @example
   * A minting delegate should check that all the expected tokens are
   * minted, AND that no other tokens are minted.
   *
   * @example
   * A role-based authentication/signature-checking delegate can
   * require an appropriate signature on the txn.
   *
   * @param tcx - the transaction context
   * @param utxo - the utxo having the authority UUT for this delegate
   * @reqt Adds the uutxo to the transaction inputs with appropriate redeemer.
   * @reqt Does not output the value; can EXPECT txnReceiveAuthorityToken to be called for that purpose.
   **/
  async DelegateAddsAuthorityToken(tcx, uutxo, redeemer) {
    const { capo } = this.configIn;
    const tcx2 = await capo.txnAttachScriptOrRefScript(
      tcx,
      this.compiledScript
    );
    return tcx2.addInput(uutxo, redeemer);
  }
  /**
   * {@inheritdoc StellarDelegate.DelegateAddsAuthorityToken}
   **/
  async DelegateRetiresAuthorityToken(tcx, fromFoundUtxo) {
    const utxo = fromFoundUtxo;
    return tcx.addInput(
      makeTxInput(utxo.id, utxo.output),
      this.activity.DelegateLifecycleActivities.Retiring
    );
  }
}
__decorateClass$4([
  Activity.redeemer
], ContractBasedDelegate.prototype, "activityReplacingMe", 1);
__decorateClass$4([
  Activity.redeemer
], ContractBasedDelegate.prototype, "activityRetiring", 1);
__decorateClass$4([
  Activity.redeemer
], ContractBasedDelegate.prototype, "activityValidatingSettings", 1);
__decorateClass$4([
  Activity.redeemer
], ContractBasedDelegate.prototype, "activityDeletingDelegatedData", 1);
__decorateClass$4([
  datum
], ContractBasedDelegate.prototype, "mkDatumIsDelegation", 1);

const heliosModule$2 = {
  content: "module UnspecializedDelegate\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash,\n    get_cont_outputs\n} from ScriptContext\n\n// specialized to ...\n//   -   NOT YET SPECIALIZED (replace with your specialization notes here) - \n// original notes about (un)specialization follow:\n\n\n//  //! provides a basic version, not yet specialized,\n//  // of the \"specializedDelegate\" interface, which simply\n//  // exports a DelegateDatum enum and DelegateActivities (redeemer enum).  \n\n//  //! Your specialization MUST include the enum variants found in this\n//  //  ... unspecialized version.  It MAY include additional Datum variants.\n//  // Any additional Redeemer/Activity variants should be added underneath \n//  // the SpendingActivity / MintingActivity top-level enum variants, instead \n//  // of adding new top-level enum variants to DelegateActivity.\n\n//  // The DelegateActivity (redeemer) enum conforms to the \n//  // Delegate Redeemer protocol, in which enum 0 is reserved for\n//  // lifecycle activities, enum 1 is used for spend-related activities \n//  // (if the delegate is used as a spend delegate), and enum 2 is called\n//  // for authorizing minting.  Enum 3 and beyond are reserved for\n//  // extensions to the Delegate Redeemer protocol.\n\n//  // Within the minting and spending activities, the specialization can \n//  // indicate a nested activity enum to support various dApp-specific\n//  // activities.  \n\n//  // Activities that validate minting of UUTs should contain enum fields \n//  // to identify the seed-transaction details needed for properly validating \n//  // UUT mints fitting the use-case.\n\n//  //! Your specialization MAY include any additional functions, imports or \n//  //  methods defined on any of the types in this file.\n\nimport {\n    AnyData,\n    REQT,\n    bREQT,\n    TODO\n} from StellarHeliosHelpers\n\nimport {\n    DelegationDetail,\n    mustReturnValueToScript,\n    DelegateLifecycleActivity,\n    CapoLifecycleActivity,\n    unmodifiedDelegation\n} from CapoDelegateHelpers\n\nimport {\n    validateUutMinting,\n    mkUutTnFactory\n} from CapoMintHelpers\n\nimport {\n    mkCapoCtx\n} from CapoHelpers\n \n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nenum DelegateDatum {\n    // we only have to use this if we decide Constr#0 is essential for practical CIP-68 compat\n    Cip68RefToken {  \n        // NOTE: this datum contains reference details for a user-facing token minted according to the cip-68 standard \n        //  - the asset name (in the Value of this UTXO) MUST be:  #000643b0 + tokenName\n        //     - this asset name can serve user-side tokens using the CIP-68 \"222\", \"333\" or other token types.\n        //     - the user-side asset name with its (222/333/etc) CIP-67 prefix and \n        //       ... its remaining tokenName will be matched to this asset name (#000643b0 +tokenName)\n        //       ... to locate this reference datum; this datum content will be interpreted\n        //       ... according to the semantics implied by the user-side asset-name prefix.\n        //\n        //  - The attached 'meta' field in this Datum variant contains the relevant data, depending on the token type\n        //    - for \"222\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"files\" :   // {mediaType, src (url), name?, ... otherFields)\n        //        - \"image\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //    - for \"333\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"ticker\" : String\n        //        - \"url\": String  // project URL\n        //        - \"logo\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //                    - it must have a mime type `image/png`, `image/jpeg` or `image/svg+xml`\n        //        - \"decimals\" : Int\n\n        cip68meta: AnyData\n        cip68version: Int\n        otherDetails: Data\n        // otherDetails: Data // can be Unit () or anything else\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index as Capo's DelegatedData\n    capoStoredData {\n        data: AnyData\n        version: Int\n        otherDetails: Data \n    }\n\n    // func validateSettings(self, settings: ProtocolSettings) -> Bool{\n    // ... get the settings object from the contract manifest via cctx\n    //     assert(false, \"not valid (stubbed)\");\n    //     settings.serialize() != self.serialize() &&\n    //     true\n    // }\n}\n\nenum MintingActivity {\n    // application can replace the placeholder, which is only here to \n    // avoid a syntax error in the unspecialized version\n    _placeholder1MA {\n        seed: TxOutputId\n    }\n}\n\n//! The minting delegate can also be used as a general spending \n// delegate (this is the default arrangement during the Capo \n// charter mint).  These activities are required by the Capo when\n// spending utxos having DelegatedDatum type.\nenum SpendingActivity {\n    // application can replace the placeholder, which is only here to \n    // avoid a syntax error in the unspecialized version\n    _placeholder1SA  {\n        recId: ByteArray\n    }\n}\n\nenum BurningActivity {\n    // application can replace the placeholder, which is only here to \n    // avoid a syntax error in the unspecialized version\n    _placeholder1BA {\n        recId: ByteArray\n    }\n}\nenum DelegateActivity {\n    // must ALWAYS be at Enum position 0\n    CapoLifecycleActivities {\n        activity: CapoLifecycleActivity\n    }\n\n    // must ALWAYS be at Enum position 1\n    DelegateLifecycleActivities {\n        // administrative activities for the delegate lifecycle, enforced\n        //  by the basic mint delegate code.  Specializations can add more \n        //  restrictions, but in many/most cases they will not need to.\n        activity: DelegateLifecycleActivity\n    }\n\n    // application-specific spending activities, ALWAYS at Enum position 2\n    SpendingActivities {\n        activity: SpendingActivity\n    }\n\n    // application-specific minting activities, ALWAYS at Enum position 3\n    // remember:M and 3 have a similar shape.\n    MintingActivities {\n        activity: MintingActivity\n    }\n\n    BurningActivities {\n        // application-specific burning activities, ALWAYS at Enum position 4\n        activity: BurningActivity\n    }\n\n    CreatingDelegatedData {\n        seed: TxOutputId\n        dataType: String\n        // id from seed\n    }\n\n    UpdatingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n\n    DeletingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n\n    MultipleDelegateActivities {\n        activities: []Data // actually a []DelegateActivity\n        // todo: change this back when the recursive enum's `__is_valid_data not found` error is resolved\n    }\n\n    // this function gives a general-purpose implementation of checking for \n    // valid uut minting. \n    //\n    // A specialization might modify it to use different policies\n    // or enforce additional requirements\n    // \n    // func genericUutMinting(self, \n    //     mdd: DelegateDatum,\n    // ) -> Bool {\n    //     //!!! replace with an activity using the same seed-txn pattern:\n    //     // MintingActivities::SomethingMintingUuts{seed, purposes} = self;\n    //     DelegateDatum::IsDelegation{dd} = mdd;\n    //     returnsAuthzToken : Bool = mustReturnValueToScript(dd.tvAuthorityToken());\n\n    //     o : []TxOutput = get_cont_outputs();\n    //     if (o.length != 1) { error(\"single utxo only\") };\n\n    //     print (\"in unsp_MD\");\n    //     isOk : Bool = returnsAuthzToken && \n\n    //     unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize()) &&\n\n    //     // This call can serve as a template for enforcing expected mints \n    //     // of uuts (and additional token values) in validation of application-\n    //     // specific activities, given (mph, seed, purposes)\n    //     validateUutMinting(\n    //         mph: dd.mph,\n    //         seed: seed,\n    //         purposes: purposes,\n    //         // otherMintedValue: ()\n    //         mkTokenName: mkUutTnFactory(seed)\n    //     );\n\n    //     isOk\n    // }\n\n    //! used only for validating IsDelegation datum, that is,\n    //   ... to approve minting requests or any customize spending modes \n    //   ... of that datum.  \n    \n    //  Note that the basic delegate already enforces some basic\n    //    administrative expectations for DelegateLifecycleActivities and CapoLifecycleActivities\n    //    so a specialization doesn't need to re-implement those checks.\n    func additionalDelegateValidation( self,\n        priorMddd: DelegateDatum::IsDelegation\n    ) -> Bool {\n        // print(\"  ----- checking additional delegate validation\");\n        mph : MintingPolicyHash = priorMddd.dd.mph;\n\n        self.switch {\n            // generic DelegateLifecycleActivities is already validated, but \n            //  ... you can add more constraints here if needed\n            DelegateLifecycleActivities => true,\n            CapoLifecycleActivities{CLA} => {\n                // CapoLifecycleActivites.queuePendingChange is only relevant for the MINT delegate.\n                // CapoLifecycleActivites.{removing, committing}PendingChange(s) are served by the SPEND delegate\n                // Capo\n                // CapoLifecycleActivites.{forcing}* are ONLY ever served by the Capo itself as an escape-hatch\n                //  assert(isMintingDelegate, \"unreachable\"); // TODO access this const defined in the main script\n\n                // They're normally rejected in this unspecialized (minting) delegate:\n                //   ... but if you have cases for creating new delegates, such as \n                //   ... named delegates for advanced constellations of contracts \n                //   ... in your Capo, you can implement checks for that here.\n                //  You can use this construct as-is, or modify it to suit your needs.\n                CLA.switch {\n                    // queuePendingChange{action, role, name} => {\n                    //     print(\"unspecialized mint delegate allowing queuePendingChange\");\n                    // },\n                    // committingPendingDgtChange{action, role, name} => {\n                    //     print(\"unspecialized mint delegate allowing committingPendingChange\");\n                    // },\n                    CreatingDelegate{seed, purpose} => {\n                        self.supportedCapoDelegatePurposes().find_safe(\n                            (p : String) -> Bool { p == purpose } \n                        ).switch {\n                            None => {\n                                if (self.supportedCapoDelegatePurposes().length == 0) {\n                                    print(\"note: unspecialized delegate has no supported purposes\")\n                                };\n                                error(\"can't mint delegate with unsupported purpose\")\n                            },\n                            Some => {\n                                validateUutMinting(\n                                    mph: mph,\n                                    seed: seed,\n                                    purposes: []String{purpose},\n                                    // otherMintedValue: ()\n                                    mkTokenName: mkUutTnFactory(seed),\n                                    // WE ARE the mint delegate.\n                                    needsMintDelegateApproval: false \n                                )\n                            }\n                        }\n                    },\n                    _ => {\n                        REQT(\"   -- to customize: mint/spend delegates have an option to validate additional lifecycle constraints here\");\n                        true\n                    }\n                 }\n            },\n            MintingActivities => {\n                _cctx = mkCapoCtx(mph).withCharterRef();\n\n                error(\"unspecialized mint delegate doesn't have any MintingActivities\")\n            },\n            CreatingDelegatedData => {\n                print(\" ℹ️  mint delegate allowing CreatingDelegatedData on the say-so of its policy delegate\");\n                true\n            },\n            UpdatingDelegatedData => {\n                print(\" ℹ️  spend delegate allowing UpdatingDelegatedData on the say-so of its policy delegate\");\n                true\n            },\n            DeletingDelegatedData => {\n                print(\" ℹ️  mint delegate allowing DeletingDelegatedData on the say-so of its policy delegate\");\n                true\n            },\n            _ => {\n                assert(false, \"mint/spend delegate rejecting other activity\");\n                false\n            }\n        } || tx.serialize() == priorMddd.serialize()        \n    }\n    func supportedCapoDelegatePurposes(self) -> []String {\n        assert(true || /* prevent unused variable */ self == self, \"no way, man\" );\n         []String{ \n            // \"nothingHereYet\",\n        }\n    }\n\n    //! Used only for validating non-IsDelegation datum types and activities.\n    // if you have any special admininstrative data structures that inform \n    // ...  your minting policy, this might be useful.  Otherwise, and typically,\n    // ... you should look to Activity validations above in additionalDelegateValidation,\n    // ...  in which the isDelegation token is being spent with an application-specific\n    // ...  activity/redeemer\n    func otherDatumValidation( self,\n        _priorMdd: DelegateDatum\n    ) -> Bool {\n        neverTriggered = () -> {  error(\"never called\") };\n        self.switch{\n            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.\n            //  Using it on any other Datum type will always fail and execution will never arrive here.\n            DelegateLifecycleActivities => neverTriggered(),\n            CapoLifecycleActivities => neverTriggered(),\n\n            // -- Application-specific activities can be added here \n            // -- for special & app-specific types of datum in a delegate,\n            // -- for EXCEPTIONAL cases, if you really know what you're doing.  \n            //  -- see above for normal cases\n\n            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls\n        }\n    }\n}\n\n",
  project: "stellar-contracts",
  purpose: "module",
  name:  "src/delegation/UnspecializedDelegate.hl", // source filename
  moduleName:  "UnspecializedDelegate",
};

class UnspecializedDgtBundle extends CapoDelegateBundle.usingCapoBundleClass(CapoHeliosBundle) {
  get moduleName() {
    return "UnspecializedDelegate";
  }
  get bridgeClassName() {
    return "UnspecializedDelegateBridge";
  }
  get specializedDelegateModule() {
    return heliosModule$2;
  }
}

var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorateClass$3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$3(target, key, result);
  return result;
};
class BasicMintDelegate extends ContractBasedDelegate {
  static currentRev = 1n;
  get delegateName() {
    return "mintDelegate";
  }
  get isMintAndSpendDelegate() {
    return true;
  }
  /**
   * the scriptBundle for the BasicMintDelegate looks concrete,
   * but it's actually just referencing a generic, unspecialized delegate script
   * that may not provide much value to any specific application.  
   * 
   * Subclasses should expect to override this and provide a specialized
   * `get scriptBundle() { return new ‹YourMintDelegateBundle› }`, using
   *  a class you derive from CapoDelegateBundle and your own delegate
   * specialization.  TODO: a generator to make this easier.  Until then,
   * you can copy the UnspecializedDelegate.hl and specialize it.
   */
  scriptBundle() {
    return new UnspecializedDgtBundle();
  }
  // uses the basic delegate script, plus the isMintDelegate param
  static get defaultParams() {
    return {
      ...super.defaultParams,
      delegateName: "mintDelegate",
      isMintDelegate: true,
      isSpendDelegate: this.prototype.isMintAndSpendDelegate
    };
  }
  activityCreatingDelegatedData(seedFrom, uutPurpose) {
    throw new Error(`deprecated: explicit activity helper`);
  }
  activityCreatingDataDelegate(seedFrom, uutPurpose) {
    throw new Error(`deprecated: explicit activity helper`);
  }
  mkDatumScriptReference() {
    throw new Error(`obsolete mkDatumScriptReference!!!`);
  }
  async txnGrantAuthority(tcx, redeemer, skipReturningDelegate) {
    if (!redeemer)
      throw new Error(
        `mint delegate requires an explicit redeemer for txnGrantAuthority()`
      );
    const { capo } = this.configIn;
    await capo.txnAttachScriptOrRefScript(tcx, this.compiledScript);
    return super.txnGrantAuthority(tcx, redeemer, skipReturningDelegate);
  }
  // moved to to super
  // static mkDelegateWithArgs(a: capoDelegateConfig) {}
}
__decorateClass$3([
  Activity.redeemer
], BasicMintDelegate.prototype, "activityCreatingDelegatedData", 1);
__decorateClass$3([
  Activity.redeemer
], BasicMintDelegate.prototype, "activityCreatingDataDelegate", 1);
__decorateClass$3([
  datum
], BasicMintDelegate.prototype, "mkDatumScriptReference", 1);

class AuthorityPolicy extends StellarDelegate {
  // this class is distinct from other delegates
}

class AnyAddressAuthorityPolicy extends AuthorityPolicy {
  loadBundle(params) {
    return void 0;
  }
  usesContractScript = false;
  getContractScriptParamsUplc() {
    return {
      rev: makeIntData(0)
    };
  }
  get delegateValidatorHash() {
    return void 0;
  }
  // /**
  //  * special-case activity for non-contract (no redeemer)
  //  */
  // @Activity.redeemer
  // activityAuthorizing(): isActivity {
  //     return { redeemer: undefined };
  // }
  //! impls MUST resolve the indicated token to a specific UTxO
  //  ... or throw an informative error
  async DelegateMustFindAuthorityToken(tcx, label) {
    const v = this.tvAuthorityToken();
    const { addrHint } = this.configIn;
    return this.uh.mustFindActorUtxo(
      `${label}: ${decodeUtf8(this.configIn.tn)}`,
      this.uh.mkTokenPredicate(v),
      tcx,
      "are you connected to the right wallet address? " + (addrHint?.length ? "\nauthority token originally issued to " + addrHint.map((x) => {
        const addr = "string" == typeof x ? makeAddress(x) : x;
        return dumpAny(addr) + " = " + addr.toString();
      }).join("\n or ") : "")
    );
  }
  async txnReceiveAuthorityToken(tcx, tokenValue, fromFoundUtxo) {
    let dest;
    console.log("\u{1F41E}\u{1F41E}  receive authority token");
    if (fromFoundUtxo) {
      dest = fromFoundUtxo.address;
      console.log(
        "    \u{1F41E}\u{1F41E}  " + dumpAny(fromFoundUtxo.address, this.networkParams)
      );
    } else {
      if (!this.configIn?.addrHint?.[0])
        throw new Error(`missing addrHint`);
      const {
        addrHint
        // reqdAddress,  // removed
      } = this.configIn;
      dest = addrHint[0];
    }
    const output = makeTxOutput(dest, tokenValue);
    output.correctLovelace(this.networkParams);
    tcx.addOutput(output);
    console.log(
      "    \u{1F41E}\u{1F41E}  ...with output" + dumpAny(output, this.networkParams)
    );
    return tcx;
  }
  //! Adds the indicated token to the txn as an input with apporpriate activity/redeemer
  //! EXPECTS to receive a Utxo having the result of txnMustFindAuthorityToken()
  async DelegateAddsAuthorityToken(tcx, fromFoundUtxo, redeemer) {
    //! no need to specify a redeemer, but we pass it through
    return tcx.addInput(fromFoundUtxo, redeemer);
  }
  //! Adds the indicated utxo to the transaction with appropriate activity/redeemer
  //  ... allowing the token to be burned by the minting policy.
  //! EXPECTS to receive a Utxo having the result of txnMustFindAuthorityToken()
  async DelegateRetiresAuthorityToken(tcx, fromFoundUtxo) {
    //! no need to specify a redeemer
    return tcx.addInput(fromFoundUtxo);
  }
}

class CapoDataBridge extends ContractDataBridge {
  static isAbstract = false;
  isAbstract = false;
  /**
   * Helper class for generating TxOutputDatum for the ***datum type (CapoDatum)***
   * for this contract script. 
   */
  datum = new CapoDatumHelper({});
  // datumAccessor/enum
  /**
   * this is the specific type of datum for the `Capo` script
   */
  CapoDatum = this.datum;
  readDatum = (d) => {
    return this.reader.CapoDatum(d);
  };
  /**
   * generates UplcData for the activity type (***CapoActivity***) for the `Capo` script
   */
  activity = new CapoActivityHelper({ isActivity: true });
  // activityAccessor/enum
  CapoActivity = this.activity;
  reader = new CapoDataBridgeReader(this);
  /**
   * accessors for all the types defined in the `Capo` script
   * @remarks - these accessors are used to generate UplcData for each type
   */
  types = {
    /**
     * generates UplcData for the enum type ***DelegateRole*** for the `Capo` script
     */
    DelegateRole: new DelegateRoleHelper$2(),
    /**
     * generates UplcData for the enum type ***ManifestEntryType*** for the `Capo` script
     */
    ManifestEntryType: new ManifestEntryTypeHelper$2(),
    /**
     * generates UplcData for the enum type ***PendingDelegateAction*** for the `Capo` script
     */
    PendingDelegateAction: new PendingDelegateActionHelper$2(),
    /**
     * generates UplcData for the enum type ***PendingCharterChange*** for the `Capo` script
     */
    PendingCharterChange: new PendingCharterChangeHelper$2(),
    /**
     * generates UplcData for the enum type ***CapoDatum*** for the `Capo` script
     */
    CapoDatum: new CapoDatumHelper(),
    /**
     * generates UplcData for the enum type ***ManifestActivity*** for the `Capo` script
     */
    ManifestActivity: new ManifestActivityHelper$2(),
    /**
     * generates UplcData for the enum type ***CapoLifecycleActivity*** for the `Capo` script
     */
    CapoLifecycleActivity: new CapoLifecycleActivityHelper$2(),
    /**
     * generates UplcData for the enum type ***CapoActivity*** for the `Capo` script
     */
    CapoActivity: new CapoActivityHelper(),
    /**
     * generates UplcData for the enum type ***RelativeDelegateLink*** for the `Capo` script
     */
    RelativeDelegateLink: (fields) => {
      return this["\u1C7A\u1C7ARelativeDelegateLinkCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***CapoManifestEntry*** for the `Capo` script
     */
    CapoManifestEntry: (fields) => {
      return this["\u1C7A\u1C7ACapoManifestEntryCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***PendingDelegateChange*** for the `Capo` script
     */
    PendingDelegateChange: (fields) => {
      return this["\u1C7A\u1C7APendingDelegateChangeCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***AnyData*** for the `Capo` script
     */
    AnyData: (fields) => {
      return this["\u1C7A\u1C7AAnyDataCast"].toUplcData(fields);
    }
  };
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ARelativeDelegateLinkCast" = makeCast(
    RelativeDelegateLinkSchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ACapoManifestEntryCast" = makeCast(
    CapoManifestEntrySchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7APendingDelegateChangeCast" = makeCast(
    PendingDelegateChangeSchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7AAnyDataCast" = makeCast(
    AnyDataSchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
}
class CapoDataBridgeReader extends DataBridgeReaderClass {
  constructor(bridge) {
    super();
    this.bridge = bridge;
  }
  /**
      * reads UplcData *known to fit the **DelegateRole*** enum type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegateRole(d) {
    const typeHelper = this.bridge.types.DelegateRole;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **ManifestEntryType*** enum type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  ManifestEntryType(d) {
    const typeHelper = this.bridge.types.ManifestEntryType;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **PendingDelegateAction*** enum type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  PendingDelegateAction(d) {
    const typeHelper = this.bridge.types.PendingDelegateAction;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **PendingCharterChange*** enum type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  PendingCharterChange(d) {
    const typeHelper = this.bridge.types.PendingCharterChange;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  datum = (d) => {
    return this.CapoDatum(d);
  };
  /**
      * reads UplcData *known to fit the **CapoDatum*** enum type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  CapoDatum(d) {
    const typeHelper = this.bridge.types.CapoDatum;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **ManifestActivity*** enum type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  ManifestActivity(d) {
    const typeHelper = this.bridge.types.ManifestActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **CapoLifecycleActivity*** enum type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  CapoLifecycleActivity(d) {
    const typeHelper = this.bridge.types.CapoLifecycleActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **CapoActivity*** enum type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  CapoActivity(d) {
    const typeHelper = this.bridge.types.CapoActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **RelativeDelegateLink*** struct type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  RelativeDelegateLink(d) {
    const cast = this.bridge["\u1C7A\u1C7ARelativeDelegateLinkCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **CapoManifestEntry*** struct type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  CapoManifestEntry(d) {
    const cast = this.bridge["\u1C7A\u1C7ACapoManifestEntryCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **PendingDelegateChange*** struct type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  PendingDelegateChange(d) {
    const cast = this.bridge["\u1C7A\u1C7APendingDelegateChangeCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **AnyData*** struct type,
      * for the Capo script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  AnyData(d) {
    const cast = this.bridge["\u1C7A\u1C7AAnyDataCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
}
let DelegateRoleHelper$2 = class DelegateRoleHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateRoleSchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get MintDgt() {
    const uplc = this.mkUplcData(
      { MintDgt: {} },
      "CapoDelegateHelpers::DelegateRole.MintDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get SpendDgt() {
    const uplc = this.mkUplcData(
      { SpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.SpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get MintInvariant() {
    const uplc = this.mkUplcData(
      { MintInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.MintInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get SpendInvariant() {
    const uplc = this.mkUplcData(
      { SpendInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.SpendInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.DgDataPolicy"***
   */
  DgDataPolicy(name) {
    const uplc = this.mkUplcData({
      DgDataPolicy: name
    }, "CapoDelegateHelpers::DelegateRole.DgDataPolicy");
    return uplc;
  }
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.OtherNamedDgt"***
   */
  OtherNamedDgt(name) {
    const uplc = this.mkUplcData({
      OtherNamedDgt: name
    }, "CapoDelegateHelpers::DelegateRole.OtherNamedDgt");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#6***
   */
  get BothMintAndSpendDgt() {
    const uplc = this.mkUplcData(
      { BothMintAndSpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#7***
   */
  get HandledByCapoOnly() {
    const uplc = this.mkUplcData(
      { HandledByCapoOnly: {} },
      "CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let ManifestEntryTypeHelper$2 = class ManifestEntryTypeHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    ManifestEntryTypeSchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoHelpers::ManifestEntryType.NamedTokenRef"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get NamedTokenRef() {
    const uplc = this.mkUplcData(
      { NamedTokenRef: {} },
      "CapoHelpers::ManifestEntryType.NamedTokenRef"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoHelpers::ManifestEntryType.DgDataPolicy"***
   * @remarks - ***ManifestEntryType$DgDataPolicyLike*** is the same as the expanded field-types.
   */
  DgDataPolicy(fields) {
    const uplc = this.mkUplcData({
      DgDataPolicy: fields
    }, "CapoHelpers::ManifestEntryType.DgDataPolicy");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoHelpers::ManifestEntryType.DelegateThreads"***
   * @remarks - ***ManifestEntryType$DelegateThreadsLike*** is the same as the expanded field-types.
   */
  DelegateThreads(fields) {
    const uplc = this.mkUplcData({
      DelegateThreads: fields
    }, "CapoHelpers::ManifestEntryType.DelegateThreads");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * (property getter): UplcData for ***"CapoHelpers::ManifestEntryType.MerkleMembership"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get MerkleMembership() {
    const uplc = this.mkUplcData(
      { MerkleMembership: {} },
      "CapoHelpers::ManifestEntryType.MerkleMembership"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoHelpers::ManifestEntryType.MerkleStateRoot"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#4***
   */
  get MerkleStateRoot() {
    const uplc = this.mkUplcData(
      { MerkleStateRoot: {} },
      "CapoHelpers::ManifestEntryType.MerkleStateRoot"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let PendingDelegateActionHelper$2 = class PendingDelegateActionHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    PendingDelegateActionSchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  Add(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        Add: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::PendingDelegateAction.Add");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        Add: fields
      }, "CapoDelegateHelpers::PendingDelegateAction.Add");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::PendingDelegateAction.Add"***, 
   * @param fields - \{ purpose: string, idPrefix: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$Add({ purpose, idPrefix })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$Add = impliedSeedActivityMaker(
    this,
    this.Add
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::PendingDelegateAction.Remove"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get Remove() {
    const uplc = this.mkUplcData(
      { Remove: {} },
      "CapoDelegateHelpers::PendingDelegateAction.Remove"
    );
    return uplc;
  }
  Replace(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        Replace: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::PendingDelegateAction.Replace");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        Replace: fields
      }, "CapoDelegateHelpers::PendingDelegateAction.Replace");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::PendingDelegateAction.Replace"***, 
   * @param fields - \{ purpose: string, idPrefix: string, replacesDgt: AssetClass | string | [string | MintingPolicyHash | number[], string | number[]] | \{mph: MintingPolicyHash | string | number[], tokenName: string | number[]\} \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$Replace({ purpose, idPrefix, replacesDgt })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$Replace = impliedSeedActivityMaker(
    this,
    this.Replace
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
};
let PendingCharterChangeHelper$2 = class PendingCharterChangeHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    PendingCharterChangeSchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::PendingCharterChange.delegateChange"***
   * @remarks - ***PendingDelegateChangeLike*** is the same as the expanded field-type.
   */
  delegateChange(change) {
    const uplc = this.mkUplcData({
      delegateChange: change
    }, "CapoDelegateHelpers::PendingCharterChange.delegateChange");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::PendingCharterChange.otherManifestChange"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get otherManifestChange() {
    const uplc = this.mkUplcData(
      { otherManifestChange: {} },
      "CapoDelegateHelpers::PendingCharterChange.otherManifestChange"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
class CapoDatumHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    CapoDatumSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  InlineTxOutputDatum for ***"CapoHelpers::CapoDatum.CharterData"***
   * @remarks - ***CapoDatum$CharterDataLike*** is the same as the expanded field-types.
   */
  CharterData(fields) {
    const uplc = this.mkUplcData({
      CharterData: fields
    }, "CapoHelpers::CapoDatum.CharterData");
    return makeInlineTxOutputDatum(uplc);
  }
  /*multiFieldVariant enum accessor*/
  /**
   * (property getter): InlineTxOutputDatum for ***"CapoHelpers::CapoDatum.ScriptReference"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get ScriptReference() {
    const uplc = this.mkUplcData(
      { ScriptReference: {} },
      "CapoHelpers::CapoDatum.ScriptReference"
    );
    return makeInlineTxOutputDatum(uplc);
  }
  /* tagOnly variant accessor */
  /**
   * generates  InlineTxOutputDatum for ***"CapoHelpers::CapoDatum.DelegatedData"***
   * @remarks - ***CapoDatum$DelegatedDataLike*** is the same as the expanded field-types.
   */
  DelegatedData(fields) {
    const uplc = this.mkUplcData({
      DelegatedData: fields
    }, "CapoHelpers::CapoDatum.DelegatedData");
    return makeInlineTxOutputDatum(uplc);
  }
  /*multiFieldVariant enum accessor*/
}
let ManifestActivityHelper$2 = class ManifestActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    ManifestActivitySchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.retiringEntry"***
   */
  retiringEntry(key) {
    const uplc = this.mkUplcData({
      retiringEntry: key
    }, "CapoDelegateHelpers::ManifestActivity.retiringEntry");
    return uplc;
  }
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.updatingEntry"***
   * @remarks - ***ManifestActivity$updatingEntryLike*** is the same as the expanded field-types.
   */
  updatingEntry(fields) {
    const uplc = this.mkUplcData({
      updatingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.updatingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.addingEntry"***
   * @remarks - ***ManifestActivity$addingEntryLike*** is the same as the expanded field-types.
   */
  addingEntry(fields) {
    const uplc = this.mkUplcData({
      addingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.addingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.forkingThreadToken"***
   * @remarks - ***ManifestActivity$forkingThreadTokenLike*** is the same as the expanded field-types.
   */
  forkingThreadToken(fields) {
    const uplc = this.mkUplcData({
      forkingThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.forkingThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.burningThreadToken"***
   * @remarks - ***ManifestActivity$burningThreadTokenLike*** is the same as the expanded field-types.
   */
  burningThreadToken(fields) {
    const uplc = this.mkUplcData({
      burningThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.burningThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
};
let DelegateRoleHelperNested$2 = class DelegateRoleHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateRoleSchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get MintDgt() {
    const uplc = this.mkUplcData(
      { MintDgt: {} },
      "CapoDelegateHelpers::DelegateRole.MintDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get SpendDgt() {
    const uplc = this.mkUplcData(
      { SpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.SpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get MintInvariant() {
    const uplc = this.mkUplcData(
      { MintInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.MintInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get SpendInvariant() {
    const uplc = this.mkUplcData(
      { SpendInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.SpendInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.DgDataPolicy"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  DgDataPolicy(name) {
    const uplc = this.mkUplcData({
      DgDataPolicy: name
    }, "CapoDelegateHelpers::DelegateRole.DgDataPolicy");
    return uplc;
  }
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.OtherNamedDgt"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  OtherNamedDgt(name) {
    const uplc = this.mkUplcData({
      OtherNamedDgt: name
    }, "CapoDelegateHelpers::DelegateRole.OtherNamedDgt");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#6***
   */
  get BothMintAndSpendDgt() {
    const uplc = this.mkUplcData(
      { BothMintAndSpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#7***
   */
  get HandledByCapoOnly() {
    const uplc = this.mkUplcData(
      { HandledByCapoOnly: {} },
      "CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let ManifestActivityHelperNested$2 = class ManifestActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    ManifestActivitySchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.retiringEntry"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  retiringEntry(key) {
    const uplc = this.mkUplcData({
      retiringEntry: key
    }, "CapoDelegateHelpers::ManifestActivity.retiringEntry");
    return uplc;
  }
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.updatingEntry"***
   * @remarks - ***ManifestActivity$updatingEntryLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  updatingEntry(fields) {
    const uplc = this.mkUplcData({
      updatingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.updatingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.addingEntry"***
   * @remarks - ***ManifestActivity$addingEntryLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  addingEntry(fields) {
    const uplc = this.mkUplcData({
      addingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.addingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.forkingThreadToken"***
   * @remarks - ***ManifestActivity$forkingThreadTokenLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  forkingThreadToken(fields) {
    const uplc = this.mkUplcData({
      forkingThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.forkingThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.burningThreadToken"***
   * @remarks - ***ManifestActivity$burningThreadTokenLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  burningThreadToken(fields) {
    const uplc = this.mkUplcData({
      burningThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.burningThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
};
let CapoLifecycleActivityHelper$2 = class CapoLifecycleActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    CapoLifecycleActivitySchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  CreatingDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        CreatingDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        CreatingDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$CreatingDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$CreatingDelegate = impliedSeedActivityMaker(
    this,
    this.CreatingDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get queuePendingChange() {
    const uplc = this.mkUplcData(
      { queuePendingChange: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * access to different variants of the ***nested DelegateRole*** type needed for ***CapoLifecycleActivity:removePendingChange***.
   */
  get removePendingChange() {
    const nestedAccessor = new DelegateRoleHelperNested$2({
      isNested: true,
      isActivity: false
    });
    nestedAccessor.mkDataVia(
      (role) => {
        return this.mkUplcData(
          { removePendingChange: role },
          "CapoDelegateHelpers::CapoLifecycleActivity.removePendingChange"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get commitPendingChanges() {
    const uplc = this.mkUplcData(
      { commitPendingChanges: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"
    );
    return uplc;
  }
  forcingNewSpendDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewSpendDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$forcingNewSpendDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewSpendDelegate
  );
  forcingNewMintDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewMintDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$forcingNewMintDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewMintDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * access to different variants of the ***nested ManifestActivity*** type needed for ***CapoLifecycleActivity:updatingManifest***.
   */
  get updatingManifest() {
    const nestedAccessor = new ManifestActivityHelperNested$2({
      isNested: true,
      isActivity: false
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { updatingManifest: activity },
          "CapoDelegateHelpers::CapoLifecycleActivity.updatingManifest"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
};
let ActivityDelegateRoleHelperNested$2 = class ActivityDelegateRoleHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateRoleSchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get MintDgt() {
    const uplc = this.mkUplcData(
      { MintDgt: {} },
      "CapoDelegateHelpers::DelegateRole.MintDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get SpendDgt() {
    const uplc = this.mkUplcData(
      { SpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.SpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get MintInvariant() {
    const uplc = this.mkUplcData(
      { MintInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.MintInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get SpendInvariant() {
    const uplc = this.mkUplcData(
      { SpendInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.SpendInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::DelegateRole.DgDataPolicy"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  DgDataPolicy(name) {
    const uplc = this.mkUplcData({
      DgDataPolicy: name
    }, "CapoDelegateHelpers::DelegateRole.DgDataPolicy");
    return uplc;
  }
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::DelegateRole.OtherNamedDgt"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  OtherNamedDgt(name) {
    const uplc = this.mkUplcData({
      OtherNamedDgt: name
    }, "CapoDelegateHelpers::DelegateRole.OtherNamedDgt");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#6***
   */
  get BothMintAndSpendDgt() {
    const uplc = this.mkUplcData(
      { BothMintAndSpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#7***
   */
  get HandledByCapoOnly() {
    const uplc = this.mkUplcData(
      { HandledByCapoOnly: {} },
      "CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let CapoLifecycleActivityHelperNested$2 = class CapoLifecycleActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    CapoLifecycleActivitySchema$2,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  CreatingDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        CreatingDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        CreatingDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$CreatingDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$CreatingDelegate = impliedSeedActivityMaker(
    this,
    this.CreatingDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get queuePendingChange() {
    const uplc = this.mkUplcData(
      { queuePendingChange: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * access to different variants of the ***nested DelegateRole*** type needed for ***CapoLifecycleActivity:removePendingChange***.
   */
  get removePendingChange() {
    const nestedAccessor = new ActivityDelegateRoleHelperNested$2({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (role) => {
        return this.mkUplcData(
          { removePendingChange: role },
          "CapoDelegateHelpers::CapoLifecycleActivity.removePendingChange"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get commitPendingChanges() {
    const uplc = this.mkUplcData(
      { commitPendingChanges: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"
    );
    return uplc;
  }
  forcingNewSpendDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewSpendDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$forcingNewSpendDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewSpendDelegate
  );
  forcingNewMintDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewMintDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$forcingNewMintDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewMintDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * access to different variants of the ***nested ManifestActivity*** type needed for ***CapoLifecycleActivity:updatingManifest***.
   */
  get updatingManifest() {
    const nestedAccessor = new ManifestActivityHelperNested$2({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { updatingManifest: activity },
          "CapoDelegateHelpers::CapoLifecycleActivity.updatingManifest"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
};
class CapoActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    CapoActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * access to different variants of the ***nested CapoLifecycleActivity*** type needed for ***CapoActivity:capoLifecycleActivity***.
   */
  get capoLifecycleActivity() {
    const nestedAccessor = new CapoLifecycleActivityHelperNested$2({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { capoLifecycleActivity: activity },
          "CapoHelpers::CapoActivity.capoLifecycleActivity"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * (property getter): UplcData for ***"CapoHelpers::CapoActivity.usingAuthority"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get usingAuthority() {
    const uplc = this.mkUplcData(
      { usingAuthority: {} },
      "CapoHelpers::CapoActivity.usingAuthority"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoHelpers::CapoActivity.retiringRefScript"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get retiringRefScript() {
    const uplc = this.mkUplcData(
      { retiringRefScript: {} },
      "CapoHelpers::CapoActivity.retiringRefScript"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoHelpers::CapoActivity.addingSpendInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get addingSpendInvariant() {
    const uplc = this.mkUplcData(
      { addingSpendInvariant: {} },
      "CapoHelpers::CapoActivity.addingSpendInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoHelpers::CapoActivity.spendingDelegatedDatum"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#4***
   */
  get spendingDelegatedDatum() {
    const uplc = this.mkUplcData(
      { spendingDelegatedDatum: {} },
      "CapoHelpers::CapoActivity.spendingDelegatedDatum"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoHelpers::CapoActivity.updatingCharter"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#5***
   */
  get updatingCharter() {
    const uplc = this.mkUplcData(
      { updatingCharter: {} },
      "CapoHelpers::CapoActivity.updatingCharter"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
}
const RelativeDelegateLinkSchema$2 = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
  "name": "RelativeDelegateLink",
  "fieldTypes": [
    {
      "name": "uutName",
      "type": {
        "kind": "internal",
        "name": "String"
      }
    },
    {
      "name": "delegateValidatorHash",
      "type": {
        "kind": "option",
        "someType": {
          "kind": "internal",
          "name": "ValidatorHash"
        }
      }
    },
    {
      "name": "config",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      }
    }
  ]
};
const DelegateRoleSchema$2 = {
  "kind": "enum",
  "name": "DelegateRole",
  "id": "__module__CapoDelegateHelpers__DelegateRole[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
      "name": "MintDgt",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
      "name": "SpendDgt",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
      "name": "MintInvariant",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
      "name": "SpendInvariant",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
      "name": "DgDataPolicy",
      "fieldTypes": [
        {
          "name": "name",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 5,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
      "name": "OtherNamedDgt",
      "fieldTypes": [
        {
          "name": "name",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 6,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
      "name": "BothMintAndSpendDgt",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 7,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
      "name": "HandledByCapoOnly",
      "fieldTypes": []
    }
  ]
};
const ManifestEntryTypeSchema$2 = {
  "kind": "enum",
  "name": "ManifestEntryType",
  "id": "__module__CapoHelpers__ManifestEntryType[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
      "name": "NamedTokenRef",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
      "name": "DgDataPolicy",
      "fieldTypes": [
        {
          "name": "policyLink",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
            "name": "RelativeDelegateLink",
            "fieldTypes": [
              {
                "name": "uutName",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "delegateValidatorHash",
                "type": {
                  "kind": "option",
                  "someType": {
                    "kind": "internal",
                    "name": "ValidatorHash"
                  }
                }
              },
              {
                "name": "config",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                }
              }
            ]
          }
        },
        {
          "name": "idPrefix",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "refCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
      "name": "DelegateThreads",
      "fieldTypes": [
        {
          "name": "role",
          "type": {
            "kind": "enum",
            "name": "DelegateRole",
            "id": "__module__CapoDelegateHelpers__DelegateRole[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                "name": "MintDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                "name": "SpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                "name": "MintInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                "name": "SpendInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                "name": "DgDataPolicy",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 5,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                "name": "OtherNamedDgt",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 6,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                "name": "BothMintAndSpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 7,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                "name": "HandledByCapoOnly",
                "fieldTypes": []
              }
            ]
          }
        },
        {
          "name": "refCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
      "name": "MerkleMembership",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
      "name": "MerkleStateRoot",
      "fieldTypes": []
    }
  ]
};
const CapoManifestEntrySchema$2 = {
  "kind": "struct",
  "format": "map",
  "id": "__module__CapoHelpers__CapoManifestEntry[]",
  "name": "CapoManifestEntry",
  "fieldTypes": [
    {
      "name": "entryType",
      "type": {
        "kind": "enum",
        "name": "ManifestEntryType",
        "id": "__module__CapoHelpers__ManifestEntryType[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
            "name": "NamedTokenRef",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
            "name": "DgDataPolicy",
            "fieldTypes": [
              {
                "name": "policyLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "idPrefix",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "refCount",
                "type": {
                  "kind": "internal",
                  "name": "Int"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
            "name": "DelegateThreads",
            "fieldTypes": [
              {
                "name": "role",
                "type": {
                  "kind": "enum",
                  "name": "DelegateRole",
                  "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                  "variantTypes": [
                    {
                      "kind": "variant",
                      "tag": 0,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                      "name": "MintDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 1,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                      "name": "SpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 2,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                      "name": "MintInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 3,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                      "name": "SpendInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 4,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                      "name": "DgDataPolicy",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 5,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                      "name": "OtherNamedDgt",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 6,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                      "name": "BothMintAndSpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 7,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                      "name": "HandledByCapoOnly",
                      "fieldTypes": []
                    }
                  ]
                }
              },
              {
                "name": "refCount",
                "type": {
                  "kind": "internal",
                  "name": "Int"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 3,
            "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
            "name": "MerkleMembership",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 4,
            "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
            "name": "MerkleStateRoot",
            "fieldTypes": []
          }
        ]
      },
      "key": "tpe"
    },
    {
      "name": "tokenName",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      },
      "key": "tn"
    },
    {
      "name": "mph",
      "type": {
        "kind": "option",
        "someType": {
          "kind": "internal",
          "name": "MintingPolicyHash"
        }
      }
    }
  ]
};
const PendingDelegateActionSchema$2 = {
  "kind": "enum",
  "name": "PendingDelegateAction",
  "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
      "name": "Add",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "idPrefix",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
      "name": "Remove",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
      "name": "Replace",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "idPrefix",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "replacesDgt",
          "type": {
            "kind": "internal",
            "name": "AssetClass"
          }
        }
      ]
    }
  ]
};
const PendingDelegateChangeSchema$2 = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
  "name": "PendingDelegateChange",
  "fieldTypes": [
    {
      "name": "action",
      "type": {
        "kind": "enum",
        "name": "PendingDelegateAction",
        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
            "name": "Add",
            "fieldTypes": [
              {
                "name": "seed",
                "type": {
                  "kind": "internal",
                  "name": "TxOutputId"
                }
              },
              {
                "name": "purpose",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "idPrefix",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
            "name": "Remove",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
            "name": "Replace",
            "fieldTypes": [
              {
                "name": "seed",
                "type": {
                  "kind": "internal",
                  "name": "TxOutputId"
                }
              },
              {
                "name": "purpose",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "idPrefix",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "replacesDgt",
                "type": {
                  "kind": "internal",
                  "name": "AssetClass"
                }
              }
            ]
          }
        ]
      }
    },
    {
      "name": "role",
      "type": {
        "kind": "enum",
        "name": "DelegateRole",
        "id": "__module__CapoDelegateHelpers__DelegateRole[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
            "name": "MintDgt",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
            "name": "SpendDgt",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
            "name": "MintInvariant",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 3,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
            "name": "SpendInvariant",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 4,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
            "name": "DgDataPolicy",
            "fieldTypes": [
              {
                "name": "name",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 5,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
            "name": "OtherNamedDgt",
            "fieldTypes": [
              {
                "name": "name",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 6,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
            "name": "BothMintAndSpendDgt",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 7,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
            "name": "HandledByCapoOnly",
            "fieldTypes": []
          }
        ]
      }
    },
    {
      "name": "dgtLink",
      "type": {
        "kind": "option",
        "someType": {
          "kind": "struct",
          "format": "list",
          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
          "name": "RelativeDelegateLink",
          "fieldTypes": [
            {
              "name": "uutName",
              "type": {
                "kind": "internal",
                "name": "String"
              }
            },
            {
              "name": "delegateValidatorHash",
              "type": {
                "kind": "option",
                "someType": {
                  "kind": "internal",
                  "name": "ValidatorHash"
                }
              }
            },
            {
              "name": "config",
              "type": {
                "kind": "internal",
                "name": "ByteArray"
              }
            }
          ]
        }
      }
    }
  ]
};
const PendingCharterChangeSchema$2 = {
  "kind": "enum",
  "name": "PendingCharterChange",
  "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
      "name": "delegateChange",
      "fieldTypes": [
        {
          "name": "change",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
            "name": "PendingDelegateChange",
            "fieldTypes": [
              {
                "name": "action",
                "type": {
                  "kind": "enum",
                  "name": "PendingDelegateAction",
                  "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                  "variantTypes": [
                    {
                      "kind": "variant",
                      "tag": 0,
                      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                      "name": "Add",
                      "fieldTypes": [
                        {
                          "name": "seed",
                          "type": {
                            "kind": "internal",
                            "name": "TxOutputId"
                          }
                        },
                        {
                          "name": "purpose",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        },
                        {
                          "name": "idPrefix",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 1,
                      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                      "name": "Remove",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 2,
                      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                      "name": "Replace",
                      "fieldTypes": [
                        {
                          "name": "seed",
                          "type": {
                            "kind": "internal",
                            "name": "TxOutputId"
                          }
                        },
                        {
                          "name": "purpose",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        },
                        {
                          "name": "idPrefix",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        },
                        {
                          "name": "replacesDgt",
                          "type": {
                            "kind": "internal",
                            "name": "AssetClass"
                          }
                        }
                      ]
                    }
                  ]
                }
              },
              {
                "name": "role",
                "type": {
                  "kind": "enum",
                  "name": "DelegateRole",
                  "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                  "variantTypes": [
                    {
                      "kind": "variant",
                      "tag": 0,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                      "name": "MintDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 1,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                      "name": "SpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 2,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                      "name": "MintInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 3,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                      "name": "SpendInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 4,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                      "name": "DgDataPolicy",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 5,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                      "name": "OtherNamedDgt",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 6,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                      "name": "BothMintAndSpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 7,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                      "name": "HandledByCapoOnly",
                      "fieldTypes": []
                    }
                  ]
                }
              },
              {
                "name": "dgtLink",
                "type": {
                  "kind": "option",
                  "someType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
      "name": "otherManifestChange",
      "fieldTypes": []
    }
  ]
};
const CapoDatumSchema = {
  "kind": "enum",
  "name": "CapoDatum",
  "id": "__module__CapoHelpers__CapoDatum[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoHelpers__CapoDatum[]__CharterData",
      "name": "CharterData",
      "fieldTypes": [
        {
          "name": "spendDelegateLink",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
            "name": "RelativeDelegateLink",
            "fieldTypes": [
              {
                "name": "uutName",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "delegateValidatorHash",
                "type": {
                  "kind": "option",
                  "someType": {
                    "kind": "internal",
                    "name": "ValidatorHash"
                  }
                }
              },
              {
                "name": "config",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                }
              }
            ]
          }
        },
        {
          "name": "spendInvariants",
          "type": {
            "kind": "list",
            "itemType": {
              "kind": "struct",
              "format": "list",
              "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
              "name": "RelativeDelegateLink",
              "fieldTypes": [
                {
                  "name": "uutName",
                  "type": {
                    "kind": "internal",
                    "name": "String"
                  }
                },
                {
                  "name": "delegateValidatorHash",
                  "type": {
                    "kind": "option",
                    "someType": {
                      "kind": "internal",
                      "name": "ValidatorHash"
                    }
                  }
                },
                {
                  "name": "config",
                  "type": {
                    "kind": "internal",
                    "name": "ByteArray"
                  }
                }
              ]
            }
          }
        },
        {
          "name": "otherNamedDelegates",
          "type": {
            "kind": "map",
            "keyType": {
              "kind": "internal",
              "name": "String"
            },
            "valueType": {
              "kind": "struct",
              "format": "list",
              "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
              "name": "RelativeDelegateLink",
              "fieldTypes": [
                {
                  "name": "uutName",
                  "type": {
                    "kind": "internal",
                    "name": "String"
                  }
                },
                {
                  "name": "delegateValidatorHash",
                  "type": {
                    "kind": "option",
                    "someType": {
                      "kind": "internal",
                      "name": "ValidatorHash"
                    }
                  }
                },
                {
                  "name": "config",
                  "type": {
                    "kind": "internal",
                    "name": "ByteArray"
                  }
                }
              ]
            }
          }
        },
        {
          "name": "mintDelegateLink",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
            "name": "RelativeDelegateLink",
            "fieldTypes": [
              {
                "name": "uutName",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "delegateValidatorHash",
                "type": {
                  "kind": "option",
                  "someType": {
                    "kind": "internal",
                    "name": "ValidatorHash"
                  }
                }
              },
              {
                "name": "config",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                }
              }
            ]
          }
        },
        {
          "name": "mintInvariants",
          "type": {
            "kind": "list",
            "itemType": {
              "kind": "struct",
              "format": "list",
              "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
              "name": "RelativeDelegateLink",
              "fieldTypes": [
                {
                  "name": "uutName",
                  "type": {
                    "kind": "internal",
                    "name": "String"
                  }
                },
                {
                  "name": "delegateValidatorHash",
                  "type": {
                    "kind": "option",
                    "someType": {
                      "kind": "internal",
                      "name": "ValidatorHash"
                    }
                  }
                },
                {
                  "name": "config",
                  "type": {
                    "kind": "internal",
                    "name": "ByteArray"
                  }
                }
              ]
            }
          }
        },
        {
          "name": "govAuthorityLink",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
            "name": "RelativeDelegateLink",
            "fieldTypes": [
              {
                "name": "uutName",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "delegateValidatorHash",
                "type": {
                  "kind": "option",
                  "someType": {
                    "kind": "internal",
                    "name": "ValidatorHash"
                  }
                }
              },
              {
                "name": "config",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                }
              }
            ]
          }
        },
        {
          "name": "manifest",
          "type": {
            "kind": "map",
            "keyType": {
              "kind": "internal",
              "name": "String"
            },
            "valueType": {
              "kind": "struct",
              "format": "map",
              "id": "__module__CapoHelpers__CapoManifestEntry[]",
              "name": "CapoManifestEntry",
              "fieldTypes": [
                {
                  "name": "entryType",
                  "type": {
                    "kind": "enum",
                    "name": "ManifestEntryType",
                    "id": "__module__CapoHelpers__ManifestEntryType[]",
                    "variantTypes": [
                      {
                        "kind": "variant",
                        "tag": 0,
                        "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
                        "name": "NamedTokenRef",
                        "fieldTypes": []
                      },
                      {
                        "kind": "variant",
                        "tag": 1,
                        "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
                        "name": "DgDataPolicy",
                        "fieldTypes": [
                          {
                            "name": "policyLink",
                            "type": {
                              "kind": "struct",
                              "format": "list",
                              "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                              "name": "RelativeDelegateLink",
                              "fieldTypes": [
                                {
                                  "name": "uutName",
                                  "type": {
                                    "kind": "internal",
                                    "name": "String"
                                  }
                                },
                                {
                                  "name": "delegateValidatorHash",
                                  "type": {
                                    "kind": "option",
                                    "someType": {
                                      "kind": "internal",
                                      "name": "ValidatorHash"
                                    }
                                  }
                                },
                                {
                                  "name": "config",
                                  "type": {
                                    "kind": "internal",
                                    "name": "ByteArray"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "idPrefix",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "refCount",
                            "type": {
                              "kind": "internal",
                              "name": "Int"
                            }
                          }
                        ]
                      },
                      {
                        "kind": "variant",
                        "tag": 2,
                        "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
                        "name": "DelegateThreads",
                        "fieldTypes": [
                          {
                            "name": "role",
                            "type": {
                              "kind": "enum",
                              "name": "DelegateRole",
                              "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                              "variantTypes": [
                                {
                                  "kind": "variant",
                                  "tag": 0,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                  "name": "MintDgt",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 1,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                  "name": "SpendDgt",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 2,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                  "name": "MintInvariant",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 3,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                  "name": "SpendInvariant",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 4,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                  "name": "DgDataPolicy",
                                  "fieldTypes": [
                                    {
                                      "name": "name",
                                      "type": {
                                        "kind": "internal",
                                        "name": "String"
                                      }
                                    }
                                  ]
                                },
                                {
                                  "kind": "variant",
                                  "tag": 5,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                  "name": "OtherNamedDgt",
                                  "fieldTypes": [
                                    {
                                      "name": "name",
                                      "type": {
                                        "kind": "internal",
                                        "name": "String"
                                      }
                                    }
                                  ]
                                },
                                {
                                  "kind": "variant",
                                  "tag": 6,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                  "name": "BothMintAndSpendDgt",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 7,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                  "name": "HandledByCapoOnly",
                                  "fieldTypes": []
                                }
                              ]
                            }
                          },
                          {
                            "name": "refCount",
                            "type": {
                              "kind": "internal",
                              "name": "Int"
                            }
                          }
                        ]
                      },
                      {
                        "kind": "variant",
                        "tag": 3,
                        "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
                        "name": "MerkleMembership",
                        "fieldTypes": []
                      },
                      {
                        "kind": "variant",
                        "tag": 4,
                        "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
                        "name": "MerkleStateRoot",
                        "fieldTypes": []
                      }
                    ]
                  },
                  "key": "tpe"
                },
                {
                  "name": "tokenName",
                  "type": {
                    "kind": "internal",
                    "name": "ByteArray"
                  },
                  "key": "tn"
                },
                {
                  "name": "mph",
                  "type": {
                    "kind": "option",
                    "someType": {
                      "kind": "internal",
                      "name": "MintingPolicyHash"
                    }
                  }
                }
              ]
            }
          }
        },
        {
          "name": "pendingChanges",
          "type": {
            "kind": "list",
            "itemType": {
              "kind": "enum",
              "name": "PendingCharterChange",
              "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
              "variantTypes": [
                {
                  "kind": "variant",
                  "tag": 0,
                  "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
                  "name": "delegateChange",
                  "fieldTypes": [
                    {
                      "name": "change",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
                        "name": "PendingDelegateChange",
                        "fieldTypes": [
                          {
                            "name": "action",
                            "type": {
                              "kind": "enum",
                              "name": "PendingDelegateAction",
                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                              "variantTypes": [
                                {
                                  "kind": "variant",
                                  "tag": 0,
                                  "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                                  "name": "Add",
                                  "fieldTypes": [
                                    {
                                      "name": "seed",
                                      "type": {
                                        "kind": "internal",
                                        "name": "TxOutputId"
                                      }
                                    },
                                    {
                                      "name": "purpose",
                                      "type": {
                                        "kind": "internal",
                                        "name": "String"
                                      }
                                    },
                                    {
                                      "name": "idPrefix",
                                      "type": {
                                        "kind": "internal",
                                        "name": "String"
                                      }
                                    }
                                  ]
                                },
                                {
                                  "kind": "variant",
                                  "tag": 1,
                                  "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                                  "name": "Remove",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 2,
                                  "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                                  "name": "Replace",
                                  "fieldTypes": [
                                    {
                                      "name": "seed",
                                      "type": {
                                        "kind": "internal",
                                        "name": "TxOutputId"
                                      }
                                    },
                                    {
                                      "name": "purpose",
                                      "type": {
                                        "kind": "internal",
                                        "name": "String"
                                      }
                                    },
                                    {
                                      "name": "idPrefix",
                                      "type": {
                                        "kind": "internal",
                                        "name": "String"
                                      }
                                    },
                                    {
                                      "name": "replacesDgt",
                                      "type": {
                                        "kind": "internal",
                                        "name": "AssetClass"
                                      }
                                    }
                                  ]
                                }
                              ]
                            }
                          },
                          {
                            "name": "role",
                            "type": {
                              "kind": "enum",
                              "name": "DelegateRole",
                              "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                              "variantTypes": [
                                {
                                  "kind": "variant",
                                  "tag": 0,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                  "name": "MintDgt",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 1,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                  "name": "SpendDgt",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 2,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                  "name": "MintInvariant",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 3,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                  "name": "SpendInvariant",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 4,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                  "name": "DgDataPolicy",
                                  "fieldTypes": [
                                    {
                                      "name": "name",
                                      "type": {
                                        "kind": "internal",
                                        "name": "String"
                                      }
                                    }
                                  ]
                                },
                                {
                                  "kind": "variant",
                                  "tag": 5,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                  "name": "OtherNamedDgt",
                                  "fieldTypes": [
                                    {
                                      "name": "name",
                                      "type": {
                                        "kind": "internal",
                                        "name": "String"
                                      }
                                    }
                                  ]
                                },
                                {
                                  "kind": "variant",
                                  "tag": 6,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                  "name": "BothMintAndSpendDgt",
                                  "fieldTypes": []
                                },
                                {
                                  "kind": "variant",
                                  "tag": 7,
                                  "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                  "name": "HandledByCapoOnly",
                                  "fieldTypes": []
                                }
                              ]
                            }
                          },
                          {
                            "name": "dgtLink",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "struct",
                                "format": "list",
                                "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                "name": "RelativeDelegateLink",
                                "fieldTypes": [
                                  {
                                    "name": "uutName",
                                    "type": {
                                      "kind": "internal",
                                      "name": "String"
                                    }
                                  },
                                  {
                                    "name": "delegateValidatorHash",
                                    "type": {
                                      "kind": "option",
                                      "someType": {
                                        "kind": "internal",
                                        "name": "ValidatorHash"
                                      }
                                    }
                                  },
                                  {
                                    "name": "config",
                                    "type": {
                                      "kind": "internal",
                                      "name": "ByteArray"
                                    }
                                  }
                                ]
                              }
                            }
                          }
                        ]
                      }
                    }
                  ]
                },
                {
                  "kind": "variant",
                  "tag": 1,
                  "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
                  "name": "otherManifestChange",
                  "fieldTypes": []
                }
              ]
            }
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoHelpers__CapoDatum[]__ScriptReference",
      "name": "ScriptReference",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoHelpers__CapoDatum[]__DelegatedData",
      "name": "DelegatedData",
      "fieldTypes": [
        {
          "name": "data",
          "type": {
            "kind": "map",
            "keyType": {
              "kind": "internal",
              "name": "String"
            },
            "valueType": {
              "kind": "internal",
              "name": "Data"
            }
          }
        },
        {
          "name": "version",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        },
        {
          "name": "otherDetails",
          "type": {
            "kind": "internal",
            "name": "Data"
          }
        }
      ]
    }
  ]
};
const ManifestActivitySchema$2 = {
  "kind": "enum",
  "name": "ManifestActivity",
  "id": "__module__CapoDelegateHelpers__ManifestActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__retiringEntry",
      "name": "retiringEntry",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__updatingEntry",
      "name": "updatingEntry",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "tokenName",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__addingEntry",
      "name": "addingEntry",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "tokenName",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__forkingThreadToken",
      "name": "forkingThreadToken",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "newThreadCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__burningThreadToken",
      "name": "burningThreadToken",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "burnedThreadCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    }
  ]
};
const CapoLifecycleActivitySchema$2 = {
  "kind": "enum",
  "name": "CapoLifecycleActivity",
  "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__CreatingDelegate",
      "name": "CreatingDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__queuePendingChange",
      "name": "queuePendingChange",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__removePendingChange",
      "name": "removePendingChange",
      "fieldTypes": [
        {
          "name": "role",
          "type": {
            "kind": "enum",
            "name": "DelegateRole",
            "id": "__module__CapoDelegateHelpers__DelegateRole[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                "name": "MintDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                "name": "SpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                "name": "MintInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                "name": "SpendInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                "name": "DgDataPolicy",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 5,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                "name": "OtherNamedDgt",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 6,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                "name": "BothMintAndSpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 7,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                "name": "HandledByCapoOnly",
                "fieldTypes": []
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__commitPendingChanges",
      "name": "commitPendingChanges",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewSpendDelegate",
      "name": "forcingNewSpendDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 5,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewMintDelegate",
      "name": "forcingNewMintDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 6,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__updatingManifest",
      "name": "updatingManifest",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "ManifestActivity",
            "id": "__module__CapoDelegateHelpers__ManifestActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__retiringEntry",
                "name": "retiringEntry",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__updatingEntry",
                "name": "updatingEntry",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "tokenName",
                    "type": {
                      "kind": "internal",
                      "name": "ByteArray"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__addingEntry",
                "name": "addingEntry",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "tokenName",
                    "type": {
                      "kind": "internal",
                      "name": "ByteArray"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__forkingThreadToken",
                "name": "forkingThreadToken",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "newThreadCount",
                    "type": {
                      "kind": "internal",
                      "name": "Int"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__burningThreadToken",
                "name": "burningThreadToken",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "burnedThreadCount",
                    "type": {
                      "kind": "internal",
                      "name": "Int"
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    }
  ]
};
const CapoActivitySchema = {
  "kind": "enum",
  "name": "CapoActivity",
  "id": "__module__CapoHelpers__CapoActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoHelpers__CapoActivity[]__capoLifecycleActivity",
      "name": "capoLifecycleActivity",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "CapoLifecycleActivity",
            "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__CreatingDelegate",
                "name": "CreatingDelegate",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__queuePendingChange",
                "name": "queuePendingChange",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__removePendingChange",
                "name": "removePendingChange",
                "fieldTypes": [
                  {
                    "name": "role",
                    "type": {
                      "kind": "enum",
                      "name": "DelegateRole",
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                      "variantTypes": [
                        {
                          "kind": "variant",
                          "tag": 0,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                          "name": "MintDgt",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 1,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                          "name": "SpendDgt",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 2,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                          "name": "MintInvariant",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 3,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                          "name": "SpendInvariant",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 4,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                          "name": "DgDataPolicy",
                          "fieldTypes": [
                            {
                              "name": "name",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 5,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                          "name": "OtherNamedDgt",
                          "fieldTypes": [
                            {
                              "name": "name",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 6,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                          "name": "BothMintAndSpendDgt",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 7,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                          "name": "HandledByCapoOnly",
                          "fieldTypes": []
                        }
                      ]
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__commitPendingChanges",
                "name": "commitPendingChanges",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewSpendDelegate",
                "name": "forcingNewSpendDelegate",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 5,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewMintDelegate",
                "name": "forcingNewMintDelegate",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 6,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__updatingManifest",
                "name": "updatingManifest",
                "fieldTypes": [
                  {
                    "name": "activity",
                    "type": {
                      "kind": "enum",
                      "name": "ManifestActivity",
                      "id": "__module__CapoDelegateHelpers__ManifestActivity[]",
                      "variantTypes": [
                        {
                          "kind": "variant",
                          "tag": 0,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__retiringEntry",
                          "name": "retiringEntry",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 1,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__updatingEntry",
                          "name": "updatingEntry",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "tokenName",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 2,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__addingEntry",
                          "name": "addingEntry",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "tokenName",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 3,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__forkingThreadToken",
                          "name": "forkingThreadToken",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "newThreadCount",
                              "type": {
                                "kind": "internal",
                                "name": "Int"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 4,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__burningThreadToken",
                          "name": "burningThreadToken",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "burnedThreadCount",
                              "type": {
                                "kind": "internal",
                                "name": "Int"
                              }
                            }
                          ]
                        }
                      ]
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoHelpers__CapoActivity[]__usingAuthority",
      "name": "usingAuthority",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoHelpers__CapoActivity[]__retiringRefScript",
      "name": "retiringRefScript",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoHelpers__CapoActivity[]__addingSpendInvariant",
      "name": "addingSpendInvariant",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoHelpers__CapoActivity[]__spendingDelegatedDatum",
      "name": "spendingDelegatedDatum",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 5,
      "id": "__module__CapoHelpers__CapoActivity[]__updatingCharter",
      "name": "updatingCharter",
      "fieldTypes": []
    }
  ]
};
const AnyDataSchema$2 = {
  "kind": "struct",
  "format": "map",
  "id": "__module__StellarHeliosHelpers__AnyData[]",
  "name": "AnyData",
  "fieldTypes": [
    {
      "name": "id",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      },
      "key": "@id"
    },
    {
      "name": "type",
      "type": {
        "kind": "internal",
        "name": "String"
      },
      "key": "tpe"
    }
  ]
};

class UnspecializedDelegateBridge extends ContractDataBridge {
  static isAbstract = false;
  isAbstract = false;
  /**
   * Helper class for generating TxOutputDatum for the ***datum type (DelegateDatum)***
   * for this contract script. 
   */
  datum = new DelegateDatumHelper$1({});
  // datumAccessor/enum
  /**
   * this is the specific type of datum for the `BasicDelegate` script
   */
  DelegateDatum = this.datum;
  readDatum = (d) => {
    return this.reader.DelegateDatum(d);
  };
  /**
   * generates UplcData for the activity type (***DelegateActivity***) for the `BasicDelegate` script
   */
  activity = new DelegateActivityHelper$1({ isActivity: true });
  // activityAccessor/enum
  DelegateActivity = this.activity;
  reader = new UnspecializedDelegateBridgeReader(this);
  /**
   * accessors for all the types defined in the `BasicDelegate` script
   * @remarks - these accessors are used to generate UplcData for each type
   */
  types = {
    /**
     * generates UplcData for the enum type ***DelegateDatum*** for the `BasicDelegate` script
     */
    DelegateDatum: new DelegateDatumHelper$1(),
    /**
     * generates UplcData for the enum type ***DelegateRole*** for the `BasicDelegate` script
     */
    DelegateRole: new DelegateRoleHelper$1(),
    /**
     * generates UplcData for the enum type ***ManifestActivity*** for the `BasicDelegate` script
     */
    ManifestActivity: new ManifestActivityHelper$1(),
    /**
     * generates UplcData for the enum type ***CapoLifecycleActivity*** for the `BasicDelegate` script
     */
    CapoLifecycleActivity: new CapoLifecycleActivityHelper$1(),
    /**
     * generates UplcData for the enum type ***DelegateLifecycleActivity*** for the `BasicDelegate` script
     */
    DelegateLifecycleActivity: new DelegateLifecycleActivityHelper$1(),
    /**
     * generates UplcData for the enum type ***SpendingActivity*** for the `BasicDelegate` script
     */
    SpendingActivity: new SpendingActivityHelper$1(),
    /**
     * generates UplcData for the enum type ***MintingActivity*** for the `BasicDelegate` script
     */
    MintingActivity: new MintingActivityHelper$1(),
    /**
     * generates UplcData for the enum type ***BurningActivity*** for the `BasicDelegate` script
     */
    BurningActivity: new BurningActivityHelper$1(),
    /**
     * generates UplcData for the enum type ***DelegateActivity*** for the `BasicDelegate` script
     */
    DelegateActivity: new DelegateActivityHelper$1(),
    /**
     * generates UplcData for the enum type ***PendingDelegateAction*** for the `BasicDelegate` script
     */
    PendingDelegateAction: new PendingDelegateActionHelper$1(),
    /**
     * generates UplcData for the enum type ***ManifestEntryType*** for the `BasicDelegate` script
     */
    ManifestEntryType: new ManifestEntryTypeHelper$1(),
    /**
     * generates UplcData for the enum type ***PendingCharterChange*** for the `BasicDelegate` script
     */
    PendingCharterChange: new PendingCharterChangeHelper$1(),
    /**
     * generates UplcData for the enum type ***cctx_CharterInputType*** for the `BasicDelegate` script
     */
    cctx_CharterInputType: new cctx_CharterInputTypeHelper$1(),
    /**
     * generates UplcData for the enum type ***AnyData*** for the `BasicDelegate` script
     */
    AnyData: (fields) => {
      return this["\u1C7A\u1C7AAnyDataCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***DelegationDetail*** for the `BasicDelegate` script
     */
    DelegationDetail: (fields) => {
      return this["\u1C7A\u1C7ADelegationDetailCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***RelativeDelegateLink*** for the `BasicDelegate` script
     */
    RelativeDelegateLink: (fields) => {
      return this["\u1C7A\u1C7ARelativeDelegateLinkCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***PendingDelegateChange*** for the `BasicDelegate` script
     */
    PendingDelegateChange: (fields) => {
      return this["\u1C7A\u1C7APendingDelegateChangeCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***CapoManifestEntry*** for the `BasicDelegate` script
     */
    CapoManifestEntry: (fields) => {
      return this["\u1C7A\u1C7ACapoManifestEntryCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***CapoCtx*** for the `BasicDelegate` script
     */
    CapoCtx: (fields) => {
      return this["\u1C7A\u1C7ACapoCtxCast"].toUplcData(fields);
    }
  };
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7AAnyDataCast" = makeCast(
    AnyDataSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ADelegationDetailCast" = makeCast(
    DelegationDetailSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ARelativeDelegateLinkCast" = makeCast(
    RelativeDelegateLinkSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7APendingDelegateChangeCast" = makeCast(
    PendingDelegateChangeSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ACapoManifestEntryCast" = makeCast(
    CapoManifestEntrySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ACapoCtxCast" = makeCast(
    CapoCtxSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
}
class UnspecializedDelegateBridgeReader extends DataBridgeReaderClass {
  constructor(bridge) {
    super();
    this.bridge = bridge;
  }
  datum = (d) => {
    return this.DelegateDatum(d);
  };
  /**
      * reads UplcData *known to fit the **DelegateDatum*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegateDatum(d) {
    const typeHelper = this.bridge.types.DelegateDatum;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **DelegateRole*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegateRole(d) {
    const typeHelper = this.bridge.types.DelegateRole;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **ManifestActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  ManifestActivity(d) {
    const typeHelper = this.bridge.types.ManifestActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **CapoLifecycleActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  CapoLifecycleActivity(d) {
    const typeHelper = this.bridge.types.CapoLifecycleActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **DelegateLifecycleActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegateLifecycleActivity(d) {
    const typeHelper = this.bridge.types.DelegateLifecycleActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **SpendingActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  SpendingActivity(d) {
    const typeHelper = this.bridge.types.SpendingActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **MintingActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  MintingActivity(d) {
    const typeHelper = this.bridge.types.MintingActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **BurningActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  BurningActivity(d) {
    const typeHelper = this.bridge.types.BurningActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **DelegateActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegateActivity(d) {
    const typeHelper = this.bridge.types.DelegateActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **PendingDelegateAction*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  PendingDelegateAction(d) {
    const typeHelper = this.bridge.types.PendingDelegateAction;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **ManifestEntryType*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  ManifestEntryType(d) {
    const typeHelper = this.bridge.types.ManifestEntryType;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **PendingCharterChange*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  PendingCharterChange(d) {
    const typeHelper = this.bridge.types.PendingCharterChange;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **cctx_CharterInputType*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  cctx_CharterInputType(d) {
    const typeHelper = this.bridge.types.cctx_CharterInputType;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **AnyData*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  AnyData(d) {
    const cast = this.bridge["\u1C7A\u1C7AAnyDataCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **DelegationDetail*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegationDetail(d) {
    const cast = this.bridge["\u1C7A\u1C7ADelegationDetailCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **RelativeDelegateLink*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  RelativeDelegateLink(d) {
    const cast = this.bridge["\u1C7A\u1C7ARelativeDelegateLinkCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **PendingDelegateChange*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  PendingDelegateChange(d) {
    const cast = this.bridge["\u1C7A\u1C7APendingDelegateChangeCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **CapoManifestEntry*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  CapoManifestEntry(d) {
    const cast = this.bridge["\u1C7A\u1C7ACapoManifestEntryCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **CapoCtx*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  CapoCtx(d) {
    const cast = this.bridge["\u1C7A\u1C7ACapoCtxCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
}
let DelegateDatumHelper$1 = class DelegateDatumHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateDatumSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  InlineTxOutputDatum for ***"UnspecializedDelegate::DelegateDatum.Cip68RefToken"***
   * @remarks - ***DelegateDatum$Cip68RefTokenLike*** is the same as the expanded field-types.
   */
  Cip68RefToken(fields) {
    const uplc = this.mkUplcData({
      Cip68RefToken: fields
    }, "UnspecializedDelegate::DelegateDatum.Cip68RefToken");
    return makeInlineTxOutputDatum(uplc);
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  InlineTxOutputDatum for ***"UnspecializedDelegate::DelegateDatum.IsDelegation"***
   * @remarks - ***DelegationDetailLike*** is the same as the expanded field-type.
   */
  IsDelegation(dd) {
    const uplc = this.mkUplcData({
      IsDelegation: dd
    }, "UnspecializedDelegate::DelegateDatum.IsDelegation");
    return makeInlineTxOutputDatum(uplc);
  }
  /**
   * generates  InlineTxOutputDatum for ***"UnspecializedDelegate::DelegateDatum.capoStoredData"***
   * @remarks - ***DelegateDatum$capoStoredDataLike*** is the same as the expanded field-types.
   */
  capoStoredData(fields) {
    const uplc = this.mkUplcData({
      capoStoredData: fields
    }, "UnspecializedDelegate::DelegateDatum.capoStoredData");
    return makeInlineTxOutputDatum(uplc);
  }
  /*multiFieldVariant enum accessor*/
};
let DelegateRoleHelper$1 = class DelegateRoleHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateRoleSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get MintDgt() {
    const uplc = this.mkUplcData(
      { MintDgt: {} },
      "CapoDelegateHelpers::DelegateRole.MintDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get SpendDgt() {
    const uplc = this.mkUplcData(
      { SpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.SpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get MintInvariant() {
    const uplc = this.mkUplcData(
      { MintInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.MintInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get SpendInvariant() {
    const uplc = this.mkUplcData(
      { SpendInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.SpendInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.DgDataPolicy"***
   */
  DgDataPolicy(name) {
    const uplc = this.mkUplcData({
      DgDataPolicy: name
    }, "CapoDelegateHelpers::DelegateRole.DgDataPolicy");
    return uplc;
  }
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.OtherNamedDgt"***
   */
  OtherNamedDgt(name) {
    const uplc = this.mkUplcData({
      OtherNamedDgt: name
    }, "CapoDelegateHelpers::DelegateRole.OtherNamedDgt");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#6***
   */
  get BothMintAndSpendDgt() {
    const uplc = this.mkUplcData(
      { BothMintAndSpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#7***
   */
  get HandledByCapoOnly() {
    const uplc = this.mkUplcData(
      { HandledByCapoOnly: {} },
      "CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let ManifestActivityHelper$1 = class ManifestActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    ManifestActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.retiringEntry"***
   */
  retiringEntry(key) {
    const uplc = this.mkUplcData({
      retiringEntry: key
    }, "CapoDelegateHelpers::ManifestActivity.retiringEntry");
    return uplc;
  }
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.updatingEntry"***
   * @remarks - ***ManifestActivity$updatingEntryLike*** is the same as the expanded field-types.
   */
  updatingEntry(fields) {
    const uplc = this.mkUplcData({
      updatingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.updatingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.addingEntry"***
   * @remarks - ***ManifestActivity$addingEntryLike*** is the same as the expanded field-types.
   */
  addingEntry(fields) {
    const uplc = this.mkUplcData({
      addingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.addingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.forkingThreadToken"***
   * @remarks - ***ManifestActivity$forkingThreadTokenLike*** is the same as the expanded field-types.
   */
  forkingThreadToken(fields) {
    const uplc = this.mkUplcData({
      forkingThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.forkingThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.burningThreadToken"***
   * @remarks - ***ManifestActivity$burningThreadTokenLike*** is the same as the expanded field-types.
   */
  burningThreadToken(fields) {
    const uplc = this.mkUplcData({
      burningThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.burningThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
};
let DelegateRoleHelperNested$1 = class DelegateRoleHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateRoleSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get MintDgt() {
    const uplc = this.mkUplcData(
      { MintDgt: {} },
      "CapoDelegateHelpers::DelegateRole.MintDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get SpendDgt() {
    const uplc = this.mkUplcData(
      { SpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.SpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get MintInvariant() {
    const uplc = this.mkUplcData(
      { MintInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.MintInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get SpendInvariant() {
    const uplc = this.mkUplcData(
      { SpendInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.SpendInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.DgDataPolicy"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  DgDataPolicy(name) {
    const uplc = this.mkUplcData({
      DgDataPolicy: name
    }, "CapoDelegateHelpers::DelegateRole.DgDataPolicy");
    return uplc;
  }
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.OtherNamedDgt"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  OtherNamedDgt(name) {
    const uplc = this.mkUplcData({
      OtherNamedDgt: name
    }, "CapoDelegateHelpers::DelegateRole.OtherNamedDgt");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#6***
   */
  get BothMintAndSpendDgt() {
    const uplc = this.mkUplcData(
      { BothMintAndSpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#7***
   */
  get HandledByCapoOnly() {
    const uplc = this.mkUplcData(
      { HandledByCapoOnly: {} },
      "CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let ManifestActivityHelperNested$1 = class ManifestActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    ManifestActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.retiringEntry"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  retiringEntry(key) {
    const uplc = this.mkUplcData({
      retiringEntry: key
    }, "CapoDelegateHelpers::ManifestActivity.retiringEntry");
    return uplc;
  }
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.updatingEntry"***
   * @remarks - ***ManifestActivity$updatingEntryLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  updatingEntry(fields) {
    const uplc = this.mkUplcData({
      updatingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.updatingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.addingEntry"***
   * @remarks - ***ManifestActivity$addingEntryLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  addingEntry(fields) {
    const uplc = this.mkUplcData({
      addingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.addingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.forkingThreadToken"***
   * @remarks - ***ManifestActivity$forkingThreadTokenLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  forkingThreadToken(fields) {
    const uplc = this.mkUplcData({
      forkingThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.forkingThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.burningThreadToken"***
   * @remarks - ***ManifestActivity$burningThreadTokenLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  burningThreadToken(fields) {
    const uplc = this.mkUplcData({
      burningThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.burningThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
};
let CapoLifecycleActivityHelper$1 = class CapoLifecycleActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    CapoLifecycleActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  CreatingDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        CreatingDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        CreatingDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$CreatingDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$CreatingDelegate = impliedSeedActivityMaker(
    this,
    this.CreatingDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get queuePendingChange() {
    const uplc = this.mkUplcData(
      { queuePendingChange: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * access to different variants of the ***nested DelegateRole*** type needed for ***CapoLifecycleActivity:removePendingChange***.
   */
  get removePendingChange() {
    const nestedAccessor = new DelegateRoleHelperNested$1({
      isNested: true,
      isActivity: false
    });
    nestedAccessor.mkDataVia(
      (role) => {
        return this.mkUplcData(
          { removePendingChange: role },
          "CapoDelegateHelpers::CapoLifecycleActivity.removePendingChange"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get commitPendingChanges() {
    const uplc = this.mkUplcData(
      { commitPendingChanges: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"
    );
    return uplc;
  }
  forcingNewSpendDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewSpendDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$forcingNewSpendDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewSpendDelegate
  );
  forcingNewMintDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewMintDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$forcingNewMintDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewMintDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * access to different variants of the ***nested ManifestActivity*** type needed for ***CapoLifecycleActivity:updatingManifest***.
   */
  get updatingManifest() {
    const nestedAccessor = new ManifestActivityHelperNested$1({
      isNested: true,
      isActivity: false
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { updatingManifest: activity },
          "CapoDelegateHelpers::CapoLifecycleActivity.updatingManifest"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
};
let DelegateLifecycleActivityHelper$1 = class DelegateLifecycleActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateLifecycleActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  ReplacingMe(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        ReplacingMe: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        ReplacingMe: fields
      }, "CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$ReplacingMe({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$ReplacingMe = impliedSeedActivityMaker(
    this,
    this.ReplacingMe
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.Retiring"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get Retiring() {
    const uplc = this.mkUplcData(
      { Retiring: {} },
      "CapoDelegateHelpers::DelegateLifecycleActivity.Retiring"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.ValidatingSettings"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get ValidatingSettings() {
    const uplc = this.mkUplcData(
      { ValidatingSettings: {} },
      "CapoDelegateHelpers::DelegateLifecycleActivity.ValidatingSettings"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let SpendingActivityHelper$1 = class SpendingActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    SpendingActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  UplcData for ***"UnspecializedDelegate::SpendingActivity._placeholder1SA"***
   */
  _placeholder1SA(recId) {
    const uplc = this.mkUplcData({
      _placeholder1SA: recId
    }, "UnspecializedDelegate::SpendingActivity._placeholder1SA");
    return uplc;
  }
};
let MintingActivityHelper$1 = class MintingActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    MintingActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
  * generates  UplcData for ***"UnspecializedDelegate::MintingActivity._placeholder1MA"***, 
  * given a transaction-context (or direct arg) with a ***seed utxo*** 
  * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
  *  - to get a transaction context having the seed needed for this argument, 
  *    see the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.
  * - or see the {@link hasSeed} type for other ways to feed it with a TxOutputId.
  *  - in a context providing an implicit seed utxo, use 
  *    the `$seeded$_placeholder1MA}` variant of this activity instead
  *
   */
  _placeholder1MA(thingWithSeed) {
    const seedTxOutputId = this.getSeed(thingWithSeed);
    const uplc = this.mkUplcData({
      _placeholder1MA: seedTxOutputId
    }, "UnspecializedDelegate::MintingActivity._placeholder1MA");
    return uplc;
  }
  /*singleField/seeded enum variant*/
  /**
   * generates  UplcData for ***"UnspecializedDelegate::MintingActivity._placeholder1MA"***
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   * ## Usage
   * Access the activity-creator as a getter: `$seeded$_placeholder1MA`
   *
   * Use the resulting activity-creator in a seed-providing context, such as the delegated-data-controller's
   * `mkTxnCreateRecord({activity, ...})` method.
   */
  get $seeded$_placeholder1MA() {
    return impliedSeedActivityMaker(this, this._placeholder1MA)();
  }
  /* coda: seeded helper in same singleField/seeded enum variant*/
};
let BurningActivityHelper$1 = class BurningActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    BurningActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  UplcData for ***"UnspecializedDelegate::BurningActivity._placeholder1BA"***
   */
  _placeholder1BA(recId) {
    const uplc = this.mkUplcData({
      _placeholder1BA: recId
    }, "UnspecializedDelegate::BurningActivity._placeholder1BA");
    return uplc;
  }
};
let ActivityDelegateRoleHelperNested$1 = class ActivityDelegateRoleHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateRoleSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get MintDgt() {
    const uplc = this.mkUplcData(
      { MintDgt: {} },
      "CapoDelegateHelpers::DelegateRole.MintDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get SpendDgt() {
    const uplc = this.mkUplcData(
      { SpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.SpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get MintInvariant() {
    const uplc = this.mkUplcData(
      { MintInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.MintInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get SpendInvariant() {
    const uplc = this.mkUplcData(
      { SpendInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.SpendInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::DelegateRole.DgDataPolicy"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  DgDataPolicy(name) {
    const uplc = this.mkUplcData({
      DgDataPolicy: name
    }, "CapoDelegateHelpers::DelegateRole.DgDataPolicy");
    return uplc;
  }
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::DelegateRole.OtherNamedDgt"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  OtherNamedDgt(name) {
    const uplc = this.mkUplcData({
      OtherNamedDgt: name
    }, "CapoDelegateHelpers::DelegateRole.OtherNamedDgt");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#6***
   */
  get BothMintAndSpendDgt() {
    const uplc = this.mkUplcData(
      { BothMintAndSpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#7***
   */
  get HandledByCapoOnly() {
    const uplc = this.mkUplcData(
      { HandledByCapoOnly: {} },
      "CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let CapoLifecycleActivityHelperNested$1 = class CapoLifecycleActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    CapoLifecycleActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  CreatingDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        CreatingDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        CreatingDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$CreatingDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$CreatingDelegate = impliedSeedActivityMaker(
    this,
    this.CreatingDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get queuePendingChange() {
    const uplc = this.mkUplcData(
      { queuePendingChange: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * access to different variants of the ***nested DelegateRole*** type needed for ***CapoLifecycleActivity:removePendingChange***.
   */
  get removePendingChange() {
    const nestedAccessor = new ActivityDelegateRoleHelperNested$1({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (role) => {
        return this.mkUplcData(
          { removePendingChange: role },
          "CapoDelegateHelpers::CapoLifecycleActivity.removePendingChange"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get commitPendingChanges() {
    const uplc = this.mkUplcData(
      { commitPendingChanges: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"
    );
    return uplc;
  }
  forcingNewSpendDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewSpendDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$forcingNewSpendDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewSpendDelegate
  );
  forcingNewMintDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewMintDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$forcingNewMintDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewMintDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * access to different variants of the ***nested ManifestActivity*** type needed for ***CapoLifecycleActivity:updatingManifest***.
   */
  get updatingManifest() {
    const nestedAccessor = new ManifestActivityHelperNested$1({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { updatingManifest: activity },
          "CapoDelegateHelpers::CapoLifecycleActivity.updatingManifest"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
};
let DelegateLifecycleActivityHelperNested$1 = class DelegateLifecycleActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateLifecycleActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  ReplacingMe(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        ReplacingMe: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        ReplacingMe: fields
      }, "CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$ReplacingMe({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$ReplacingMe = impliedSeedActivityMaker(
    this,
    this.ReplacingMe
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.Retiring"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get Retiring() {
    const uplc = this.mkUplcData(
      { Retiring: {} },
      "CapoDelegateHelpers::DelegateLifecycleActivity.Retiring"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.ValidatingSettings"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get ValidatingSettings() {
    const uplc = this.mkUplcData(
      { ValidatingSettings: {} },
      "CapoDelegateHelpers::DelegateLifecycleActivity.ValidatingSettings"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let SpendingActivityHelperNested$1 = class SpendingActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    SpendingActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"UnspecializedDelegate::SpendingActivity._placeholder1SA"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  _placeholder1SA(recId) {
    const uplc = this.mkUplcData({
      _placeholder1SA: recId
    }, "UnspecializedDelegate::SpendingActivity._placeholder1SA");
    return uplc;
  }
};
let MintingActivityHelperNested$1 = class MintingActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    MintingActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
  * generates isActivity/redeemer wrapper with UplcData for ***"UnspecializedDelegate::MintingActivity._placeholder1MA"***, 
  * given a transaction-context (or direct arg) with a ***seed utxo*** 
  * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
  *  - to get a transaction context having the seed needed for this argument, 
  *    see the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.
  * - or see the {@link hasSeed} type for other ways to feed it with a TxOutputId.
  *  - in a context providing an implicit seed utxo, use 
  *    the `$seeded$_placeholder1MA}` variant of this activity instead
  *
   * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
  */
  _placeholder1MA(thingWithSeed) {
    const seedTxOutputId = this.getSeed(thingWithSeed);
    const uplc = this.mkUplcData({
      _placeholder1MA: seedTxOutputId
    }, "UnspecializedDelegate::MintingActivity._placeholder1MA");
    return uplc;
  }
  /*singleField/seeded enum variant*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"UnspecializedDelegate::MintingActivity._placeholder1MA"***
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   * ## Usage
   * Access the activity-creator as a getter: `$seeded$_placeholder1MA`
   *
   * Use the resulting activity-creator in a seed-providing context, such as the delegated-data-controller's
   * `mkTxnCreateRecord({activity, ...})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  get $seeded$_placeholder1MA() {
    return impliedSeedActivityMaker(this, this._placeholder1MA)();
  }
  /* coda: seeded helper in same singleField/seeded enum variant*/
};
let BurningActivityHelperNested$1 = class BurningActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    BurningActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"UnspecializedDelegate::BurningActivity._placeholder1BA"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  _placeholder1BA(recId) {
    const uplc = this.mkUplcData({
      _placeholder1BA: recId
    }, "UnspecializedDelegate::BurningActivity._placeholder1BA");
    return uplc;
  }
};
let DelegateActivityHelper$1 = class DelegateActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateActivitySchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * access to different variants of the ***nested CapoLifecycleActivity*** type needed for ***DelegateActivity:CapoLifecycleActivities***.
   */
  get CapoLifecycleActivities() {
    const nestedAccessor = new CapoLifecycleActivityHelperNested$1({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { CapoLifecycleActivities: activity },
          "UnspecializedDelegate::DelegateActivity.CapoLifecycleActivities"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * access to different variants of the ***nested DelegateLifecycleActivity*** type needed for ***DelegateActivity:DelegateLifecycleActivities***.
   */
  get DelegateLifecycleActivities() {
    const nestedAccessor = new DelegateLifecycleActivityHelperNested$1({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { DelegateLifecycleActivities: activity },
          "UnspecializedDelegate::DelegateActivity.DelegateLifecycleActivities"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * access to different variants of the ***nested SpendingActivity*** type needed for ***DelegateActivity:SpendingActivities***.
   */
  get SpendingActivities() {
    const nestedAccessor = new SpendingActivityHelperNested$1({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { SpendingActivities: activity },
          "UnspecializedDelegate::DelegateActivity.SpendingActivities"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * access to different variants of the ***nested MintingActivity*** type needed for ***DelegateActivity:MintingActivities***.
   */
  get MintingActivities() {
    const nestedAccessor = new MintingActivityHelperNested$1({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { MintingActivities: activity },
          "UnspecializedDelegate::DelegateActivity.MintingActivities"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * access to different variants of the ***nested BurningActivity*** type needed for ***DelegateActivity:BurningActivities***.
   */
  get BurningActivities() {
    const nestedAccessor = new BurningActivityHelperNested$1({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { BurningActivities: activity },
          "UnspecializedDelegate::DelegateActivity.BurningActivities"
        );
      }
    );
    return nestedAccessor;
  }
  CreatingDelegatedData(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        CreatingDelegatedData: { seed: seedTxOutputId, ...filteredFields }
      }, "UnspecializedDelegate::DelegateActivity.CreatingDelegatedData");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        CreatingDelegatedData: fields
      }, "UnspecializedDelegate::DelegateActivity.CreatingDelegatedData");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"UnspecializedDelegate::DelegateActivity.CreatingDelegatedData"***, 
   * @param fields - \{ dataType: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$CreatingDelegatedData({ dataType })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$CreatingDelegatedData = impliedSeedActivityMaker(
    this,
    this.CreatingDelegatedData
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"UnspecializedDelegate::DelegateActivity.UpdatingDelegatedData"***
   * @remarks - ***DelegateActivity$UpdatingDelegatedDataLike*** is the same as the expanded field-types.
   */
  UpdatingDelegatedData(fields) {
    const uplc = this.mkUplcData({
      UpdatingDelegatedData: fields
    }, "UnspecializedDelegate::DelegateActivity.UpdatingDelegatedData");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"UnspecializedDelegate::DelegateActivity.DeletingDelegatedData"***
   * @remarks - ***DelegateActivity$DeletingDelegatedDataLike*** is the same as the expanded field-types.
   */
  DeletingDelegatedData(fields) {
    const uplc = this.mkUplcData({
      DeletingDelegatedData: fields
    }, "UnspecializedDelegate::DelegateActivity.DeletingDelegatedData");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"UnspecializedDelegate::DelegateActivity.MultipleDelegateActivities"***
   */
  MultipleDelegateActivities(activities) {
    const uplc = this.mkUplcData({
      MultipleDelegateActivities: activities
    }, "UnspecializedDelegate::DelegateActivity.MultipleDelegateActivities");
    return uplc;
  }
};
let PendingDelegateActionHelper$1 = class PendingDelegateActionHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    PendingDelegateActionSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  Add(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        Add: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::PendingDelegateAction.Add");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        Add: fields
      }, "CapoDelegateHelpers::PendingDelegateAction.Add");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::PendingDelegateAction.Add"***, 
   * @param fields - \{ purpose: string, idPrefix: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$Add({ purpose, idPrefix })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$Add = impliedSeedActivityMaker(
    this,
    this.Add
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::PendingDelegateAction.Remove"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get Remove() {
    const uplc = this.mkUplcData(
      { Remove: {} },
      "CapoDelegateHelpers::PendingDelegateAction.Remove"
    );
    return uplc;
  }
  Replace(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        Replace: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::PendingDelegateAction.Replace");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        Replace: fields
      }, "CapoDelegateHelpers::PendingDelegateAction.Replace");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::PendingDelegateAction.Replace"***, 
   * @param fields - \{ purpose: string, idPrefix: string, replacesDgt: AssetClass | string | [string | MintingPolicyHash | number[], string | number[]] | \{mph: MintingPolicyHash | string | number[], tokenName: string | number[]\} \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$Replace({ purpose, idPrefix, replacesDgt })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$Replace = impliedSeedActivityMaker(
    this,
    this.Replace
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
};
let ManifestEntryTypeHelper$1 = class ManifestEntryTypeHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    ManifestEntryTypeSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoHelpers::ManifestEntryType.NamedTokenRef"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get NamedTokenRef() {
    const uplc = this.mkUplcData(
      { NamedTokenRef: {} },
      "CapoHelpers::ManifestEntryType.NamedTokenRef"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoHelpers::ManifestEntryType.DgDataPolicy"***
   * @remarks - ***ManifestEntryType$DgDataPolicyLike*** is the same as the expanded field-types.
   */
  DgDataPolicy(fields) {
    const uplc = this.mkUplcData({
      DgDataPolicy: fields
    }, "CapoHelpers::ManifestEntryType.DgDataPolicy");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoHelpers::ManifestEntryType.DelegateThreads"***
   * @remarks - ***ManifestEntryType$DelegateThreadsLike*** is the same as the expanded field-types.
   */
  DelegateThreads(fields) {
    const uplc = this.mkUplcData({
      DelegateThreads: fields
    }, "CapoHelpers::ManifestEntryType.DelegateThreads");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * (property getter): UplcData for ***"CapoHelpers::ManifestEntryType.MerkleMembership"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get MerkleMembership() {
    const uplc = this.mkUplcData(
      { MerkleMembership: {} },
      "CapoHelpers::ManifestEntryType.MerkleMembership"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoHelpers::ManifestEntryType.MerkleStateRoot"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#4***
   */
  get MerkleStateRoot() {
    const uplc = this.mkUplcData(
      { MerkleStateRoot: {} },
      "CapoHelpers::ManifestEntryType.MerkleStateRoot"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let PendingCharterChangeHelper$1 = class PendingCharterChangeHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    PendingCharterChangeSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::PendingCharterChange.delegateChange"***
   * @remarks - ***PendingDelegateChangeLike*** is the same as the expanded field-type.
   */
  delegateChange(change) {
    const uplc = this.mkUplcData({
      delegateChange: change
    }, "CapoDelegateHelpers::PendingCharterChange.delegateChange");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::PendingCharterChange.otherManifestChange"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get otherManifestChange() {
    const uplc = this.mkUplcData(
      { otherManifestChange: {} },
      "CapoDelegateHelpers::PendingCharterChange.otherManifestChange"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
};
let cctx_CharterInputTypeHelper$1 = class cctx_CharterInputTypeHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    cctx_CharterInputTypeSchema$1,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoHelpers::cctx_CharterInputType.Unk"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get Unk() {
    const uplc = this.mkUplcData(
      { Unk: {} },
      "CapoHelpers::cctx_CharterInputType.Unk"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoHelpers::cctx_CharterInputType.RefInput"***
   * @remarks - ***cctx_CharterInputType$RefInputLike*** is the same as the expanded field-types.
   */
  RefInput(fields) {
    const uplc = this.mkUplcData({
      RefInput: fields
    }, "CapoHelpers::cctx_CharterInputType.RefInput");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoHelpers::cctx_CharterInputType.Input"***
   * @remarks - ***cctx_CharterInputType$InputLike*** is the same as the expanded field-types.
   */
  Input(fields) {
    const uplc = this.mkUplcData({
      Input: fields
    }, "CapoHelpers::cctx_CharterInputType.Input");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
};
const AnyDataSchema$1 = {
  "kind": "struct",
  "format": "map",
  "id": "__module__StellarHeliosHelpers__AnyData[]",
  "name": "AnyData",
  "fieldTypes": [
    {
      "name": "id",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      },
      "key": "@id"
    },
    {
      "name": "type",
      "type": {
        "kind": "internal",
        "name": "String"
      },
      "key": "tpe"
    }
  ]
};
const DelegationDetailSchema$1 = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoDelegateHelpers__DelegationDetail[]",
  "name": "DelegationDetail",
  "fieldTypes": [
    {
      "name": "capoAddr",
      "type": {
        "kind": "internal",
        "name": "Address"
      }
    },
    {
      "name": "mph",
      "type": {
        "kind": "internal",
        "name": "MintingPolicyHash"
      }
    },
    {
      "name": "tn",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      }
    }
  ]
};
const DelegateDatumSchema$1 = {
  "kind": "enum",
  "name": "DelegateDatum",
  "id": "__module__UnspecializedDelegate__DelegateDatum[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__UnspecializedDelegate__DelegateDatum[]__Cip68RefToken",
      "name": "Cip68RefToken",
      "fieldTypes": [
        {
          "name": "cip68meta",
          "type": {
            "kind": "struct",
            "format": "map",
            "id": "__module__StellarHeliosHelpers__AnyData[]",
            "name": "AnyData",
            "fieldTypes": [
              {
                "name": "id",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                },
                "key": "@id"
              },
              {
                "name": "type",
                "type": {
                  "kind": "internal",
                  "name": "String"
                },
                "key": "tpe"
              }
            ]
          }
        },
        {
          "name": "cip68version",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        },
        {
          "name": "otherDetails",
          "type": {
            "kind": "internal",
            "name": "Data"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__UnspecializedDelegate__DelegateDatum[]__IsDelegation",
      "name": "IsDelegation",
      "fieldTypes": [
        {
          "name": "dd",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__DelegationDetail[]",
            "name": "DelegationDetail",
            "fieldTypes": [
              {
                "name": "capoAddr",
                "type": {
                  "kind": "internal",
                  "name": "Address"
                }
              },
              {
                "name": "mph",
                "type": {
                  "kind": "internal",
                  "name": "MintingPolicyHash"
                }
              },
              {
                "name": "tn",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                }
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__UnspecializedDelegate__DelegateDatum[]__capoStoredData",
      "name": "capoStoredData",
      "fieldTypes": [
        {
          "name": "data",
          "type": {
            "kind": "struct",
            "format": "map",
            "id": "__module__StellarHeliosHelpers__AnyData[]",
            "name": "AnyData",
            "fieldTypes": [
              {
                "name": "id",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                },
                "key": "@id"
              },
              {
                "name": "type",
                "type": {
                  "kind": "internal",
                  "name": "String"
                },
                "key": "tpe"
              }
            ]
          }
        },
        {
          "name": "version",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        },
        {
          "name": "otherDetails",
          "type": {
            "kind": "internal",
            "name": "Data"
          }
        }
      ]
    }
  ]
};
const DelegateRoleSchema$1 = {
  "kind": "enum",
  "name": "DelegateRole",
  "id": "__module__CapoDelegateHelpers__DelegateRole[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
      "name": "MintDgt",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
      "name": "SpendDgt",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
      "name": "MintInvariant",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
      "name": "SpendInvariant",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
      "name": "DgDataPolicy",
      "fieldTypes": [
        {
          "name": "name",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 5,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
      "name": "OtherNamedDgt",
      "fieldTypes": [
        {
          "name": "name",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 6,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
      "name": "BothMintAndSpendDgt",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 7,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
      "name": "HandledByCapoOnly",
      "fieldTypes": []
    }
  ]
};
const ManifestActivitySchema$1 = {
  "kind": "enum",
  "name": "ManifestActivity",
  "id": "__module__CapoDelegateHelpers__ManifestActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__retiringEntry",
      "name": "retiringEntry",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__updatingEntry",
      "name": "updatingEntry",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "tokenName",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__addingEntry",
      "name": "addingEntry",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "tokenName",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__forkingThreadToken",
      "name": "forkingThreadToken",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "newThreadCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__burningThreadToken",
      "name": "burningThreadToken",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "burnedThreadCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    }
  ]
};
const CapoLifecycleActivitySchema$1 = {
  "kind": "enum",
  "name": "CapoLifecycleActivity",
  "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__CreatingDelegate",
      "name": "CreatingDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__queuePendingChange",
      "name": "queuePendingChange",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__removePendingChange",
      "name": "removePendingChange",
      "fieldTypes": [
        {
          "name": "role",
          "type": {
            "kind": "enum",
            "name": "DelegateRole",
            "id": "__module__CapoDelegateHelpers__DelegateRole[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                "name": "MintDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                "name": "SpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                "name": "MintInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                "name": "SpendInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                "name": "DgDataPolicy",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 5,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                "name": "OtherNamedDgt",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 6,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                "name": "BothMintAndSpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 7,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                "name": "HandledByCapoOnly",
                "fieldTypes": []
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__commitPendingChanges",
      "name": "commitPendingChanges",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewSpendDelegate",
      "name": "forcingNewSpendDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 5,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewMintDelegate",
      "name": "forcingNewMintDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 6,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__updatingManifest",
      "name": "updatingManifest",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "ManifestActivity",
            "id": "__module__CapoDelegateHelpers__ManifestActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__retiringEntry",
                "name": "retiringEntry",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__updatingEntry",
                "name": "updatingEntry",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "tokenName",
                    "type": {
                      "kind": "internal",
                      "name": "ByteArray"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__addingEntry",
                "name": "addingEntry",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "tokenName",
                    "type": {
                      "kind": "internal",
                      "name": "ByteArray"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__forkingThreadToken",
                "name": "forkingThreadToken",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "newThreadCount",
                    "type": {
                      "kind": "internal",
                      "name": "Int"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__burningThreadToken",
                "name": "burningThreadToken",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "burnedThreadCount",
                    "type": {
                      "kind": "internal",
                      "name": "Int"
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    }
  ]
};
const DelegateLifecycleActivitySchema$1 = {
  "kind": "enum",
  "name": "DelegateLifecycleActivity",
  "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__ReplacingMe",
      "name": "ReplacingMe",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__Retiring",
      "name": "Retiring",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__ValidatingSettings",
      "name": "ValidatingSettings",
      "fieldTypes": []
    }
  ]
};
const SpendingActivitySchema$1 = {
  "kind": "enum",
  "name": "SpendingActivity",
  "id": "__module__UnspecializedDelegate__SpendingActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__UnspecializedDelegate__SpendingActivity[]___placeholder1SA",
      "name": "_placeholder1SA",
      "fieldTypes": [
        {
          "name": "recId",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    }
  ]
};
const MintingActivitySchema$1 = {
  "kind": "enum",
  "name": "MintingActivity",
  "id": "__module__UnspecializedDelegate__MintingActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__UnspecializedDelegate__MintingActivity[]___placeholder1MA",
      "name": "_placeholder1MA",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        }
      ]
    }
  ]
};
const BurningActivitySchema$1 = {
  "kind": "enum",
  "name": "BurningActivity",
  "id": "__module__UnspecializedDelegate__BurningActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__UnspecializedDelegate__BurningActivity[]___placeholder1BA",
      "name": "_placeholder1BA",
      "fieldTypes": [
        {
          "name": "recId",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    }
  ]
};
const DelegateActivitySchema$1 = {
  "kind": "enum",
  "name": "DelegateActivity",
  "id": "__module__UnspecializedDelegate__DelegateActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__UnspecializedDelegate__DelegateActivity[]__CapoLifecycleActivities",
      "name": "CapoLifecycleActivities",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "CapoLifecycleActivity",
            "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__CreatingDelegate",
                "name": "CreatingDelegate",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__queuePendingChange",
                "name": "queuePendingChange",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__removePendingChange",
                "name": "removePendingChange",
                "fieldTypes": [
                  {
                    "name": "role",
                    "type": {
                      "kind": "enum",
                      "name": "DelegateRole",
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                      "variantTypes": [
                        {
                          "kind": "variant",
                          "tag": 0,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                          "name": "MintDgt",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 1,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                          "name": "SpendDgt",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 2,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                          "name": "MintInvariant",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 3,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                          "name": "SpendInvariant",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 4,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                          "name": "DgDataPolicy",
                          "fieldTypes": [
                            {
                              "name": "name",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 5,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                          "name": "OtherNamedDgt",
                          "fieldTypes": [
                            {
                              "name": "name",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 6,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                          "name": "BothMintAndSpendDgt",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 7,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                          "name": "HandledByCapoOnly",
                          "fieldTypes": []
                        }
                      ]
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__commitPendingChanges",
                "name": "commitPendingChanges",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewSpendDelegate",
                "name": "forcingNewSpendDelegate",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 5,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewMintDelegate",
                "name": "forcingNewMintDelegate",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 6,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__updatingManifest",
                "name": "updatingManifest",
                "fieldTypes": [
                  {
                    "name": "activity",
                    "type": {
                      "kind": "enum",
                      "name": "ManifestActivity",
                      "id": "__module__CapoDelegateHelpers__ManifestActivity[]",
                      "variantTypes": [
                        {
                          "kind": "variant",
                          "tag": 0,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__retiringEntry",
                          "name": "retiringEntry",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 1,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__updatingEntry",
                          "name": "updatingEntry",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "tokenName",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 2,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__addingEntry",
                          "name": "addingEntry",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "tokenName",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 3,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__forkingThreadToken",
                          "name": "forkingThreadToken",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "newThreadCount",
                              "type": {
                                "kind": "internal",
                                "name": "Int"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 4,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__burningThreadToken",
                          "name": "burningThreadToken",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "burnedThreadCount",
                              "type": {
                                "kind": "internal",
                                "name": "Int"
                              }
                            }
                          ]
                        }
                      ]
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__UnspecializedDelegate__DelegateActivity[]__DelegateLifecycleActivities",
      "name": "DelegateLifecycleActivities",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "DelegateLifecycleActivity",
            "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__ReplacingMe",
                "name": "ReplacingMe",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__Retiring",
                "name": "Retiring",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__ValidatingSettings",
                "name": "ValidatingSettings",
                "fieldTypes": []
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__UnspecializedDelegate__DelegateActivity[]__SpendingActivities",
      "name": "SpendingActivities",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "SpendingActivity",
            "id": "__module__UnspecializedDelegate__SpendingActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__UnspecializedDelegate__SpendingActivity[]___placeholder1SA",
                "name": "_placeholder1SA",
                "fieldTypes": [
                  {
                    "name": "recId",
                    "type": {
                      "kind": "internal",
                      "name": "ByteArray"
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__UnspecializedDelegate__DelegateActivity[]__MintingActivities",
      "name": "MintingActivities",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "MintingActivity",
            "id": "__module__UnspecializedDelegate__MintingActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__UnspecializedDelegate__MintingActivity[]___placeholder1MA",
                "name": "_placeholder1MA",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__UnspecializedDelegate__DelegateActivity[]__BurningActivities",
      "name": "BurningActivities",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "BurningActivity",
            "id": "__module__UnspecializedDelegate__BurningActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__UnspecializedDelegate__BurningActivity[]___placeholder1BA",
                "name": "_placeholder1BA",
                "fieldTypes": [
                  {
                    "name": "recId",
                    "type": {
                      "kind": "internal",
                      "name": "ByteArray"
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 5,
      "id": "__module__UnspecializedDelegate__DelegateActivity[]__CreatingDelegatedData",
      "name": "CreatingDelegatedData",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "dataType",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 6,
      "id": "__module__UnspecializedDelegate__DelegateActivity[]__UpdatingDelegatedData",
      "name": "UpdatingDelegatedData",
      "fieldTypes": [
        {
          "name": "dataType",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "recId",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 7,
      "id": "__module__UnspecializedDelegate__DelegateActivity[]__DeletingDelegatedData",
      "name": "DeletingDelegatedData",
      "fieldTypes": [
        {
          "name": "dataType",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "recId",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 8,
      "id": "__module__UnspecializedDelegate__DelegateActivity[]__MultipleDelegateActivities",
      "name": "MultipleDelegateActivities",
      "fieldTypes": [
        {
          "name": "activities",
          "type": {
            "kind": "list",
            "itemType": {
              "kind": "internal",
              "name": "Data"
            }
          }
        }
      ]
    }
  ]
};
const PendingDelegateActionSchema$1 = {
  "kind": "enum",
  "name": "PendingDelegateAction",
  "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
      "name": "Add",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "idPrefix",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
      "name": "Remove",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
      "name": "Replace",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "idPrefix",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "replacesDgt",
          "type": {
            "kind": "internal",
            "name": "AssetClass"
          }
        }
      ]
    }
  ]
};
const RelativeDelegateLinkSchema$1 = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
  "name": "RelativeDelegateLink",
  "fieldTypes": [
    {
      "name": "uutName",
      "type": {
        "kind": "internal",
        "name": "String"
      }
    },
    {
      "name": "delegateValidatorHash",
      "type": {
        "kind": "option",
        "someType": {
          "kind": "internal",
          "name": "ValidatorHash"
        }
      }
    },
    {
      "name": "config",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      }
    }
  ]
};
const PendingDelegateChangeSchema$1 = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
  "name": "PendingDelegateChange",
  "fieldTypes": [
    {
      "name": "action",
      "type": {
        "kind": "enum",
        "name": "PendingDelegateAction",
        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
            "name": "Add",
            "fieldTypes": [
              {
                "name": "seed",
                "type": {
                  "kind": "internal",
                  "name": "TxOutputId"
                }
              },
              {
                "name": "purpose",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "idPrefix",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
            "name": "Remove",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
            "name": "Replace",
            "fieldTypes": [
              {
                "name": "seed",
                "type": {
                  "kind": "internal",
                  "name": "TxOutputId"
                }
              },
              {
                "name": "purpose",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "idPrefix",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "replacesDgt",
                "type": {
                  "kind": "internal",
                  "name": "AssetClass"
                }
              }
            ]
          }
        ]
      }
    },
    {
      "name": "role",
      "type": {
        "kind": "enum",
        "name": "DelegateRole",
        "id": "__module__CapoDelegateHelpers__DelegateRole[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
            "name": "MintDgt",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
            "name": "SpendDgt",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
            "name": "MintInvariant",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 3,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
            "name": "SpendInvariant",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 4,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
            "name": "DgDataPolicy",
            "fieldTypes": [
              {
                "name": "name",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 5,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
            "name": "OtherNamedDgt",
            "fieldTypes": [
              {
                "name": "name",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 6,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
            "name": "BothMintAndSpendDgt",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 7,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
            "name": "HandledByCapoOnly",
            "fieldTypes": []
          }
        ]
      }
    },
    {
      "name": "dgtLink",
      "type": {
        "kind": "option",
        "someType": {
          "kind": "struct",
          "format": "list",
          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
          "name": "RelativeDelegateLink",
          "fieldTypes": [
            {
              "name": "uutName",
              "type": {
                "kind": "internal",
                "name": "String"
              }
            },
            {
              "name": "delegateValidatorHash",
              "type": {
                "kind": "option",
                "someType": {
                  "kind": "internal",
                  "name": "ValidatorHash"
                }
              }
            },
            {
              "name": "config",
              "type": {
                "kind": "internal",
                "name": "ByteArray"
              }
            }
          ]
        }
      }
    }
  ]
};
const ManifestEntryTypeSchema$1 = {
  "kind": "enum",
  "name": "ManifestEntryType",
  "id": "__module__CapoHelpers__ManifestEntryType[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
      "name": "NamedTokenRef",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
      "name": "DgDataPolicy",
      "fieldTypes": [
        {
          "name": "policyLink",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
            "name": "RelativeDelegateLink",
            "fieldTypes": [
              {
                "name": "uutName",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "delegateValidatorHash",
                "type": {
                  "kind": "option",
                  "someType": {
                    "kind": "internal",
                    "name": "ValidatorHash"
                  }
                }
              },
              {
                "name": "config",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                }
              }
            ]
          }
        },
        {
          "name": "idPrefix",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "refCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
      "name": "DelegateThreads",
      "fieldTypes": [
        {
          "name": "role",
          "type": {
            "kind": "enum",
            "name": "DelegateRole",
            "id": "__module__CapoDelegateHelpers__DelegateRole[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                "name": "MintDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                "name": "SpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                "name": "MintInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                "name": "SpendInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                "name": "DgDataPolicy",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 5,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                "name": "OtherNamedDgt",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 6,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                "name": "BothMintAndSpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 7,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                "name": "HandledByCapoOnly",
                "fieldTypes": []
              }
            ]
          }
        },
        {
          "name": "refCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
      "name": "MerkleMembership",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
      "name": "MerkleStateRoot",
      "fieldTypes": []
    }
  ]
};
const CapoManifestEntrySchema$1 = {
  "kind": "struct",
  "format": "map",
  "id": "__module__CapoHelpers__CapoManifestEntry[]",
  "name": "CapoManifestEntry",
  "fieldTypes": [
    {
      "name": "entryType",
      "type": {
        "kind": "enum",
        "name": "ManifestEntryType",
        "id": "__module__CapoHelpers__ManifestEntryType[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
            "name": "NamedTokenRef",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
            "name": "DgDataPolicy",
            "fieldTypes": [
              {
                "name": "policyLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "idPrefix",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "refCount",
                "type": {
                  "kind": "internal",
                  "name": "Int"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
            "name": "DelegateThreads",
            "fieldTypes": [
              {
                "name": "role",
                "type": {
                  "kind": "enum",
                  "name": "DelegateRole",
                  "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                  "variantTypes": [
                    {
                      "kind": "variant",
                      "tag": 0,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                      "name": "MintDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 1,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                      "name": "SpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 2,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                      "name": "MintInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 3,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                      "name": "SpendInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 4,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                      "name": "DgDataPolicy",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 5,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                      "name": "OtherNamedDgt",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 6,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                      "name": "BothMintAndSpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 7,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                      "name": "HandledByCapoOnly",
                      "fieldTypes": []
                    }
                  ]
                }
              },
              {
                "name": "refCount",
                "type": {
                  "kind": "internal",
                  "name": "Int"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 3,
            "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
            "name": "MerkleMembership",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 4,
            "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
            "name": "MerkleStateRoot",
            "fieldTypes": []
          }
        ]
      },
      "key": "tpe"
    },
    {
      "name": "tokenName",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      },
      "key": "tn"
    },
    {
      "name": "mph",
      "type": {
        "kind": "option",
        "someType": {
          "kind": "internal",
          "name": "MintingPolicyHash"
        }
      }
    }
  ]
};
const PendingCharterChangeSchema$1 = {
  "kind": "enum",
  "name": "PendingCharterChange",
  "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
      "name": "delegateChange",
      "fieldTypes": [
        {
          "name": "change",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
            "name": "PendingDelegateChange",
            "fieldTypes": [
              {
                "name": "action",
                "type": {
                  "kind": "enum",
                  "name": "PendingDelegateAction",
                  "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                  "variantTypes": [
                    {
                      "kind": "variant",
                      "tag": 0,
                      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                      "name": "Add",
                      "fieldTypes": [
                        {
                          "name": "seed",
                          "type": {
                            "kind": "internal",
                            "name": "TxOutputId"
                          }
                        },
                        {
                          "name": "purpose",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        },
                        {
                          "name": "idPrefix",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 1,
                      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                      "name": "Remove",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 2,
                      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                      "name": "Replace",
                      "fieldTypes": [
                        {
                          "name": "seed",
                          "type": {
                            "kind": "internal",
                            "name": "TxOutputId"
                          }
                        },
                        {
                          "name": "purpose",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        },
                        {
                          "name": "idPrefix",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        },
                        {
                          "name": "replacesDgt",
                          "type": {
                            "kind": "internal",
                            "name": "AssetClass"
                          }
                        }
                      ]
                    }
                  ]
                }
              },
              {
                "name": "role",
                "type": {
                  "kind": "enum",
                  "name": "DelegateRole",
                  "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                  "variantTypes": [
                    {
                      "kind": "variant",
                      "tag": 0,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                      "name": "MintDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 1,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                      "name": "SpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 2,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                      "name": "MintInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 3,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                      "name": "SpendInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 4,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                      "name": "DgDataPolicy",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 5,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                      "name": "OtherNamedDgt",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 6,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                      "name": "BothMintAndSpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 7,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                      "name": "HandledByCapoOnly",
                      "fieldTypes": []
                    }
                  ]
                }
              },
              {
                "name": "dgtLink",
                "type": {
                  "kind": "option",
                  "someType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
      "name": "otherManifestChange",
      "fieldTypes": []
    }
  ]
};
const cctx_CharterInputTypeSchema$1 = {
  "kind": "enum",
  "name": "cctx_CharterInputType",
  "id": "__module__CapoHelpers__cctx_CharterInputType[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoHelpers__cctx_CharterInputType[]__Unk",
      "name": "Unk",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoHelpers__cctx_CharterInputType[]__RefInput",
      "name": "RefInput",
      "fieldTypes": [
        {
          "name": "datum",
          "type": {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoHelpers__CapoDatum[]__CharterData",
            "name": "CharterData",
            "fieldTypes": [
              {
                "name": "spendDelegateLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "spendInvariants",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "otherNamedDelegates",
                "type": {
                  "kind": "map",
                  "keyType": {
                    "kind": "internal",
                    "name": "String"
                  },
                  "valueType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "mintDelegateLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "mintInvariants",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "govAuthorityLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "manifest",
                "type": {
                  "kind": "map",
                  "keyType": {
                    "kind": "internal",
                    "name": "String"
                  },
                  "valueType": {
                    "kind": "struct",
                    "format": "map",
                    "id": "__module__CapoHelpers__CapoManifestEntry[]",
                    "name": "CapoManifestEntry",
                    "fieldTypes": [
                      {
                        "name": "entryType",
                        "type": {
                          "kind": "enum",
                          "name": "ManifestEntryType",
                          "id": "__module__CapoHelpers__ManifestEntryType[]",
                          "variantTypes": [
                            {
                              "kind": "variant",
                              "tag": 0,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
                              "name": "NamedTokenRef",
                              "fieldTypes": []
                            },
                            {
                              "kind": "variant",
                              "tag": 1,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
                              "name": "DgDataPolicy",
                              "fieldTypes": [
                                {
                                  "name": "policyLink",
                                  "type": {
                                    "kind": "struct",
                                    "format": "list",
                                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                    "name": "RelativeDelegateLink",
                                    "fieldTypes": [
                                      {
                                        "name": "uutName",
                                        "type": {
                                          "kind": "internal",
                                          "name": "String"
                                        }
                                      },
                                      {
                                        "name": "delegateValidatorHash",
                                        "type": {
                                          "kind": "option",
                                          "someType": {
                                            "kind": "internal",
                                            "name": "ValidatorHash"
                                          }
                                        }
                                      },
                                      {
                                        "name": "config",
                                        "type": {
                                          "kind": "internal",
                                          "name": "ByteArray"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "idPrefix",
                                  "type": {
                                    "kind": "internal",
                                    "name": "String"
                                  }
                                },
                                {
                                  "name": "refCount",
                                  "type": {
                                    "kind": "internal",
                                    "name": "Int"
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 2,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
                              "name": "DelegateThreads",
                              "fieldTypes": [
                                {
                                  "name": "role",
                                  "type": {
                                    "kind": "enum",
                                    "name": "DelegateRole",
                                    "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                        "name": "MintDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                        "name": "SpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                        "name": "MintInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 3,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                        "name": "SpendInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 4,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                        "name": "DgDataPolicy",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 5,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                        "name": "OtherNamedDgt",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 6,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                        "name": "BothMintAndSpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 7,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                        "name": "HandledByCapoOnly",
                                        "fieldTypes": []
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "refCount",
                                  "type": {
                                    "kind": "internal",
                                    "name": "Int"
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 3,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
                              "name": "MerkleMembership",
                              "fieldTypes": []
                            },
                            {
                              "kind": "variant",
                              "tag": 4,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
                              "name": "MerkleStateRoot",
                              "fieldTypes": []
                            }
                          ]
                        },
                        "key": "tpe"
                      },
                      {
                        "name": "tokenName",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        },
                        "key": "tn"
                      },
                      {
                        "name": "mph",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "MintingPolicyHash"
                          }
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "pendingChanges",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "enum",
                    "name": "PendingCharterChange",
                    "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
                    "variantTypes": [
                      {
                        "kind": "variant",
                        "tag": 0,
                        "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
                        "name": "delegateChange",
                        "fieldTypes": [
                          {
                            "name": "change",
                            "type": {
                              "kind": "struct",
                              "format": "list",
                              "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
                              "name": "PendingDelegateChange",
                              "fieldTypes": [
                                {
                                  "name": "action",
                                  "type": {
                                    "kind": "enum",
                                    "name": "PendingDelegateAction",
                                    "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                                        "name": "Add",
                                        "fieldTypes": [
                                          {
                                            "name": "seed",
                                            "type": {
                                              "kind": "internal",
                                              "name": "TxOutputId"
                                            }
                                          },
                                          {
                                            "name": "purpose",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "idPrefix",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                                        "name": "Remove",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                                        "name": "Replace",
                                        "fieldTypes": [
                                          {
                                            "name": "seed",
                                            "type": {
                                              "kind": "internal",
                                              "name": "TxOutputId"
                                            }
                                          },
                                          {
                                            "name": "purpose",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "idPrefix",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "replacesDgt",
                                            "type": {
                                              "kind": "internal",
                                              "name": "AssetClass"
                                            }
                                          }
                                        ]
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "role",
                                  "type": {
                                    "kind": "enum",
                                    "name": "DelegateRole",
                                    "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                        "name": "MintDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                        "name": "SpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                        "name": "MintInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 3,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                        "name": "SpendInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 4,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                        "name": "DgDataPolicy",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 5,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                        "name": "OtherNamedDgt",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 6,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                        "name": "BothMintAndSpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 7,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                        "name": "HandledByCapoOnly",
                                        "fieldTypes": []
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "dgtLink",
                                  "type": {
                                    "kind": "option",
                                    "someType": {
                                      "kind": "struct",
                                      "format": "list",
                                      "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                      "name": "RelativeDelegateLink",
                                      "fieldTypes": [
                                        {
                                          "name": "uutName",
                                          "type": {
                                            "kind": "internal",
                                            "name": "String"
                                          }
                                        },
                                        {
                                          "name": "delegateValidatorHash",
                                          "type": {
                                            "kind": "option",
                                            "someType": {
                                              "kind": "internal",
                                              "name": "ValidatorHash"
                                            }
                                          }
                                        },
                                        {
                                          "name": "config",
                                          "type": {
                                            "kind": "internal",
                                            "name": "ByteArray"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      },
                      {
                        "kind": "variant",
                        "tag": 1,
                        "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
                        "name": "otherManifestChange",
                        "fieldTypes": []
                      }
                    ]
                  }
                }
              }
            ]
          }
        },
        {
          "name": "utxo",
          "type": {
            "kind": "internal",
            "name": "TxInput"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoHelpers__cctx_CharterInputType[]__Input",
      "name": "Input",
      "fieldTypes": [
        {
          "name": "datum",
          "type": {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoHelpers__CapoDatum[]__CharterData",
            "name": "CharterData",
            "fieldTypes": [
              {
                "name": "spendDelegateLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "spendInvariants",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "otherNamedDelegates",
                "type": {
                  "kind": "map",
                  "keyType": {
                    "kind": "internal",
                    "name": "String"
                  },
                  "valueType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "mintDelegateLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "mintInvariants",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "govAuthorityLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "manifest",
                "type": {
                  "kind": "map",
                  "keyType": {
                    "kind": "internal",
                    "name": "String"
                  },
                  "valueType": {
                    "kind": "struct",
                    "format": "map",
                    "id": "__module__CapoHelpers__CapoManifestEntry[]",
                    "name": "CapoManifestEntry",
                    "fieldTypes": [
                      {
                        "name": "entryType",
                        "type": {
                          "kind": "enum",
                          "name": "ManifestEntryType",
                          "id": "__module__CapoHelpers__ManifestEntryType[]",
                          "variantTypes": [
                            {
                              "kind": "variant",
                              "tag": 0,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
                              "name": "NamedTokenRef",
                              "fieldTypes": []
                            },
                            {
                              "kind": "variant",
                              "tag": 1,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
                              "name": "DgDataPolicy",
                              "fieldTypes": [
                                {
                                  "name": "policyLink",
                                  "type": {
                                    "kind": "struct",
                                    "format": "list",
                                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                    "name": "RelativeDelegateLink",
                                    "fieldTypes": [
                                      {
                                        "name": "uutName",
                                        "type": {
                                          "kind": "internal",
                                          "name": "String"
                                        }
                                      },
                                      {
                                        "name": "delegateValidatorHash",
                                        "type": {
                                          "kind": "option",
                                          "someType": {
                                            "kind": "internal",
                                            "name": "ValidatorHash"
                                          }
                                        }
                                      },
                                      {
                                        "name": "config",
                                        "type": {
                                          "kind": "internal",
                                          "name": "ByteArray"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "idPrefix",
                                  "type": {
                                    "kind": "internal",
                                    "name": "String"
                                  }
                                },
                                {
                                  "name": "refCount",
                                  "type": {
                                    "kind": "internal",
                                    "name": "Int"
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 2,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
                              "name": "DelegateThreads",
                              "fieldTypes": [
                                {
                                  "name": "role",
                                  "type": {
                                    "kind": "enum",
                                    "name": "DelegateRole",
                                    "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                        "name": "MintDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                        "name": "SpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                        "name": "MintInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 3,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                        "name": "SpendInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 4,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                        "name": "DgDataPolicy",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 5,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                        "name": "OtherNamedDgt",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 6,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                        "name": "BothMintAndSpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 7,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                        "name": "HandledByCapoOnly",
                                        "fieldTypes": []
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "refCount",
                                  "type": {
                                    "kind": "internal",
                                    "name": "Int"
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 3,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
                              "name": "MerkleMembership",
                              "fieldTypes": []
                            },
                            {
                              "kind": "variant",
                              "tag": 4,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
                              "name": "MerkleStateRoot",
                              "fieldTypes": []
                            }
                          ]
                        },
                        "key": "tpe"
                      },
                      {
                        "name": "tokenName",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        },
                        "key": "tn"
                      },
                      {
                        "name": "mph",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "MintingPolicyHash"
                          }
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "pendingChanges",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "enum",
                    "name": "PendingCharterChange",
                    "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
                    "variantTypes": [
                      {
                        "kind": "variant",
                        "tag": 0,
                        "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
                        "name": "delegateChange",
                        "fieldTypes": [
                          {
                            "name": "change",
                            "type": {
                              "kind": "struct",
                              "format": "list",
                              "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
                              "name": "PendingDelegateChange",
                              "fieldTypes": [
                                {
                                  "name": "action",
                                  "type": {
                                    "kind": "enum",
                                    "name": "PendingDelegateAction",
                                    "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                                        "name": "Add",
                                        "fieldTypes": [
                                          {
                                            "name": "seed",
                                            "type": {
                                              "kind": "internal",
                                              "name": "TxOutputId"
                                            }
                                          },
                                          {
                                            "name": "purpose",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "idPrefix",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                                        "name": "Remove",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                                        "name": "Replace",
                                        "fieldTypes": [
                                          {
                                            "name": "seed",
                                            "type": {
                                              "kind": "internal",
                                              "name": "TxOutputId"
                                            }
                                          },
                                          {
                                            "name": "purpose",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "idPrefix",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "replacesDgt",
                                            "type": {
                                              "kind": "internal",
                                              "name": "AssetClass"
                                            }
                                          }
                                        ]
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "role",
                                  "type": {
                                    "kind": "enum",
                                    "name": "DelegateRole",
                                    "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                        "name": "MintDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                        "name": "SpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                        "name": "MintInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 3,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                        "name": "SpendInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 4,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                        "name": "DgDataPolicy",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 5,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                        "name": "OtherNamedDgt",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 6,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                        "name": "BothMintAndSpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 7,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                        "name": "HandledByCapoOnly",
                                        "fieldTypes": []
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "dgtLink",
                                  "type": {
                                    "kind": "option",
                                    "someType": {
                                      "kind": "struct",
                                      "format": "list",
                                      "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                      "name": "RelativeDelegateLink",
                                      "fieldTypes": [
                                        {
                                          "name": "uutName",
                                          "type": {
                                            "kind": "internal",
                                            "name": "String"
                                          }
                                        },
                                        {
                                          "name": "delegateValidatorHash",
                                          "type": {
                                            "kind": "option",
                                            "someType": {
                                              "kind": "internal",
                                              "name": "ValidatorHash"
                                            }
                                          }
                                        },
                                        {
                                          "name": "config",
                                          "type": {
                                            "kind": "internal",
                                            "name": "ByteArray"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      },
                      {
                        "kind": "variant",
                        "tag": 1,
                        "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
                        "name": "otherManifestChange",
                        "fieldTypes": []
                      }
                    ]
                  }
                }
              }
            ]
          }
        },
        {
          "name": "utxo",
          "type": {
            "kind": "internal",
            "name": "TxInput"
          }
        }
      ]
    }
  ]
};
const CapoCtxSchema$1 = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoHelpers__CapoCtx[]",
  "name": "CapoCtx",
  "fieldTypes": [
    {
      "name": "mph",
      "type": {
        "kind": "internal",
        "name": "MintingPolicyHash"
      }
    },
    {
      "name": "charter",
      "type": {
        "kind": "enum",
        "name": "cctx_CharterInputType",
        "id": "__module__CapoHelpers__cctx_CharterInputType[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoHelpers__cctx_CharterInputType[]__Unk",
            "name": "Unk",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoHelpers__cctx_CharterInputType[]__RefInput",
            "name": "RefInput",
            "fieldTypes": [
              {
                "name": "datum",
                "type": {
                  "kind": "variant",
                  "tag": 0,
                  "id": "__module__CapoHelpers__CapoDatum[]__CharterData",
                  "name": "CharterData",
                  "fieldTypes": [
                    {
                      "name": "spendDelegateLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "spendInvariants",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "otherNamedDelegates",
                      "type": {
                        "kind": "map",
                        "keyType": {
                          "kind": "internal",
                          "name": "String"
                        },
                        "valueType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "mintDelegateLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "mintInvariants",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "govAuthorityLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "manifest",
                      "type": {
                        "kind": "map",
                        "keyType": {
                          "kind": "internal",
                          "name": "String"
                        },
                        "valueType": {
                          "kind": "struct",
                          "format": "map",
                          "id": "__module__CapoHelpers__CapoManifestEntry[]",
                          "name": "CapoManifestEntry",
                          "fieldTypes": [
                            {
                              "name": "entryType",
                              "type": {
                                "kind": "enum",
                                "name": "ManifestEntryType",
                                "id": "__module__CapoHelpers__ManifestEntryType[]",
                                "variantTypes": [
                                  {
                                    "kind": "variant",
                                    "tag": 0,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
                                    "name": "NamedTokenRef",
                                    "fieldTypes": []
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 1,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
                                    "name": "DgDataPolicy",
                                    "fieldTypes": [
                                      {
                                        "name": "policyLink",
                                        "type": {
                                          "kind": "struct",
                                          "format": "list",
                                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                          "name": "RelativeDelegateLink",
                                          "fieldTypes": [
                                            {
                                              "name": "uutName",
                                              "type": {
                                                "kind": "internal",
                                                "name": "String"
                                              }
                                            },
                                            {
                                              "name": "delegateValidatorHash",
                                              "type": {
                                                "kind": "option",
                                                "someType": {
                                                  "kind": "internal",
                                                  "name": "ValidatorHash"
                                                }
                                              }
                                            },
                                            {
                                              "name": "config",
                                              "type": {
                                                "kind": "internal",
                                                "name": "ByteArray"
                                              }
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "idPrefix",
                                        "type": {
                                          "kind": "internal",
                                          "name": "String"
                                        }
                                      },
                                      {
                                        "name": "refCount",
                                        "type": {
                                          "kind": "internal",
                                          "name": "Int"
                                        }
                                      }
                                    ]
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 2,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
                                    "name": "DelegateThreads",
                                    "fieldTypes": [
                                      {
                                        "name": "role",
                                        "type": {
                                          "kind": "enum",
                                          "name": "DelegateRole",
                                          "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                              "name": "MintDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                              "name": "SpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                              "name": "MintInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 3,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                              "name": "SpendInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 4,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                              "name": "DgDataPolicy",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 5,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                              "name": "OtherNamedDgt",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 6,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                              "name": "BothMintAndSpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 7,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                              "name": "HandledByCapoOnly",
                                              "fieldTypes": []
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "refCount",
                                        "type": {
                                          "kind": "internal",
                                          "name": "Int"
                                        }
                                      }
                                    ]
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 3,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
                                    "name": "MerkleMembership",
                                    "fieldTypes": []
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 4,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
                                    "name": "MerkleStateRoot",
                                    "fieldTypes": []
                                  }
                                ]
                              },
                              "key": "tpe"
                            },
                            {
                              "name": "tokenName",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              },
                              "key": "tn"
                            },
                            {
                              "name": "mph",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "MintingPolicyHash"
                                }
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "pendingChanges",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "enum",
                          "name": "PendingCharterChange",
                          "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
                          "variantTypes": [
                            {
                              "kind": "variant",
                              "tag": 0,
                              "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
                              "name": "delegateChange",
                              "fieldTypes": [
                                {
                                  "name": "change",
                                  "type": {
                                    "kind": "struct",
                                    "format": "list",
                                    "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
                                    "name": "PendingDelegateChange",
                                    "fieldTypes": [
                                      {
                                        "name": "action",
                                        "type": {
                                          "kind": "enum",
                                          "name": "PendingDelegateAction",
                                          "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                                              "name": "Add",
                                              "fieldTypes": [
                                                {
                                                  "name": "seed",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "TxOutputId"
                                                  }
                                                },
                                                {
                                                  "name": "purpose",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "idPrefix",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                                              "name": "Remove",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                                              "name": "Replace",
                                              "fieldTypes": [
                                                {
                                                  "name": "seed",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "TxOutputId"
                                                  }
                                                },
                                                {
                                                  "name": "purpose",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "idPrefix",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "replacesDgt",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "AssetClass"
                                                  }
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "role",
                                        "type": {
                                          "kind": "enum",
                                          "name": "DelegateRole",
                                          "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                              "name": "MintDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                              "name": "SpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                              "name": "MintInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 3,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                              "name": "SpendInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 4,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                              "name": "DgDataPolicy",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 5,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                              "name": "OtherNamedDgt",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 6,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                              "name": "BothMintAndSpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 7,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                              "name": "HandledByCapoOnly",
                                              "fieldTypes": []
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "dgtLink",
                                        "type": {
                                          "kind": "option",
                                          "someType": {
                                            "kind": "struct",
                                            "format": "list",
                                            "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                            "name": "RelativeDelegateLink",
                                            "fieldTypes": [
                                              {
                                                "name": "uutName",
                                                "type": {
                                                  "kind": "internal",
                                                  "name": "String"
                                                }
                                              },
                                              {
                                                "name": "delegateValidatorHash",
                                                "type": {
                                                  "kind": "option",
                                                  "someType": {
                                                    "kind": "internal",
                                                    "name": "ValidatorHash"
                                                  }
                                                }
                                              },
                                              {
                                                "name": "config",
                                                "type": {
                                                  "kind": "internal",
                                                  "name": "ByteArray"
                                                }
                                              }
                                            ]
                                          }
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 1,
                              "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
                              "name": "otherManifestChange",
                              "fieldTypes": []
                            }
                          ]
                        }
                      }
                    }
                  ]
                }
              },
              {
                "name": "utxo",
                "type": {
                  "kind": "internal",
                  "name": "TxInput"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoHelpers__cctx_CharterInputType[]__Input",
            "name": "Input",
            "fieldTypes": [
              {
                "name": "datum",
                "type": {
                  "kind": "variant",
                  "tag": 0,
                  "id": "__module__CapoHelpers__CapoDatum[]__CharterData",
                  "name": "CharterData",
                  "fieldTypes": [
                    {
                      "name": "spendDelegateLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "spendInvariants",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "otherNamedDelegates",
                      "type": {
                        "kind": "map",
                        "keyType": {
                          "kind": "internal",
                          "name": "String"
                        },
                        "valueType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "mintDelegateLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "mintInvariants",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "govAuthorityLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "manifest",
                      "type": {
                        "kind": "map",
                        "keyType": {
                          "kind": "internal",
                          "name": "String"
                        },
                        "valueType": {
                          "kind": "struct",
                          "format": "map",
                          "id": "__module__CapoHelpers__CapoManifestEntry[]",
                          "name": "CapoManifestEntry",
                          "fieldTypes": [
                            {
                              "name": "entryType",
                              "type": {
                                "kind": "enum",
                                "name": "ManifestEntryType",
                                "id": "__module__CapoHelpers__ManifestEntryType[]",
                                "variantTypes": [
                                  {
                                    "kind": "variant",
                                    "tag": 0,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
                                    "name": "NamedTokenRef",
                                    "fieldTypes": []
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 1,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
                                    "name": "DgDataPolicy",
                                    "fieldTypes": [
                                      {
                                        "name": "policyLink",
                                        "type": {
                                          "kind": "struct",
                                          "format": "list",
                                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                          "name": "RelativeDelegateLink",
                                          "fieldTypes": [
                                            {
                                              "name": "uutName",
                                              "type": {
                                                "kind": "internal",
                                                "name": "String"
                                              }
                                            },
                                            {
                                              "name": "delegateValidatorHash",
                                              "type": {
                                                "kind": "option",
                                                "someType": {
                                                  "kind": "internal",
                                                  "name": "ValidatorHash"
                                                }
                                              }
                                            },
                                            {
                                              "name": "config",
                                              "type": {
                                                "kind": "internal",
                                                "name": "ByteArray"
                                              }
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "idPrefix",
                                        "type": {
                                          "kind": "internal",
                                          "name": "String"
                                        }
                                      },
                                      {
                                        "name": "refCount",
                                        "type": {
                                          "kind": "internal",
                                          "name": "Int"
                                        }
                                      }
                                    ]
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 2,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
                                    "name": "DelegateThreads",
                                    "fieldTypes": [
                                      {
                                        "name": "role",
                                        "type": {
                                          "kind": "enum",
                                          "name": "DelegateRole",
                                          "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                              "name": "MintDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                              "name": "SpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                              "name": "MintInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 3,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                              "name": "SpendInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 4,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                              "name": "DgDataPolicy",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 5,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                              "name": "OtherNamedDgt",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 6,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                              "name": "BothMintAndSpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 7,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                              "name": "HandledByCapoOnly",
                                              "fieldTypes": []
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "refCount",
                                        "type": {
                                          "kind": "internal",
                                          "name": "Int"
                                        }
                                      }
                                    ]
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 3,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
                                    "name": "MerkleMembership",
                                    "fieldTypes": []
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 4,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
                                    "name": "MerkleStateRoot",
                                    "fieldTypes": []
                                  }
                                ]
                              },
                              "key": "tpe"
                            },
                            {
                              "name": "tokenName",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              },
                              "key": "tn"
                            },
                            {
                              "name": "mph",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "MintingPolicyHash"
                                }
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "pendingChanges",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "enum",
                          "name": "PendingCharterChange",
                          "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
                          "variantTypes": [
                            {
                              "kind": "variant",
                              "tag": 0,
                              "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
                              "name": "delegateChange",
                              "fieldTypes": [
                                {
                                  "name": "change",
                                  "type": {
                                    "kind": "struct",
                                    "format": "list",
                                    "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
                                    "name": "PendingDelegateChange",
                                    "fieldTypes": [
                                      {
                                        "name": "action",
                                        "type": {
                                          "kind": "enum",
                                          "name": "PendingDelegateAction",
                                          "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                                              "name": "Add",
                                              "fieldTypes": [
                                                {
                                                  "name": "seed",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "TxOutputId"
                                                  }
                                                },
                                                {
                                                  "name": "purpose",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "idPrefix",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                                              "name": "Remove",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                                              "name": "Replace",
                                              "fieldTypes": [
                                                {
                                                  "name": "seed",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "TxOutputId"
                                                  }
                                                },
                                                {
                                                  "name": "purpose",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "idPrefix",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "replacesDgt",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "AssetClass"
                                                  }
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "role",
                                        "type": {
                                          "kind": "enum",
                                          "name": "DelegateRole",
                                          "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                              "name": "MintDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                              "name": "SpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                              "name": "MintInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 3,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                              "name": "SpendInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 4,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                              "name": "DgDataPolicy",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 5,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                              "name": "OtherNamedDgt",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 6,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                              "name": "BothMintAndSpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 7,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                              "name": "HandledByCapoOnly",
                                              "fieldTypes": []
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "dgtLink",
                                        "type": {
                                          "kind": "option",
                                          "someType": {
                                            "kind": "struct",
                                            "format": "list",
                                            "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                            "name": "RelativeDelegateLink",
                                            "fieldTypes": [
                                              {
                                                "name": "uutName",
                                                "type": {
                                                  "kind": "internal",
                                                  "name": "String"
                                                }
                                              },
                                              {
                                                "name": "delegateValidatorHash",
                                                "type": {
                                                  "kind": "option",
                                                  "someType": {
                                                    "kind": "internal",
                                                    "name": "ValidatorHash"
                                                  }
                                                }
                                              },
                                              {
                                                "name": "config",
                                                "type": {
                                                  "kind": "internal",
                                                  "name": "ByteArray"
                                                }
                                              }
                                            ]
                                          }
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 1,
                              "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
                              "name": "otherManifestChange",
                              "fieldTypes": []
                            }
                          ]
                        }
                      }
                    }
                  ]
                }
              },
              {
                "name": "utxo",
                "type": {
                  "kind": "internal",
                  "name": "TxInput"
                }
              }
            ]
          }
        ]
      }
    }
  ]
};

var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
class UnspecializedMintDelegate extends BasicMintDelegate {
  dataBridgeClass = UnspecializedDelegateBridge;
  get delegateName() {
    return "unspecialDelegate";
  }
  scriptBundle() {
    if (process.env.NODE_ENV === "development") {
      console.warn(
        "mint+spend delegate: using unspecialized delegate bundle\n  ... this is good enough for getting started, but you'll need to\n  ... specialize this delegate to fit your application's needs. \nTo do that, you'll add mintDgt and spendDgt entries into \n  ... your Capo's delegateRoles() method, typically with\n  ... both pointing to a single specialized mint-delegate class."
      );
    }
    return new UnspecializedDgtBundle();
  }
  activityMintingUutsAppSpecific(seedFrom, purposes) {
    const seed = this.getSeed(seedFrom);
    return this.mkSeededMintingActivity("mintingUuts", {
      seed,
      purposes
    });
  }
  activityCreatingTestNamedDelegate(seedFrom, purpose) {
    const seed = this.getSeed(seedFrom);
    return this.mkCapoLifecycleActivity("CreatingDelegate", {
      seed,
      purpose
    });
  }
  // get specializedDelegateModule() {
  //     return uutMintingMintDelegate;
  // }
}
__decorateClass$2([
  Activity.redeemer
], UnspecializedMintDelegate.prototype, "activityMintingUutsAppSpecific", 1);
__decorateClass$2([
  Activity.redeemer
], UnspecializedMintDelegate.prototype, "activityCreatingTestNamedDelegate", 1);

function mkDgtStateKey(n, p = "dgPol") {
  return `${p}${n.slice(0, 1).toUpperCase()}${n.slice(1)}`;
}

var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
class Capo extends StellarContract {
  //, hasRoleMap<SELF>
  static currentRev = 1n;
  static async currentConfig() {
  }
  dataBridgeClass = CapoDataBridge;
  get onchain() {
    return this.getOnchainBridge();
  }
  get offchain() {
    return super.offchain;
  }
  get reader() {
    return super.offchain;
  }
  get activity() {
    const bridge = this.onchain;
    return bridge.activity;
  }
  get mkDatum() {
    return this.onchain.datum;
  }
  get newReadDatum() {
    const bridge = this.getOnchainBridge();
    const { readDatum } = bridge;
    if (!readDatum) {
      throw new Error(
        `${this.constructor.name}: this contract script doesn't use datum`
      );
    }
    return readDatum;
  }
  verifyConfigs() {
    return this.verifyCoreDelegates();
  }
  get isConfigured() {
    if (!this.configIn)
      return Promise.resolve(false);
    return Promise.resolve(true);
  }
  scriptBundle() {
    console.warn(
      `${this.constructor.name}: each Capo will need to provide a scriptBundle() method.
It should return an instance of a class defined in a *.hlb.ts file.  At minimum:

    export default class MyAppCapo extends CapoHeliosBundle {
       get modules() { 
           return [
               ...super.modules,
               // additional custom .hl module imports here
           ];
       }
    }

We'll generate types for that .js file, based on the types in your Helios sources.
Your scriptBundle() method can \`return new MyAppCapo();\`

We suggest naming your Capo bundle class with your application's name.
`
    );
    console.warn(
      "using a generic Capo bundle - just enough for getting started."
    );
    return new CapoHeliosBundle();
  }
  /**
   * Reveals any bootstrapping details that may be present during initial creation
   * of the Capo contract, for use during and immediately after charter-creation.
   *
   * @public
   **/
  bootstrapping;
  // abstract delegatedDataWrappers(): Promise<
  //     Record<string, someDataWrapper<any>>
  // >;
  static parseConfig(rawJsonConfig) {
    const { mph, rev, seedTxn, seedIndex, rootCapoScriptHash } = rawJsonConfig;
    const outputConfig = {};
    if (mph)
      outputConfig.mph = makeMintingPolicyHash(mph.bytes);
    if (rev)
      outputConfig.rev = BigInt(rev);
    if (seedTxn)
      outputConfig.seedTxn = makeTxId(seedTxn.bytes);
    if (seedIndex)
      outputConfig.seedIndex = BigInt(seedIndex);
    if (rootCapoScriptHash)
      outputConfig.rootCapoScriptHash = makeValidatorHash(
        rootCapoScriptHash.bytes
      );
    return outputConfig;
  }
  get scriptDatumName() {
    return "CapoDatum";
  }
  get scriptActivitiesName() {
    return "CapoActivity";
  }
  static get defaultParams() {
    const params = {
      rev: this.currentRev
    };
    return params;
  }
  /**
   * extracts from the input configuration the key details needed to construct/reconstruct the on-chain contract address
   * @remarks
   *
   * extracts the details that are key to parameterizing the Capo / leader's on-chain contract script
   * @public
   **/
  getContractScriptParamsUplc(config) {
    if (this.configIn && config.mph && this.minter && !config.mph.isEqual(this.mph))
      throw new Error(`mph mismatch`);
    const { mph } = config;
    const rev = this.constructor.currentRev;
    const params = {
      mph,
      rev
    };
    return this.paramsToUplc(params);
  }
  async init(args) {
    await super.init(args);
    const {
      scriptDatumName: onChainDatumName,
      scriptActivitiesName: onChainActivitiesName
    } = this;
    const { CharterData } = this.onChainDatumType.typeMembers;
    const updatingCharter = this.activity.updatingCharter;
    const usingAuthority = this.activity.usingAuthority;
    if (!CharterData)
      throw new Error(
        `datum type ${onChainDatumName} must have a 'CharterData' variant`
      );
    if (!updatingCharter)
      throw new Error(
        `activities type ${onChainActivitiesName} must have a 'updatingCharter' variant`
      );
    if (!usingAuthority)
      throw new Error(
        `activities type${onChainActivitiesName} must have a 'usingAuthority' variant`
      );
    if (this.configIn && !this.configIn.bootstrapping) {
      const { seedTxn, seedIndex } = this.configIn;
      await this.connectMintingScript({
        seedTxn,
        seedIndex
      });
      this._delegateRoles = this.initDelegateRoles();
      await this.verifyConfigs();
    } else {
      this._delegateRoles = this.initDelegateRoles();
    }
    return this;
  }
  static bootstrapWith(args) {
    const { setup, config } = args;
    const Class = this;
    return new Class({ setup, config: { ...config, bootstrapping: true } });
  }
  /**
   * Creates any additional transactions needed during charter creation
   * @remarks
   *
   * This method is a hook for subclasses to add extra transactions during the
   * charter creation process.  It is called during the creation of the charter transaction.
   *
   * The Capo has a {@link Capo.bootstrapping|`bootstrapping`} property that can be referenced as needed
   * during extra transaction creation.
   *
   * This method should use {@link StellarTxnContext.includeAddlTxn} to add transactions
   * to the context.
   *
   * @public
   **/
  async mkAdditionalTxnsForCharter(tcx) {
    return tcx;
  }
  // async readSettingsDatum<THIS extends Capo<any>>(
  //     this: THIS,
  //     parsedDatum: adapterParsedOnchainData<
  //         CapoOnchainSettingsType<THIS>,
  //         "SettingsData"
  //     >
  // ): Promise<CapoOffchainSettingsType<THIS>> {
  //     type t = CapoOnchainSettingsType<THIS>;
  //     return this.settingsAdapter.fromOnchainDatum(parsedDatum);
  // }
  get minterClass() {
    return CapoMinter;
  }
  minter;
  uutsValue(x) {
    let uutMap = x instanceof StellarTxnContext ? x.state.uuts : x instanceof UutName ? { single: x } : Array.isArray(x) ? { single: new UutName("some-uut", x) } : x;
    const vEntries = mkUutValuesEntries(uutMap);
    return makeValue(0, makeAssets([[this.mintingPolicyHash, vEntries]]));
  }
  activityUsingAuthority() {
    return {
      redeemer: this.activityVariantToUplc("usingAuthority", {})
    };
  }
  tvCharter() {
    return this.minter.tvCharter();
  }
  get charterTokenAsValue() {
    console.warn(
      "deprecated get charterTokenAsValue; use tvCharter() instead"
    );
    return this.tvCharter();
  }
  get charterTokenPredicate() {
    const predicate = this.uh.mkTokenPredicate(this.tvCharter());
    return predicate;
  }
  //! forms a Value with minUtxo included
  tokenAsValue(tokenName, count = 1n) {
    const { mph } = this;
    return this.uh.mkMinTv(mph, tokenName, count);
  }
  async mustFindCharterUtxo() {
    const predicate = this.uh.mkTokenPredicate(this.tvCharter());
    return this.mustFindMyUtxo("charter", predicate, "has it been minted?");
  }
  //     /**
  //  * Finds a free seed-utxo from the user wallet, and adds it to the transaction
  //  * @remarks
  //  *
  //  * Accepts a transaction context that may already have a seed.  Returns a typed
  //  * tcx with hasSeedUtxo type.
  //  *
  //  * The seedUtxo will be consumed in the transaction, so it can never be used
  //  * again; its value will be returned to the user wallet.
  //  *
  //  * The seedUtxo is needed for UUT minting, and the transaction is typed with
  //  * the presence of that seed (found in tcx.state.seedUtxo).
  //  *
  //  * If a seedUtxo is already present in the transaction context, no additional seedUtxo
  //  * will be added.
  //  *
  //  * If a seedUtxo is provided as an argument, that utxo must already be present
  //  * in the transaction inputs; the state will be updated to reference it.
  //  *
  //  * @public
  //  *
  //  **/
  //     async tcxWithSeedUtxo<TCX extends StellarTxnContext>(
  //         tcx: TCX = new StellarTxnContext(this.actorContext) as TCX,
  //         seedUtxo?: TxInput
  //     ): Promise<TCX & hasSeedUtxo> {
  /**
   * @deprecated - use tcxWithCharterRef() instead
   */
  async txnAddCharterRef(tcx) {
    return this.tcxWithCharterRef(tcx);
  }
  /**
   * Ensures the transaction context has a reference to the charter token
   * @remarks
   *
   * Accepts a transaction context that may already have a charter reference.  Returns a typed
   * tcx with hasCharterRef type.
   *
   * The transaction is typed with the presence of the charter reference (found in tcx.state.charterRef).
   *
   * If the charter reference is already present in the transaction context, the transaction will not be modified.
   */
  async tcxWithCharterRef(tcx) {
    if (
      //@ts-expect-error on type-probe:
      tcx.state.charterRef
    )
      return tcx;
    const ctUtxo = await this.mustFindCharterUtxo();
    tcx.addRefInput(ctUtxo);
    const charterData = await this.findCharterData(ctUtxo);
    const tcx2 = tcx;
    tcx2.state.charterRef = ctUtxo;
    tcx2.state.charterData = charterData;
    return tcx2.addRefInput(ctUtxo);
  }
  async tcxWithSettingsRef(tcx) {
    if (
      //@ts-expect-error on type-probe:
      tcx.state.settingsInfo
    ) {
      return tcx;
    }
    const settingsInfo = await this.findSettingsInfo();
    tcx.addRefInput(settingsInfo.utxo);
    const tcx2 = tcx;
    tcx2.state.settingsInfo = settingsInfo;
    return tcx2;
  }
  // non-activity partial
  async txnMustUseCharterUtxo(tcx, redeemerOrRefInput, newCharterData) {
    return this.mustFindCharterUtxo().then(async (ctUtxo) => {
      if (true === redeemerOrRefInput || "refInput" === redeemerOrRefInput) {
        throw new Error(`use tcxWithCharterRef(tcx) instead`);
      }
      const redeemer = redeemerOrRefInput;
      const tcx2 = await this.txnAttachScriptOrRefScript(
        tcx,
        this.compiledScript
      );
      tcx2.addInput(ctUtxo, redeemer);
      const datum2 = newCharterData ? this.mkDatum.CharterData(newCharterData) : ctUtxo.output.datum;
      return this.txnKeepCharterToken(tcx2, datum2);
    });
  }
  // non-activity partial
  async txnUpdateCharterUtxo(tcx, redeemer, newDatum) {
    return this.txnMustUseCharterUtxo(tcx, redeemer, newDatum);
  }
  // non-activity partial
  txnKeepCharterToken(tcx, datum2) {
    if (datum2.kind !== "InlineTxOutputDatum") {
      throw new Error(
        `datum must be InlineTxOutputDatum, not ${datum2.kind}`
      );
    }
    const txo = makeTxOutput(this.address, this.tvCharter(), datum2);
    txo.correctLovelace(this.networkParams);
    tcx.addOutput(txo);
    return tcx;
  }
  async txnAddGovAuthorityTokenRef(tcx) {
    const tcx2 = await this.tcxWithCharterRef(tcx);
    const tcx3 = await this.txnAddGovAuthority(tcx2);
    return tcx3;
  }
  async txnMustUseSpendDelegate(tcx, spendDelegate, activity) {
    const tcx2 = tcx;
    tcx2.state.spendDelegate = spendDelegate;
    return spendDelegate.txnGrantAuthority(tcx2, activity);
  }
  /**
   * provides minter-targeted params extracted from the input configuration
   * @remarks
   *
   * extracts the seed-txn details that are key to parameterizing the minter contract
   * @public
   **/
  getMinterParams() {
    const { seedTxn, seedIndex } = this.configIn;
    return { seedTxn, seedIndex };
  }
  // getCapoRev() {
  //     return 1n;
  // }
  get mph() {
    return this.minter.mintingPolicyHash;
  }
  get mintingPolicyHash() {
    return this.mph;
  }
  async findActorUut(uutPrefix, mph = this.mph) {
    const foundUtxo = await this.uh.findActorUtxo(
      `uut ${uutPrefix}-`,
      (utxo) => {
        if (getMatchingTokenName(utxo, mph)) {
          return utxo;
        }
      }
    );
    if (!foundUtxo)
      return void 0;
    return {
      utxo: foundUtxo,
      uut: new UutName(uutPrefix, getMatchingTokenName(foundUtxo, mph))
    };
    function getMatchingTokenName(utxo, mph2) {
      const tokenNamesExisting = utxo.value.assets.getPolicyTokenNames(mph2).map((x) => decodeUtf8(x));
      const tokenNames = tokenNamesExisting.filter((x) => {
        return !!x.startsWith(`${uutPrefix}-`);
      });
      return tokenNames[0];
    }
  }
  /**
   * parses details in a delegate-link
   * @deprecated - use an adapter for CharterData instead?
   */
  offchainLink(link) {
    if ("string" == typeof link.config) {
      throw new Error(`wrong type`);
    }
    if (Array.isArray(link.config)) {
      link = {
        ...link,
        config: JSON.parse(decodeUtf8(link.config))
      };
    }
    const { config } = link;
    if (config.rev)
      config.rev = BigInt(config.rev);
    return link;
  }
  parseDgtConfig(inLink) {
    if ("string" == typeof inLink.config) {
      throw new Error(`wrong type`);
    }
    if (!Array.isArray(inLink.config)) {
      throw new Error(`expected serialized JSON as bytearray`);
    }
    const config = JSON.parse(decodeUtf8(inLink.config));
    if (config.rev)
      config.rev = BigInt(config.rev);
    return config;
  }
  serializeDgtConfig(config) {
    return encodeUtf8(JSON.stringify(config, delegateLinkSerializer));
  }
  /**
   * @deprecated - use the bridge type directly, and parseDgtConfig iff we ever need that.
   */
  parseDelegateLinksInCharter(charterData) {
    const { otherNamedDelegates: nDgts, manifest } = charterData;
    nDgts instanceof Map ? [...nDgts.entries()] : Object.entries(nDgts);
  }
  async findCharterData(currentCharterUtxo) {
    if (!currentCharterUtxo) {
      currentCharterUtxo = await this.mustFindCharterUtxo();
    }
    const datum2 = currentCharterUtxo.output.datum;
    if (datum2?.kind !== "InlineTxOutputDatum") {
      throw new Error(`invalid charter UTxO datum`);
    }
    const charterData = this.newReadDatum(datum2.data).CharterData;
    if (!charterData)
      throw Error(`invalid charter UTxO datum`);
    return charterData;
  }
  async findSettingsInfo(charterRefOrInputOrProps) {
    const chUtxo = charterRefOrInputOrProps || await this.mustFindCharterUtxo();
    let charterData = charterRefOrInputOrProps instanceof StellarTxnContext ? charterRefOrInputOrProps.state.charterData : (
      //@ts-expect-error - probing for txinput
      charterRefOrInputOrProps?.kind == "TxInput" ? await this.findCharterData(chUtxo) : charterRefOrInputOrProps
    );
    if (!charterData) {
      charterData = await this.findCharterData();
    }
    const currentSettings = charterData.manifest.get("currentSettings");
    if (!currentSettings) {
      throw new Error(
        `there is no currentSettings in the Capo's manifest`
      );
    }
    const uutName = currentSettings?.tokenName;
    return this.findDelegatedDataUtxos({
      type: "settings",
      id: uutName
    }).then((xs) => this.singleItem(xs));
  }
  async connectMintingScript(params) {
    if (this.minter)
      throw new Error(`just use this.minter when it's already present`);
    const { minterClass } = this;
    const { seedTxn, seedIndex } = params;
    const { mph: expectedMph, rev } = this.configIn || {
      mph: void 0,
      ...this.constructor.defaultParams
    };
    const minter = await this.addStrellaWithConfig(minterClass, {
      rev,
      seedTxn,
      seedIndex,
      capo: this
    });
    if (expectedMph && !minter.mintingPolicyHash?.isEqual(expectedMph)) {
      throw new Error(
        `This minter script with this seed-utxo doesn't produce the required  minting policy hash
expected: ` + expectedMph.toHex() + "\nactual: " + minter.mintingPolicyHash?.toHex()
      );
    } else if (!expectedMph) {
      console.log(`${this.constructor.name}: seeding new minting policy`);
    }
    minter.mustHaveActivity("mintingCharter");
    return this.minter = minter;
  }
  /**
   * Finds a sufficient-sized utxo for seeding one or more named tokens
   * @remarks
   *
   * For allocating a charter token (/its minter), one or more UUTs, or other token name(s)
   * to be minted, this function calculates the size of minUtxo needed for all the needed tokens,
   * assuming they'll each be stored in separate utxos.  It then finds and returns a UTxO from the
   * current actor's wallet.  The utxo is NOT implicitly added to the transaction (use tcx.addInput() to add it).
   *
   * When the transaction context already has some utxo's being consumed, they're not
   * eligible for selection.
   *
   * If the transaction doesn't store the new tokens in separate utxos, any spare lovelace
   * are returned as change in the transaction.
   *
   * @param tcx - transaction context
   * @param purpose - a descriptive purpose used during utxo-finding in case of problems
   * @param tokenNames - the token names to be seeded.
   * @public
   **/
  async txnMustGetSeedUtxo(tcx, purpose, tokenNames) {
    //! given a Capo-based contract instance having a free TxInput to seed its validator address,
    //! prior to initial on-chain creation of contract,
    //! it finds that specific TxInput in the current user's wallet.
    const fakeMph = makeDummyMintingPolicyHash();
    const totalMinUtxoValue = tokenNames.reduce(
      addTokenValue.bind(this),
      makeValue(0n)
    );
    //! accumulates min-utxos for each stringy token-name in a reduce()
    function addTokenValue(accumulator, tn) {
      const vMin = this.uh.mkMinTv(fakeMph, tn);
      return accumulator.add(vMin);
    }
    const uutSeed = this.uh.mkValuePredicate(
      totalMinUtxoValue.lovelace,
      tcx
    );
    const seedUtxo = await this.uh.mustFindActorUtxo(purpose, uutSeed, tcx).catch((x) => {
      throw x;
    });
    const { txId: seedTxn, index: utxoIdx } = seedUtxo.id;
    const seedIndex = BigInt(utxoIdx);
    const count = tokenNames.length > 1 ? `${tokenNames.length} uuts for ` : "";
    const hex = seedTxn.toHex();
    console.log(
      `Seed tx for ${count}${purpose}: ${hex.slice(0, 8)}\u2026${hex.slice(
        -4
      )}#${seedIndex}`
    );
    return seedUtxo;
  }
  /**
   * Creates a new delegate link, given a delegation role and and strategy-selection details
   * @param tcx - A transaction-context having state.uuts[roleName] matching the roleName
   * @param roleLabel - the role of the delegate, matched with the `delegateRoles()` of `this`
   * @param delegateInfo - partial detail of the delegation with any
   *     details required by the particular role.  Its delegate type may be a subclass of the type
   *     indicated by the `roleName`.
   * @remarks
   *
   * Combines partal and implied configuration settings, validating the resulting configuration.
   *
   * It expects the transaction-context to have a UUT whose name (or a UUT roleName) matching
   * the indicated `roleName`.  Use {@link Capo.txnWillMintUuts|txnWillMintUuts()} or {@link Capo.txnMintingUuts|txnMintingUuts()} to construct
   * a transaction having that and a compliant txn-type.
   *
   * The resulting delegate-linking details can be used with this.mkRelativeDelegateLink() to
   * encode it as an on-chain RelativeLinkLink in the Capo's charter.
   *
   * The delegate-link is by default a contract-based delegate.  If that's not what you want,
   * you can the type-parameters to override it to a more general StellarDelegate type (NOTE: if you
   * find you're needing to specify a more specific contract-based delegate type, please let us know, as
   * our expectation is that the general type for a contract-based delegate should already provide all the
   * necessary type information for all kinds of contract-based delegate subclasses).
   *
   * To get a full DelegateSettings object, use txnCreateDelegateSettings() instead.
   *
   * @public
   *
   * @reqt throws DelegateConfigNeeded with an `errors` entry
   *   ... if there are any problems in validating the net configuration settings.
   * @reqt EXPECTS the `tcx` to be minting a UUT for the delegation,
   *   ... whose UutName can be found in `tcx.state.uuts[roleName]`
   * @reqt combines base settings from the selected delegate class's `defaultParams`
   *   ... adding the delegateRoles()[roleName] configuration for the selected roleName,
   *   ... along with any explicit `config` from the provided `delegateInfo`
   *   ... and automatically applies a `uut` setting.
   *   ... The later properties in this sequence take precedence.
   **/
  async txnCreateOffchainDelegateLink(tcx, roleLabel, delegateInfo) {
    const configured = await this.txnCreateConfiguredDelegate(
      tcx,
      roleLabel,
      delegateInfo
    );
    await configured.delegate.txnReceiveAuthorityToken(
      tcx,
      this.uh.mkMinTv(this.mph, tcx.state.uuts[roleLabel])
    );
    const delegateLink = this.extractDelegateLinkDetails(configured);
    const cacheKey = JSON.stringify(
      delegateLink,
      delegateLinkSerializer
      // 4 // indent 4 spaces
    );
    console.log("offchainDgtLink cache key", roleLabel, cacheKey);
    this.#_delegateCache[roleLabel] = this.#_delegateCache[roleLabel] || {};
    this.#_delegateCache[roleLabel][cacheKey] = configured;
    return configured;
  }
  /**
   * extracts the key details for creating an on-chain delegate link, given a setup-phase
   * configuration for that delegate.
   */
  mkOnchainRelativeDelegateLink(configured) {
    const {
      uutName,
      // strategyName,
      delegateValidatorHash,
      config = {}
    } = configured;
    if (!uutName) {
      throw new Error(`missing required uutName for delegate link`);
    }
    return {
      uutName,
      // strategyName,
      delegateValidatorHash,
      config: this.serializeDgtConfig(config)
    };
  }
  /**
   * extracts the key details of a delegate link, given a delegate configuration.
   * @remarks
   * This is valid only during the setup phase of creating a delegate, and does not encode the config entry.
   *
   * use mkRelativeDelegateLink() to encode the config entry, and use this.parseDgtConfig() to decode it.
   */
  extractDelegateLinkDetails(configured) {
    const {
      uutName,
      // strategyName,
      delegateValidatorHash,
      config = {}
    } = configured;
    return {
      uutName,
      // strategyName,
      delegateValidatorHash,
      config
    };
  }
  // mkDelegateLink(
  //     dl: OffchainPartialDelegateLink
  // ) {
  //     const { RelativeDelegateLink: hlRelativeDelegateLink } =
  //         this.onChainTypes;
  //     let {
  //         uutName,
  //         // strategyName,
  //         delegateValidatorHash,
  //         config,
  //         // reqdAddress: canRequireAddr,
  //         // addrHint = [],
  //     } = dl;
  //     const delegateLink : RelativeDelegateLinkLike ={
  //         // this.typeToUplc(hlRelativeDelegateLink, {
  //         uutName,
  //         // strategyName,
  //         delegateValidatorHash,
  //         config: textToBytes(JSON.stringify(config, delegateLinkSerializer)), //, 4)
  //     };
  // }
  /**
   * Generates and returns a complete set of delegate settings, given a delegation role and strategy-selection details.
   * @remarks
   *
   * Maps the indicated delegation role to specific UUT details from the provided transaction-context
   * to provide the resulting settings.  The transaction context isn't modified.
   *
   * Behaves exactly like (and provides the core implementation of) {@link Capo.txnCreateOffchainDelegateLink | txnCreateDelegateLink()},
   * returning additional `roleName` and `delegateClass`, to conform with the DelegateSettings type.
   *
   * ### Overriding the Delegate Type
   * The configuration is typed for a contract-based delegate by default.  If you need a more general
   * StellarDelegate type (for AuthorityPolicy, for example), you can override the type-parameters (if you are finding
   * that you need to specify a more specific contract-based delegate type, please let us know, as our expectation is that
   * the general type for a contract-based delegate should already provide all the necessary type information for all kinds of
   * contract-based delegate subclasses).
   *
   * See txnCreateDelegateLink for further details.
   * @public
   **/
  async txnCreateConfiguredDelegate(tcx, roleName, delegateInfo) {
    const {
      // strategyName,
      config: explicitConfig = {}
    } = delegateInfo;
    const { delegateRoles: delegateRoles2 } = this;
    const uut = tcx.state.uuts[roleName];
    if (!uut) {
      console.warn(
        `missing required UUT for role '${roleName}' in transaction context:`,
        tcx.state.uuts
      );
      throw new Error(
        `missing required UUT for role '${roleName}' (see logged details)`
      );
    }
    const impliedDelegationDetails = this.mkImpliedDelegationDetails(uut);
    const selectedDgt = delegateRoles2[roleName];
    if (!selectedDgt) {
      let msg = `invalid dgt role requested: '${roleName}'`;
      debugger;
      const e = new DelegateConfigNeeded(msg, {
        errorRole: roleName,
        availableDgtNames: Object.keys(delegateRoles2)
      });
      throw e;
    }
    const {
      delegateClass,
      config: { validateConfig, partialConfig: paramsFromRole = {} }
    } = selectedDgt;
    const { defaultParams: defaultParamsFromDelegateClass } = delegateClass;
    const configForOnchainRelativeDelegateLink = {
      ...defaultParamsFromDelegateClass,
      ...paramsFromRole || {},
      ...explicitConfig
    };
    const fullCapoDgtConfig = {
      ...configForOnchainRelativeDelegateLink,
      ...impliedDelegationDetails,
      capo: this
    };
    //! it validates the net configuration so it can return a working config.
    const errors = validateConfig && validateConfig(fullCapoDgtConfig) || void 0;
    if (errors) {
      throw new DelegateConfigNeeded(
        `validation errors in delegateInfo.config for ${roleName}:
` + errorMapAsString(errors),
        { errors }
      );
    }
    let delegateSettings = {};
    let delegate = void 0;
    try {
      delegateSettings = {
        ...delegateInfo,
        roleName,
        //@ts-expect-error "could be instantiated with a different type" - TS2352
        //  ... typescript doesn't see the connection between the input settings and this variable
        delegateClass,
        uutName: uut.name,
        fullCapoDgtConfig,
        config: configForOnchainRelativeDelegateLink
      };
      delegate = await this.mustGetDelegate(delegateSettings);
    } catch (e) {
      console.log("error: unable to create delegate: ", e.stack);
      debugger;
      this.mustGetDelegate(delegateSettings).catch(
        (sameErrorIgnored) => void 0
      );
      e.message = `${e.message} (see logged details and/or debugging breakpoint)`;
      throw e;
    }
    const { uutName } = delegateSettings;
    if (!uutName) {
      throw new Error(`missing required uutName in delegateSettings`);
    }
    const { delegateValidatorHash } = delegate;
    const pcd = {
      ...delegateSettings,
      config: configForOnchainRelativeDelegateLink,
      uutName,
      delegateValidatorHash,
      delegate
    };
    return pcd;
  }
  mkImpliedDelegationDetails(uut) {
    return {
      capoAddr: this.address,
      mph: this.mph,
      tn: encodeUtf8(uut.name)
    };
  }
  #_delegateCache = {};
  // get connectDelegate()
  async connectDelegateWithOnchainRDLink(roleLabel, delegateLink) {
    const role = this.delegateRoles[roleLabel];
    //!!! work on type-safety with roleName + available roles
    const onchainDgtLink = this.reader.RelativeDelegateLink(
      this.onchain.types.RelativeDelegateLink(delegateLink)
    );
    const selectedDgt = role.delegateClass;
    const cache = this.#_delegateCache;
    const cacheKey = JSON.stringify(
      onchainDgtLink,
      // this.parseDgtConfig(delegateLink),
      delegateLinkSerializer
    );
    if (!cache[roleLabel])
      cache[roleLabel] = {};
    const roleCache = cache[roleLabel];
    const cachedRole = roleCache[cacheKey];
    if (cachedRole) {
      const {
        // strategyName,
        delegate: delegate2
      } = cachedRole;
      return delegate2;
    }
    console.log(`   \u{1F50E}delegate \u{1F481} ${roleLabel}`);
    const {
      // strategyName,
      uutName,
      delegateValidatorHash: expectedDvh,
      // addrHint,  //moved to config
      // reqdAddress,  // removed
      config: configBytesFromLink
    } = onchainDgtLink;
    if (!selectedDgt) {
      throw new Error(
        `no selected dgt for role '${roleLabel}'
link details: ${this.showDelegateLink(delegateLink)}`
      );
    }
    const {
      delegateClass,
      config: { partialConfig: dgtMapSettings }
    } = role;
    const { defaultParams: defaultParamsFromDelegateClass } = delegateClass;
    const impliedDelegationDetails = this.mkImpliedDelegationDetails(
      new UutName(roleLabel, uutName)
    );
    const effectiveConfig = {
      ...defaultParamsFromDelegateClass,
      ...dgtMapSettings
    };
    if (effectiveConfig.rev === "1") {
      debugger;
    }
    const serializedCfg1 = JSON.stringify(
      effectiveConfig,
      delegateLinkSerializer,
      4
    );
    const parsedConfigFromLink = this.parseDgtConfig(delegateLink);
    const serializedCfg2 = JSON.stringify(
      parsedConfigFromLink,
      delegateLinkSerializer,
      4
    );
    if (serializedCfg1 !== serializedCfg2) {
      console.warn(
        `mismatched or modified delegate configuration for role '${roleLabel}'
  ...expected: ${serializedCfg1}
  ...got: ${serializedCfg2}`
      );
    }
    const fullCapoDgtConfig = {
      ...effectiveConfig,
      ...parsedConfigFromLink,
      ...impliedDelegationDetails,
      capo: this
    };
    //!  //  delegate: DT // omitted in "pre-configured";
    const delegate = await this.mustGetDelegate({
      delegateClass,
      fullCapoDgtConfig,
      roleName: roleLabel,
      uutName,
      // strategyName,
      config: parsedConfigFromLink
      // reqdAddress,
      // addrHint,
    });
    const dvh = delegate.delegateValidatorHash;
    if (expectedDvh && dvh && !expectedDvh.isEqual(dvh)) {
      throw new Error(
        `${this.constructor.name}: ${roleLabel}: mismatched or modified delegate: expected validator ${expectedDvh?.toHex()}, got ${dvh.toHex()}`
      );
    }
    console.log(
      `   \u2705 \u{1F481} ${roleLabel}  (now cached) `
      // +Debug info: +` @ key = ${cacheKey}`
    );
    roleCache[cacheKey] = {
      delegate
      // strategyName,
    };
    return delegate;
  }
  showDelegateLink(delegateLink) {
    return JSON.stringify(delegateLink, null, 2);
  }
  async mustGetDelegate(configuredDelegate) {
    const { delegateClass, fullCapoDgtConfig: config } = configuredDelegate;
    try {
      const configured = await this.addStrellaWithConfig(
        delegateClass,
        config
      );
      return configured;
    } catch (e) {
      const t = e.message.match(/invalid parameter name '([^']+)'$/);
      const [_, badParamName] = t || [];
      if (badParamName) {
        throw new DelegateConfigNeeded(
          "configuration error while parameterizing contract script",
          { errors: { [badParamName]: e.message } }
        );
      }
      throw e;
    }
  }
  tvForDelegate(dgtLink) {
    return this.tokenAsValue(dgtLink.uutName);
  }
  mkDelegatePredicate(dgtLink) {
    return this.uh.mkTokenPredicate(this.tvForDelegate(dgtLink));
  }
  activityUpdatingCharter() {
    return {
      redeemer: this.activityVariantToUplc("updatingCharter", {})
    };
  }
  activitySpendingDelegatedDatum() {
    return {
      redeemer: this.activityVariantToUplc("spendingDelegatedDatum", {})
    };
  }
  // @Activity.redeemer
  // activityUpdatingSettings(): isActivity {
  //     return {
  //         redeemer: this.activityVariantToUplc("updatingSettings", {}),
  //     };
  // }
  /**
   * USE THE `delegateRoles` GETTER INSTEAD
   * @remarks
   *
   * - this no-op method is a convenience for Stellar Contracts maintainers
   *   and intuitive developers using autocomplete.
   * - Including it enables an entry
   *   in VSCode "Outline" view, which doesn't include the delegateRoles getter : /
   * @deprecated but please keep as a kind of redirect
   * @public
   **/
  getDelegateRoles() {
    throw new Error(`use the delegateRoles getter instead`);
  }
  get delegateRoles() {
    return this._delegateRoles;
  }
  _delegateRoles;
  // & myDelegateRoles;
  addressAuthorityConfig() {
    return {
      validateConfig(args) {
        const { rev, tn, addrHint } = args;
        const errors = {};
        if (!rev)
          errors.rev = ["required"];
        if (!tn?.length)
          errors.tn = ["(token-name) required"];
        if (!addrHint?.length)
          errors.addrHint = ["destination address required"];
        if (Object.keys(errors).length > 0)
          return errors;
        return void 0;
      }
    };
  }
  basicDelegateRoles() {
    const myRoles = delegateRoles({
      govAuthority: defineRole(
        "authority",
        AnyAddressAuthorityPolicy,
        this.addressAuthorityConfig(),
        "capoGov"
        // multisig: {
        //     delegateClass: MultisigAuthorityPolicy,
        //     validateConfig(args): strategyValidation {
        //         const { rev, uut } = args;
        //         const errors: ErrorMap = {};
        //         if (!rev) errors.rev = ["required"];
        //         if (!uut) errors.uut = ["required"];
        //         if (Object.keys(errors).length > 0) return errors;
        //         return undefined;
        //     },
        // },
      ),
      mintDelegate: defineRole("mintDgt", UnspecializedMintDelegate, {
        partialConfig: {},
        validateConfig(args) {
          return void 0;
        }
      }),
      spendDelegate: defineRole("spendDgt", UnspecializedMintDelegate, {
        partialConfig: {},
        validateConfig(args) {
          return void 0;
        }
      })
      // otherNamedDelegates: none by default
      //     namedDelegate: defineRole("namedDgt",
      //         //@ts-expect-error assigning abstract class where it prefers a concrete class
      //         StellarDelegate,
      //         {
      //             // no named delegates by default
      //         }
      //     ),
    });
    return myRoles;
  }
  /**
   * Performs a validation of all critical delegate connections
   * @remarks
   *
   * Checks that each delegate connection is correct and that the underlying
   * scripts for those delegates have not been modified in unplanned ways.
   *
   * Every Capo subclass that adds new delegate types SHOULD implement
   * this method, performing any checks needed to verify the scripts underlying
   * those delegate-types.  It should return `Promise.all([ super(), ...myOwnChecks])`.
   * @public
   **/
  async verifyCoreDelegates() {
    const rcsh = this.configIn?.rootCapoScriptHash;
    if (rcsh && !rcsh.isEqual(this.validatorHash)) {
      console.error(
        `expected: ` + rcsh.toHex() + `
  actual: ` + this.validatorHash.toHex()
      );
      throw new Error(
        `${this.constructor.name}: the leader contract script '${this.program.name}', or one of its dependencies, has been modified`
      );
    }
    const charter = await this.findCharterData();
    const { govAuthorityLink, mintDelegateLink, spendDelegateLink } = charter;
    return Promise.all([
      this.connectDelegateWithOnchainRDLink("mintDelegate", mintDelegateLink),
      this.connectDelegateWithOnchainRDLink("govAuthority", govAuthorityLink),
      this.connectDelegateWithOnchainRDLink("spendDelegate", spendDelegateLink)
    ]);
  }
  mkDatumScriptReference() {
    return this.inlineDatum("ScriptReference", {});
  }
  // dataWrappers!: Record<string, someDataWrapper<any>> &
  //     Awaited<ReturnType<this["delegatedDataWrappers"]>>;
  // @datum
  // async mkDatumSettingsData<THISTYPE extends Capo<any>>(
  //     this: THISTYPE,
  //     settings: CapoOffchainSettingsType<THISTYPE>
  // ): Promise<TxOutputDatum> {
  //     const adapter = this.settingsAdapter;
  //     return adapter.toOnchainDatum(settings) as any;
  // }
  async findGovDelegate(charterData) {
    const chD = charterData || await this.findCharterData();
    const capoGovDelegate = await this.connectDelegateWithOnchainRDLink(
      "govAuthority",
      chD.govAuthorityLink
    );
    console.log(
      "finding charter's govDelegate via link" + uplcDataSerializer("link", chD.govAuthorityLink)
    );
    return capoGovDelegate;
  }
  async txnAddGovAuthority(tcx) {
    const charterDataMaybe = "charterData" in tcx.state ? tcx.state.charterData : void 0;
    if (tcx.state.govAuthority) {
      return tcx;
    }
    const capoGovDelegate = await this.findGovDelegate(charterDataMaybe);
    console.log("adding charter's govAuthority");
    const tcx2 = await capoGovDelegate.txnGrantAuthority(tcx);
    tcx2.state.govAuthority = capoGovDelegate;
    return tcx2;
  }
  // getMinterParams() {
  //     const { seedTxn, seedIdx } = this.configIn
  //     return { seedTxn, seedIdx }
  // }
  // async txnBurnUuts<
  //     existingTcx extends StellarTxnContext<any>,
  // >(
  //     initialTcx: existingTcx,
  //     uutNames: UutName[],
  // ): Promise<existingTcx> {
  //     const minter = this.connectMinter();
  //     const tcx = await minter.txnBurnUuts(
  //         initialTcx,
  //         uutNames,
  //     );
  //     const tcx2 = await this.txnAddCharterRef(tcx);
  //     return this.txnAddMintDelegate(tcx2);
  // }
  // async getMintDelegate<
  //     THIS extends Capo<any>,
  //     MDT extends BasicMintDelegate & THIS["delegateRoles"]["mintDgt"] extends RoleInfo<any, any, infer DT> ? DT : never
  // >() : Promise<MDT>{
  // todo: get mintDelegate type from delegateRoles
  async getMintDelegate(charterData) {
    if (!this.configIn) {
      throw new Error(`what now?`);
    }
    //!!! needs to work also during bootstrapping.
    const chD = charterData || await this.findCharterData();
    return this.connectDelegateWithOnchainRDLink("mintDelegate", chD.mintDelegateLink);
  }
  // todo: get spendDelegate type from delegateRoles
  async getSpendDelegate(charterData) {
    const chD = charterData || await this.findCharterData();
    return this.connectDelegateWithOnchainRDLink("spendDelegate", chD.spendDelegateLink);
  }
  getSettingsController() {
    return this.getDgDataController("settings");
  }
  /**
   * Finds the delegated-data controller for a given typeName.
   * @remarks
   * REQUIRES that the Capo manifest contains an installed DgDataPolicy
   * and that the off-chain Capo delegateMap provides an off-chain controller
   * for that typeName.
   */
  async getDgDataController(roleName, charterData) {
    const chD = charterData || await this.findCharterData();
    const foundME = chD.manifest.get(roleName);
    if (!foundME) {
      throw new Error(
        `no manifest entry found with link to installed ${roleName}`
      );
    }
    if (foundME?.entryType.DgDataPolicy) {
      return this.connectDelegateWithOnchainRDLink(roleName, foundME.entryType.DgDataPolicy.policyLink);
    } else {
      const actualEntryType = Object.keys(foundME.entryType)[0];
      throw new Error(
        `invalid data-controller name '${roleName}' is invalid as a data-controller name; 
"+
                "  ... manifest entry has type '${actualEntryType}', not DgDataPolicy!`
      );
    }
  }
  /**
   * @deprecated - use getOtherNamedDelegate() or getDgDataController() instead
   */
  getNamedDelegate() {
  }
  /**
   * Finds a contract's named delegate, given the expected delegateName.
   * @remarks
   * @public
   **/
  async getOtherNamedDelegate(delegateName, charterData) {
    const chD = charterData || await this.findCharterData();
    const foundDelegateLink = chD.otherNamedDelegates.get(delegateName);
    if (!foundDelegateLink) {
      throw new Error(
        `${this.constructor.name}: no namedDelegate found: ${delegateName}`
      );
    }
    return this.connectDelegateWithOnchainRDLink(delegateName, foundDelegateLink);
  }
  async getNamedDelegates(charterData) {
    const chD = charterData || await this.findCharterData();
    const namedDelegates = chD.otherNamedDelegates;
    const allNamedDelegates = [...namedDelegates.entries()].map(
      async ([otherDgtName, v]) => {
        return [
          otherDgtName,
          await this.connectDelegateWithOnchainRDLink(otherDgtName, v)
        ];
      }
    );
    const done = await Promise.all(allNamedDelegates);
    return Object.fromEntries(done);
  }
  async getGovDelegate(charterData) {
    throw new Error("unused");
  }
  /**
   * helper for test environment, allowing an abortive initial charter-creation, without
   * most of the costs, but enabling named-delegate scripts to be compiled/validated
   * much earlier in the test lifecycle.  The real charter process can then continue without
   * duplicating any of the dry-run setup costs.
   */
  didDryRun = {};
  /**
   * Initiates a seeding transaction, creating a new Capo contract of this type
   * @remarks
   *
   * The returned transaction context has `state.bootstrappedConfig` for
   * capturing the details for reproducing the contract's settings and on-chain
   * address.
   *
   * @param charterDataArgs - initial details for the charter datum
   * @param existinTcx - any existing transaction context
   * @typeParam TCX - inferred type of a provided transaction context
   * @public
   **/
  // @txn
  async mkTxnMintCharterToken(charterDataArgs, existingTcx, dryRun) {
    const dry = this.didDryRun || {};
    const didHaveDryRun = !!dry.minter;
    if (didHaveDryRun) {
      console.log(
        `\u{1F501} resuming charter setup after partial setup in dry-run`
      );
      if (JSON.stringify(dry.args, delegateLinkSerializer) !== JSON.stringify(charterDataArgs, delegateLinkSerializer)) {
        throw new Error(`dry-run args mismatch`);
      }
      if (JSON.stringify(dry.configIn, delegateLinkSerializer) !== JSON.stringify(this.configIn, delegateLinkSerializer)) {
        throw new Error(`dry-run config mismatch`);
      }
    } else if (this.configIn) {
      throw new Error(
        `this contract suite is already configured and can't be re-chartered`
      );
    }
    if (dryRun) {
      console.log(`  \u{1F3C3} dry-run mode for charter setup`);
    }
    const initialTcx = existingTcx || this.mkTcx("mint charter token");
    const tcxWithSeed = !!dry.seedUtxo ? await this.tcxWithSeedUtxo(
      initialTcx.addInput(dry.seedUtxo),
      dry.seedUtxo
    ) : await this.tcxWithSeedUtxo(initialTcx);
    const seedUtxo = tcxWithSeed.state.seedUtxo;
    const { txId: seedTxn, index: utxoIdx } = seedUtxo.id;
    const seedIndex = BigInt(utxoIdx);
    const minter = dry.minter || await this.connectMintingScript({
      seedIndex,
      seedTxn
    });
    const { mintingPolicyHash: mph } = minter;
    if (!didHaveDryRun) {
      const csp = (
        //this.getContractScriptParamsUplc(
        this.partialConfig
      );
      const bsc = {
        ...csp,
        mph,
        seedTxn,
        seedIndex
      };
      this.contractParams = this.getContractScriptParamsUplc(bsc);
      this.contractParams = this.contractParams;
      await this.compileWithScriptParams();
      bsc.rootCapoScriptHash = makeValidatorHash(
        this.compiledScript.hash()
      );
      this.configIn = bsc;
    }
    tcxWithSeed.state.bsc = this.configIn;
    tcxWithSeed.state.bootstrappedConfig = JSON.parse(
      JSON.stringify(this.configIn, delegateLinkSerializer)
    );
    const uutPurposes = [
      "capoGov",
      "mintDgt",
      "spendDgt"
      // "set" as const,
    ];
    const tcx = await this.txnWillMintUuts(
      tcxWithSeed,
      uutPurposes,
      { usingSeedUtxo: seedUtxo },
      {
        govAuthority: "capoGov",
        mintDelegate: "mintDgt",
        spendDelegate: "spendDgt"
        // settings: "set",
      }
    );
    const { uuts } = tcx.state;
    if (uuts.govAuthority !== uuts.capoGov) {
      throw new Error(`assertion can't fail`);
    }
    if (dryRun) {
      this.didDryRun = {
        minter,
        seedUtxo,
        configIn: this.configIn,
        args: charterDataArgs
      };
      console.log(`  \u{1F3C3}  dry-run charter setup done`);
      return tcx;
    } else {
      this.didDryRun = {};
    }
    const govAuthority = await this.txnCreateOffchainDelegateLink(
      tcx,
      "govAuthority",
      charterDataArgs.govAuthorityLink
    );
    const mintDelegate = await this.txnCreateOffchainDelegateLink(
      tcx,
      "mintDelegate",
      charterDataArgs.mintDelegateLink
    );
    const spendDelegate = await this.txnCreateOffchainDelegateLink(
      tcx,
      "spendDelegate",
      charterDataArgs.spendDelegateLink
    );
    this.bootstrapping = {
      govAuthority,
      mintDelegate,
      spendDelegate
    };
    const charterOut = makeTxOutput(
      this.address,
      this.tvCharter(),
      this.onchain.datum?.CharterData({
        govAuthorityLink: this.mkOnchainRelativeDelegateLink(govAuthority),
        spendDelegateLink: this.mkOnchainRelativeDelegateLink(spendDelegate),
        mintDelegateLink: this.mkOnchainRelativeDelegateLink(mintDelegate),
        // empty items during charter setup:
        otherNamedDelegates: /* @__PURE__ */ new Map(),
        manifest: /* @__PURE__ */ new Map(),
        spendInvariants: [],
        mintInvariants: [],
        pendingChanges: []
      })
      // this.compiledScript
    );
    charterOut.correctLovelace(this.networkParams);
    tcx.addOutput(charterOut);
    const tcxWithCharterMint = await this.minter.txnMintingCharter(tcx, {
      owner: this.address,
      capoGov: uuts.capoGov,
      // same as govAuthority,
      mintDelegate: uuts.mintDelegate,
      spendDelegate: uuts.spendDelegate
      // settingsUut: uuts.set,
    });
    await this.txnMkAddlRefScriptTxn(
      tcxWithCharterMint,
      "mintDelegate",
      mintDelegate.delegate.compiledScript
    );
    await this.txnMkAddlRefScriptTxn(
      tcxWithCharterMint,
      "capo",
      this.compiledScript
    );
    await this.txnMkAddlRefScriptTxn(
      tcxWithCharterMint,
      "minter",
      minter.compiledScript
    );
    const tcx4a = await this.mkAdditionalTxnsForCharter(tcxWithCharterMint);
    if (!tcx4a)
      throw new Error(
        `${this.constructor.name}: mkAdditionalTxnsForCharter() must return a txn context`
      );
    console.log(
      " --------------------- CHARTER MINT ---------------------\n"
      // txAsString(tcx4.tx, this.networkParams)
    );
    return tcxWithCharterMint;
  }
  // async txnAddSettingsOutput<
  //     TCX extends StellarTxnContext<hasAllUuts<"set">>
  // >(tcx: TCX, settings: CapoOffchainSettingsType<this>): Promise<TCX> {
  //     const settingsDatum = await this.mkDatumSettingsData(
  //         {
  //             id: tcx.state.uuts.set.name,
  //             ... (settings as any),
  //         });
  //     const settingsOut = new TxOutput(
  //         this.address,
  //         this.uutsValue(tcx.state.uuts.set),
  //         settingsDatum
  //     );
  //     settingsOut.correctLovelace(this.networkParams);
  //     return tcx.addOutput(settingsOut);
  // }
  // /**
  //  * @deprecated - use tcxWithSettingsRef() instead
  //  */
  // async addSettingsRef<TCX extends StellarTxnContext>(
  //     tcx: TCX
  // ): Promise<TCX & hasSettingsRef> {
  //     return this.tcxWithSettingsRef(tcx);
  // }
  // /**
  //  * ensures that the transaction context has a reference to the settings UTXO
  //  * @public
  //  * @remarks
  //  *
  //  * Accepts a transaction context, and ensures that it has a reference to the
  //  * settings UTXO.  If the transaction context already has a settings reference,
  //  * it is returned as-is.  Otherwise, the settings UTXO is found and added to
  //  * the transaction context.
  //  */
  // async tcxWithSettingsRef<TCX extends StellarTxnContext>(
  //     tcx: TCX
  // ): Promise<TCX & hasSettingsRef> {
  //     if (
  //         //@ts-expect-error on type-probe:
  //         tcx.state.settingsRef
  //     )
  //         return tcx as TCX & hasSettingsRef;
  //     const settingsUtxo = await this.findSettingsInfo(
  //         //@ts-expect-error it's ok if it's not there
  //         tcx.state.charterData
  //     );
  //     const tcx2 = tcx.addRefInput(settingsUtxo) as TCX & hasSettingsRef;
  //     tcx2.state.settingsRef = settingsUtxo;
  //     return tcx2;
  // }
  /**
   * Creates an additional reference-script-creation txn
   * @remarks
   *
   * Creates a txn for reference-script creation, and
   * adds it to the current transaction context to also be submitted.
   *
   * The reference script is stored in the Capo contract with a special
   * Datum, and it can be used in future transactions to save space and fees.
   *
   * @param tcx - the transaction context
   * @param scriptName - the name of the script, used in the addlTxn's  name
   * @param script - the script to be stored onchain for future reference
   * @public
   **/
  async txnMkAddlRefScriptTxn(tcx, scriptName, script) {
    const sn = scriptName[0].toUpperCase() + scriptName.slice(1);
    return tcx.includeAddlTxn(`refScript${sn}`, {
      description: `creates on-chain reference script for ${scriptName}`,
      moreInfo: "saves txn fees and txn space in future txns",
      optional: false,
      tcx: this.mkRefScriptTxn(script)
    });
  }
  mkRefScriptTxn(script) {
    const tcx = this.mkTcx();
    const txo = makeTxOutput(
      this.address,
      makeValue(this.ADA(0n)),
      this.mkDatumScriptReference(),
      script
    );
    txo.correctLovelace(this.networkParams);
    return tcx.addOutput(
      txo
    );
  }
  async txnAttachScriptOrRefScript(tcx, program = this.compiledScript, useRefScript = true) {
    let expectedVh = program.hash();
    const isCorrectRefScript = (txin) => {
      const refScript = txin.output.refScript;
      if (!refScript)
        return false;
      const foundHash = refScript.hash();
      return equalsBytes(foundHash, expectedVh);
    };
    if (tcx.txRefInputs.find(isCorrectRefScript)) {
      console.warn("suppressing second add of refScript");
      return tcx;
    }
    const scriptReferences = useRefScript ? await this.findScriptReferences() : [];
    const matchingScriptRefs = scriptReferences.find(
      ([txin, refScript]) => isCorrectRefScript(txin)
    );
    if (!matchingScriptRefs) {
      console.warn(
        new Error(
          `\u26A0\uFE0F  missing refScript in Capo ${this.address.toString()} 
  ... for expected script hash ${bytesToHex(
            expectedVh
          )}; adding script directly to txn`
        ).stack?.replace(/^Error/, "")
      );
      return tcx.addScriptProgram(program);
    }
    return tcx.addRefInput(matchingScriptRefs[0]);
  }
  async findScriptReferences() {
    const utxos = await this.network.getUtxos(this.address);
    const utxosWithDatum = (await Promise.all(
      utxos.map((utxo) => {
        const datum2 = utxo.output.datum?.data;
        if (!datum2)
          return null;
        const scriptRef = this.newReadDatum(datum2);
        if (!scriptRef.ScriptReference) {
          return null;
        }
        return [utxo, scriptRef];
      })
    )).filter((x) => !!x);
    return utxosWithDatum;
  }
  async mkTxnUpdateCharter(args, activity = this.activityUpdatingCharter(), tcx = this.mkTcx()) {
    console.log("update charter" + uplcDataSerializer("activity", activity));
    return this.txnUpdateCharterUtxo(tcx, activity, args);
  }
  async txnAddNamedDelegateAuthority(tcx, delegateName, delegate, activity) {
    return delegate.txnGrantAuthority(tcx, activity);
  }
  /**
   * Returns a single item from a list, throwing an error if it has multiple items
   *
   */
  singleItem(xs) {
    const [first, ...excess] = xs;
    if (excess.length) {
      throw new Error("expected single item, got " + excess.length);
    }
    return first;
  }
  /**
   * Queries a chain-index to find utxos having a specific type of delegated datum
   * @remarks
   * Optionally filters records by `id`, `type` and/or `predicate`
   *
   * The `predicate` function, if provided, can implement any logic suitable for a specific case of data-finding.
   */
  async findDelegatedDataUtxos({
    type,
    id,
    predicate,
    query
  }) {
    if (!type && !predicate && !id) {
      throw new Error("Must provide either type, predicate or id");
    }
    if (id && predicate) {
      throw new Error("Cannot provide both id and predicate");
    }
    if (id) {
      let idBytes;
      if (Array.isArray(id)) {
        idBytes = id;
      } else {
        idBytes = encodeUtf8(id.toString());
      }
      predicate = (utxo, datum2) => {
        if (!datum2.id) {
          throw new Error(`um?`);
        }
        return equalsBytes(datum2.id, idBytes);
      };
    }
    if ("undefined" !== typeof type) {
      const dgtForType = await this.getDgDataController(type);
      if (!dgtForType) {
        console.log("no adapter for type", type);
      }
    }
    const utxos = await this.network.getUtxos(this.address);
    const utxosWithDatum = (await Promise.all(
      utxos.map(async (utxo) => {
        const { datum: datum2 } = utxo.output;
        if (!datum2?.data)
          return null;
        if (datum2.kind != "InlineTxOutputDatum") {
          throw new Error(
            `unexpected datum kind ${datum2.kind} in utxo`
          );
        }
        let type2;
        if (datum2.data.kind == "constr") {
          const cField = datum2.data.fields[0];
          if (!cField) {
            return void 0;
          }
          const map = cField.kind == "map" ? cField.items : null;
          if (map) {
            const typeBytes = encodeUtf8("tpe");
            const seenTypeBytes = map.find(([k, v]) => {
              if (k.kind != "bytes") {
                console.log("   - key not bytes", k.kind);
              } else {
                console.log("key ", decodeUtf8(k.bytes));
                return k.kind == "bytes" && equalsBytes(k.bytes, typeBytes);
              }
            })?.[1];
            if (seenTypeBytes?.kind == "bytes") {
              type2 = decodeUtf8(seenTypeBytes.bytes);
            }
          } else {
            console.log(
              "   - no map field in datum",
              datum2.data.dataPath
            );
          }
          if (!type2) {
            console.log(
              "   - no type field in datum",
              datum2.data.dataPath
            );
            return void 0;
          }
        }
        const dgtForType = type2 && await this.getDgDataController(type2);
        if (!dgtForType) {
          console.log(
            "no type found in datum",
            datum2.data.dataPath,
            "in utxo",
            dumpAny(utxo.id)
          );
          const msg = type2 ? `no delegate for type ${type2}` : "no type in datum";
          return {
            utxo,
            datum: datum2,
            dataWrapped: `Error: ${msg}, couldn't parse data`,
            toJSON() {
              return {
                utxo: utxo.datum,
                data: `[error: couldn't parse]`,
                dataWrapped: null
              };
            }
          };
        }
        const data = dgtForType.newReadDatum(datum2.data);
        const typedData = data.capoStoredData.data;
        return mkFoundDatum(utxo, dgtForType, datum2, typedData);
      })
    )).filter((x) => !!x);
    console.log(type, `findDelegatedData: `, utxosWithDatum.length);
    return utxosWithDatum;
    function mkFoundDatum(utxo, delegate, datum2, data) {
      if (!data) {
        return null;
      }
      if (!data.id || !data.type) {
        console.log(
          `\u26A0\uFE0F  WARNING: missing required 'id' or 'type' field in this delegated datum
`,
          dumpAny(utxo),
          data
        );
        debugger;
        return null;
      }
      if (type && data.type != type) {
        return null;
      }
      if (predicate && !predicate(utxo, data)) {
        return null;
      }
      const dataWrapped = delegate.usesWrappedData ? (
        //@ts-expect-error because we don't have a strong type for the delegate
        delegate.wrapData(data)
      ) : void 0;
      return {
        utxo,
        datum: datum2,
        data,
        dataWrapped,
        toJSON() {
          return {
            utxo: utxo.id,
            datum: datum2,
            data,
            dataWrapped: dataWrapped ? `[data wrapped  as ${dataWrapped?.constructor.name}]` : void 0
          };
        }
      };
    }
  }
  async mkTxnUpdatingMintDelegate(delegateInfo, tcx = new StellarTxnContext(this.setup)) {
    const currentCharter = await this.mustFindCharterUtxo();
    const currentDatum = await this.findCharterData(currentCharter);
    const mintDelegate = await this.getMintDelegate();
    const { minter } = this;
    const tcxWithSeed = await this.tcxWithSeedUtxo(tcx);
    const uutOptions = delegateInfo.forcedUpdate ? {
      withoutMintDelegate: {
        omitMintDelegate: true,
        specialMinterActivity: minter.activity.forcingNewMintDelegate(tcxWithSeed)
      }
    } : {
      mintDelegateActivity: mintDelegate.activity.DelegateLifecycleActivities.ReplacingMe(
        {
          seed: tcxWithSeed.state.seedUtxo.id,
          purpose: "mintDgt"
        }
      ),
      additionalMintValues: this.mkValuesBurningDelegateUut(
        currentDatum.mintDelegateLink
      ),
      skipDelegateReturn: true
      // so it can be burned without a txn imbalance
    };
    const tcx2 = await this.txnMintingUuts(
      // todo: make sure seed-utxo is selected with enough minUtxo ADA for the new UUT name.
      tcxWithSeed,
      ["mintDgt"],
      uutOptions,
      {
        mintDelegate: "mintDgt"
      }
    );
    console.warn("updating mint delegate with info", delegateInfo);
    const newMintDelegate = await this.txnCreateOffchainDelegateLink(
      tcx2,
      "mintDelegate",
      // !!! not tested:
      {
        ...delegateInfo,
        uutName: tcx2.state.uuts.mintDgt.name
      }
    );
    const fullCharterArgs = {
      ...currentDatum,
      mintDelegateLink: this.mkOnchainRelativeDelegateLink(newMintDelegate)
    };
    const capoActivity = delegateInfo.forcedUpdate ? this.activity.capoLifecycleActivity.forcingNewMintDelegate(tcx2, {
      purpose: "mintDgt"
    }) : void 0;
    const tcx3 = await this.mkTxnUpdateCharter(
      fullCharterArgs,
      capoActivity,
      await this.txnAddGovAuthority(tcx2)
    );
    return tcx3;
  }
  mkValuesBurningDelegateUut(current) {
    return [mkValuesEntry(current.uutName, -1n)];
  }
  async mkTxnUpdatingSpendDelegate(delegateInfo, tcx = new StellarTxnContext(this.setup)) {
    const currentCharter = await this.mustFindCharterUtxo();
    const currentDatum = await this.findCharterData(currentCharter);
    const spendDelegate = await this.getSpendDelegate(currentDatum);
    const tcxWithSeed = await this.tcxWithSeedUtxo(tcx);
    const uutOptions = {
      withoutMintDelegate: {
        omitMintDelegate: true,
        specialMinterActivity: this.minter.activity.CreatingNewSpendDelegate(tcxWithSeed, {
          replacingUut: delegateInfo.forcedUpdate ? void 0 : (
            // minter will enforce the Burn of this token name
            spendDelegate.authorityTokenName
          )
        }),
        additionalMintValues: delegateInfo.forcedUpdate ? void 0 : this.mkValuesBurningDelegateUut(
          currentDatum.spendDelegateLink
        ),
        // the minter won't require the old delegate to be burned,
        //  ... so it can be burned without a txn imbalance:
        skipDelegateReturn: delegateInfo.forcedUpdate
      }
    };
    const tcx2 = await this.txnMintingUuts(
      // todo: make sure seed-utxo is selected with enough minUtxo ADA for the new UUT name.
      tcxWithSeed,
      ["spendDgt"],
      uutOptions,
      {
        spendDelegate: "spendDgt"
      }
    );
    const newSpendDelegate = await this.txnCreateConfiguredDelegate(
      tcx2,
      "spendDelegate",
      delegateInfo
    );
    const tcx2a = delegateInfo.forcedUpdate ? tcx2 : await spendDelegate.txnGrantAuthority(
      tcx2,
      spendDelegate.activity.DelegateLifecycleActivities.ReplacingMe(
        {
          seed: tcxWithSeed.state.seedUtxo.id,
          purpose: "spendDgt"
        }
      ),
      "skipDelegateReturn"
    );
    const tcx2b = await newSpendDelegate.delegate.txnReceiveAuthorityToken(
      tcx2a,
      newSpendDelegate.delegate.tvAuthorityToken()
    );
    const fullCharterArgs = {
      ...currentDatum,
      spendDelegateLink: this.mkOnchainRelativeDelegateLink(newSpendDelegate)
    };
    const capoActivity = delegateInfo.forcedUpdate ? this.activity.capoLifecycleActivity.forcingNewSpendDelegate(
      tcx2,
      { purpose: "spendDgt" }
    ) : void 0;
    return this.mkTxnUpdateCharter(
      fullCharterArgs,
      capoActivity,
      await this.txnAddGovAuthority(tcx2b)
    );
  }
  async mkTxnAddingMintInvariant(delegateInfo, tcx = new StellarTxnContext(this.setup)) {
    await this.findCharterData();
    throw new Error(`test me!`);
  }
  async mkTxnAddingSpendInvariant(delegateInfo, tcx = new StellarTxnContext(this.setup)) {
    await this.findCharterData();
    throw new Error(`test me!`);
  }
  /**
   * Adds or replaces a named delegate in the Capo contract
   * @remarks
   *
   * Registers a new delegate, keyed by its name.  The delegate may
   * replace another
   *
   * Other contract scripts can reference named delegates through the
   * contract's charter, requiring their presence in a transaction - thus
   * delegating some portion of validation responsibility to the other script
   *
   * @param delegateName - the key that will be used in the on-chain data structures and in dependent contracts.
   *  @param options - configuration for the delegate
   * @public
   **/
  async mkTxnAddingNamedDelegate(delegateName, options, tcx = this.mkTcx()) {
    const currentCharter = await this.findCharterData();
    console.log(
      "------------------ TODO SUPPORT OPTIONS.forcedUpdate ----------------"
    );
    const uutPurpose = options.uutName || delegateName;
    if (uutPurpose.length > 13) {
      throw new Error(
        `uutName ${uutPurpose} can be max 13 chars 
   ... adjust this separately from the delegateName with options.uutName`
      );
    }
    await this.getMintDelegate(currentCharter);
    console.log("  -- \u{1F41E}\u{1F41E}adding named delegate with options", options);
    const tcx1 = tcx.state.seedUtxo === void 0 ? await this.tcxWithSeedUtxo() : tcx;
    const tcx2 = await this.txnMintingUuts(
      tcx1,
      [uutPurpose],
      options.mintSetup,
      {
        // role / uut map
        [delegateName]: uutPurpose
      }
    );
    const newNamedDelegate = await this.txnCreateOffchainDelegateLink(
      tcx2,
      delegateName,
      options
    );
    const tcx4 = await this.mkTxnUpdateCharter(
      {
        ...currentCharter,
        otherNamedDelegates: new Map([
          ...currentCharter.otherNamedDelegates.entries(),
          [
            delegateName,
            this.mkOnchainRelativeDelegateLink(newNamedDelegate)
          ]
        ])
      },
      void 0,
      await this.txnAddGovAuthority(tcx2)
    );
    const DelegateName = delegateName[0].toUpperCase() + delegateName.slice(1);
    const bigDelegateName = `namedDelegate${DelegateName}`;
    tcx4.state[bigDelegateName] = newNamedDelegate;
    const tcx5 = await this.txnMkAddlRefScriptTxn(
      tcx4,
      bigDelegateName,
      newNamedDelegate.delegate.compiledScript
    );
    return tcx5;
  }
  async mkTxnInstallingPolicyDelegate(dgtRole, idPrefix, charter) {
    const tcx1 = await this.tcxWithSeedUtxo(this.mkTcx());
    return this.mkTxnQueuingDelegateChange(
      "Add",
      dgtRole,
      idPrefix,
      void 0,
      tcx1
    );
  }
  // async mkTxnQueuingDelegateRemoval<
  //     THIS extends Capo<any>,
  //     TCX extends StellarTxnContext<anyState> = StellarTxnContext<anyState>
  // >(this: THIS, pendingChange: toQueueDgtRemoval, tcx = this.mkTcx()) {
  //     const currentCharter = await this.findCharterData();
  //     const mintDelegate = await this.getMintDelegate(currentCharter);
  //     const spendDelegate = await this.getSpendDelegate(currentCharter);
  //     const tcx1 = await spendDelegate.txnGrantAuthority(
  //         tcx,
  //         spendDelegate.activity.capoLifecycleActivity.queuePendingChange(
  //             pendingChange
  //         )
  //     );
  //     const tcx2 = await this.mkTxnUpdateCharter(
  //         {
  //             ...currentCharter,
  //             pendingChanges: [
  //                 pendingChange,
  //                 ...currentCharter.pendingChanges,
  //             ],
  //         },
  //         this.activity.capoLifecycleActivity.queuePendingChange(
  //             pendingChange
  //         ),
  //         tcx1
  //     );
  //     return tcx2;
  // }
  /**
   * Adds a new entry to the Capo's manifest
   * @remarks
   * Use mkTxnQueueingDelegateChange for changing DgDataPolicy entries.
   *
   * The type exclusions here mean this CURRENTLY works only with the
   * NamedTokenRef variety of manifest entry, but that's just pragmatic
   * because the other types don't yet have an implementation.
   * Other types can be eligible for adding to this API or to a different call.
   */
  async mkTxnAddManifestEntry(key, utxo, entry, tcx = this.mkTcx()) {
    const currentCharter = await this.findCharterData();
    if (!entry.entryType.NamedTokenRef) {
      throw new Error(`not yet supported for ${Object.keys(entry)}[0]`);
    }
    const { tokenName } = entry;
    const spendDgt = await this.getSpendDelegate(currentCharter);
    const tcx1a = await this.txnAddGovAuthority(tcx);
    const tcx1b = tcx1a.addRefInput(utxo.utxo);
    const tcx1c = await spendDgt.txnGrantAuthority(
      tcx1b,
      spendDgt.activity.CapoLifecycleActivities.updatingManifest.addingEntry(
        {
          key,
          tokenName
        }
      )
    );
    const tcx2 = await this.mkTxnUpdateCharter(
      {
        ...currentCharter,
        manifest: new Map([
          ...currentCharter.manifest.entries(),
          [key, entry]
        ])
      },
      this.activity.capoLifecycleActivity.updatingManifest.addingEntry({
        key,
        tokenName
      }),
      tcx1c
    );
    return tcx2;
  }
  async mkTxnQueuingDelegateChange(change, policyName, idPrefix, options = { config: {} }, tcx = this.mkTcx()) {
    const purpose = options.uutName || "dgPol";
    if (purpose.length > 13) {
      throw new Error(
        `delegate-purpose ${purpose} can be max 13 chars for a UUT-name.  
   ... adjust this separately from the policyName with options.uutName`
      );
    }
    const currentCharter = await this.findCharterData();
    const mintDgt = await this.getMintDelegate(currentCharter);
    const mintDgtActivity = mintDgt.activity;
    const tcx1 = (
      //@ts-expect-error on checking for possible seedUtxo presence
      tcx.state.seedUtxo === void 0 ? await this.tcxWithSeedUtxo() : tcx
    );
    const tempDataPolicyLink = await this.tempMkDelegateLinkForQueuingDgtChange(
      tcx1.state.seedUtxo,
      mintDgtActivity,
      purpose,
      policyName,
      idPrefix,
      options
    );
    this.mkOnchainRelativeDelegateLink(tempDataPolicyLink);
    const addDetails = {
      seed: tcx1.state.seedUtxo.id,
      purpose,
      idPrefix
      // delegateValidatorHash: tempOCDPLink.delegateValidatorHash,
      // config: tempOCDPLink.config,
    };
    const policyNameBytes = encodeUtf8(policyName);
    const replacesDgtME = [...currentCharter.manifest.values()].find(
      (m) => {
        !!m.entryType.DgDataPolicy && m.tokenName == policyNameBytes;
      }
    );
    const acReplacesDgt = replacesDgtME?.tokenName;
    if (acReplacesDgt) {
      if ("Add" === change) {
        throw new Error(
          `Cannot add a policy with the same name as an existing one: ${policyName} (use Replace activity)`
        );
      }
      throw new Error(`TODO: delegate-replacement support (test needed)`);
    } else {
      if ("Replace" === change) {
        throw new Error(
          `Cannot replace a policy that doesn't exist: ${policyName} (use Add activity)`
        );
      }
    }
    const dgtAction = change === "Add" ? {
      Add: addDetails
    } : {
      Replace: {
        ...addDetails,
        replacesDgt: this.uh.acAuthorityToken(policyNameBytes)
      }
    };
    const tcx2 = await this.txnMintingUuts(
      tcx1,
      [purpose],
      {
        usingSeedUtxo: tcx1.state.seedUtxo,
        mintDelegateActivity: mintDgtActivity.CapoLifecycleActivities.queuePendingChange
        // (
        //     pendingDgtChange
        // ),
      },
      {
        // role / uut map
        dgDataPolicy: purpose,
        [policyName]: purpose
      }
    );
    const delegateLink = this.mkOnchainRelativeDelegateLink(
      await this.txnCreateOffchainDelegateLink(tcx2, policyName, options)
    );
    const pendingChange = {
      delegateChange: {
        action: dgtAction,
        role: { DgDataPolicy: policyName },
        // idPrefix,
        // dgtLink: tempOCDPLink,
        dgtLink: delegateLink
      }
    };
    const tcx4 = await this.mkTxnUpdateCharter(
      {
        ...currentCharter,
        pendingChanges: [
          pendingChange,
          ...currentCharter.pendingChanges
        ]
      },
      this.activity.capoLifecycleActivity.queuePendingChange,
      // (
      //     pendingDgtChange
      // ),
      await this.txnAddGovAuthority(tcx2)
    );
    const stateKey = mkDgtStateKey(policyName);
    const tcx5 = tcx4;
    const tcx6 = await this.txnMkAddlRefScriptTxn(
      tcx5,
      stateKey,
      tempDataPolicyLink.delegate.compiledScript
    );
    return tcx6;
  }
  async tempMkDelegateLinkForQueuingDgtChange(seedUtxo, mintDgtActivity, purpose, policyName, idPrefix, options) {
    const ttcx1 = await this.tcxWithSeedUtxo(this.mkTcx(), seedUtxo);
    const ttcx2 = await this.txnMintingUuts(
      ttcx1,
      [purpose],
      {
        usingSeedUtxo: seedUtxo,
        mintDelegateActivity: mintDgtActivity.CapoLifecycleActivities.queuePendingChange
        //     {
        //         action: {
        //             Add: {
        //                 seed: ttcx1.state.seedUtxo.id,
        //                 purpose,
        //                 idPrefix: idPrefix
        //             },
        //         },
        //         role: { DgDataPolicy: {} },
        //         name: policyName,
        //     }
        // ),
      },
      {
        // role / uut map
        [policyName]: purpose
      }
    );
    return this.txnCreateOffchainDelegateLink(ttcx2, policyName, options);
  }
  async mkTxnCommittingPendingChanges(tcx = this.mkTcx()) {
    const currentCharter = await this.findCharterData();
    const mintDgt = await this.getMintDelegate(currentCharter);
    const spendDgt = await this.getSpendDelegate(currentCharter);
    const pendingChanges = currentCharter.pendingChanges;
    const tcx1a = await spendDgt.txnGrantAuthority(
      tcx,
      spendDgt.activity.CapoLifecycleActivities.commitPendingChanges
    );
    const tcx1b = await mintDgt.txnGrantAuthority(
      tcx1a,
      mintDgt.activity.CapoLifecycleActivities.commitPendingChanges
    );
    const tcx1c = await this.txnAddGovAuthority(tcx1b);
    const currentManifest = currentCharter.manifest;
    const newManifestEntries = /* @__PURE__ */ new Map();
    for (const pendingChange of pendingChanges) {
      if (pendingChange.otherManifestChange) {
        throw new Error(`otherManifestChange not yet supported`);
      }
      const {
        action: thisAction,
        role,
        dgtLink
      } = pendingChange.delegateChange;
      const name = role.DgDataPolicy;
      if (!name) {
        throw new Error(
          `only DgDataPolicy changes are currently supported here`
        );
      }
      if (!dgtLink) {
        throw new Error(`missing expected 'dgtLink' in pendingChange`);
      }
      const { uutName } = dgtLink;
      let idPrefix;
      if (thisAction.Add) {
        const { purpose, seed, idPrefix: PAidPrefix } = thisAction.Add;
        if (!PAidPrefix) {
          throw new Error(
            `missing expected 'idPrefix' in pendingChange`
          );
        }
        idPrefix = PAidPrefix;
        this.mkTcx();
        if (currentManifest.get(name)) {
          throw new Error(`can't Add conflicting name to manifest`);
        }
      } else {
        if (!thisAction.Replace) {
          throw new Error(
            `only Add and Replace actions are supported here`
          );
        }
        const {
          purpose,
          seed,
          idPrefix: PRidPrefix
        } = thisAction.Replace;
        if (!PRidPrefix) {
          throw new Error(
            `missing expected 'idPrefix' in pendingChange`
          );
        }
        idPrefix = PRidPrefix;
        if (!currentManifest.get(name)) {
          throw new Error(
            `can't Replace non-existent name '${name}' in manifest`
          );
        }
      }
      newManifestEntries.set(name, {
        tokenName: encodeUtf8(uutName),
        mph: void 0,
        entryType: {
          DgDataPolicy: {
            policyLink: dgtLink,
            idPrefix,
            refCount: 1n
          }
        }
      });
    }
    const updatedManifest = new Map([
      ...newManifestEntries.entries(),
      ...currentManifest.entries()
    ]);
    const tcx2 = await this.mkTxnUpdateCharter(
      {
        ...currentCharter,
        manifest: updatedManifest,
        pendingChanges: []
      },
      this.activity.capoLifecycleActivity.commitPendingChanges,
      tcx1c
    );
    return tcx2;
  }
  async txnMintingUuts(initialTcx, uutPurposes, options, roles = {}) {
    const {
      usingSeedUtxo,
      additionalMintValues = [],
      omitMintDelegate = false,
      mintDelegateActivity,
      specialMinterActivity,
      skipDelegateReturn
    } = (
      //@ts-expect-error accessing the intersection type
      options.withoutMintDelegate || options
    );
    const mintDelegate = await this.getMintDelegate();
    const { seedUtxo } = initialTcx.state;
    const tcx = await this.txnWillMintUuts(
      initialTcx,
      uutPurposes,
      {
        usingSeedUtxo: seedUtxo
        // additionalMintValues,
        // existingDelegateReplacementActivity,
      },
      roles
    );
    if (omitMintDelegate) {
      if (mintDelegateActivity)
        throw new Error(
          `omitMintDelegate and usingMintDelegateActivity are mutually exclusive`
        );
      if (!specialMinterActivity) {
        throw new Error(
          `txnMintingUuts: omitMintDelegate requires a specialMinterActivity to be specified
  ... this indicates an activity in the MINTER (not the minting delegate),  ... the minter should be able to honor that activity/redeemer.`
        );
      }
      const tcx22 = await this.minter.txnMintingWithoutDelegate(
        tcx,
        [
          ...mkUutValuesEntries(tcx.state.uuts),
          ...additionalMintValues
        ],
        specialMinterActivity
      );
      return tcx22;
    }
    if (additionalMintValues.length && !mintDelegateActivity) {
      throw new Error(
        `additionalMintValues requires a custom activity provided by your mint delegate specialization`
      );
    }
    if (!mintDelegateActivity) {
      throw new Error(
        `txnMintingUuts: options.mintDelegateActivity is required;   ... it should indicate an application-specific use-case for which the mint delegate validates the exact needed UUTs to be minted`
      );
    }
    const tcx2 = await this.minter.txnMintWithDelegateAuthorizing(
      tcx,
      [...mkUutValuesEntries(tcx.state.uuts), ...additionalMintValues],
      mintDelegate,
      mintDelegateActivity,
      skipDelegateReturn
    );
    return tcx2;
  }
  /**
   * @deprecated use tcxWithSeedUtxo() instead
   * @remarks adds a seed utxo to a transaction-context,
   */
  async addSeedUtxo(tcx = new StellarTxnContext(this.setup), seedUtxo) {
    return this.tcxWithSeedUtxo(tcx, seedUtxo);
  }
  async txnWillMintUuts(tcx, uutPurposes, { usingSeedUtxo }, roles = {}) {
    if (!usingSeedUtxo)
      debugger;
    const { txId, index: utxoIdx } = usingSeedUtxo.id;
    const uutMap = Object.fromEntries(
      uutPurposes.map((uutPurpose) => {
        const idx = makeIntData(BigInt(utxoIdx)).toCbor();
        const txoId = txId.bytes.concat(["@".charCodeAt(0)], idx);
        const uutName = new UutName(
          uutPurpose,
          `${uutPurpose}-${bytesToHex(blake2b(txoId).slice(0, 6))}`
        );
        return [uutPurpose, uutName];
      })
    );
    for (const [role, uutPurpose] of Object.entries(roles)) {
      const mappedUutName = uutMap[uutPurpose];
      if (!mappedUutName) {
        throw new Error(
          `role/name mismatch: ${role}: not found: ${uutPurpose}
  ... available: ${uutPurposes.join(", ")}`
        );
      }
      uutMap[role] = mappedUutName;
    }
    if (!tcx.state)
      tcx.state = { uuts: {} };
    tcx.state.uuts = {
      ...tcx.state.uuts,
      ...uutMap
    };
    return tcx;
  }
  requirements() {
    return hasReqts({
      "is a base class for leader/Capo pattern": {
        purpose: "so that smart contract developers can easily start multi-script development",
        details: [
          "Instantiating a Capo contract always uses the seed-utxo pattern for uniqueness.",
          "Subclassing Capo with no type-params gives the default minter,",
          "  ... which only allows UUTs to be created",
          "Subclassing Capo<CustomMinter> gives an overloaded minter,",
          "  ... which must allow UUT minting and may allow more Activities too."
        ],
        mech: [
          "provides a default minter",
          "allows the minter class to be overridden"
        ]
      },
      "can create unique utility tokens": {
        purpose: "so the contract can use UUTs for scoped-authority semantics",
        details: [
          "That UUT (a Value) is returned, and then should be added to a TxOutput.",
          "The partial-helper doesn't constrain the semantics of the UUT.",
          "The uniqueness level can be iterated in future as needed.",
          "The UUT's token-name combines its textual purpose with a short hash ",
          "   ... of the seed UTxO, formatted with bech32"
        ],
        mech: [
          "Building a txn with a UUT involves using the txnMintingUuts partial-helper on the Capo.",
          "Fills tcx.state.uuts with purpose-keyed unique token-names",
          "The UUT uses the seed-utxo pattern to form 64 bits of uniqueness, so that token-names stay short-ish."
        ]
      },
      "supports the Delegation pattern using roles and strategy-variants": {
        purpose: "enables structured modularity and extensibility",
        details: [
          "A Capo constellation can declare a set of roles to be filled in the contract logic.",
          "The roles are typed, so that implementers of extensibility can know ",
          "  ... which capabilities their plugins need to provide",
          "Each role should be filled by a StellarContract class, ",
          "  ... which is required at the time it is needed during creation of a transaction.",
          "Each role should normally provide a base implementation ",
          "  ... of a delegate that can serve the role.",
          "Strategies, strategy-variants, or simple 'variants' are all similar ways ",
          "  ... of indicating different named plugins that can serve a particular role.",
          "Variant-names are human-readable, while the actual code",
          "  ... behind each variant name are the strategies"
        ],
        mech: [],
        requires: [
          "supports well-typed role declarations and strategy-adding",
          "supports just-in-time strategy-selection using txnCreateDelegateLink()",
          "given a configured delegate-link, it can create a ready-to-use Stellar subclass with all the right settings",
          "supports concrete resolution of existing role delegates"
        ]
      },
      "supports well-typed role declarations and strategy-adding": {
        purpose: "for plugin implementers to have a clear picture of what to implement",
        details: [
          "Each Capo class may declare a roles data structure.",
          "GOAL: The required type for each role must be matched when adding a plugin class serving a role",
          "A dApp using a Capo class can add strategy variants by subclassing"
        ],
        mech: [
          "Capo EXPECTS a synchronous getter for 'delegateRoles' to be defined",
          "Capo provides a default 'delegateRoles' having no specific roles (or maybe just minter - TBD)",
          "Subclasses can define their own get delegateRoles(), return a role-map-to-variant-map structure"
        ],
        requires: [
          "Each role uses a RoleVariants structure which can accept new variants"
        ]
      },
      "supports just-in-time strategy-selection using txnCreateDelegateLink()": {
        purpose: "enabling each transaction to select appropriate plugins for its contextual needs",
        details: [
          "When a transaction having an extensibility-point is being created,",
          "  ... it SHOULD require an explicit choice of the delegate to use in that role.",
          "When a 'mkTxn\u2039DoesThings\u203A' method creates a new role-delegated UTxO, ",
          "  ... it sets essential configuration details for the delegation ",
          "  ... including a specific UUT that provides a linking mechanism for the delegate",
          "The delegate contract, including its address and/or reference-script UTxO ",
          "  ... and/or its parameters and its StellarContract class, MUST be captured ",
          "  ... so that it can be easily resolved and used/referenced",
          "  .... during a later transaction whose UTxO-spending is governed by the delegate contract.",
          "When the delegate serving the role is selected, ",
          "  ... that delegate will be manifested as a concrete pair of StellarContract subclass ",
          "  ... and contract address.  The contract address MAY be pre-existing ",
          "  ... or be instantiated as a result of the delegation details."
        ],
        mech: [
          "txnCreateDelegateLink(tcx, role, delegationSettings) method configures a new delegate",
          "txnCreateDelegateLink() will use a 'default' delegate strategy",
          "If there is no delegate configured (or defaulted) for the needed role, txnCreateDelegateLink throws a DelegateConfigNeeded error.",
          "If the strategy-configuration doesn't match available variants, the DelegateConfigNeeded error offers suggested strategy-names",
          "If the strategy-configuration has any configuration problems, the DelegateConfigNeeded error contains an 'errors' object",
          "txnCreateDelegateSettings(tcx, role, delegationSettings) returns the delegate link plus a concreted delegate instance"
        ]
      },
      "given a configured delegate-link, it can create a ready-to-use Stellar subclass with all the right settings": {
        purpose: "allows the known facts about a delegate to be resolved to working SC class",
        details: [
          "A delegate link created by txnCreateDelegateLink(), can be captured in different ways",
          "  ... e.g. as a Datum property in a contract, ",
          "  ... or in any off-chain way.",
          "A dApp then reconstitutes this key information to a StellarContract, ",
          "  ... enabling simple multi-contract collaboration"
        ],
        mech: [
          "mustGetDelegate(configuredDelegate) method retrieves a configured delegate"
        ]
      },
      "Each role uses a RoleVariants structure which can accept new variants": {
        purpose: "provides a type-safe container for adding strategy-variants to a role",
        details: [
          "Adding a strategy variant requires a human-readable name for the variant",
          "  ... and a reference to the StellarContract class implementing that variant.",
          "Each variant may indicate a type for its configuration data-structure",
          "  ... and may include a factory function accepting a data-structure of that type.",
          "TBD: base configuration type?  Capo txn-builders supporting utxo-creation can provide baseline details of the base type, ",
          "  ... with additional strategy-specific details provided in the transaction-context.",
          "When adding strategies, existing variants cannot be removed or replaced."
        ],
        mech: [
          "RoleVariants has type-parameters indicating the baseline types & interfaces for delegates in that role",
          "TODO: variants can augment the delegateRoles object without removing or replacing any existing variant"
        ],
        requires: [
          "provides a Strategy type for binding a contract to a strategy-variant name"
        ]
      },
      "provides a Strategy type for binding a contract to a strategy-variant name": {
        purpose: "has all the strategy-specific bindings between a variant and the contract delegate",
        details: [
          "When adding a contract as a delegate serving in a role, its name",
          "  ... and its Strategy binding creates the connection between the host contract (suite) ",
          "  ... and the StellarContract subclass implementing the details of the strategy.",
          "The Strategy and its underlying contract are type-matched",
          "  ... with the interface needed by the Role.",
          "The Strategy is a well-typed structure supporting ",
          "  ... any strategy-specific configuration details (script parameters)",
          "  ... and validation of script parameters"
        ],
        mech: [
          "Each strategy must reference a type-matched implementation class",
          "Each strategy may define scriptParams always used for that strategy",
          "Each strategy may defer the definition of other script-params to be defined when a specific delegation relationship is being created",
          "Each strategy must define a validateScriptParams(allScriptParams) function, returning an errors object if there are problems",
          "validateScriptParams() should return undefined if there are no problems"
        ],
        requires: [
          "supports concrete resolution of existing role delegates"
        ]
      },
      "supports concrete resolution of existing role delegates": {
        purpose: "so that transactions involving delegated responsibilities can be executed",
        details: [
          "When a transaction needs to involve a UTxO governed by a delegate contract",
          "   ... the need for that delegate contract is signalled through Capo callbacks ",
          "   ... during the transaction-building process.",
          "Those callbacks contain key information, such as role-name, parameters, and address",
          "  ... needed in the collaboration to find the correct concrete delegate.",
          "Once the delegate is resolved to a configured StellarContract class, ",
          "   ... its established transaction-building interface is triggered, ",
          "   ... augmenting the transaction with the correct details, ",
          "   ... and enabling the right on-chain behaviors / verifications",
          "The Strategy adapter is expected to return the proper delegate with its matching address."
        ],
        mech: [
          "TODO: with an existing delegate, the selected strategy class MUST exactly match the known delegate-address"
        ]
      },
      "can locate UUTs in the user's wallet": {
        purpose: "for finding UUTs representing user's authority",
        details: [
          "A Capo contract can locate UUTs in the user's wallet",
          "  ... using the findActorUut() method",
          "This is useful for finding authority tokens, ",
          "  ... such as a charter-governance token, ",
          "  ... or a token representing a user's authority in a smart contract"
        ],
        mech: ["findActorUut() returns a FoundUut object, "]
      },
      "positively governs all administrative actions": {
        purpose: "to maintain clear control by an abstract entity",
        details: [
          // descriptive details of the requirement (not the tech):
          "A governance delegate is defined during contract creation",
          "The contract's policy for allowing governance actions is abstract, ",
          "  ... enforced only by a delegation pattern. ",
          "Thus, the Capo doesn't contain any of the policy details.",
          "The delegate can be evolved through governance action"
        ],
        mech: [
          // descriptive details of the chosen mechanisms for implementing the reqts:
          "uses a 'charter' token specialized for this contract",
          "the charter token has a govDgt (governance delegate) in its Datum structure",
          "the gov delegate's token can provide authorization for administrative actions",
          "the charter Datum is updated when needed to reflect a new gov delegation config"
        ],
        requires: [
          "has a unique, permanent charter token",
          "has a unique, permanent treasury address",
          // "the trustee threshold is enforced on all administrative actions",
          // "the trustee group can be changed",
          "the charter token is always kept in the contract",
          "the charter details can be updated by authority of the capoGov-* token",
          "can mint other tokens, on the authority of the charter's registered mintDgt- token",
          "can handle large transactions with reference scripts"
        ]
      },
      "has a singleton minting policy": {
        purpose: "to mint various tokens authorized by the treasury",
        details: [
          "A chosen minting script is bound deterministically to the contract constellation",
          "Its inaugural (aka 'initial Charter' or 'Charter Mint') transaction creates a charter token",
          "The minting script can issue further tokens approved by the Capo's minting delegate",
          "The minting script does not need to concern itself with details of the delegate's approval"
        ],
        mech: [
          "has an initial UTxO chosen arbitrarily, and that UTxO is consumed during initial Charter",
          "makes a different address depending on (txId, outputIndex) parameters of the Minting script"
        ],
        requires: [
          "can mint other tokens, on the authority of the charter's registered mintDgt- token"
        ]
      },
      "the charter details can be updated by authority of the capoGov-* token": {
        purpose: "to support behavioral changes over time by repointing the delegate links",
        details: [
          "The Capo's ability to accept charter-configuration changes allows its behavior to evolve. ",
          "These configuration changes can accept a new minting-delegate configuration ,",
          " ... or other details of the Charter datum that may be specialized.",
          "Charter updates are authorized by the gov delegate"
        ],
        mech: ["can update details of the datum"],
        requires: [
          "can update the minting delegate in the charter data",
          "can update the spending delegate in the charter data",
          "can add invariant minting delegates to the charter data",
          "can add invariant spending delegates to the charter data"
        ]
      },
      "can update the minting delegate in the charter data": {
        purpose: "to evolve the minting policy for the contract",
        details: [
          "when updating the minting policy delegate, the gov authority is used to authorize the change",
          "the minting policy is updated in the charter datum",
          "the old minting policy should be retired when changing policies"
        ],
        impl: "mkTxnUpdatingMintDelegate()",
        mech: [
          "can install an updated minting delegate",
          "fails without the capoGov- authority uut",
          "normally requires the eixsting mint delegate to be involved in the replacement",
          "can force-replace the mint delegate if needed",
          "keeps the charter token in the contract address",
          "uses the new minting delegate after it is installed",
          "can't use the old minting delegate after it is replaced"
        ]
      },
      "can update the spending delegate in the charter data": {
        purpose: "to evolve the spending policy for the contract's delegated-datum types",
        details: [
          "when updating the spending policy delegate, the gov authority is used to authorize the change",
          "the spending policy is updated in the charter datum",
          "the old spending policy should be retired when changing policies"
        ],
        mech: [
          "can install an updated spending delegate",
          "fails without the capoGov- authority uut",
          "normally requires the eixsting mint delegate to be involved in the replacement",
          "can force-replace the mint delegate if needed",
          "keeps the charter token in the contract address",
          "uses the new spending delegate after it is installed",
          "can't use the old spending delegate after it is replaced"
        ]
      },
      "can add invariant spending delegates to the charter data": {
        purpose: "to arrange permanent spending policies for custom data types",
        details: [
          "The Capo can add invariant spending policies for custom data types",
          "These invariants are enforced forever, and can't be changed",
          "The baseline scripts directly enforce these invariants, so that a delegate-swap actvity can't undermine the invariant"
        ],
        mech: [
          "TODO: TEST can add an invariant spending delegate for a datum type",
          "TODO: TEST cannot change any other charter settings when adding an invariant",
          "TODO: TEST cannot change spend invariants when updating other charter settings",
          "TODO: TEST new invariants are always enforced",
          "TODO: TEST can never remove an invariant spending delegate for a datum type"
        ]
      },
      "can add invariant minting delegates to the charter data": {
        purpose: "to arrange permanent minting policies constraining what can be minted",
        details: [
          "The Capo can add invariant mint policies",
          "These invariants are enforced forever, and can't be changed",
          "The baseline scripts directly enforce these invariants, so that a mint-delegate-swap actvity can't undermine the invariant"
        ],
        mech: [
          "TODO: TEST can add an invariant mint delegate",
          "TODO: TEST fails without the capoGov- authority uut",
          "TODO: TEST cannot change any other charter settings when adding the mint invariant",
          "TODO: TEST can never remove an mint invariant mint after it is added",
          "TODO: TEST cannot change mint invariants when updating other charter settings",
          "TODO: TEST always enforces new mint invariants"
        ]
      },
      "has a unique, permanent treasury address": {
        purpose: "to give continuity for its stakeholders",
        details: [
          "One-time creation is ensured by UTxO's unique-spendability property",
          "Determinism is transferred from the charter utxo to the MPH and to the treasury address",
          "Further software development lifecycle is enabled by evolution of details stored in the Charter datum"
        ],
        mech: [
          "uses the Minting Policy Hash as the sole parameter for the treasury spending script"
        ],
        requires: ["has a singleton minting policy"]
      },
      "has a unique, permanent charter token": {
        purpose: "to guarantee permanent identity of a token constraining administrative actions",
        details: [
          "a charter token is uniquely created when bootstrapping the constellation contract",
          "the charter token can't ever be recreated (it's non-fungible and can't be re-minted)",
          "the treasury address, minting policy hash, and charter token are all deterministic based on input utxo"
        ],
        impl: "txnMintCharterToken()",
        mech: [
          "creates a unique 'charter' token, with assetId determined from minting-policy-hash+'charter'",
          // "XXX - move to multi-sig Delegate - TODO: fails if minSigs is longer than trustee list",
          "doesn't work with a different spent utxo"
        ],
        requires: [
          "has a singleton minting policy",
          "the charter token is always kept in the contract"
        ]
      },
      "supports an abstract Settings structure stored in the contact": {
        purpose: "allows settings that can evolve to support Capo-related scripts as needed",
        details: [
          "The Settings structure can be stored in the contract, separately from the CharterData. ",
          "It can be updated by the govAuthority, and can be used to store any ",
          "  ... data needed by the Capo's scripts, such as minting and spending delegates.",
          "The charter datum references the settings uut, and shouldn't ",
          "  ... ever need to change that reference, since the settings data can be updated in place.",
          "The settings can store various data using string keys and conventions defined within the Capo.",
          "The Capo contract MUST NOT make any calls to methods in the Settings structure, ",
          "  ... so that that the Capo's code won't be changed if any methods are modified."
        ],
        mech: [
          // "has a 'SettingsData' datum variant & utxo in the contract",
          // "offchain code can read the settings data from the contract",
          // "TODO: TEST onchain code can read the settings data from the contract",
          // "charter creation requires a CharterData reference to the settings UUT",
          // "charter creation requires presence of a SettingsData map",
          // "updatingCharter activity MUST NOT change the set-UUT reference",
        ],
        requires: [
          // "mkTxnUpdateSettings(): can update the settings",
          "added and updated delegates always validate the present configuration data"
        ]
      },
      // "mkTxnUpdateSettings(): can update the settings": {
      //     purpose: "to support parameter changes",
      //     impl: "mkTxnUpdateSettings()",
      //     details: [
      //         "The minting delegate is expected to validate all updates to the configuration data.",
      //         "The spending delegate is expected to validate all updates to the configuration data.",
      //         "Settings changes are validated by all registered delegates before being accepted.",
      //     ],
      //     mech: [
      //         "can update the settings data with a separate UpdatingSettings Activity on the Settings",
      //         "requires the capoGov- authority uut to update the settings data",
      //         "the spending delegate must validate the UpdatingSettings details",
      //         "the minting delegate must validate the UpdatingSettings details",
      //         "all named delegates must validate the UpdatingSettings details",
      //         "TODO: the spending invariant delegates must validate the UpdatingSettings details",
      //         "TODO: the minting invariant delegates must validate the UpdatingSettings details",
      //     ],
      // },
      "added and updated delegates always validate the present configuration data": {
        purpose: "to ensure that the entirety of policies in a contract suite have integrity",
        details: [
          "New delegates cannot be adopted unless they also validate the present configuration data, ",
          "  ... so that configuration and current delegates can always be expected to be in sync.",
          "However, a new delegate can't verify the config during their creation, ",
          "  ... because its policy can be triggered only after it has a utxo in it)",
          "With an an initial step of staging a prospective delegate, the new delegate can ",
          "  ... provide positive assurance of  compatibility with the current settings."
        ],
        impl: "mkTxnStagingNewDelegate",
        mech: [
          "TODO: staging a Named delegate updates the namedDelegates structure with staged item",
          "TODO: staging a Mint delegate updates the mintDelegateLink structure with staged item",
          "TODO: staging a Spend delegate updates the spendDelegateLink structure with staged item",
          "TODO: staging an invariant delegate updates the invariantDelegates structure with staged item"
        ],
        requires: ["can commit new delegates"]
      },
      "can commit new delegates": {
        purpose: "to finalize the adoption of a new or updated delegate",
        details: [
          "A staged delegate can be committed, if it the current settings validate okay with it. ",
          "Given it already exists, then its settings-validation logic can be triggered ",
          " ... and its status can advance from 'staged' to 'active' "
        ],
        mech: [
          "TODO: a staged delegate is only adopted if it validates ok with the then-current settings"
        ]
      },
      "supports storing new types of datum not pre-defined in the Capo's on-chain script": {
        purpose: "to allow data extensibility and evolution in a backwards-compatible way",
        details: [
          "The Capo's DelegatedDatum type encapsulates all custom data types, ",
          "  ... and can be thought of as a Union of types that can be extended over time",
          "This allows the policies governing each type of data to evolve independently",
          "  ... without those data needing to be moved between contract addresses when changing the policies.",
          "The spending delegate script is expected to enforce spending rules for each type of custom data",
          "The minting delegate is expected to enforce creation rules for each type of custom data",
          "The mint- and spend-delegates can evolve to handle new types of data",
          "A namedDelegates structure in the Capo provides a manifest of additional delegates, ",
          "  ... whose involvement may be required as needed by the mint- and spend-delegates."
        ],
        mech: [
          "has named delegates, as a string map to named delegate links",
          "the spending policy "
        ],
        requires: [
          "the charter has a namedDelegates structure for semantic delegate links",
          "CreatingDelegatedDatum: creates a UTxO with any custom datum",
          "UpdatingDelegatedDatum: checks that a custom data element can be updated"
        ]
      },
      "the charter has a namedDelegates structure for semantic delegate links": {
        purpose: "to provide a manifest of additional delegates that may be required to enforce application semantics",
        details: [
          "The namedDelegates structure is a string map to named delegate links",
          "The minting and spending delegates can use these named delegates as needed",
          "The minting and spending delegates can evolve to handle new types of data",
          "The namedDelegates structure can be updated by the gov delegate"
        ],
        mech: [
          "has a namedDelegates structure in the charter datum",
          "TODO: TEST a named delegate can be added if the minter approves its creation",
          "the charter.namedDelegates structure can only be updated by the gov delegate",
          "can reject creation of named delegate with name not fitting the application's rules",
          "TODO: won't mint the new delegate without the seed-utxo being included in the transaction",
          "TODO: is created as a PendingDelegate datum during initial creation",
          "TODO: can only be adopted into Charter datum when it successfully validates the current SettingsData"
        ],
        requires: []
      },
      "CreatingDelegatedDatum: creates a UTxO with any custom datum": {
        purpose: "allows the application to enforce policies for custom record creation",
        details: [
          "The Capo must involve the minting delegate in creating a custom datum",
          "  ... which can apply its own logic to deciding whether the creation is allowed.",
          "The Capo trusts the minting delegate's enforcement of policy.",
          "The mint delegate can be signalled to validate multiple minting activities creating multiple delegated-datum UTxOs with separate seeds"
        ],
        impl: "mkTxnCreatingDelegatedDatum",
        mech: [
          "builds transactions including the minting delegate",
          "fails if the minting delegate is not included in the transaction",
          "fails if a CreatingDelegatedData activity isn't matched on recId by a data-controller MintingActivity",
          "TODO: TEST the mint delegate's multi-activity works with the generic CreatingDelegatedData activity",
          "TODO: the mint delegate's multi-activity can TODO work with the generic DeletingDelegatedData activity",
          "TODO: the mint delegate's multi-activity fails if the delegated-data controller isn't triggered with a matching MintingActivity(seed, recId)",
          "TODO: the mint delegate's multi-activity fails if the delegated-data controller has multiple activities for the same record id",
          "TODO: the data-controller policy fails if any of its creation activities doesn't have a matching output record",
          "TODO: the data-controller policy fails if any of the creation activities corresponds to an existing record-id input",
          "TODO: the data-controller policy fails if a deletion activity isn't matched with a BURN of the record's UUT"
        ]
      },
      "UpdatingDelegatedDatum: checks that a custom data element can be updated": {
        purpose: "guards appropriate updates to custom data elements",
        details: [
          "When updating a custom datum, the Capo must involve the spending delegate ",
          "  ... which can apply its own logic to deciding whether the update is allowed.",
          "The Capo trusts the spending delegate's enforcement of policy.",
          "The spend delegate can be signalled to validate multiple activities covering multiple utxos in a single transaction"
        ],
        mech: [
          "builds transactions including the spending-delegate",
          "TODO: TEST the capo fails if the spend delegate doesn't have an activity matching the record being updated",
          "TODO: TEST the capo fails if the spend delegate has multiple activities for any one record id",
          "TODO: TEST the spend delegate's multi-activity works only with the generic UpdatingDelegatedData activity",
          "TODO: TEST the spend delegate fails if any of its activities isn't matched by a spent/updated record",
          "TODO: TEST the spend delegate fails if the delegated data controller doesn't have an activity matching that record",
          "TODO: TEST the spend delegate fails if the delegated data controller has multiple activities for the record id",
          "TODO: TEST the data-controller policy fails if any of its activities isn't matched by a spent/updated record",
          "TODO: TEST the data-controller policy works only with its specific SpendingActivities/MintingActivities, not the generic activities used by the SpendDgt",
          "fails if the spending delegate is not included in the transaction",
          "TODO: builds transactions including the invariant spending-delegates",
          "TODO: fails if the expected invariant delegate is not included in the transaction"
        ]
      },
      "the charter token is always kept in the contract": {
        purpose: "so that the treasury contract is always in control of administrative changes",
        details: [
          "The charter token's spendability' is used as a signal of administrative authority for transactions wanting proof of authority",
          "... thus, other scripts don't need to express any of the authority policy, but can simply verify the token's presence in the txn",
          "It shouldn't ever be possible to interfere with its spendability, e.g. by bundling it in an inconvenient way with other assets",
          "By enforcing that the charter token is always returned to the contract, ",
          "... it has assurance of continuing ability to govern the next activity using that token",
          "Note: the charter mint can bind with any contract having suitable assurances, ",
          "... but we only focus on the case of binding to this treasury contract"
        ],
        mech: [
          "builds transactions with the charter token returned to the contract",
          "fails to spend the charter token if it's not returned to the contract",
          "TODO: ensures that the charter token is kept separate from other assets in the contract"
        ],
        requires: []
      },
      "can mint other tokens, on the authority of the charter's registered mintDgt- token": {
        purpose: "to simplify the logic of minting, while being sure of minting authority",
        details: [
          "the minting policy doesn't have to directly express detailed policy for authorization",
          "instead, it defers authority to the minting delegate, ",
          "... which can implement its own policy for minting",
          "... and by simply requiring that the mintDgt token is being spent.",
          "The minting delegate decides whether that's to be allowed."
        ],
        mech: [
          "can build transactions that mint non-'charter' tokens",
          "requires the charter-token to be spent as proof of authority",
          "fails if the charter-token is not returned to the treasury",
          "fails if the charter-token parameters are modified"
        ]
      },
      "can handle large transactions with reference scripts": {
        purpose: "to support large transactions and reduce per-transaction costs",
        details: [
          "Each Capo involves the leader contract, a short minting script, ",
          "  ... and a minting delegate.  Particularly in pre-production, these ",
          "  ... can easily add up to more than the basic 16kB transaction size limit.",
          "By creating reference scripts, the size budget overhead for later ",
          "  ... transactions is reduced, at cost of an initial deposit for each refScript. ",
          "Very small validators may get away without refScripts, but more complicated ",
          "  ... transactions will need them.  So creating them is recommended in all cases."
        ],
        mech: [
          "creates refScript for minter during charter creation",
          "creates refScript for capo during charter creation",
          "creates refScript for mintDgt during charter creation",
          "finds refScripts in the Capo's utxos",
          "txnAttachScriptOrRefScript(): uses scriptRefs in txns on request"
        ]
      }
    });
  }
}
__decorateClass$1([
  Activity.redeemer
], Capo.prototype, "activityUsingAuthority", 1);
__decorateClass$1([
  partialTxn
], Capo.prototype, "txnMustUseCharterUtxo", 1);
__decorateClass$1([
  partialTxn
], Capo.prototype, "txnUpdateCharterUtxo", 1);
__decorateClass$1([
  partialTxn
], Capo.prototype, "txnKeepCharterToken", 1);
__decorateClass$1([
  partialTxn
], Capo.prototype, "txnAddGovAuthorityTokenRef", 1);
__decorateClass$1([
  Activity.redeemer
], Capo.prototype, "activityUpdatingCharter", 1);
__decorateClass$1([
  Activity.redeemer
], Capo.prototype, "activitySpendingDelegatedDatum", 1);
__decorateClass$1([
  datum
], Capo.prototype, "mkDatumScriptReference", 1);
__decorateClass$1([
  partialTxn
], Capo.prototype, "txnAttachScriptOrRefScript", 1);
__decorateClass$1([
  txn
], Capo.prototype, "mkTxnUpdateCharter", 1);
__decorateClass$1([
  partialTxn
], Capo.prototype, "txnAddNamedDelegateAuthority", 1);
__decorateClass$1([
  txn
], Capo.prototype, "mkTxnUpdatingMintDelegate", 1);
__decorateClass$1([
  txn
], Capo.prototype, "mkTxnUpdatingSpendDelegate", 1);
__decorateClass$1([
  txn
], Capo.prototype, "mkTxnAddingMintInvariant", 1);
__decorateClass$1([
  txn
], Capo.prototype, "mkTxnAddingSpendInvariant", 1);
__decorateClass$1([
  txn
], Capo.prototype, "mkTxnInstallingPolicyDelegate", 1);
__decorateClass$1([
  partialTxn
], Capo.prototype, "txnMintingUuts", 1);
__decorateClass$1([
  partialTxn
], Capo.prototype, "txnWillMintUuts", 1);

class SimpleWallet_stellar {
  #networkCtx;
  spendingPrivateKey;
  spendingPubKey;
  stakingPrivateKey;
  stakingPubKey;
  get cardanoClient() {
    return this.#networkCtx.network;
  }
  static fromPhrase(phrase, networkCtx, dict = BIP39_DICT_EN) {
    return SimpleWallet_stellar.fromRootPrivateKey(
      restoreRootPrivateKey(phrase, dict),
      networkCtx
    );
  }
  static fromRootPrivateKey(key, networkCtx) {
    return new SimpleWallet_stellar(
      networkCtx,
      key.deriveSpendingKey(),
      key.deriveStakingKey()
    );
  }
  constructor(networkCtx, spendingPrivateKey, stakingPrivateKey = void 0) {
    this.#networkCtx = networkCtx;
    this.spendingPrivateKey = spendingPrivateKey;
    this.spendingPubKey = this.spendingPrivateKey.derivePubKey();
    this.stakingPrivateKey = stakingPrivateKey;
    this.stakingPubKey = this.stakingPrivateKey?.derivePubKey();
  }
  get privateKey() {
    return this.spendingPrivateKey;
  }
  get pubKey() {
    return this.spendingPubKey;
  }
  get spendingPubKeyHash() {
    return this.spendingPubKey.hash();
  }
  get stakingPubKeyHash() {
    return this.stakingPubKey?.hash();
  }
  get address() {
    return makeAddress(
      this.cardanoClient.isMainnet(),
      this.spendingPubKeyHash,
      this.stakingPubKey?.hash()
    );
  }
  get stakingAddress() {
    if (this.stakingPubKey) {
      return makeStakingAddress(
        this.cardanoClient.isMainnet(),
        this.stakingPubKey.hash()
      );
    } else {
      return void 0;
    }
  }
  get stakingAddresses() {
    return new Promise((resolve, _) => {
      const stakingAddress = this.stakingAddress;
      resolve(stakingAddress ? [stakingAddress] : []);
    });
  }
  async isMainnet() {
    return this.#networkCtx.network.isMainnet();
  }
  /**
   * Assumed wallet was initiated with at least 1 UTxO at the pubkeyhash address.
   */
  get usedAddresses() {
    return new Promise((resolve, _) => {
      resolve([this.address]);
    });
  }
  get unusedAddresses() {
    return new Promise((resolve, _) => {
      resolve([]);
    });
  }
  get utxos() {
    return new Promise((resolve, _) => {
      resolve(this.cardanoClient.getUtxos(this.address));
    });
  }
  get collateral() {
    return new Promise((resolve, _) => {
      resolve([]);
    });
  }
  /**
   * Not yet implemented.
   */
  async signData(addr, message) {
    throw new Error("not yet implemented");
  }
  /**
   * Simply assumed the tx needs to by signed by this wallet without checking.
   */
  async signTx(tx) {
    return [this.spendingPrivateKey.sign(tx.body.hash())];
  }
  async submitTx(tx) {
    return await this.cardanoClient.submitTx(tx);
  }
}
let i = 1;
class StellarNetworkEmulator {
  #seed;
  #random;
  genesis;
  mempool;
  blocks;
  /**
   * Cached map of all UTxOs ever created
   * @internal
   */
  _allUtxos;
  /**
   * Cached set of all UTxOs ever consumed
   * @internal
   */
  _consumedUtxos;
  /**
   * Cached map of UTxOs at addresses
   * @internal
   */
  _addressUtxos;
  id;
  params;
  /**
   * Instantiates a NetworkEmulator at slot 0.
   * An optional seed number can be specified, from which all EMULATED RANDOMNESS is derived.
   */
  constructor(seed = 0, { params } = {
    params: DEFAULT_NETWORK_PARAMS()
  }) {
    this.id = i++;
    this.params = params || DEFAULT_NETWORK_PARAMS();
    this.#seed = seed;
    this.currentSlot = 0;
    this.#random = this.mulberry32.bind(this);
    this.genesis = [];
    this.mempool = [];
    this.blocks = [];
    this._allUtxos = {};
    this._consumedUtxos = /* @__PURE__ */ new Set();
    this._addressUtxos = {};
    this.initHelper();
  }
  isMainnet() {
    return false;
  }
  /**
   * Each slot is assumed to be 1000 milliseconds
   *
   * returns milliseconds since start of emulation
   */
  get now() {
    return SECOND * this.currentSlot;
  }
  get parameters() {
    return new Promise((resolve, _) => resolve(this.parametersSync));
  }
  get parametersSync() {
    return {
      ...this.params,
      refTipSlot: this.currentSlot,
      refTipTime: this.now
    };
  }
  /**
   * retains continuity for the seed and the RNG through one or more snapshots.
   * @internal
   */
  mulberry32 = () => {
    //!!mutates vvvvvvvvvv this.#seed
    let t = this.#seed += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
  netPHelper;
  initHelper() {
    this.netPHelper = makeNetworkParamsHelper(this.parametersSync);
    return this.netPHelper;
  }
  /**
   * Ignores the genesis txs
   */
  get txIds() {
    const res = [];
    for (let block of this.blocks) {
      for (let tx of block) {
        if (tx.kind == "Regular") {
          res.push(tx.id());
        }
      }
    }
    return res;
  }
  snapshot(snapName) {
    if (this.mempool.length > 0) {
      throw new Error(`can't snapshot with pending txns`);
    }
    console.log(
      "====================================================================\n" + dumpAny(this.utxoTotals(this._addressUtxos["addr_test1qqh9ym7atglu4dhez3r0ak5q2ka7emzqap9a0ktsqqzhzeztj8qhzu8m4rdc8kqtdxkjyf25ahha9prqpmnlt2weq0lsdnk75q"] || [])) + "\n===================================================================="
    );
    console.log(
      "            \u{1F4F8} \u{1F4F8} \u{1F4F8}   \u2588\u2588\u2588\u2588  \u{1F4F8} \u{1F4F8} \u{1F4F8}  #" + this.id,
      ` - snapshot '${snapName}' at slot `,
      this.currentSlot.toString(),
      "height ",
      this.blocks.length
    );
    return {
      name: snapName,
      seed: this.#seed,
      netNumber: this.id,
      slot: this.currentSlot,
      genesis: [...this.genesis],
      blocks: [...this.blocks],
      allUtxos: { ...this._allUtxos },
      consumedUtxos: new Set(this._consumedUtxos),
      // addressUtxos: { ...this._addressUtxos },
      addressUtxos: Object.fromEntries(
        Object.entries(this._addressUtxos).map(([addr, utxoList]) => [
          addr,
          [...utxoList]
        ])
      )
    };
  }
  utxoTotals(utxos) {
    return utxos.reduce(
      (acc, txo) => acc.add(txo.value),
      makeValue(0n)
    );
  }
  fromSnapshot = "";
  loadSnapshot(snapshot) {
    this.#seed = snapshot.seed;
    this.currentSlot = snapshot.slot;
    this.genesis = [...snapshot.genesis];
    this.blocks = [...snapshot.blocks];
    this.fromSnapshot = snapshot.name;
    this._allUtxos = { ...snapshot.allUtxos };
    this._consumedUtxos = new Set(snapshot.consumedUtxos);
    this._addressUtxos = Object.fromEntries(
      Object.entries(snapshot.addressUtxos).map(([addr, utxoList]) => [
        addr,
        [...utxoList]
      ])
    );
    this.initHelper();
    console.log(
      "            \u{1F33A}\u{1F33A}\u{1F33A} \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  #" + this.id,
      ` - restored snapshot '${snapshot.name}' from #${snapshot.netNumber} at slot `,
      this.currentSlot.toString(),
      "height ",
      this.blocks.length
    );
    console.log(
      "====================================================================\n" + dumpAny(this.utxoTotals(this._addressUtxos["addr_test1qqh9ym7atglu4dhez3r0ak5q2ka7emzqap9a0ktsqqzhzeztj8qhzu8m4rdc8kqtdxkjyf25ahha9prqpmnlt2weq0lsdnk75q"] || [])) + "\n===================================================================="
    );
  }
  // /**
  //  * Creates a new `NetworkParams` instance that has access to current slot
  //  * (so that the `Tx` validity range can be set automatically during `Tx.finalize()`).
  //  */
  // initNetworkParams(networkParams): NetworkParams {
  //     const raw = Object.assign({}, networkParams.raw);
  //     // raw.latestTip = {
  //     //     epoch: 0,
  //     //     hash: "",
  //     //     slot: 0,
  //     //     time: 0,
  //     // };
  //     return (this.#netParams = new NetworkParams(raw, () => {
  //         return this.currentSlot;
  //     }));
  // }
  /**
   * Creates a new SimpleWallet and populates it with a given lovelace quantity and assets.
   * Special genesis transactions are added to the emulated chain in order to create these assets.
   * @deprecated - use TestHelper.createWallet instead, enabling wallets to be transported to
   *     different networks (e.g. ones that have loaded snapshots from the original network).
   */
  createWallet(lovelace = 0n, assets = makeAssets([])) {
    throw new Error("use TestHelper.createWallet instead");
  }
  /**
   * Creates a UTxO using a GenesisTx.  The txn doesn't need to balance or be signed.  It's magic.
   * @param wallet - the utxo is created at this wallet's address
   * @param lovelace - the lovelace amount to create
   * @param assets - other assets to include in the utxo
   */
  createUtxo(wallet, lovelace, assets = makeAssets([])) {
    if (lovelace != 0n || !assets.isZero()) {
      const tx = makeEmulatorGenesisTx(
        this.genesis.length,
        wallet.address,
        lovelace,
        assets
      );
      this.genesis.push(tx);
      this.mempool.push(tx);
      return makeTxOutputId(tx.id(), 0);
    } else {
      throw new Error("zero-value utxos not supported");
    }
  }
  // #netParams!: NetworkParams;
  // async getParameters() {
  //     if (this.#netParams) return this.#netParams;
  //     return this.initNetworkParams(
  //         new NetworkParams(rawNetworkEmulatorParams)
  //     );
  // }
  warnMempool() {
    if (this.mempool.length > 0) {
      console.error(
        "Warning: mempool not empty (hint: use 'network.tick()')"
      );
    }
  }
  /**
   * Throws an error if the UTxO isn't found
   */
  async getUtxo(id) {
    this.warnMempool();
    const utxo = this._allUtxos[id.toString()];
    if (!utxo) {
      throw new Error(`utxo with id ${id.toString()} doesn't exist`);
    } else {
      return utxo;
    }
  }
  async getUtxos(address) {
    this.warnMempool();
    return this._addressUtxos[address.toString()] ?? [];
  }
  dump() {
    console.log(`${this.blocks.length} BLOCKS`);
    this.blocks.forEach((block, i2) => {
      console.log(`${block.length} TXs in BLOCK ${i2}`);
      for (let tx of block) {
        tx.dump();
      }
    });
  }
  isConsumed(utxo) {
    return this._consumedUtxos.has(utxo.id.toString()) || this.mempool.some((tx) => {
      return tx.consumes(utxo);
    });
  }
  async submitTx(tx, logger) {
    this.warnMempool();
    if (!tx.isValidSlot(BigInt(this.currentSlot))) {
      throw new Error(
        `tx invalid (slot out of range, ${this.currentSlot} not in ${tx.body.getValidityTimeRange(this.parametersSync).toString()})`
      );
    }
    if (!tx.body.inputs.every(
      (input) => input.id.toString() in this._allUtxos
    )) {
      throw new Error("some inputs don't exist");
    }
    if (!tx.body.refInputs.every(
      (input) => input.id.toString() in this._allUtxos
    )) {
      throw new Error("some ref inputs don't exist");
    }
    for (const input of tx.body.inputs) {
      if (this.isConsumed(input)) {
        throw new Error(
          `## ${this.id}: input previously consumed:` + dumpAny(input)
        );
      }
    }
    this.mempool.push(makeEmulatorRegularTx(tx));
    if (logger) {
      logger.logPrint(
        `[EmuNet #${this.id}] +mempool txn = ${this.mempool.length}`
      );
    } else {
      console.log(
        `[EmuNet #${this.id}] +mempool txn = ${this.mempool.length}`
      );
    }
    return tx.id();
  }
  /**
   * Mint a block with the current mempool, and advance the slot by a number of slots.
   */
  tick(nSlots) {
    const n = BigInt(nSlots);
    if (n < 1)
      throw new Error(`nSlots must be > 0, got ${n.toString()}`);
    const count = this.mempool.length;
    const height = this.blocks.length;
    this.currentSlot += Number(n);
    const time = new Date(
      Number(this.netPHelper.slotToTime(this.currentSlot))
    );
    if (this.mempool.length > 0) {
      this.pushBlock(this.mempool);
      this.mempool = [];
      console.log(`\u2588  #${this.id} @ht=${height}`);
      console.log(
        `\u2588${"\u2592".repeat(
          count
        )} ${count} txns -> slot ${this.currentSlot.toString()} = ${formatDate(
          time
        )}`
      );
    } else {
      console.log(
        `tick -> slot ${this.currentSlot.toString()} = ${formatDate(
          time
        )} (no txns)`
      );
    }
  }
  /**
   * @internal
   */
  pushBlock(txs) {
    this.blocks.push(txs);
    txs.forEach((tx) => {
      tx.newUtxos().forEach((utxo) => {
        const key = utxo.id.toString();
        this._allUtxos[key] = utxo;
        const addr = utxo.address.toString();
        if (addr in this._addressUtxos) {
          this._addressUtxos[addr].push(utxo);
        } else {
          this._addressUtxos[addr] = [utxo];
        }
      });
      tx.consumedUtxos().forEach((utxo) => {
        this._consumedUtxos.add(utxo.id.toString());
        const addr = utxo.address.toString();
        if (addr in this._addressUtxos) {
          this._addressUtxos[addr] = this._addressUtxos[addr].filter(
            (inner) => !inner.isEqual(utxo)
          );
        }
      });
    });
  }
}
function formatDate(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");
  const seconds = String(date.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}

async function addTestContext(context, TestHelperClass, stConfig, helperState) {
  console.log(" ======== ======== ======== +test context");
  Object.defineProperty(context, "strella", {
    get: function() {
      return this.h.strella;
    }
  });
  context.initHelper = async (stConfig2, helperState2) => {
    const helper = new TestHelperClass(stConfig2, helperState2);
    if (context.h) {
      if (!stConfig2.skipSetup)
        throw new Error(
          `re-initializing shouldn't be necessary without skipSetup`
        );
      console.log(
        "   ............. reinitializing test helper without setup"
      );
    }
    context.h = helper;
    return helper;
  };
  try {
    await context.initHelper(stConfig, helperState);
  } catch (e) {
    if (!stConfig) {
      console.error(
        `${TestHelperClass.name}: error during initialization; does this test helper require initialization with explicit params?`
      );
      throw e;
    } else {
      console.error("urgh");
      throw e;
    }
  }
}
const ADA = 1000000n;

class StellarTestHelper {
  state;
  config;
  defaultActor;
  strella;
  actors;
  optimize = false;
  netPHelper;
  networkCtx;
  _actorName;
  get actorName() {
    return this._actorName;
  }
  get network() {
    return this.networkCtx.network;
  }
  /**
   * Gets the current actor wallet
   *
   * @public
   **/
  get wallet() {
    const { wallet } = this.actorContext;
    if (!wallet) {
      throw new Error(`no current actor; use setActor(actorName) first`);
    }
    return wallet;
  }
  actorContext = {
    wallet: void 0
  };
  async setActor(actorName) {
    const thisActor = this.actors[actorName];
    if (!thisActor)
      throw new Error(
        `setCurrentActor: network #${this.network.id}: invalid actor name '${actorName}'
   ... try one of: 
  - ` + Object.keys(this.actors).join(",\n  - ")
      );
    if (this._actorName) {
      if (actorName == this._actorName) {
        if (this.actorContext.wallet !== thisActor) {
          throw new Error(
            `actor / wallet mismatch: ${this._actorName} ${dumpAny(
              this.actorContext.wallet?.address
            )} vs ${actorName} ${dumpAny(thisActor.address)}`
          );
        }
        return;
      }
      console.log(
        `
\u{1F3AD} -> \u{1F3AD} changing actor from \u{1F3AD} ${this._actorName} to  \u{1F3AD} ${actorName} ${dumpAny(thisActor.address)}`
      );
    } else {
      console.log(
        `
\u{1F3AD}\u{1F3AD} initial actor ${actorName} ${dumpAny(
          thisActor.address
        )}`
      );
    }
    this._actorName = actorName;
    this.actorContext.wallet = thisActor;
  }
  address;
  setupPending;
  async setupActors() {
    console.warn(
      `using 'hiro' as default actor because ${this.constructor.name} doesn't define setupActors()`
    );
    this.addActor("hiro", 1863n * ADA);
  }
  setDefaultActor() {
    return this.setActor("hiro");
  }
  helperState;
  constructor(config, helperState) {
    this.state = {};
    if (!helperState) {
      console.warn(
        // warning emoji: "⚠️"
        // info emoji: "ℹ️"
        `\u26A0\uFE0F \u26A0\uFE0F \u26A0\uFE0F Note: this test helper doesn't have a helperState, so it won't be able to use test-chain snapshots
\u2139\uFE0F \u2139\uFE0F \u2139\uFE0F ... to add helper state, follow this pattern:

    // in your test helper:

    @CapoTestHelper.hasNamedSnapshot("yourSnapshot", "tina")
    snapTo\u2039YourSnapshot\u203A() {
        // never called
    }
    async \u2039yourSnapshot\u203A() {
        this.setActor("tina");

        // ... your good sequence of transaction(s) here
        const tcx = this.capo.mkTxn\u2039...\u203A(...)
        return this.submitTxnWithBlock(tcx);
    }

    // in your test setup:

    type localTC = StellarTestContext<YourCapo>;
    let helperState: TestHelperState<YourCapo> = {
        snapshots: {},
    } as any;

    beforeEach<localTC>(async (context) => {
        await addTestContext(context,YourCapoTestHelper,
        undefined,
        helperState
    )}                

    // in your tests:
    
    describe("your thing", async () => {
        it("your test", async (context: localTC) => {
            await context.h.snapTo\u2039yourSnapshot\u203A()
        });
        it("your other test", async (context: localTC) => { 
            // this one will use the snapshot generated earlier
            await context.h.snapTo\u2039yourSnapshot\u203A()
        });
    })

... happy (and snappy) testing!`
      );
    }
    this.helperState = helperState;
    const { skipSetup, ...cfg } = config || {};
    if (Object.keys(cfg).length) {
      console.log(
        "XXXXXXXXXXXXXXXXXXXXXXXXXX test helper with config",
        config
      );
      this.config = config;
    }
    const [theNetwork, netParamsHelper] = this.mkNetwork(
      this.fixupParams(DEFAULT_NETWORK_PARAMS())
    );
    this.netPHelper = netParamsHelper;
    this.networkCtx = {
      network: theNetwork
    };
    this.randomSeed = config?.randomSeed || 42;
    this.actors = {};
    const now = /* @__PURE__ */ new Date();
    this.waitUntil(now);
    if (skipSetup) {
      throw new Error(`obsolete skipSetup: just don't call initialze()`);
    }
    console.log(" + StellarTestHelper");
  }
  fixupParams(preProdParams) {
    if (preProdParams.isFixedUp)
      return preProdParams;
    const origMaxTxSize = preProdParams.maxTxSize;
    preProdParams.origMaxTxSize = origMaxTxSize;
    const maxTxSize = Math.floor(origMaxTxSize * 4);
    console.log(
      "test env: \u{1F527}\u{1F527}\u{1F527} fixup max tx size",
      origMaxTxSize,
      " -> \u{1F527}",
      maxTxSize
    );
    preProdParams.maxTxSize = maxTxSize;
    const origMaxMem = preProdParams.maxTxExMem;
    preProdParams.origMaxTxExMem = origMaxMem;
    const maxMem = Math.floor(origMaxMem * 7);
    console.log("test env: \u{1F527}\u{1F527}\u{1F527} fixup max memory", origMaxMem, " -> \u{1F527}", maxMem);
    preProdParams.maxTxExMem = maxMem;
    const origMaxCpu = preProdParams.maxTxExCpu;
    preProdParams.origMaxTxExCpu = origMaxCpu;
    const maxCpu = Math.floor(origMaxCpu * 3);
    console.log("test env: \u{1F527}\u{1F527}\u{1F527} fixup max cpu", origMaxCpu, " -> \u{1F527}", maxCpu);
    preProdParams.maxTxExCpu = maxCpu;
    preProdParams.isFixedUp = true;
    return preProdParams;
  }
  async submitTxnWithBlock(tcx, options = {}) {
    const t = await tcx;
    await this.advanceNetworkTimeForTx(t, options.futureDate);
    return t.submit(options).then(() => {
      this.network.tick(1);
      return tcx;
    });
  }
  async advanceNetworkTimeForTx(tcx, futureDate) {
    const tx = await tcx.builtTx;
    const txBody = tx.body;
    function txnAttr(x) {
      return txBody[x];
    }
    function withPositiveSign(x) {
      return x < 0 ? `${x}` : `+${x}`;
    }
    const validFrom = txnAttr("firstValidSlot");
    const validTo = txnAttr("lastValidSlot");
    let targetTime = futureDate?.getTime() || Date.now();
    let targetSlot = this.netPHelper.timeToSlot(BigInt(targetTime));
    tcx.logger.logPrint(
      "\n  \u2697\uFE0F \u{1F41E}\u2139\uFE0F  advanceNetworkTimeForTx: " + (tcx.txnName || "")
    );
    if (futureDate) {
      debugger;
      tcx.logger.logPrint(
        `
    ---- \u2697\uFE0F \u{1F41E}\u{1F41E} explicit futureDate ${futureDate.toISOString()} -> slot ${targetSlot}`
      );
    }
    const { currentSlot } = this.network;
    const { netPHelper: nph } = this;
    const nowSlot = nph.timeToSlot(BigInt(Date.now()));
    const slotDiff = targetSlot - currentSlot;
    const validInPast = validTo && nowSlot > validTo;
    const validInFuture = validFrom && nowSlot < validFrom;
    tcx.logger.logPrint(
      `
    ---- \u2697\uFE0F \u{1F41E}\u{1F41E} advanceNetworkTimeForTx: tx valid ${validFrom || "anytime"} -> ${validTo || "anytime"}`
    );
    const currentToNowDiff = withPositiveSign(nowSlot - currentSlot);
    const currentToTargetDiff = withPositiveSign(slotDiff);
    let effectiveNetworkSlot = targetSlot;
    function showEffectiveNetworkSlotTIme() {
      tcx.logger.logPrint(
        `
    \u2697\uFE0F \u{1F41E}\u2139\uFE0F  with now=network slot ${effectiveNetworkSlot}: ${nph.slotToTime(
          effectiveNetworkSlot
        )}
           tx valid ${validFrom ? withPositiveSign(effectiveNetworkSlot - validFrom) : "anytime"} -> ${validTo ? withPositiveSign(effectiveNetworkSlot - validTo) : "anytime"} from now`
      );
    }
    tcx.logger.logPrint(
      `
    ---- \u2697\uFE0F \u{1F41E}\u{1F41E} current slot ${currentSlot} ${currentToNowDiff} = now slot ${nowSlot} 
                    current ${currentToTargetDiff} = targetSlot ${targetSlot}`
    );
    if (validInPast || validInFuture) {
      if (futureDate) {
        tcx.logger.logPrint(
          `
    ---- \u2697\uFE0F \u{1F41E}\u2139\uFE0F  txnTime ${validInPast ? "already in the past" : validInFuture ? "not yet valid" : "\u2039??incontheevable??\u203A"}; advancing to explicit futureDate @now + ${targetSlot - nowSlot}s`
        );
      } else {
        tcx.logger.logPrint(
          `
    -- \u2697\uFE0F \u{1F41E} txnTime ${validInPast ? "already in the past" : validInFuture ? "not yet valid" : "\u2039??incontheevable??\u203A"}; no futureDate specified; not interfering with network time`
        );
        effectiveNetworkSlot = nowSlot;
        showEffectiveNetworkSlotTIme();
        tcx.logger.flush();
        return;
      }
    }
    if (slotDiff < 0) {
      effectiveNetworkSlot = nowSlot;
      showEffectiveNetworkSlotTIme();
      if (futureDate) {
        tcx.logger.logPrint(
          `
    ------ \u2697\uFE0F \u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}can't go back in time ${slotDiff}s (current slot ${this.network.currentSlot}, target ${targetSlot})`
        );
        throw new Error(
          `explicit futureDate ${futureDate} is in the past; can't go back ${slotDiff}s`
        );
      }
      tcx.logger.logPrint(
        `
   -- \u2697\uFE0F \u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u2697\uFE0F  NOT ADVANCING: the network is already ahead of the current time by ${0 - slotDiff}s \u2697\uFE0F \u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u2697\uFE0F`
      );
      tcx.logger.flush();
      return;
    }
    if (this.network.currentSlot < targetSlot) {
      effectiveNetworkSlot = targetSlot;
      tcx.logger.logPrint(
        `
    \u2697\uFE0F \u{1F41E}\u2139\uFE0F  advanceNetworkTimeForTx ${withPositiveSign(
          slotDiff
        )} slots`
      );
      showEffectiveNetworkSlotTIme();
      this.network.tick(slotDiff);
    } else {
      effectiveNetworkSlot = currentSlot;
      showEffectiveNetworkSlotTIme();
    }
    tcx.logger.flush();
  }
  async initialize({
    randomSeed = 42
  } = {}) {
    console.log("STINIT");
    debugger;
    if (this.strella && this.randomSeed == randomSeed) {
      console.log(
        "       ----- skipped duplicate initialize() in test helper"
      );
      return this.strella;
    }
    if (this.strella) {
      console.warn(
        ".... warning: new test helper setup with new seed...."
      );
      this.rand = void 0;
      this.randomSeed = randomSeed;
      this.actors = {};
    } else {
      console.log(
        "???????????????????????? Test helper initializing without this.strella"
      );
    }
    console.log("STINIT2");
    await this.delay(1);
    this._actorName = "";
    if (!Object.keys(this.actors).length) {
      const actorSetup = this.setupActors();
      await actorSetup;
      this.setDefaultActor();
    }
    console.log("STINIT3");
    return this.initStellarClass();
  }
  async initStellarClass(config = this.config) {
    const TargetClass = this.stellarClass;
    const strella = await this.initStrella(TargetClass, config);
    this.strella = strella;
    this.address = strella.address;
    return strella;
  }
  //!!! reconnect tests to tcx-based config-capture
  // onInstanceCreated: async (config: ConfigFor<SC>) => {
  //     this.config = config
  //     return {
  //         evidence: this,
  //         id: "empheral",
  //         scope: "unit test"
  //     }
  // }
  async initStrella(TargetClass, config) {
    const setup = {
      network: this.network,
      actorContext: this.actorContext,
      networkParams: this.networkParams,
      uh: void 0,
      isTest: true,
      optimize: this.optimize
    };
    setup.uh = new UtxoHelper(setup);
    let cfg = {
      setup,
      config
    };
    if (!config)
      cfg = {
        setup,
        partialConfig: {}
      };
    if (setup.actorContext.wallet) {
      console.log(
        "+strella init with actor addr",
        setup.actorContext.wallet.address.toBech32()
      );
    } else {
      debugger;
      console.log("+strella init without actor");
    }
    return TargetClass.createWith(cfg);
  }
  //! it has a seed for mkRandomBytes, which must be set by caller
  randomSeed;
  //! it makes a rand() function based on the randomSeed after first call to mkRandomBytes
  rand;
  delay(ms) {
    return new Promise((res) => setTimeout(res, ms));
  }
  /**
   * Creates a new SimpleWallet and populates it with a given lovelace quantity and assets.
   * Special genesis transactions are added to the emulated chain in order to create these assets.
   */
  createWallet(lovelace = 0n, assets = makeAssets([])) {
    const wallet = SimpleWallet_stellar.fromRootPrivateKey(
      makeRootPrivateKey(generateBytes(this.network.mulberry32, 32)),
      this.networkCtx
    );
    this.network.createUtxo(wallet, lovelace, assets);
    return wallet;
  }
  async mkSeedUtxo(seedIndex = 0n) {
    const { wallet } = this;
    const { network } = this;
    const txb = makeTxBuilder({
      isMainnet: network.isMainnet()
    });
    const actorMoney = await wallet.utxos;
    console.log(
      `${this._actorName} has money: 
` + utxosAsString(actorMoney)
    );
    txb.spendWithoutRedeemer(
      await findInputsInWallets(
        makeValue(30n * ADA),
        { wallets: [wallet] },
        network
      )
    );
    txb.payUnsafe(wallet.address, makeValue(10n * ADA));
    txb.payUnsafe(wallet.address, makeValue(10n * ADA));
    let si = 2;
    for (; si < seedIndex; si++) {
      txb.payUnsafe(wallet.address, makeValue(10n * ADA));
    }
    const txId = await this.submitTx(
      await txb.build({
        changeAddress: wallet.address,
        networkParams: this.networkParams
      }),
      "force"
    );
    return txId;
  }
  async submitTx(tx, force) {
    this.wallet?.address;
    const isAlreadyInitialized = !!this.strella;
    if (isAlreadyInitialized && !force) {
      throw new Error(
        `helper is already initialized; use the submitTx from the testing-context's 'strella' object instead`
      );
    }
    console.log(
      `Test helper ${force || ""} submitting tx${force && "" || " prior to instantiateWithParams()"}:
` + txAsString(tx, this.networkParams)
      // new Error(`at stack`).stack
    );
    try {
      const txId = await this.network.submitTx(tx);
      console.log(
        "test helper submitted direct txn:" + txAsString(tx, this.networkParams)
      );
      this.network.tick(1);
      return txId;
    } catch (e) {
      console.error(
        `submit failed: ${e.message}
  ... in tx ${txAsString(tx)}`
      );
      throw e;
    }
  }
  mkRandomBytes(length) {
    if (!this.randomSeed)
      throw new Error(
        `test must set context.randomSeed for deterministic randomness in tests`
      );
    if (!this.rand)
      this.rand = mulberry32(this.randomSeed);
    const bytes = [];
    for (let i = 0; i < length; i++) {
      bytes.push(Math.floor(this.rand() * 256));
    }
    return bytes;
  }
  /**
   * creates a new Actor in the transaction context with initial funds, returning a Wallet object
   * @remarks
   *
   * Given an actor name ("marcie") or role name ("marketer"), and a number
   * of indicated lovelace, creates and returns a wallet having the indicated starting balance.
   *
   * By default, three additional, separate 5-ADA utxos are created, to ensure sufficient Collateral and
   * small-change are existing, making typical transaction scenarios work easily.  If you want to include
   * other utxo's instead you can supply their lovelace sizes.
   *
   * To suppress creation of additional utxos, use `0n` for arg3.
   *
   * You may wish to import {@link ADA} = 1_000_000n from the testing/ module, and
   * multiply smaller integers by that constant.
   *
   * @param roleName - an actor name or role-name for this wallet
   * @param walletBalance - initial wallet balance
   * @param moreUtxos - additional utxos to include
   *
   * @example
   *     this.addActor("cheapo", 14n * ADA, 0n);  //  14 ADA and no additional utxos
   *     this.addActor("flexible", 14n * ADA);  //  14 ADA + default 15 ADA in 3 additional utxos
   *     this.addActor("moneyBags", 42_000_000n * ADA, 5n, 4n);  //  many ADA and two collaterals
   *
   *     //  3O ADA in 6 separate utxos:
   *     this.addActor("smallChange", 5n * ADA, 5n * ADA, 5n * ADA, 5n * ADA, 5n * ADA, 5n * ADA);
   *
   * @public
   **/
  addActor(roleName, walletBalance, ...moreUtxos) {
    if (this.actors[roleName])
      throw new Error(`duplicate role name '${roleName}'`);
    //! it instantiates a wallet with the indicated balance pre-set
    const a = this.createWallet(walletBalance);
    const addr = a.address.toString();
    console.log(
      `+\u{1F3AD} Actor: ${roleName}: ${addr.slice(0, 12)}\u2026${addr.slice(
        -4
      )} ${lovelaceToAda(walletBalance)} (\u{1F511}#${a.address.spendingCredential?.toHex().substring(0, 8)}\u2026)`
    );
    //! it makes collateral for each actor, above and beyond the initial balance,
    this.network.tick(2);
    const five = 5n * ADA;
    if (0 == moreUtxos.length)
      moreUtxos = [five, five, five];
    for (const moreLovelace of moreUtxos) {
      if (moreLovelace > 0n) {
        this.network.createUtxo(a, moreLovelace);
      }
    }
    this.network.tick(1);
    this.actors[roleName] = a;
    return a;
  }
  //todo use this for enabling prettier diagnostics with clear labels for
  //  -- actor addresses -> names
  //  -- script addresses -> names
  addrRegistry = {};
  get networkParams() {
    return this.netPHelper.params;
  }
  mkNetwork(params) {
    const theNetwork = new StellarNetworkEmulator(void 0, { params });
    const emuParams = theNetwork.initHelper();
    return [theNetwork, emuParams];
  }
  slotToTime(s) {
    return this.netPHelper.slotToTime(s);
  }
  currentSlot() {
    return this.network.currentSlot;
  }
  waitUntil(time) {
    const targetTimeMillis = BigInt(time.getTime());
    const targetSlot = this.netPHelper.timeToSlot(targetTimeMillis);
    const c = this.currentSlot();
    const slotsToWait = targetSlot - (c || 0);
    if (slotsToWait < 1) {
      throw new Error(`the indicated time is not in the future`);
    }
    this.network.tick(slotsToWait);
    return slotsToWait;
  }
}

const ACTORS_ALREADY_MOVED = "NONE! all actors were moved from a different network via snapshot";
const SNAP_BOOTSTRAP = "bootstrapped";
class CapoTestHelper extends StellarTestHelper {
  get capo() {
    return this.strella;
  }
  async initialize({
    randomSeed = 42
  } = {}, args) {
    if (this.strella && this.randomSeed == randomSeed) {
      console.log(
        "       ----- skipped duplicate initialize() in test helper"
      );
      return this.strella;
    }
    if (this.strella) {
      console.log(
        `    -- \u{1F331}\u{1F331}\u{1F331} new test helper setup with new seed (was ${this.randomSeed}, now ${randomSeed})...
` + new Error("stack").stack.split("\n").slice(1).filter(
          (line) => !line.match(/node_modules/) && !line.match(/node:internal/)
        ).join("\n")
      );
      this.strella = void 0;
      this.actors = {};
      this._actorName = "";
    }
    await this.delay(1);
    this.randomSeed = randomSeed;
    if (Object.keys(this.actors).length) {
      console.log("Skipping actor setup - already done");
    } else {
      console.log("  -- \u{1F3AD}\u{1F3AD}\u{1F3AD} actor setup...");
      const actorSetup = this.setupActors();
      await actorSetup;
      await this.setDefaultActor();
    }
    this.state.mintedCharterToken = void 0;
    this.state.parsedConfig = void 0;
    //! when there's not a preset config, it leaves the detailed setup to be done just-in-time
    if (!this.config) {
      console.log("  -- Capo not yet bootstrapped");
      const ts1 = Date.now();
      this.strella = await this.initStrella(this.stellarClass);
      const ts2 = Date.now();
      console.log(
        // stopwatch emoji: ⏱️
        `  -- \u23F1\uFE0F initialized Capo: ${ts2 - ts1}ms`
      );
      console.log("checking delegate scripts...");
      return this.checkDelegateScripts(args).then(() => {
        const ts3 = Date.now();
        console.log(
          `  -- \u23F1\uFE0F checked delegate scripts: ${ts3 - ts2}ms`
        );
        return this.strella;
      });
    }
    console.log("  -- Capo already bootstrapped");
    const strella = await this.initStrella(this.stellarClass, this.config);
    this.strella = strella;
    const { address, mintingPolicyHash: mph } = strella;
    const { name } = strella.program;
    console.log(
      name,
      address.toString().substring(0, 18) + "\u2026",
      "vHash \u{1F4DC} " + strella.validatorHash.toHex().substring(0, 12) + "\u2026",
      "mph \u{1F3E6} " + mph?.toHex().substring(0, 12) + "\u2026"
    );
    console.log("<- CAPO initialized()");
    return strella;
  }
  async checkDelegateScripts(args = {}) {
    throw new Error(`doesn't fail, because it's implemented by DefaultCapoTestHelper`);
  }
  get ready() {
    return !!(this.strella.configIn && !this.strella.didDryRun.configIn || this.state.parsedConfig);
  }
  /**
   * Creates a new transaction-context with the helper's current or default actor
   * @public
   **/
  mkTcx(txnName) {
    const tcx = new StellarTxnContext(this.strella.setup);
    if (txnName)
      return tcx.withName(txnName);
    return tcx;
  }
  loadSnapshot(snapName) {
    const snap = this.helperState.snapshots[snapName];
    if (!snap)
      throw new Error(`no snapshot named ${snapName}`);
    this.network.loadSnapshot(snap);
  }
  async reusableBootstrap(snap = SNAP_BOOTSTRAP) {
    let capo;
    const helperState = this.helperState;
    if (helperState.bootstrapped) {
      console.log("  ---  \u2697\uFE0F\u{1F41E}\u{1F41E} already bootstrapped");
      if (!helperState.previousHelper) {
        debugger;
        throw new Error(
          `already bootstrapped, but no previousHelper : ( `
        );
      }
      capo = await this.restoreFrom(snap);
    } else {
      capo = await this.bootstrap();
      helperState.bootstrappedStrella = capo;
    }
    const { previousHelper } = helperState;
    if (!previousHelper) {
      this.snapshot(SNAP_BOOTSTRAP);
    } else {
      console.log(
        `changing helper from network ${previousHelper.network.id} to ${this.network.id}`
      );
    }
    helperState.bootstrapped = true;
    helperState.previousHelper = this;
    return capo;
  }
  // a decorator for test-helper functions that generate named snapshots
  static hasNamedSnapshot(snapshotName, actorName) {
    return function(target, propertyKey, descriptor) {
      descriptor.value;
      descriptor.value = SnapWrap;
      const [_, WithCapMethodName] = propertyKey.match(/^snapTo(.*)/) || [];
      if (!WithCapMethodName) {
        throw new Error(
          `hasNamedSnapshot(): ${propertyKey}(): expected method name to start with 'snapTo'`
        );
      }
      const methodName = WithCapMethodName[0].toLowerCase() + WithCapMethodName.slice(1);
      const generateSnapshotFunc = target[methodName];
      if (!generateSnapshotFunc) {
        throw new Error(
          `hasNamedSnapshot(): ${propertyKey}: expected method ${methodName} to exist`
        );
      }
      console.log(
        "hasNamedSnapshot(): ",
        propertyKey,
        " -> ",
        methodName
      );
      async function SnapWrap(...args) {
        await this.reusableBootstrap();
        return this.findOrCreateSnapshot(
          snapshotName,
          actorName,
          () => {
            return generateSnapshotFunc.apply(this, ...args).then((result) => {
              if (this.actorName !== actorName) {
                throw new Error(
                  `actorName mismatch during snapshot generation; was '${this.actorName}', expected '${actorName}'`
                );
              }
              this.network.tick(1);
              return result;
            });
          }
        );
      }
      return descriptor;
    };
  }
  hasSnapshot(snapshotName) {
    return !!this.helperState?.snapshots[snapshotName];
  }
  snapshot(snapshotName) {
    if (!this.helperState) {
      throw new Error(`can't snapshot without a helperState`);
    }
    if (this.hasSnapshot(snapshotName)) {
      throw new Error(`snapshot ${snapshotName} already exists`);
    }
    this.helperState.snapshots[snapshotName] = this.network.snapshot(snapshotName);
  }
  async findOrCreateSnapshot(snapshotName, actorName, contentBuilder) {
    if (this.helperState.snapshots[snapshotName]) {
      const capo = await this.restoreFrom(snapshotName);
      await this.setActor(actorName);
      return capo;
    }
    let result;
    try {
      result = await contentBuilder();
      return this.strella;
      return result;
    } catch (e) {
      throw e;
    } finally {
      if (result) {
        this.snapshot(snapshotName);
      }
    }
  }
  async restoreFrom(snapshotName) {
    const {
      helperState,
      helperState: {
        snapshots,
        previousHelper,
        bootstrappedStrella
      } = {}
    } = this;
    if (!helperState)
      throw new Error(
        `can't restore from a previous helper without a helperState`
      );
    if (!bootstrappedStrella)
      throw new Error(
        `can't restore from a previous helper without a bootstrappedStrella`
      );
    if (!snapshots || !snapshots[snapshotName]) {
      throw new Error(`no snapshot named ${snapshotName} in helperState`);
    }
    if (!previousHelper) {
      throw new Error(`no previousHelper in helperState`);
    }
    const { parsedConfig } = previousHelper.state;
    const { networkCtx: oldNetworkEnvelope } = previousHelper;
    const { network: previousNetwork } = oldNetworkEnvelope;
    const { network: newNet } = this.networkCtx;
    const otherNet = previousHelper.actors[ACTORS_ALREADY_MOVED];
    if (otherNet) {
      if (otherNet !== newNet.id) {
        throw new Error(
          `actors already moved to network #${otherNet}; can't move to #${newNet.id} now.`
        );
      }
      console.log("  -- actors are already here");
    } else {
      if (this === previousHelper) {
        console.log(
          "  -- helper already transferred; loading incremental snapshot"
        );
      } else {
        Object.assign(this.actors, previousHelper.actors);
        previousHelper.networkCtx = { network: previousNetwork };
        this.networkCtx = oldNetworkEnvelope;
        this.networkCtx.network = newNet;
        this.state.mintedCharterToken = previousHelper.state.mintedCharterToken;
        this.state.parsedConfig = parsedConfig;
        previousHelper.actors = { [ACTORS_ALREADY_MOVED]: newNet.id };
        console.log(
          `   -- moving ${Object.keys(this.actors).length} actors from network ${previousNetwork.id} to ${newNet.id}`
        );
      }
      newNet.loadSnapshot(snapshots[snapshotName]);
    }
    if (!this.actorName) {
      await this.setDefaultActor();
    }
    if (!this.strella) {
      await this.initStellarClass(parsedConfig);
    }
    return this.strella;
  }
  async bootstrap(args, submitOptions = {}) {
    let strella = this.strella || await this.initialize(void 0, args);
    if (this.bootstrap != CapoTestHelper.prototype.bootstrap) {
      throw new Error(
        `Don't override the test-helper bootstrap().  Instead, provide an implementation of extraBootstrapping()`
      );
    }
    if (this.ready) {
      console.log(
        "       --- \u2697\uFE0F \u{1F41E} \u2697\uFE0F \u{1F41E} \u2697\uFE0F \u{1F41E} \u2697\uFE0F \u{1F41E} \u2705 Capo bootstrap already OK"
      );
      return strella;
    }
    await this.mintCharterToken(args, submitOptions);
    console.log(
      "       --- \u2697\uFE0F \u{1F41E} \u2697\uFE0F \u{1F41E} \u2697\uFE0F \u{1F41E} \u2697\uFE0F \u{1F41E} \u2705 Capo bootstrap with charter"
    );
    await this.bootstrapSettings();
    await this.extraBootstrapping(args);
    return strella;
  }
  async extraBootstrapping(args) {
    return this.strella;
  }
}

class DelegatedDataContract extends ContractBasedDelegate {
  usesWrappedData;
  dgDatumHelper = this.dataBridgeClass?.prototype.DelegateDatum;
  /**
   * when set to true, the controller class will include the Capo's
   * gov authority in the transaction, to ease transaction setup.
   * @remarks
   * This is a convenience for the controller, and should be used along with
   * the appropriate on-chain policy to require the gov token's presence.
   */
  needsGovAuthority = false;
  /**
   * Provides a customized label for the delegate, used in place of
   * a generic script name ("BasicDelegate").  DelegatedDataContract
   * provides a default name with the record type name and "Pol" suffix.
   *
   * Affects the on-chain logging for the policy and the compiled script
   * output in the script-cache on-disk or in browser's storage.
   */
  get delegateName() {
    return `${this.recordTypeName}Pol`;
  }
  // async findRecord(id: string | UutName) {
  //     return this.capo
  //         .findDelegatedDataUtxos({
  //             type: this.recordTypeName,
  //             id,
  //         })
  //         .then(this.capo.singleItem);
  // }
  get abstractBundleClass() {
    return void 0;
  }
  scriptBundle() {
    if (this.abstractBundleClass) {
      throw new Error(
        `${this.constructor.name}: this pluggable delegate requires a bit of setup that doesn't seem to be done yet.
First, ensure you have derived a subclass for the controller, with a scriptBundle() method.

That method should \`return new YourConcreteBundle()\`

  ... where YourConcreteBundle is a subclass of CapoDelegateBundle that you've created.

A concrete bundle class should be defined in \`${this.delegateName}.concrete.hlb.ts\`
  ... in the same directory as your derived controller class:

    import {YourAppCapo} from "./YourAppCapo.js";
    import {${this.abstractBundleClass.name}} from ...
    export default class YourConcreteBundle extends ${this.abstractBundleClass.name}} {
        // ... 
    }
`
      );
    }
    throw new Error(
      `${this.constructor.name}: missing required implementation of abstractBundleClass()

Defined in a \`*.hlb.ts\` file, it should have at minimum:
    import {YourAppCapo} from "./YourAppCapo.js";

    import SomeSpecializedDelegate from "./YourSpecializedDelegate.hl";

    export default class SomeDelegateBundle extends CapoHeliosBundle {
        get specializedDelegateModule() { return SomeSpecializedDelegate; }
    }

We'll generate types in a .typeInfo.ts file, based on the types in your Helios sources,
  ... and a .bridge.ts file having data-conversion classes for your on-chain types.
When your delegated-data controller is used within your Capo, your bundle will
have access via import {...} to any helios modules provided by that Capo's .hlb.ts. `
    );
  }
  /**
   * Finds records of this delegate's type, optionally by ID.
   * @remarks
   * Returns a record list when no ID is provided, or a single record when an ID is provided.
   */
  async findRecords(options = {}) {
    const result = await this.capo.findDelegatedDataUtxos({
      type: this.recordTypeName
      // single, // todo: support single in the options
      // predicate
    });
    if (options.id == void 0) {
      return result;
    }
    return this.capo.singleItem(result);
  }
  mkDgDatum(record) {
    return this.mkDatum.capoStoredData({
      data: record,
      version: 2n,
      otherDetails: makeIntData(0)
    });
  }
  /**
   * Intuition hook redirecting to activity.MintingActivities.$seeded$...
   * @remarks
   * @deprecated use activites.MintingActivites.$seeded$* accessors/methods instead.
   */
  usesSeedActivity(a, seedPlaceholder, ...args) {
    throw new Error(
      `make an implied-seed activity with this.activity.MintingActivites.$seeded$*`
    );
  }
  /**
   * builds a txn creating a record of this type in the data store
   * @remarks
   * The \{activity\} option can be a {@link SeedActivity} object provided by
   * `this.activity.MintingActivities.$seeded$‹activityName›` accessors/methods,
   * which creates a record id based on the (unique) spend of a seed value.
   */
  async mkTxnCreateRecord(options, tcx) {
    tcx = tcx || this.mkTcx(`create ${this.recordTypeName}`);
    const tcx1a = await this.tcxWithCharterRef(tcx);
    const tcx1b = await this.tcxWithSeedUtxo(tcx1a);
    const tcx1c = tcx1b;
    const { capo } = this;
    const mintDelegate = await capo.getMintDelegate();
    const dataType = this.recordTypeName;
    const tcx2 = await capo.txnMintingUuts(tcx1c, [this.idPrefix], {
      mintDelegateActivity: mintDelegate.activity.CreatingDelegatedData(
        tcx1c,
        { dataType }
      )
    });
    const activity = options.activity instanceof SeedActivity ? options.activity.mkRedeemer(tcx2) : options.activity;
    return this.txnCreatingRecord(tcx2, {
      ...options,
      activity
    }).then((tcx3) => tcx3);
  }
  creationDefaultDetails() {
    return {};
  }
  async txnCreatingRecord(tcx, options) {
    const newType = this.recordTypeName;
    const idPrefix = this.idPrefix;
    const {
      addedUtxoValue: extraCreationValue = makeValue(0n),
      data: typedData,
      activity
    } = options;
    const tcx2 = await this.txnGrantAuthority(tcx, activity);
    const uut = tcx.state.uuts[idPrefix];
    let newRecord = typedData;
    const defaults = this.creationDefaultDetails() || {};
    const fullRecord = {
      id: encodeUtf8(uut.toString()),
      type: newType,
      ...defaults,
      ...newRecord
    };
    const newDatum = this.mkDatum.capoStoredData({
      // data: new Map(Object.entries(beforeSave(fullRecord) as any)),
      data: fullRecord,
      version: 2n,
      otherDetails: makeIntData(0)
    });
    console.log(
      `\u{1F3D2} creating ${newType} -> ` + uplcDataSerializer(newType, fullRecord, 1)
    );
    let tcx3 = tcx2;
    if (this.needsGovAuthority) {
      tcx3 = await this.capo.txnAddGovAuthority(tcx2);
    }
    return tcx3.addOutput(
      makeTxOutput(
        this.capo.address,
        this.uh.mkMinTv(this.capo.mph, uut).add(extraCreationValue),
        newDatum
      )
    );
  }
  /**
   * Creates an indirect reference to an an update activity with arguments,
   * using a record-id placeholder.
   *
   * @remarks
   * Provide an update activity function, a placeholder for the record-id, any other args
   * for the on-chain activity/redeemer.  The update-activity function can be any of this
   * contract's `activity.SpendingActivities.*` functions.
   *
   * This approach is similar to the creation-time {@link DelegatedDataContract.usesSeedActivity|usesSeedActivity()} method,
   * with a "...recId" placeholder instead of a "...seed" placeholder.
   *
   * The arguments are passed to the update activity function, which is expected to return
   * an {@link isActivity} object serializing the `{redeemer}` data as a UplcData object.
   * Normally that's done with {@link ContractBasedDelegate.mkSpendingActivity | mkSpendingActivity()}.
   */
  usesUpdateActivity(a, _idPlaceholder, ...args) {
    return new UpdateActivity(this, a, args);
  }
  /**
   * Creates a transaction for updating a record in the delegated data store
   *
   * @remarks
   * Provide a transaction name, an existing item, and a controller activity to trigger.
   * The activity MUST either be an activity triggering one of the controller's SpendingActivity variants,
   * or the result of calling {@link DelegatedDataContract.usesUpdateActivity | usesUpdateActivity()}.
   *   **or TODO support a multi-activity**
   *
   * The updatedRecord only needs to contain the fields that are being updated.
   */
  async mkTxnUpdateRecord(txnName, item, options, tcx) {
    tcx = tcx || this.mkTcx(txnName);
    const { capo } = this;
    await capo.getMintDelegate();
    const tcx1 = await this.tcxWithCharterRef(tcx);
    const {
      activity,
      addedUtxoValue,
      // beforeSave = (x) => x,
      updatedFields
    } = options;
    const tcx2 = await capo.txnAttachScriptOrRefScript(
      tcx1,
      capo.compiledScript
    );
    const tcx2a = tcx2.addInput(
      item.utxo,
      capo.activitySpendingDelegatedDatum()
    );
    const existingTypedData = item.data;
    let recId = existingTypedData.id;
    if (!Array.isArray(recId)) {
      recId = encodeUtf8(recId);
    }
    const spendDelegate = await capo.getSpendDelegate(
      tcx2a.state.charterData
    );
    const dataType = this.recordTypeName;
    const tcx2b = await spendDelegate.txnGrantAuthority(
      tcx2a,
      spendDelegate.activity.UpdatingDelegatedData({
        dataType,
        recId
      })
    );
    const materializedActivity = activity instanceof UpdateActivity ? activity.mkRedeemer(recId) : activity;
    let recordWithUpdates = {
      ...existingTypedData,
      ...updatedFields
    };
    if (this.needsGovAuthority) {
      await this.capo.txnAddGovAuthority(tcx2b);
    }
    return this.txnUpdatingRecord(tcx2b, recId, item, {
      activity: materializedActivity,
      addedUtxoValue,
      updatedFields: recordWithUpdates
    });
  }
  async txnUpdatingRecord(tcx, id, item, options) {
    const recType = this.recordTypeName;
    const {
      addedUtxoValue = makeValue(0),
      // beforeSave = (x) => x,
      activity,
      updatedFields: updatedRecord
    } = options;
    const fullUpdatedRecord = {
      ...item.data,
      ...updatedRecord
    };
    console.log(
      `\u{1F3D2} updating ${recType} ->`,
      uplcDataSerializer(
        recType,
        JSON.parse(JSON.stringify(updatedRecord, betterJsonSerializer, 2)),
        1
      )
    );
    await this.txnGrantAuthority(tcx, activity);
    console.log(
      "    -- prev value in dgData utxo:",
      dumpAny(item.utxo.value)
    );
    console.log(
      "    -- addedUtxoValue in dgData utxo:",
      dumpAny(addedUtxoValue)
    );
    return this.returnUpdatedRecord(
      tcx,
      item.utxo.value.add(addedUtxoValue),
      // .add(this.mkMinTv(this.capo.mph, id))
      fullUpdatedRecord
    );
  }
  getReturnAddress() {
    return this.capo.address;
  }
  returnUpdatedRecord(tcx, returnedValue, updatedRecord) {
    return tcx.addOutput(
      makeTxOutput(
        this.getReturnAddress(),
        returnedValue,
        this.mkDatum.capoStoredData({
          data: updatedRecord,
          version: 2n,
          otherDetails: makeIntData(0)
        })
        // this.mkDatumDelegatedDataRecord(beforeSave(record))
      )
    );
  }
}
class UpdateActivity {
  constructor(host, factoryFunc, args) {
    this.host = host;
    this.factoryFunc = factoryFunc;
    this.args = args;
  }
  args;
  mkRedeemer(recId) {
    return this.factoryFunc.call(this.host, recId, ...this.args);
  }
}

const heliosModule$1 = {
  content: "module ReqtsPolicy\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash,\n    get_cont_outputs\n} from ScriptContext\n\n// this module provides the basic interface needed for a Capo delegate.\n//  ... see ./ReqtsDelegate.hl to see how the delegate interface is provided \n//  ... for that usage case (with a generic module name).\n\n// it is also packaged (with a unique module name above) to enable access \n// ...from other helios scopes.\n\n// THIS MODULE has been specialized to ...\n//  - do requirements-management kinds of things\n// ... more details here\n\n// original notes about (un)specialization follow:\n//  //! provides a basic version, ~~not yet specialized,~~\n//  // of the \"specializedDelegate\" interface, which simply\n//  // exports a DelegateDatum enum and DelegateActivities (redeemer enum).  \n\n//  //! Your specialization MUST include the enum variants found in this\n//  //  ... unspecialized version.  It MAY include additional Datum variants.\n//  // Any additional Redeemer/Activity variants should be added underneath \n//  // the SpendingActivity / MintingActivity top-level enum variants, instead \n//  // of adding new top-level enum variants to DelegateActivity.\n\n//  // The DelegateActivity (redeemer) enum conforms to the \n//  // Delegate Redeemer protocol, in which enum 0 is reserved for\n//  // lifecycle activities, enum 1 is used for spend-related activities \n//  // (if the delegate is used as a spend delegate), and enum 2 is called\n//  // for authorizing minting.  Enum 3 and beyond are reserved for\n//  // extensions to the Delegate Redeemer protocol.\n\n//  // Within the minting and spending activities, the specialization can \n//  // indicate a nested activity enum to support various dApp-specific\n//  // activities.  \n\n//  // Activities that validate minting of UUTs should contain enum fields \n//  // to identify the seed-transaction details needed for properly validating \n//  // UUT mints fitting the use-case.\n\n//  //! Your specialization MAY include any additional functions, imports or \n//  //  methods defined on any of the types in this file.\n\n\nimport {\n    DelegationDetail,\n    mustReturnValueToScript,\n    DelegateLifecycleActivity,\n    CapoLifecycleActivity,\n    unmodifiedDelegation\n} from CapoDelegateHelpers\n\nimport {\n    validateUutMinting,\n    tnCip68ref100,\n    tnCip68nft222,\n    mkUutTnFactory\n} from CapoMintHelpers\n\n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nimport {\n    CapoCtx,\n    mkCapoCtx,\n    mkTv,\n    AnyData \n} from CapoHelpers\n\n// import {\n//     TierLookupResult\n// } from TieredScale\n\nimport {\n    TODO,\n    REQT\n} from StellarHeliosHelpers\n\nimport { \n    ReqtData, \n    DelegateDatum, \n    MintingActivity, \n    SpendingActivity, \n    BurningActivity \n} from ReqtsData\n\n\nfunc ensureConstrainedTxValidity() -> () {\n    assert(\n        tx.time_range.end - tx.time_range.start \n            <= Duration::HOUR,\n        \"txn duration err\"\n    )\n}\n\nfunc daysInFuture(nowPlusDays: Int) -> TimeRange {\n    ensureConstrainedTxValidity();\n    expiryDuration : Duration = Duration::DAY * nowPlusDays;\n    leeway : Duration = 1 * Duration::HOUR;\n    latestAcceptable : Time = tx.time_range.end + expiryDuration + leeway;\n    \n    TimeRange::new(\n        tx.time_range.start + expiryDuration,\n        latestAcceptable\n    )\n}\n\nenum DelegateActivity {\n    // must ALWAYS be at Enum position 0\n    CapoLifecycleActivities {\n        activity: CapoLifecycleActivity\n    }\n\n    // must ALWAYS be at Enum position 1\n    DelegateLifecycleActivities {\n        // administrative activities for the delegate lifecycle, enforced\n        //  by the basic mint delegate code.  Specializations can add more \n        //  restrictions, but in many/most cases they will not need to.\n        activity: DelegateLifecycleActivity\n    }\n\n    // application-specific spending activities, ALWAYS at Enum position 2\n    SpendingActivities {\n        activity: SpendingActivity\n    }\n\n    // application-specific minting activities, ALWAYS at Enum position 3\n    // remember:M and 3 have a similar shape.\n    MintingActivities {\n        activity: MintingActivity\n    }\n\n    BurningActivities {\n        // application-specific burning activities, ALWAYS at Enum position 4\n        activity: BurningActivity\n    }\n\n    CreatingDelegatedData {\n        seed: TxOutputId\n        dataType: String\n        // id from seed\n    }\n\n    UpdatingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n\n    DeletingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n\n    MultipleDelegateActivities {\n        activities: []Data // actually a []DelegateActivity\n        // todo: change this back when the recursive enum's `__is_valid_data not found` error is resolved\n    }\n\n    // this function gives a general-purpose implementation of checking for \n    // valid uut minting. \n    //\n    // A specialization might modify it to use different policies\n    // or enforce additional requirements\n    // \n    // func genericUutMinting(self, \n    //     mdd: DelegateDatum,\n    // ) -> Bool {\n    //     //!!! replace with an activity using the same seed-txn pattern:\n    //     // MintingActivities::SomethingMintingUuts{sTxId, sIdx, purposes} = self;\n    //     DelegateDatum::IsDelegation{dd} = mdd;\n    //     returnsAuthzToken : Bool = mustReturnValueToScript(dd.tvAuthorityToken());\n\n    //     o : []TxOutput = get_cont_outputs();\n    //     if (o.length != 1) { error(\"single utxo only\") };\n\n    //     print (\"in unsp_MD\");\n    //     isOk : Bool = returnsAuthzToken && \n\n    //     unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize()) &&\n\n    //     // This call can serve as a template for enforcing expected mints \n    //     // of uuts (and additional token values) in validation of application-\n    //     // specific activities, given (mph, sTxId, sIdx, purposes)\n    //     validateUutMinting(\n    //         mph: dd.mph,\n    //         seed: seed,\n    //         purposes: purposes,\n    //         //otherMintedValue: ()\n    //         mkTokenName: mkUutTnFactory(seed)\n    //     );\n\n    //     isOk\n    // }\n\n    //! used only for validating IsDelegation datum, that is,\n    //   ... to approve minting requests or any customize spending modes \n    //   ... of that datum.  \n    \n    //  Note that the basic delegate already enforces some basic\n    //    administrative expectations for DelegateLifecycleActivities and CapoLifecycleActivities\n    //    so a specialization doesn't need to re-implement those checks.\n    func additionalDelegateValidation( self,\n        priorMddd: DelegateDatum::IsDelegation\n    ) -> Bool {\n        print(\"  -- addl dgt validity check\");\n        self.switch {\n            // generic DelegateLifecycleActivities is already validated, but \n            //  ... you can add more constraints here if needed\n            DelegateLifecycleActivities => true,\n            // non-mintDelegate can't trigger these activities\n            CapoLifecycleActivities => error(\"unreachable\"),\n            MintingActivities{VMA} => VMA.switch {\n                CreatingRecord{seed} => {\n                    print(\"creating reqt record...\\n\");\n\n                    mkTn : (String) -> String = mkUutTnFactory(seed);\n\n                    cctx : CapoCtx = mkCapoCtx(priorMddd.dd.mph).withCharterRef();\n                    // settings : ProtocolSettings = cctx.getManifestDatum[ProtocolSettings](\"settings\");\n\n                    tokenName = mkTn(\"reqt\");\n                    depositedValue: Value = mkTv(priorMddd.dd.mph, tokenName);\n\n                    newReqt : TxOutput = cctx.delegatedTxOutput(tokenName.encode_utf8());\n\n                    // print(\"required listing fee: \" + fee.show());\n                    assert(\n                        newReqt.value.contains(depositedValue),\n                        \"missing reqt token\"\n                    );\n\n                    reqtData: ReqtData = ReqtData::from_data(\n                        newReqt.datum.inline\n                    );\n\n                    assert(\n                        tx.time_range.end - tx.time_range.start \n                            <= Duration::HOUR,\n                        \"txn duration err\"\n                    );\n                    // has the right expiration date from settings\n                    // !!! todo get from settings                    \n                    acceptableExpiry : TimeRange = daysInFuture(73);\n\n                    discountEnds : Time = reqtData.mustFreshenBy;\n\n                    assert(\n                        acceptableExpiry.contains(discountEnds),\n                        \"wrong discount expiry date too late seconds: \" + (( discountEnds - acceptableExpiry.end) / Duration::SECOND).show() \n                    );\n\n                    // has the member-token reference\n                    // memberToken : String = reqtData.memberToken;\n                    // if (!reqtData.memberToken.starts_with(\"member-\")) { \n                    //     error(\"invalid member token name\"\n                    // ) };\n                    // expectedMemberToken : Value = mkTv(\n                    //     priorMddd.dd.mph, reqtData.memberToken\n                    // );\n\n                    // has the member-token in the txn\n                    // tx.inputs.find_safe((i: TxInput) -> Bool {\n                    //     i.value.contains(expectedMemberToken)\n                    // }).switch {\n                    //     None => error(\"missing member token\"),\n                    //     Some => true\n                    // } &&\n                    reqtData.validate() &&\n                    // mints a reqt UUT\n                    validateUutMinting(\n                        mph: priorMddd.dd.mph,\n                        seed: seed,\n                        purposes: []String{\"reqt\"},\n                        // otherMintedValue: ... ,\n                        mkTokenName: mkTn,\n                        // WE ARE the mint delegate.\n                        needsMintDelegateApproval: false \n                    )\n                }\n            },\n            SpendingActivities{VSA} => {\n                print(\"capo mph: \" + priorMddd.dd.mph.show());\n                cctx : CapoCtx = mkCapoCtx(priorMddd.dd.mph).withCharterRef();\n                print( \"\\ncapo addr\" + cctx.resolveCharterUtxo().address.show());\n                print(\"\\n\");\n\n                VSA.switch {                    \n                    UpdatingRecord{recId} => {\n                        hasDD : (TxInput) -> Bool = cctx.mkDelegatedDataPredicate(\"reqt\", recId);\n                        // settings: ProtocolSettings = ccts.getManifestDatum[ProtocolSettings](\"settings\");\n                        hasDDOutput : (TxOutput) -> Bool = cctx.mkDelegatedDataOutputPredicate(\"reqt\", recId);\n    \n                        tx.inputs.filter(hasDD).for_each( (utxo : TxInput) -> () {\n                            // they're all reqts, because of the above filter\n                            reqtData : ReqtData = ReqtData::from_data(utxo.datum.inline);\n                            updatedUtxo : TxOutput = tx.outputs.find(hasDDOutput);\n                            updatedReqt : ReqtData = ReqtData::from_data(updatedUtxo.datum.inline);\n\n                            _previousDeposit : Int = utxo.value.get_lovelace(); \n                            _newDepositTotal : Int = updatedUtxo.value.get_lovelace();  \n\n                                                        \n                            freshExpiry : TimeRange = daysInFuture(73); // todo get from settings\n                            \n                            REQT(\"changes the expiration date on each update\");\n                            REQT(\"uses the expiration-date policy from settings\");\n                            if (tx.time_range.end > reqtData.mustFreshenBy) {\n                                print(\"  -- reqt expired.  freshening.\\n\");\n                                REQT(\"updates the expiration date if it's expired\");\n                                assert( \n                                    freshExpiry.contains(updatedReqt.mustFreshenBy), \n                                    \"wrong expiry date @expired\"\n                                )\n                            }\n                        });\n                        true\n                    }\n                }\n            },        \n            _ => false\n        } || tx.serialize() == priorMddd.serialize()        \n    }\n\n    func supportedCapoDelegatePurposes(self) -> []String {\n        assert(true || /* prevent unused variable */ self == self, \"no way t\" );\n        []String{ \n            // \"nothingHereYet\",\n        }\n    }\n\n    //! Used only for validating non-IsDelegation datum types and activities.\n    // if you have any special admininstrative data structures that inform \n    // ...  your minting policy, this might be useful.  Otherwise, and typically,\n    // ... you should look to Activity validations above in additionalDelegateValidation,\n    // ...  in which the isDelegation token is being spent with an application-specific\n    // ...  activity/redeemer\n    func otherDatumValidation( self,\n        _priorMdd: DelegateDatum\n    ) -> Bool {\n        neverTriggered = () -> {  error(\"never called\") };\n        self.switch{\n            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.\n            //  Using it on any other Datum type will always fail and execution will never arrive here.\n            DelegateLifecycleActivities => neverTriggered(),\n            CapoLifecycleActivities => neverTriggered(),\n\n            // -- Application-specific activities can be added here \n            // -- for special & app-specific types of datum in a delegate,\n            // -- for EXCEPTIONAL cases, if you really know what you're doing.  \n            //  -- see above for normal cases\n\n            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls\n        }\n    }\n}\n\n",
  project: "stellar-contracts",
  purpose: "module",
  name:  "src/reqts/ReqtsPolicy.hl", // source filename
  moduleName:  "ReqtsPolicy",
};

const heliosModule = {
  content: "module ReqtsData\n\nimport {\n    AnyData\n} from StellarHeliosHelpers\nimport {\n    DelegationDetail\n} from CapoDelegateHelpers\n\n// !!! reqts data is stored in the Capo, \n//   ... but controlled, via the reqtsPolicy-* UUT. by the reqts delegate script \n//   ... which uses the code in this module (see DelegateActivity::additionalDelegateValidation below)\nstruct ReqtData {\n    id : ByteArray \"@id\" // = \"reqt-XXXXyyyyZZZZ\"\n    type : String \"tpe\" // = \"reqt\"\n    category: String \"cat\" // e.g. \"security\", \"usability\", \"performance\", \"compliance\"   \n    // for CIP-68 tokens issued from this requirement\n    name: String // e.g. \"Reqt XyZ\"\n    image: String // svg data for requirement graphic\n    description: String  // \"Holder of this token has a stake in the success of this requirement\"\n\n    mustFreshenBy: Time  \"exp\"\n    target: ByteArray  \"tgt\"\n    purpose: String   \"prps\"\n    details: []String  \"dtls\"\n    mech: []String  \n    impl: String\n    requires: []String\n    \n    // files: []AnyData optional\n\n    func validate(self) -> Bool {\n        assert(true || ( /* never executed*/ self.serialize() == self.serialize()), \"no\");\n        true\n    }\n}\n\nenum DelegateDatum {\n    Cip68RefToken {  \n        // NOTE: this datum contains reference details for a user-facing token minted according to the cip-68 standard \n        //  - the asset name (in the Value of this UTXO) MUST be:  #000643b0 + tokenName\n        //     - this asset name can serve user-side tokens using the CIP-68 \"222\", \"333\" or other token types.\n        //     - the user-side asset name with its (222/333/etc) CIP-67 prefix and \n        //       ... its remaining tokenName will be matched to this asset name (#000643b0 +tokenName)\n        //       ... to locate this reference datum; this datum content will be interpreted\n        //       ... according to the semantics implied by the user-side asset-name prefix.\n        //\n        //  - The attached 'meta' field in this Datum variant contains the relevant data, depending on the token type\n        //    - for \"222\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"files\" :   // {mediaType, src (url), name?, ... otherFields)\n        //        - \"image\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //    - for \"333\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"ticker\" : String\n        //        - \"url\": String  // project URL\n        //        - \"logo\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //                    - it must have a mime type `image/png`, `image/jpeg` or `image/svg+xml`\n        //        - \"decimals\" : Int\n\n        cip68meta: AnyData\n        cip68version: Int\n        otherDetails: Data // can be Unit () or anything else\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index as Capo's DelegatedData\n    capoStoredData {\n        data: ReqtData\n        version: Int\n        otherDetails: Data \n    }\n\n    // func validateSettings(self, _settings: ProtocolSettings) -> Bool{\n    //   ... get the settings from the manifest via cctx\n    //     assert(false, \"not valid (stubbed)\");\n    //     // settings.serialize() != self.serialize() &&\n    //     true\n    // }\n\n}\n\nenum MintingActivity {\n    CreatingRecord {\n        seed: TxOutputId\n    }\n}\n\nenum SpendingActivity {\n    UpdatingRecord {\n        id: ByteArray\n    }\n\n}\n\nenum BurningActivity {\n    DeletingRecord {\n        id: ByteArray\n    }\n}\n",
  project: "stellar-contracts",
  purpose: "module",
  name:  "src/reqts/ReqtsData.hl", // source filename
  moduleName:  "ReqtsData",
};

class ReqtsConcreteBundle extends CapoDelegateBundle.usingCapoBundleClass(CapoHeliosBundle) {
  get specializedDelegateModule() {
    return heliosModule$1;
  }
  get modules() {
    return [
      ...super.modules,
      heliosModule
    ];
  }
}

class ReqtsPolicyDataBridge extends ContractDataBridge {
  static isAbstract = false;
  isAbstract = false;
  /**
   * Helper class for generating TxOutputDatum for the ***datum type (DelegateDatum)***
   * for this contract script. 
   */
  datum = new DelegateDatumHelper({});
  // datumAccessor/enum
  /**
   * this is the specific type of datum for the `BasicDelegate` script
   */
  DelegateDatum = this.datum;
  readDatum = (d) => {
    return this.reader.DelegateDatum(d);
  };
  /**
   * generates UplcData for the activity type (***DelegateActivity***) for the `BasicDelegate` script
   */
  activity = new DelegateActivityHelper({ isActivity: true });
  // activityAccessor/enum
  DelegateActivity = this.activity;
  reader = new ReqtsPolicyDataBridgeReader(this);
  /**
   * accessors for all the types defined in the `BasicDelegate` script
   * @remarks - these accessors are used to generate UplcData for each type
   */
  types = {
    /**
     * generates UplcData for the enum type ***DelegateDatum*** for the `BasicDelegate` script
     */
    DelegateDatum: new DelegateDatumHelper(),
    /**
     * generates UplcData for the enum type ***DelegateRole*** for the `BasicDelegate` script
     */
    DelegateRole: new DelegateRoleHelper(),
    /**
     * generates UplcData for the enum type ***ManifestActivity*** for the `BasicDelegate` script
     */
    ManifestActivity: new ManifestActivityHelper(),
    /**
     * generates UplcData for the enum type ***CapoLifecycleActivity*** for the `BasicDelegate` script
     */
    CapoLifecycleActivity: new CapoLifecycleActivityHelper(),
    /**
     * generates UplcData for the enum type ***DelegateLifecycleActivity*** for the `BasicDelegate` script
     */
    DelegateLifecycleActivity: new DelegateLifecycleActivityHelper(),
    /**
     * generates UplcData for the enum type ***SpendingActivity*** for the `BasicDelegate` script
     */
    SpendingActivity: new SpendingActivityHelper(),
    /**
     * generates UplcData for the enum type ***MintingActivity*** for the `BasicDelegate` script
     */
    MintingActivity: new MintingActivityHelper(),
    /**
     * generates UplcData for the enum type ***BurningActivity*** for the `BasicDelegate` script
     */
    BurningActivity: new BurningActivityHelper(),
    /**
     * generates UplcData for the enum type ***DelegateActivity*** for the `BasicDelegate` script
     */
    DelegateActivity: new DelegateActivityHelper(),
    /**
     * generates UplcData for the enum type ***PendingDelegateAction*** for the `BasicDelegate` script
     */
    PendingDelegateAction: new PendingDelegateActionHelper(),
    /**
     * generates UplcData for the enum type ***ManifestEntryType*** for the `BasicDelegate` script
     */
    ManifestEntryType: new ManifestEntryTypeHelper(),
    /**
     * generates UplcData for the enum type ***PendingCharterChange*** for the `BasicDelegate` script
     */
    PendingCharterChange: new PendingCharterChangeHelper(),
    /**
     * generates UplcData for the enum type ***cctx_CharterInputType*** for the `BasicDelegate` script
     */
    cctx_CharterInputType: new cctx_CharterInputTypeHelper(),
    /**
     * generates UplcData for the enum type ***AnyData*** for the `BasicDelegate` script
     */
    AnyData: (fields) => {
      return this["\u1C7A\u1C7AAnyDataCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***DelegationDetail*** for the `BasicDelegate` script
     */
    DelegationDetail: (fields) => {
      return this["\u1C7A\u1C7ADelegationDetailCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***ReqtData*** for the `BasicDelegate` script
     */
    ReqtData: (fields) => {
      return this["\u1C7A\u1C7AReqtDataCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***RelativeDelegateLink*** for the `BasicDelegate` script
     */
    RelativeDelegateLink: (fields) => {
      return this["\u1C7A\u1C7ARelativeDelegateLinkCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***PendingDelegateChange*** for the `BasicDelegate` script
     */
    PendingDelegateChange: (fields) => {
      return this["\u1C7A\u1C7APendingDelegateChangeCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***CapoManifestEntry*** for the `BasicDelegate` script
     */
    CapoManifestEntry: (fields) => {
      return this["\u1C7A\u1C7ACapoManifestEntryCast"].toUplcData(fields);
    },
    /**
     * generates UplcData for the enum type ***CapoCtx*** for the `BasicDelegate` script
     */
    CapoCtx: (fields) => {
      return this["\u1C7A\u1C7ACapoCtxCast"].toUplcData(fields);
    }
  };
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7AAnyDataCast" = makeCast(
    AnyDataSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ADelegationDetailCast" = makeCast(
    DelegationDetailSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7AReqtDataCast" = makeCast(
    ReqtDataSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ARelativeDelegateLinkCast" = makeCast(
    RelativeDelegateLinkSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7APendingDelegateChangeCast" = makeCast(
    PendingDelegateChangeSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ACapoManifestEntryCast" = makeCast(
    CapoManifestEntrySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
              * uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7ACapoCtxCast" = makeCast(
    CapoCtxSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
}
class ReqtsPolicyDataBridgeReader extends DataBridgeReaderClass {
  constructor(bridge) {
    super();
    this.bridge = bridge;
  }
  datum = (d) => {
    return this.DelegateDatum(d);
  };
  /**
      * reads UplcData *known to fit the **DelegateDatum*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegateDatum(d) {
    const typeHelper = this.bridge.types.DelegateDatum;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **DelegateRole*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegateRole(d) {
    const typeHelper = this.bridge.types.DelegateRole;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **ManifestActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  ManifestActivity(d) {
    const typeHelper = this.bridge.types.ManifestActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **CapoLifecycleActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  CapoLifecycleActivity(d) {
    const typeHelper = this.bridge.types.CapoLifecycleActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **DelegateLifecycleActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegateLifecycleActivity(d) {
    const typeHelper = this.bridge.types.DelegateLifecycleActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **SpendingActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  SpendingActivity(d) {
    const typeHelper = this.bridge.types.SpendingActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **MintingActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  MintingActivity(d) {
    const typeHelper = this.bridge.types.MintingActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **BurningActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  BurningActivity(d) {
    const typeHelper = this.bridge.types.BurningActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **DelegateActivity*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegateActivity(d) {
    const typeHelper = this.bridge.types.DelegateActivity;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **PendingDelegateAction*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  PendingDelegateAction(d) {
    const typeHelper = this.bridge.types.PendingDelegateAction;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **ManifestEntryType*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  ManifestEntryType(d) {
    const typeHelper = this.bridge.types.ManifestEntryType;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **PendingCharterChange*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  PendingCharterChange(d) {
    const typeHelper = this.bridge.types.PendingCharterChange;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **cctx_CharterInputType*** enum type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the enum type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  cctx_CharterInputType(d) {
    const typeHelper = this.bridge.types.cctx_CharterInputType;
    const cast = typeHelper["\u1C7A\u1C7Acast"];
    return cast.fromUplcData(d);
  }
  /* enumReader helper */
  /**
      * reads UplcData *known to fit the **AnyData*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  AnyData(d) {
    const cast = this.bridge["\u1C7A\u1C7AAnyDataCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **DelegationDetail*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  DelegationDetail(d) {
    const cast = this.bridge["\u1C7A\u1C7ADelegationDetailCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **ReqtData*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  ReqtData(d) {
    const cast = this.bridge["\u1C7A\u1C7AReqtDataCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **RelativeDelegateLink*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  RelativeDelegateLink(d) {
    const cast = this.bridge["\u1C7A\u1C7ARelativeDelegateLinkCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **PendingDelegateChange*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  PendingDelegateChange(d) {
    const cast = this.bridge["\u1C7A\u1C7APendingDelegateChangeCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **CapoManifestEntry*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  CapoManifestEntry(d) {
    const cast = this.bridge["\u1C7A\u1C7ACapoManifestEntryCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
  /**
      * reads UplcData *known to fit the **CapoCtx*** struct type,
      * for the BasicDelegate script.
      * ### Standard WARNING
      * 
      * This is a low-level data-reader for use in ***advanced development scenarios***.
      * 
      * Used correctly with data that matches the type, this reader
      * returns strongly-typed data - your code using these types will be safe.
      * 
      * On the other hand, reading non-matching data will not give you a valid result.  
      * It may throw an error, or it may throw no error, but return a value that
      * causes some error later on in your code, when you try to use it.
      */
  CapoCtx(d) {
    const cast = this.bridge["\u1C7A\u1C7ACapoCtxCast"];
    return cast.fromUplcData(d);
  }
  /* structReader helper */
}
class DelegateDatumHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateDatumSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  InlineTxOutputDatum for ***"ReqtsData::DelegateDatum.Cip68RefToken"***
   * @remarks - ***DelegateDatum$Cip68RefTokenLike*** is the same as the expanded field-types.
   */
  Cip68RefToken(fields) {
    const uplc = this.mkUplcData({
      Cip68RefToken: fields
    }, "ReqtsData::DelegateDatum.Cip68RefToken");
    return makeInlineTxOutputDatum(uplc);
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  InlineTxOutputDatum for ***"ReqtsData::DelegateDatum.IsDelegation"***
   * @remarks - ***DelegationDetailLike*** is the same as the expanded field-type.
   */
  IsDelegation(dd) {
    const uplc = this.mkUplcData({
      IsDelegation: dd
    }, "ReqtsData::DelegateDatum.IsDelegation");
    return makeInlineTxOutputDatum(uplc);
  }
  /**
   * generates  InlineTxOutputDatum for ***"ReqtsData::DelegateDatum.capoStoredData"***
   * @remarks - ***DelegateDatum$capoStoredDataLike*** is the same as the expanded field-types.
   */
  capoStoredData(fields) {
    const uplc = this.mkUplcData({
      capoStoredData: fields
    }, "ReqtsData::DelegateDatum.capoStoredData");
    return makeInlineTxOutputDatum(uplc);
  }
  /*multiFieldVariant enum accessor*/
}
class DelegateRoleHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateRoleSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get MintDgt() {
    const uplc = this.mkUplcData(
      { MintDgt: {} },
      "CapoDelegateHelpers::DelegateRole.MintDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get SpendDgt() {
    const uplc = this.mkUplcData(
      { SpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.SpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get MintInvariant() {
    const uplc = this.mkUplcData(
      { MintInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.MintInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get SpendInvariant() {
    const uplc = this.mkUplcData(
      { SpendInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.SpendInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.DgDataPolicy"***
   */
  DgDataPolicy(name) {
    const uplc = this.mkUplcData({
      DgDataPolicy: name
    }, "CapoDelegateHelpers::DelegateRole.DgDataPolicy");
    return uplc;
  }
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.OtherNamedDgt"***
   */
  OtherNamedDgt(name) {
    const uplc = this.mkUplcData({
      OtherNamedDgt: name
    }, "CapoDelegateHelpers::DelegateRole.OtherNamedDgt");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#6***
   */
  get BothMintAndSpendDgt() {
    const uplc = this.mkUplcData(
      { BothMintAndSpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#7***
   */
  get HandledByCapoOnly() {
    const uplc = this.mkUplcData(
      { HandledByCapoOnly: {} },
      "CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
}
class ManifestActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    ManifestActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.retiringEntry"***
   */
  retiringEntry(key) {
    const uplc = this.mkUplcData({
      retiringEntry: key
    }, "CapoDelegateHelpers::ManifestActivity.retiringEntry");
    return uplc;
  }
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.updatingEntry"***
   * @remarks - ***ManifestActivity$updatingEntryLike*** is the same as the expanded field-types.
   */
  updatingEntry(fields) {
    const uplc = this.mkUplcData({
      updatingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.updatingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.addingEntry"***
   * @remarks - ***ManifestActivity$addingEntryLike*** is the same as the expanded field-types.
   */
  addingEntry(fields) {
    const uplc = this.mkUplcData({
      addingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.addingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.forkingThreadToken"***
   * @remarks - ***ManifestActivity$forkingThreadTokenLike*** is the same as the expanded field-types.
   */
  forkingThreadToken(fields) {
    const uplc = this.mkUplcData({
      forkingThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.forkingThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::ManifestActivity.burningThreadToken"***
   * @remarks - ***ManifestActivity$burningThreadTokenLike*** is the same as the expanded field-types.
   */
  burningThreadToken(fields) {
    const uplc = this.mkUplcData({
      burningThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.burningThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
}
class DelegateRoleHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateRoleSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get MintDgt() {
    const uplc = this.mkUplcData(
      { MintDgt: {} },
      "CapoDelegateHelpers::DelegateRole.MintDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get SpendDgt() {
    const uplc = this.mkUplcData(
      { SpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.SpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get MintInvariant() {
    const uplc = this.mkUplcData(
      { MintInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.MintInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get SpendInvariant() {
    const uplc = this.mkUplcData(
      { SpendInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.SpendInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.DgDataPolicy"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  DgDataPolicy(name) {
    const uplc = this.mkUplcData({
      DgDataPolicy: name
    }, "CapoDelegateHelpers::DelegateRole.DgDataPolicy");
    return uplc;
  }
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateRole.OtherNamedDgt"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  OtherNamedDgt(name) {
    const uplc = this.mkUplcData({
      OtherNamedDgt: name
    }, "CapoDelegateHelpers::DelegateRole.OtherNamedDgt");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#6***
   */
  get BothMintAndSpendDgt() {
    const uplc = this.mkUplcData(
      { BothMintAndSpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#7***
   */
  get HandledByCapoOnly() {
    const uplc = this.mkUplcData(
      { HandledByCapoOnly: {} },
      "CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
}
class ManifestActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    ManifestActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.retiringEntry"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  retiringEntry(key) {
    const uplc = this.mkUplcData({
      retiringEntry: key
    }, "CapoDelegateHelpers::ManifestActivity.retiringEntry");
    return uplc;
  }
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.updatingEntry"***
   * @remarks - ***ManifestActivity$updatingEntryLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  updatingEntry(fields) {
    const uplc = this.mkUplcData({
      updatingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.updatingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.addingEntry"***
   * @remarks - ***ManifestActivity$addingEntryLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  addingEntry(fields) {
    const uplc = this.mkUplcData({
      addingEntry: fields
    }, "CapoDelegateHelpers::ManifestActivity.addingEntry");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.forkingThreadToken"***
   * @remarks - ***ManifestActivity$forkingThreadTokenLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  forkingThreadToken(fields) {
    const uplc = this.mkUplcData({
      forkingThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.forkingThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::ManifestActivity.burningThreadToken"***
   * @remarks - ***ManifestActivity$burningThreadTokenLike*** is the same as the expanded field-types.
  * ### Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  burningThreadToken(fields) {
    const uplc = this.mkUplcData({
      burningThreadToken: fields
    }, "CapoDelegateHelpers::ManifestActivity.burningThreadToken");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
}
class CapoLifecycleActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    CapoLifecycleActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  CreatingDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        CreatingDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        CreatingDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$CreatingDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$CreatingDelegate = impliedSeedActivityMaker(
    this,
    this.CreatingDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get queuePendingChange() {
    const uplc = this.mkUplcData(
      { queuePendingChange: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * access to different variants of the ***nested DelegateRole*** type needed for ***CapoLifecycleActivity:removePendingChange***.
   */
  get removePendingChange() {
    const nestedAccessor = new DelegateRoleHelperNested({
      isNested: true,
      isActivity: false
    });
    nestedAccessor.mkDataVia(
      (role) => {
        return this.mkUplcData(
          { removePendingChange: role },
          "CapoDelegateHelpers::CapoLifecycleActivity.removePendingChange"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get commitPendingChanges() {
    const uplc = this.mkUplcData(
      { commitPendingChanges: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"
    );
    return uplc;
  }
  forcingNewSpendDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewSpendDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$forcingNewSpendDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewSpendDelegate
  );
  forcingNewMintDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewMintDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$forcingNewMintDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewMintDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * access to different variants of the ***nested ManifestActivity*** type needed for ***CapoLifecycleActivity:updatingManifest***.
   */
  get updatingManifest() {
    const nestedAccessor = new ManifestActivityHelperNested({
      isNested: true,
      isActivity: false
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { updatingManifest: activity },
          "CapoDelegateHelpers::CapoLifecycleActivity.updatingManifest"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
}
class DelegateLifecycleActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateLifecycleActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  ReplacingMe(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        ReplacingMe: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        ReplacingMe: fields
      }, "CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$ReplacingMe({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$ReplacingMe = impliedSeedActivityMaker(
    this,
    this.ReplacingMe
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.Retiring"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get Retiring() {
    const uplc = this.mkUplcData(
      { Retiring: {} },
      "CapoDelegateHelpers::DelegateLifecycleActivity.Retiring"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.ValidatingSettings"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get ValidatingSettings() {
    const uplc = this.mkUplcData(
      { ValidatingSettings: {} },
      "CapoDelegateHelpers::DelegateLifecycleActivity.ValidatingSettings"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
}
class SpendingActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    SpendingActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  UplcData for ***"ReqtsData::SpendingActivity.UpdatingRecord"***
   */
  UpdatingRecord(id) {
    const uplc = this.mkUplcData({
      UpdatingRecord: id
    }, "ReqtsData::SpendingActivity.UpdatingRecord");
    return uplc;
  }
}
class MintingActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    MintingActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
  * generates  UplcData for ***"ReqtsData::MintingActivity.CreatingRecord"***, 
  * given a transaction-context (or direct arg) with a ***seed utxo*** 
  * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
  *  - to get a transaction context having the seed needed for this argument, 
  *    see the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.
  * - or see the {@link hasSeed} type for other ways to feed it with a TxOutputId.
  *  - in a context providing an implicit seed utxo, use 
  *    the `$seeded$CreatingRecord}` variant of this activity instead
  *
   */
  CreatingRecord(thingWithSeed) {
    const seedTxOutputId = this.getSeed(thingWithSeed);
    const uplc = this.mkUplcData({
      CreatingRecord: seedTxOutputId
    }, "ReqtsData::MintingActivity.CreatingRecord");
    return uplc;
  }
  /*singleField/seeded enum variant*/
  /**
   * generates  UplcData for ***"ReqtsData::MintingActivity.CreatingRecord"***
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   * ## Usage
   * Access the activity-creator as a getter: `$seeded$CreatingRecord`
   *
   * Use the resulting activity-creator in a seed-providing context, such as the delegated-data-controller's
   * `mkTxnCreateRecord({activity, ...})` method.
   */
  get $seeded$CreatingRecord() {
    return impliedSeedActivityMaker(this, this.CreatingRecord)();
  }
  /* coda: seeded helper in same singleField/seeded enum variant*/
}
class BurningActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    BurningActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  UplcData for ***"ReqtsData::BurningActivity.DeletingRecord"***
   */
  DeletingRecord(id) {
    const uplc = this.mkUplcData({
      DeletingRecord: id
    }, "ReqtsData::BurningActivity.DeletingRecord");
    return uplc;
  }
}
class ActivityDelegateRoleHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateRoleSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get MintDgt() {
    const uplc = this.mkUplcData(
      { MintDgt: {} },
      "CapoDelegateHelpers::DelegateRole.MintDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get SpendDgt() {
    const uplc = this.mkUplcData(
      { SpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.SpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.MintInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get MintInvariant() {
    const uplc = this.mkUplcData(
      { MintInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.MintInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.SpendInvariant"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get SpendInvariant() {
    const uplc = this.mkUplcData(
      { SpendInvariant: {} },
      "CapoDelegateHelpers::DelegateRole.SpendInvariant"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::DelegateRole.DgDataPolicy"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  DgDataPolicy(name) {
    const uplc = this.mkUplcData({
      DgDataPolicy: name
    }, "CapoDelegateHelpers::DelegateRole.DgDataPolicy");
    return uplc;
  }
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::DelegateRole.OtherNamedDgt"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  OtherNamedDgt(name) {
    const uplc = this.mkUplcData({
      OtherNamedDgt: name
    }, "CapoDelegateHelpers::DelegateRole.OtherNamedDgt");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#6***
   */
  get BothMintAndSpendDgt() {
    const uplc = this.mkUplcData(
      { BothMintAndSpendDgt: {} },
      "CapoDelegateHelpers::DelegateRole.BothMintAndSpendDgt"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#7***
   */
  get HandledByCapoOnly() {
    const uplc = this.mkUplcData(
      { HandledByCapoOnly: {} },
      "CapoDelegateHelpers::DelegateRole.HandledByCapoOnly"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
}
class CapoLifecycleActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    CapoLifecycleActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  CreatingDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        CreatingDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        CreatingDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.CreatingDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$CreatingDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$CreatingDelegate = impliedSeedActivityMaker(
    this,
    this.CreatingDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get queuePendingChange() {
    const uplc = this.mkUplcData(
      { queuePendingChange: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.queuePendingChange"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * access to different variants of the ***nested DelegateRole*** type needed for ***CapoLifecycleActivity:removePendingChange***.
   */
  get removePendingChange() {
    const nestedAccessor = new ActivityDelegateRoleHelperNested({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (role) => {
        return this.mkUplcData(
          { removePendingChange: role },
          "CapoDelegateHelpers::CapoLifecycleActivity.removePendingChange"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get commitPendingChanges() {
    const uplc = this.mkUplcData(
      { commitPendingChanges: {} },
      "CapoDelegateHelpers::CapoLifecycleActivity.commitPendingChanges"
    );
    return uplc;
  }
  forcingNewSpendDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewSpendDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewSpendDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewSpendDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$forcingNewSpendDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewSpendDelegate
  );
  forcingNewMintDelegate(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        forcingNewMintDelegate: fields
      }, "CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::CapoLifecycleActivity.forcingNewMintDelegate"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$forcingNewMintDelegate({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$forcingNewMintDelegate = impliedSeedActivityMaker(
    this,
    this.forcingNewMintDelegate
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * access to different variants of the ***nested ManifestActivity*** type needed for ***CapoLifecycleActivity:updatingManifest***.
   */
  get updatingManifest() {
    const nestedAccessor = new ManifestActivityHelperNested({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { updatingManifest: activity },
          "CapoDelegateHelpers::CapoLifecycleActivity.updatingManifest"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
}
class DelegateLifecycleActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateLifecycleActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  ReplacingMe(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        ReplacingMe: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        ReplacingMe: fields
      }, "CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.ReplacingMe"***, 
   * @param fields - \{ purpose: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$ReplacingMe({ purpose })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  $seeded$ReplacingMe = impliedSeedActivityMaker(
    this,
    this.ReplacingMe
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.Retiring"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get Retiring() {
    const uplc = this.mkUplcData(
      { Retiring: {} },
      "CapoDelegateHelpers::DelegateLifecycleActivity.Retiring"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::DelegateLifecycleActivity.ValidatingSettings"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#2***
   */
  get ValidatingSettings() {
    const uplc = this.mkUplcData(
      { ValidatingSettings: {} },
      "CapoDelegateHelpers::DelegateLifecycleActivity.ValidatingSettings"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
}
class SpendingActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    SpendingActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"ReqtsData::SpendingActivity.UpdatingRecord"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  UpdatingRecord(id) {
    const uplc = this.mkUplcData({
      UpdatingRecord: id
    }, "ReqtsData::SpendingActivity.UpdatingRecord");
    return uplc;
  }
}
class MintingActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    MintingActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
  * generates isActivity/redeemer wrapper with UplcData for ***"ReqtsData::MintingActivity.CreatingRecord"***, 
  * given a transaction-context (or direct arg) with a ***seed utxo*** 
  * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
  *  - to get a transaction context having the seed needed for this argument, 
  *    see the `tcxWithSeedUtxo()` method in your contract's off-chain StellarContracts subclass.
  * - or see the {@link hasSeed} type for other ways to feed it with a TxOutputId.
  *  - in a context providing an implicit seed utxo, use 
  *    the `$seeded$CreatingRecord}` variant of this activity instead
  *
   * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
  */
  CreatingRecord(thingWithSeed) {
    const seedTxOutputId = this.getSeed(thingWithSeed);
    const uplc = this.mkUplcData({
      CreatingRecord: seedTxOutputId
    }, "ReqtsData::MintingActivity.CreatingRecord");
    return uplc;
  }
  /*singleField/seeded enum variant*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"ReqtsData::MintingActivity.CreatingRecord"***
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   * ## Usage
   * Access the activity-creator as a getter: `$seeded$CreatingRecord`
   *
   * Use the resulting activity-creator in a seed-providing context, such as the delegated-data-controller's
   * `mkTxnCreateRecord({activity, ...})` method.
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  get $seeded$CreatingRecord() {
    return impliedSeedActivityMaker(this, this.CreatingRecord)();
  }
  /* coda: seeded helper in same singleField/seeded enum variant*/
}
class BurningActivityHelperNested extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    BurningActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"ReqtsData::BurningActivity.DeletingRecord"***
  * ## Nested activity: 
  * this is connected to a nested-activity wrapper, so the details are piped through 
  * the parent's uplc-encoder, producing a single uplc object with 
  * a complete wrapper for this inner activity detail.
   */
  DeletingRecord(id) {
    const uplc = this.mkUplcData({
      DeletingRecord: id
    }, "ReqtsData::BurningActivity.DeletingRecord");
    return uplc;
  }
}
class DelegateActivityHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    DelegateActivitySchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * access to different variants of the ***nested CapoLifecycleActivity*** type needed for ***DelegateActivity:CapoLifecycleActivities***.
   */
  get CapoLifecycleActivities() {
    const nestedAccessor = new CapoLifecycleActivityHelperNested({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { CapoLifecycleActivities: activity },
          "ReqtsPolicy::DelegateActivity.CapoLifecycleActivities"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * access to different variants of the ***nested DelegateLifecycleActivity*** type needed for ***DelegateActivity:DelegateLifecycleActivities***.
   */
  get DelegateLifecycleActivities() {
    const nestedAccessor = new DelegateLifecycleActivityHelperNested({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { DelegateLifecycleActivities: activity },
          "ReqtsPolicy::DelegateActivity.DelegateLifecycleActivities"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * access to different variants of the ***nested SpendingActivity*** type needed for ***DelegateActivity:SpendingActivities***.
   */
  get SpendingActivities() {
    const nestedAccessor = new SpendingActivityHelperNested({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { SpendingActivities: activity },
          "ReqtsPolicy::DelegateActivity.SpendingActivities"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * access to different variants of the ***nested MintingActivity*** type needed for ***DelegateActivity:MintingActivities***.
   */
  get MintingActivities() {
    const nestedAccessor = new MintingActivityHelperNested({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { MintingActivities: activity },
          "ReqtsPolicy::DelegateActivity.MintingActivities"
        );
      }
    );
    return nestedAccessor;
  }
  /* nested enum accessor */
  /**
   * access to different variants of the ***nested BurningActivity*** type needed for ***DelegateActivity:BurningActivities***.
   */
  get BurningActivities() {
    const nestedAccessor = new BurningActivityHelperNested({
      isNested: true,
      isActivity: true
    });
    nestedAccessor.mkDataVia(
      (activity) => {
        return this.mkUplcData(
          { BurningActivities: activity },
          "ReqtsPolicy::DelegateActivity.BurningActivities"
        );
      }
    );
    return nestedAccessor;
  }
  CreatingDelegatedData(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        CreatingDelegatedData: { seed: seedTxOutputId, ...filteredFields }
      }, "ReqtsPolicy::DelegateActivity.CreatingDelegatedData");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        CreatingDelegatedData: fields
      }, "ReqtsPolicy::DelegateActivity.CreatingDelegatedData");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"ReqtsPolicy::DelegateActivity.CreatingDelegatedData"***, 
   * @param fields - \{ dataType: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$CreatingDelegatedData({ dataType })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$CreatingDelegatedData = impliedSeedActivityMaker(
    this,
    this.CreatingDelegatedData
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"ReqtsPolicy::DelegateActivity.UpdatingDelegatedData"***
   * @remarks - ***DelegateActivity$UpdatingDelegatedDataLike*** is the same as the expanded field-types.
   */
  UpdatingDelegatedData(fields) {
    const uplc = this.mkUplcData({
      UpdatingDelegatedData: fields
    }, "ReqtsPolicy::DelegateActivity.UpdatingDelegatedData");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"ReqtsPolicy::DelegateActivity.DeletingDelegatedData"***
   * @remarks - ***DelegateActivity$DeletingDelegatedDataLike*** is the same as the expanded field-types.
   */
  DeletingDelegatedData(fields) {
    const uplc = this.mkUplcData({
      DeletingDelegatedData: fields
    }, "ReqtsPolicy::DelegateActivity.DeletingDelegatedData");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates isActivity/redeemer wrapper with UplcData for ***"ReqtsPolicy::DelegateActivity.MultipleDelegateActivities"***
   */
  MultipleDelegateActivities(activities) {
    const uplc = this.mkUplcData({
      MultipleDelegateActivities: activities
    }, "ReqtsPolicy::DelegateActivity.MultipleDelegateActivities");
    return uplc;
  }
}
class PendingDelegateActionHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    PendingDelegateActionSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  Add(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        Add: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::PendingDelegateAction.Add");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        Add: fields
      }, "CapoDelegateHelpers::PendingDelegateAction.Add");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::PendingDelegateAction.Add"***, 
   * @param fields - \{ purpose: string, idPrefix: string \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$Add({ purpose, idPrefix })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$Add = impliedSeedActivityMaker(
    this,
    this.Add
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::PendingDelegateAction.Remove"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get Remove() {
    const uplc = this.mkUplcData(
      { Remove: {} },
      "CapoDelegateHelpers::PendingDelegateAction.Remove"
    );
    return uplc;
  }
  Replace(seedOrUf, filteredFields) {
    if (filteredFields) {
      const seedTxOutputId = this.getSeed(seedOrUf);
      const uplc = this.mkUplcData({
        Replace: { seed: seedTxOutputId, ...filteredFields }
      }, "CapoDelegateHelpers::PendingDelegateAction.Replace");
      return uplc;
    } else {
      const fields = seedOrUf;
      const uplc = this.mkUplcData({
        Replace: fields
      }, "CapoDelegateHelpers::PendingDelegateAction.Replace");
      return uplc;
    }
  }
  /*multiFieldVariant/seeded enum accessor*/
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::PendingDelegateAction.Replace"***, 
   * @param fields - \{ purpose: string, idPrefix: string, replacesDgt: AssetClass | string | [string | MintingPolicyHash | number[], string | number[]] | \{mph: MintingPolicyHash | string | number[], tokenName: string | number[]\} \}
   * @remarks
  * ### Seeded activity
  * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.
   * ### Activity contains implied seed
   * Creates a SeedActivity based on the provided args, reserving space for a seed to be 
   * provided implicitly by a SeedActivity-supporting library function. 
   *
   * ## Usage
   *   1. Call the `$seeded$Replace({ purpose, idPrefix, replacesDgt })`
    *       method with the indicated (non-seed) details.
   *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's
   *       `mkTxnCreateRecord({activity})` method.
   */
  $seeded$Replace = impliedSeedActivityMaker(
    this,
    this.Replace
  );
  /* coda: seeded helper in same multiFieldVariant/seeded */
}
class ManifestEntryTypeHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    ManifestEntryTypeSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoHelpers::ManifestEntryType.NamedTokenRef"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get NamedTokenRef() {
    const uplc = this.mkUplcData(
      { NamedTokenRef: {} },
      "CapoHelpers::ManifestEntryType.NamedTokenRef"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoHelpers::ManifestEntryType.DgDataPolicy"***
   * @remarks - ***ManifestEntryType$DgDataPolicyLike*** is the same as the expanded field-types.
   */
  DgDataPolicy(fields) {
    const uplc = this.mkUplcData({
      DgDataPolicy: fields
    }, "CapoHelpers::ManifestEntryType.DgDataPolicy");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoHelpers::ManifestEntryType.DelegateThreads"***
   * @remarks - ***ManifestEntryType$DelegateThreadsLike*** is the same as the expanded field-types.
   */
  DelegateThreads(fields) {
    const uplc = this.mkUplcData({
      DelegateThreads: fields
    }, "CapoHelpers::ManifestEntryType.DelegateThreads");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * (property getter): UplcData for ***"CapoHelpers::ManifestEntryType.MerkleMembership"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#3***
   */
  get MerkleMembership() {
    const uplc = this.mkUplcData(
      { MerkleMembership: {} },
      "CapoHelpers::ManifestEntryType.MerkleMembership"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * (property getter): UplcData for ***"CapoHelpers::ManifestEntryType.MerkleStateRoot"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#4***
   */
  get MerkleStateRoot() {
    const uplc = this.mkUplcData(
      { MerkleStateRoot: {} },
      "CapoHelpers::ManifestEntryType.MerkleStateRoot"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
}
class PendingCharterChangeHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    PendingCharterChangeSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * generates  UplcData for ***"CapoDelegateHelpers::PendingCharterChange.delegateChange"***
   * @remarks - ***PendingDelegateChangeLike*** is the same as the expanded field-type.
   */
  delegateChange(change) {
    const uplc = this.mkUplcData({
      delegateChange: change
    }, "CapoDelegateHelpers::PendingCharterChange.delegateChange");
    return uplc;
  }
  /**
   * (property getter): UplcData for ***"CapoDelegateHelpers::PendingCharterChange.otherManifestChange"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#1***
   */
  get otherManifestChange() {
    const uplc = this.mkUplcData(
      { otherManifestChange: {} },
      "CapoDelegateHelpers::PendingCharterChange.otherManifestChange"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
}
class cctx_CharterInputTypeHelper extends EnumBridge {
  /*mkEnumHelperClass*/
  /**
          *  uses unicode U+1c7a - sorts to the end */
  "\u1C7A\u1C7Acast" = makeCast(
    cctx_CharterInputTypeSchema,
    { isMainnet: true, unwrapSingleFieldEnumVariants: true }
  );
  /**
   * (property getter): UplcData for ***"CapoHelpers::cctx_CharterInputType.Unk"***
   * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#0***
   */
  get Unk() {
    const uplc = this.mkUplcData(
      { Unk: {} },
      "CapoHelpers::cctx_CharterInputType.Unk"
    );
    return uplc;
  }
  /* tagOnly variant accessor */
  /**
   * generates  UplcData for ***"CapoHelpers::cctx_CharterInputType.RefInput"***
   * @remarks - ***cctx_CharterInputType$RefInputLike*** is the same as the expanded field-types.
   */
  RefInput(fields) {
    const uplc = this.mkUplcData({
      RefInput: fields
    }, "CapoHelpers::cctx_CharterInputType.RefInput");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
  /**
   * generates  UplcData for ***"CapoHelpers::cctx_CharterInputType.Input"***
   * @remarks - ***cctx_CharterInputType$InputLike*** is the same as the expanded field-types.
   */
  Input(fields) {
    const uplc = this.mkUplcData({
      Input: fields
    }, "CapoHelpers::cctx_CharterInputType.Input");
    return uplc;
  }
  /*multiFieldVariant enum accessor*/
}
const AnyDataSchema = {
  "kind": "struct",
  "format": "map",
  "id": "__module__StellarHeliosHelpers__AnyData[]",
  "name": "AnyData",
  "fieldTypes": [
    {
      "name": "id",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      },
      "key": "@id"
    },
    {
      "name": "type",
      "type": {
        "kind": "internal",
        "name": "String"
      },
      "key": "tpe"
    }
  ]
};
const DelegationDetailSchema = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoDelegateHelpers__DelegationDetail[]",
  "name": "DelegationDetail",
  "fieldTypes": [
    {
      "name": "capoAddr",
      "type": {
        "kind": "internal",
        "name": "Address"
      }
    },
    {
      "name": "mph",
      "type": {
        "kind": "internal",
        "name": "MintingPolicyHash"
      }
    },
    {
      "name": "tn",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      }
    }
  ]
};
const ReqtDataSchema = {
  "kind": "struct",
  "format": "map",
  "id": "__module__ReqtsData__ReqtData[]",
  "name": "ReqtData",
  "fieldTypes": [
    {
      "name": "id",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      },
      "key": "@id"
    },
    {
      "name": "type",
      "type": {
        "kind": "internal",
        "name": "String"
      },
      "key": "tpe"
    },
    {
      "name": "category",
      "type": {
        "kind": "internal",
        "name": "String"
      },
      "key": "cat"
    },
    {
      "name": "name",
      "type": {
        "kind": "internal",
        "name": "String"
      }
    },
    {
      "name": "image",
      "type": {
        "kind": "internal",
        "name": "String"
      }
    },
    {
      "name": "description",
      "type": {
        "kind": "internal",
        "name": "String"
      }
    },
    {
      "name": "mustFreshenBy",
      "type": {
        "kind": "internal",
        "name": "Time"
      },
      "key": "exp"
    },
    {
      "name": "target",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      },
      "key": "tgt"
    },
    {
      "name": "purpose",
      "type": {
        "kind": "internal",
        "name": "String"
      },
      "key": "prps"
    },
    {
      "name": "details",
      "type": {
        "kind": "list",
        "itemType": {
          "kind": "internal",
          "name": "String"
        }
      },
      "key": "dtls"
    },
    {
      "name": "mech",
      "type": {
        "kind": "list",
        "itemType": {
          "kind": "internal",
          "name": "String"
        }
      }
    },
    {
      "name": "impl",
      "type": {
        "kind": "internal",
        "name": "String"
      }
    },
    {
      "name": "requires",
      "type": {
        "kind": "list",
        "itemType": {
          "kind": "internal",
          "name": "String"
        }
      }
    }
  ]
};
const DelegateDatumSchema = {
  "kind": "enum",
  "name": "DelegateDatum",
  "id": "__module__ReqtsData__DelegateDatum[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__ReqtsData__DelegateDatum[]__Cip68RefToken",
      "name": "Cip68RefToken",
      "fieldTypes": [
        {
          "name": "cip68meta",
          "type": {
            "kind": "struct",
            "format": "map",
            "id": "__module__StellarHeliosHelpers__AnyData[]",
            "name": "AnyData",
            "fieldTypes": [
              {
                "name": "id",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                },
                "key": "@id"
              },
              {
                "name": "type",
                "type": {
                  "kind": "internal",
                  "name": "String"
                },
                "key": "tpe"
              }
            ]
          }
        },
        {
          "name": "cip68version",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        },
        {
          "name": "otherDetails",
          "type": {
            "kind": "internal",
            "name": "Data"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__ReqtsData__DelegateDatum[]__IsDelegation",
      "name": "IsDelegation",
      "fieldTypes": [
        {
          "name": "dd",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__DelegationDetail[]",
            "name": "DelegationDetail",
            "fieldTypes": [
              {
                "name": "capoAddr",
                "type": {
                  "kind": "internal",
                  "name": "Address"
                }
              },
              {
                "name": "mph",
                "type": {
                  "kind": "internal",
                  "name": "MintingPolicyHash"
                }
              },
              {
                "name": "tn",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                }
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__ReqtsData__DelegateDatum[]__capoStoredData",
      "name": "capoStoredData",
      "fieldTypes": [
        {
          "name": "data",
          "type": {
            "kind": "struct",
            "format": "map",
            "id": "__module__ReqtsData__ReqtData[]",
            "name": "ReqtData",
            "fieldTypes": [
              {
                "name": "id",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                },
                "key": "@id"
              },
              {
                "name": "type",
                "type": {
                  "kind": "internal",
                  "name": "String"
                },
                "key": "tpe"
              },
              {
                "name": "category",
                "type": {
                  "kind": "internal",
                  "name": "String"
                },
                "key": "cat"
              },
              {
                "name": "name",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "image",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "description",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "mustFreshenBy",
                "type": {
                  "kind": "internal",
                  "name": "Time"
                },
                "key": "exp"
              },
              {
                "name": "target",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                },
                "key": "tgt"
              },
              {
                "name": "purpose",
                "type": {
                  "kind": "internal",
                  "name": "String"
                },
                "key": "prps"
              },
              {
                "name": "details",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "internal",
                    "name": "String"
                  }
                },
                "key": "dtls"
              },
              {
                "name": "mech",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "internal",
                    "name": "String"
                  }
                }
              },
              {
                "name": "impl",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "requires",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "internal",
                    "name": "String"
                  }
                }
              }
            ]
          }
        },
        {
          "name": "version",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        },
        {
          "name": "otherDetails",
          "type": {
            "kind": "internal",
            "name": "Data"
          }
        }
      ]
    }
  ]
};
const DelegateRoleSchema = {
  "kind": "enum",
  "name": "DelegateRole",
  "id": "__module__CapoDelegateHelpers__DelegateRole[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
      "name": "MintDgt",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
      "name": "SpendDgt",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
      "name": "MintInvariant",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
      "name": "SpendInvariant",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
      "name": "DgDataPolicy",
      "fieldTypes": [
        {
          "name": "name",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 5,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
      "name": "OtherNamedDgt",
      "fieldTypes": [
        {
          "name": "name",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 6,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
      "name": "BothMintAndSpendDgt",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 7,
      "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
      "name": "HandledByCapoOnly",
      "fieldTypes": []
    }
  ]
};
const ManifestActivitySchema = {
  "kind": "enum",
  "name": "ManifestActivity",
  "id": "__module__CapoDelegateHelpers__ManifestActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__retiringEntry",
      "name": "retiringEntry",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__updatingEntry",
      "name": "updatingEntry",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "tokenName",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__addingEntry",
      "name": "addingEntry",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "tokenName",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__forkingThreadToken",
      "name": "forkingThreadToken",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "newThreadCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoDelegateHelpers__ManifestActivity[]__burningThreadToken",
      "name": "burningThreadToken",
      "fieldTypes": [
        {
          "name": "key",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "burnedThreadCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    }
  ]
};
const CapoLifecycleActivitySchema = {
  "kind": "enum",
  "name": "CapoLifecycleActivity",
  "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__CreatingDelegate",
      "name": "CreatingDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__queuePendingChange",
      "name": "queuePendingChange",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__removePendingChange",
      "name": "removePendingChange",
      "fieldTypes": [
        {
          "name": "role",
          "type": {
            "kind": "enum",
            "name": "DelegateRole",
            "id": "__module__CapoDelegateHelpers__DelegateRole[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                "name": "MintDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                "name": "SpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                "name": "MintInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                "name": "SpendInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                "name": "DgDataPolicy",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 5,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                "name": "OtherNamedDgt",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 6,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                "name": "BothMintAndSpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 7,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                "name": "HandledByCapoOnly",
                "fieldTypes": []
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__commitPendingChanges",
      "name": "commitPendingChanges",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewSpendDelegate",
      "name": "forcingNewSpendDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 5,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewMintDelegate",
      "name": "forcingNewMintDelegate",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 6,
      "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__updatingManifest",
      "name": "updatingManifest",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "ManifestActivity",
            "id": "__module__CapoDelegateHelpers__ManifestActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__retiringEntry",
                "name": "retiringEntry",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__updatingEntry",
                "name": "updatingEntry",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "tokenName",
                    "type": {
                      "kind": "internal",
                      "name": "ByteArray"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__addingEntry",
                "name": "addingEntry",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "tokenName",
                    "type": {
                      "kind": "internal",
                      "name": "ByteArray"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__forkingThreadToken",
                "name": "forkingThreadToken",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "newThreadCount",
                    "type": {
                      "kind": "internal",
                      "name": "Int"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__ManifestActivity[]__burningThreadToken",
                "name": "burningThreadToken",
                "fieldTypes": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  },
                  {
                    "name": "burnedThreadCount",
                    "type": {
                      "kind": "internal",
                      "name": "Int"
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    }
  ]
};
const DelegateLifecycleActivitySchema = {
  "kind": "enum",
  "name": "DelegateLifecycleActivity",
  "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__ReplacingMe",
      "name": "ReplacingMe",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__Retiring",
      "name": "Retiring",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__ValidatingSettings",
      "name": "ValidatingSettings",
      "fieldTypes": []
    }
  ]
};
const SpendingActivitySchema = {
  "kind": "enum",
  "name": "SpendingActivity",
  "id": "__module__ReqtsData__SpendingActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__ReqtsData__SpendingActivity[]__UpdatingRecord",
      "name": "UpdatingRecord",
      "fieldTypes": [
        {
          "name": "id",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    }
  ]
};
const MintingActivitySchema = {
  "kind": "enum",
  "name": "MintingActivity",
  "id": "__module__ReqtsData__MintingActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__ReqtsData__MintingActivity[]__CreatingRecord",
      "name": "CreatingRecord",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        }
      ]
    }
  ]
};
const BurningActivitySchema = {
  "kind": "enum",
  "name": "BurningActivity",
  "id": "__module__ReqtsData__BurningActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__ReqtsData__BurningActivity[]__DeletingRecord",
      "name": "DeletingRecord",
      "fieldTypes": [
        {
          "name": "id",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    }
  ]
};
const DelegateActivitySchema = {
  "kind": "enum",
  "name": "DelegateActivity",
  "id": "__module__ReqtsPolicy__DelegateActivity[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__ReqtsPolicy__DelegateActivity[]__CapoLifecycleActivities",
      "name": "CapoLifecycleActivities",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "CapoLifecycleActivity",
            "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__CreatingDelegate",
                "name": "CreatingDelegate",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__queuePendingChange",
                "name": "queuePendingChange",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__removePendingChange",
                "name": "removePendingChange",
                "fieldTypes": [
                  {
                    "name": "role",
                    "type": {
                      "kind": "enum",
                      "name": "DelegateRole",
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                      "variantTypes": [
                        {
                          "kind": "variant",
                          "tag": 0,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                          "name": "MintDgt",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 1,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                          "name": "SpendDgt",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 2,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                          "name": "MintInvariant",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 3,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                          "name": "SpendInvariant",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 4,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                          "name": "DgDataPolicy",
                          "fieldTypes": [
                            {
                              "name": "name",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 5,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                          "name": "OtherNamedDgt",
                          "fieldTypes": [
                            {
                              "name": "name",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 6,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                          "name": "BothMintAndSpendDgt",
                          "fieldTypes": []
                        },
                        {
                          "kind": "variant",
                          "tag": 7,
                          "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                          "name": "HandledByCapoOnly",
                          "fieldTypes": []
                        }
                      ]
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__commitPendingChanges",
                "name": "commitPendingChanges",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewSpendDelegate",
                "name": "forcingNewSpendDelegate",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 5,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__forcingNewMintDelegate",
                "name": "forcingNewMintDelegate",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 6,
                "id": "__module__CapoDelegateHelpers__CapoLifecycleActivity[]__updatingManifest",
                "name": "updatingManifest",
                "fieldTypes": [
                  {
                    "name": "activity",
                    "type": {
                      "kind": "enum",
                      "name": "ManifestActivity",
                      "id": "__module__CapoDelegateHelpers__ManifestActivity[]",
                      "variantTypes": [
                        {
                          "kind": "variant",
                          "tag": 0,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__retiringEntry",
                          "name": "retiringEntry",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 1,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__updatingEntry",
                          "name": "updatingEntry",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "tokenName",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 2,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__addingEntry",
                          "name": "addingEntry",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "tokenName",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 3,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__forkingThreadToken",
                          "name": "forkingThreadToken",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "newThreadCount",
                              "type": {
                                "kind": "internal",
                                "name": "Int"
                              }
                            }
                          ]
                        },
                        {
                          "kind": "variant",
                          "tag": 4,
                          "id": "__module__CapoDelegateHelpers__ManifestActivity[]__burningThreadToken",
                          "name": "burningThreadToken",
                          "fieldTypes": [
                            {
                              "name": "key",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "burnedThreadCount",
                              "type": {
                                "kind": "internal",
                                "name": "Int"
                              }
                            }
                          ]
                        }
                      ]
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__ReqtsPolicy__DelegateActivity[]__DelegateLifecycleActivities",
      "name": "DelegateLifecycleActivities",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "DelegateLifecycleActivity",
            "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__ReplacingMe",
                "name": "ReplacingMe",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  },
                  {
                    "name": "purpose",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__Retiring",
                "name": "Retiring",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__DelegateLifecycleActivity[]__ValidatingSettings",
                "name": "ValidatingSettings",
                "fieldTypes": []
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__ReqtsPolicy__DelegateActivity[]__SpendingActivities",
      "name": "SpendingActivities",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "SpendingActivity",
            "id": "__module__ReqtsData__SpendingActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__ReqtsData__SpendingActivity[]__UpdatingRecord",
                "name": "UpdatingRecord",
                "fieldTypes": [
                  {
                    "name": "id",
                    "type": {
                      "kind": "internal",
                      "name": "ByteArray"
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__ReqtsPolicy__DelegateActivity[]__MintingActivities",
      "name": "MintingActivities",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "MintingActivity",
            "id": "__module__ReqtsData__MintingActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__ReqtsData__MintingActivity[]__CreatingRecord",
                "name": "CreatingRecord",
                "fieldTypes": [
                  {
                    "name": "seed",
                    "type": {
                      "kind": "internal",
                      "name": "TxOutputId"
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__ReqtsPolicy__DelegateActivity[]__BurningActivities",
      "name": "BurningActivities",
      "fieldTypes": [
        {
          "name": "activity",
          "type": {
            "kind": "enum",
            "name": "BurningActivity",
            "id": "__module__ReqtsData__BurningActivity[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__ReqtsData__BurningActivity[]__DeletingRecord",
                "name": "DeletingRecord",
                "fieldTypes": [
                  {
                    "name": "id",
                    "type": {
                      "kind": "internal",
                      "name": "ByteArray"
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 5,
      "id": "__module__ReqtsPolicy__DelegateActivity[]__CreatingDelegatedData",
      "name": "CreatingDelegatedData",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "dataType",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 6,
      "id": "__module__ReqtsPolicy__DelegateActivity[]__UpdatingDelegatedData",
      "name": "UpdatingDelegatedData",
      "fieldTypes": [
        {
          "name": "dataType",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "recId",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 7,
      "id": "__module__ReqtsPolicy__DelegateActivity[]__DeletingDelegatedData",
      "name": "DeletingDelegatedData",
      "fieldTypes": [
        {
          "name": "dataType",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "recId",
          "type": {
            "kind": "internal",
            "name": "ByteArray"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 8,
      "id": "__module__ReqtsPolicy__DelegateActivity[]__MultipleDelegateActivities",
      "name": "MultipleDelegateActivities",
      "fieldTypes": [
        {
          "name": "activities",
          "type": {
            "kind": "list",
            "itemType": {
              "kind": "internal",
              "name": "Data"
            }
          }
        }
      ]
    }
  ]
};
const PendingDelegateActionSchema = {
  "kind": "enum",
  "name": "PendingDelegateAction",
  "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
      "name": "Add",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "idPrefix",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
      "name": "Remove",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
      "name": "Replace",
      "fieldTypes": [
        {
          "name": "seed",
          "type": {
            "kind": "internal",
            "name": "TxOutputId"
          }
        },
        {
          "name": "purpose",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "idPrefix",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "replacesDgt",
          "type": {
            "kind": "internal",
            "name": "AssetClass"
          }
        }
      ]
    }
  ]
};
const RelativeDelegateLinkSchema = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
  "name": "RelativeDelegateLink",
  "fieldTypes": [
    {
      "name": "uutName",
      "type": {
        "kind": "internal",
        "name": "String"
      }
    },
    {
      "name": "delegateValidatorHash",
      "type": {
        "kind": "option",
        "someType": {
          "kind": "internal",
          "name": "ValidatorHash"
        }
      }
    },
    {
      "name": "config",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      }
    }
  ]
};
const PendingDelegateChangeSchema = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
  "name": "PendingDelegateChange",
  "fieldTypes": [
    {
      "name": "action",
      "type": {
        "kind": "enum",
        "name": "PendingDelegateAction",
        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
            "name": "Add",
            "fieldTypes": [
              {
                "name": "seed",
                "type": {
                  "kind": "internal",
                  "name": "TxOutputId"
                }
              },
              {
                "name": "purpose",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "idPrefix",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
            "name": "Remove",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
            "name": "Replace",
            "fieldTypes": [
              {
                "name": "seed",
                "type": {
                  "kind": "internal",
                  "name": "TxOutputId"
                }
              },
              {
                "name": "purpose",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "idPrefix",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "replacesDgt",
                "type": {
                  "kind": "internal",
                  "name": "AssetClass"
                }
              }
            ]
          }
        ]
      }
    },
    {
      "name": "role",
      "type": {
        "kind": "enum",
        "name": "DelegateRole",
        "id": "__module__CapoDelegateHelpers__DelegateRole[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
            "name": "MintDgt",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
            "name": "SpendDgt",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
            "name": "MintInvariant",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 3,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
            "name": "SpendInvariant",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 4,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
            "name": "DgDataPolicy",
            "fieldTypes": [
              {
                "name": "name",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 5,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
            "name": "OtherNamedDgt",
            "fieldTypes": [
              {
                "name": "name",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 6,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
            "name": "BothMintAndSpendDgt",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 7,
            "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
            "name": "HandledByCapoOnly",
            "fieldTypes": []
          }
        ]
      }
    },
    {
      "name": "dgtLink",
      "type": {
        "kind": "option",
        "someType": {
          "kind": "struct",
          "format": "list",
          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
          "name": "RelativeDelegateLink",
          "fieldTypes": [
            {
              "name": "uutName",
              "type": {
                "kind": "internal",
                "name": "String"
              }
            },
            {
              "name": "delegateValidatorHash",
              "type": {
                "kind": "option",
                "someType": {
                  "kind": "internal",
                  "name": "ValidatorHash"
                }
              }
            },
            {
              "name": "config",
              "type": {
                "kind": "internal",
                "name": "ByteArray"
              }
            }
          ]
        }
      }
    }
  ]
};
const ManifestEntryTypeSchema = {
  "kind": "enum",
  "name": "ManifestEntryType",
  "id": "__module__CapoHelpers__ManifestEntryType[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
      "name": "NamedTokenRef",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
      "name": "DgDataPolicy",
      "fieldTypes": [
        {
          "name": "policyLink",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
            "name": "RelativeDelegateLink",
            "fieldTypes": [
              {
                "name": "uutName",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "delegateValidatorHash",
                "type": {
                  "kind": "option",
                  "someType": {
                    "kind": "internal",
                    "name": "ValidatorHash"
                  }
                }
              },
              {
                "name": "config",
                "type": {
                  "kind": "internal",
                  "name": "ByteArray"
                }
              }
            ]
          }
        },
        {
          "name": "idPrefix",
          "type": {
            "kind": "internal",
            "name": "String"
          }
        },
        {
          "name": "refCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
      "name": "DelegateThreads",
      "fieldTypes": [
        {
          "name": "role",
          "type": {
            "kind": "enum",
            "name": "DelegateRole",
            "id": "__module__CapoDelegateHelpers__DelegateRole[]",
            "variantTypes": [
              {
                "kind": "variant",
                "tag": 0,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                "name": "MintDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 1,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                "name": "SpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 2,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                "name": "MintInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 3,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                "name": "SpendInvariant",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 4,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                "name": "DgDataPolicy",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 5,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                "name": "OtherNamedDgt",
                "fieldTypes": [
                  {
                    "name": "name",
                    "type": {
                      "kind": "internal",
                      "name": "String"
                    }
                  }
                ]
              },
              {
                "kind": "variant",
                "tag": 6,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                "name": "BothMintAndSpendDgt",
                "fieldTypes": []
              },
              {
                "kind": "variant",
                "tag": 7,
                "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                "name": "HandledByCapoOnly",
                "fieldTypes": []
              }
            ]
          }
        },
        {
          "name": "refCount",
          "type": {
            "kind": "internal",
            "name": "Int"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 3,
      "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
      "name": "MerkleMembership",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 4,
      "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
      "name": "MerkleStateRoot",
      "fieldTypes": []
    }
  ]
};
const CapoManifestEntrySchema = {
  "kind": "struct",
  "format": "map",
  "id": "__module__CapoHelpers__CapoManifestEntry[]",
  "name": "CapoManifestEntry",
  "fieldTypes": [
    {
      "name": "entryType",
      "type": {
        "kind": "enum",
        "name": "ManifestEntryType",
        "id": "__module__CapoHelpers__ManifestEntryType[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
            "name": "NamedTokenRef",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
            "name": "DgDataPolicy",
            "fieldTypes": [
              {
                "name": "policyLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "idPrefix",
                "type": {
                  "kind": "internal",
                  "name": "String"
                }
              },
              {
                "name": "refCount",
                "type": {
                  "kind": "internal",
                  "name": "Int"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
            "name": "DelegateThreads",
            "fieldTypes": [
              {
                "name": "role",
                "type": {
                  "kind": "enum",
                  "name": "DelegateRole",
                  "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                  "variantTypes": [
                    {
                      "kind": "variant",
                      "tag": 0,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                      "name": "MintDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 1,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                      "name": "SpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 2,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                      "name": "MintInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 3,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                      "name": "SpendInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 4,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                      "name": "DgDataPolicy",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 5,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                      "name": "OtherNamedDgt",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 6,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                      "name": "BothMintAndSpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 7,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                      "name": "HandledByCapoOnly",
                      "fieldTypes": []
                    }
                  ]
                }
              },
              {
                "name": "refCount",
                "type": {
                  "kind": "internal",
                  "name": "Int"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 3,
            "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
            "name": "MerkleMembership",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 4,
            "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
            "name": "MerkleStateRoot",
            "fieldTypes": []
          }
        ]
      },
      "key": "tpe"
    },
    {
      "name": "tokenName",
      "type": {
        "kind": "internal",
        "name": "ByteArray"
      },
      "key": "tn"
    },
    {
      "name": "mph",
      "type": {
        "kind": "option",
        "someType": {
          "kind": "internal",
          "name": "MintingPolicyHash"
        }
      }
    }
  ]
};
const PendingCharterChangeSchema = {
  "kind": "enum",
  "name": "PendingCharterChange",
  "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
      "name": "delegateChange",
      "fieldTypes": [
        {
          "name": "change",
          "type": {
            "kind": "struct",
            "format": "list",
            "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
            "name": "PendingDelegateChange",
            "fieldTypes": [
              {
                "name": "action",
                "type": {
                  "kind": "enum",
                  "name": "PendingDelegateAction",
                  "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                  "variantTypes": [
                    {
                      "kind": "variant",
                      "tag": 0,
                      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                      "name": "Add",
                      "fieldTypes": [
                        {
                          "name": "seed",
                          "type": {
                            "kind": "internal",
                            "name": "TxOutputId"
                          }
                        },
                        {
                          "name": "purpose",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        },
                        {
                          "name": "idPrefix",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 1,
                      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                      "name": "Remove",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 2,
                      "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                      "name": "Replace",
                      "fieldTypes": [
                        {
                          "name": "seed",
                          "type": {
                            "kind": "internal",
                            "name": "TxOutputId"
                          }
                        },
                        {
                          "name": "purpose",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        },
                        {
                          "name": "idPrefix",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        },
                        {
                          "name": "replacesDgt",
                          "type": {
                            "kind": "internal",
                            "name": "AssetClass"
                          }
                        }
                      ]
                    }
                  ]
                }
              },
              {
                "name": "role",
                "type": {
                  "kind": "enum",
                  "name": "DelegateRole",
                  "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                  "variantTypes": [
                    {
                      "kind": "variant",
                      "tag": 0,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                      "name": "MintDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 1,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                      "name": "SpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 2,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                      "name": "MintInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 3,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                      "name": "SpendInvariant",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 4,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                      "name": "DgDataPolicy",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 5,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                      "name": "OtherNamedDgt",
                      "fieldTypes": [
                        {
                          "name": "name",
                          "type": {
                            "kind": "internal",
                            "name": "String"
                          }
                        }
                      ]
                    },
                    {
                      "kind": "variant",
                      "tag": 6,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                      "name": "BothMintAndSpendDgt",
                      "fieldTypes": []
                    },
                    {
                      "kind": "variant",
                      "tag": 7,
                      "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                      "name": "HandledByCapoOnly",
                      "fieldTypes": []
                    }
                  ]
                }
              },
              {
                "name": "dgtLink",
                "type": {
                  "kind": "option",
                  "someType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
      "name": "otherManifestChange",
      "fieldTypes": []
    }
  ]
};
const cctx_CharterInputTypeSchema = {
  "kind": "enum",
  "name": "cctx_CharterInputType",
  "id": "__module__CapoHelpers__cctx_CharterInputType[]",
  "variantTypes": [
    {
      "kind": "variant",
      "tag": 0,
      "id": "__module__CapoHelpers__cctx_CharterInputType[]__Unk",
      "name": "Unk",
      "fieldTypes": []
    },
    {
      "kind": "variant",
      "tag": 1,
      "id": "__module__CapoHelpers__cctx_CharterInputType[]__RefInput",
      "name": "RefInput",
      "fieldTypes": [
        {
          "name": "datum",
          "type": {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoHelpers__CapoDatum[]__CharterData",
            "name": "CharterData",
            "fieldTypes": [
              {
                "name": "spendDelegateLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "spendInvariants",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "otherNamedDelegates",
                "type": {
                  "kind": "map",
                  "keyType": {
                    "kind": "internal",
                    "name": "String"
                  },
                  "valueType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "mintDelegateLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "mintInvariants",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "govAuthorityLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "manifest",
                "type": {
                  "kind": "map",
                  "keyType": {
                    "kind": "internal",
                    "name": "String"
                  },
                  "valueType": {
                    "kind": "struct",
                    "format": "map",
                    "id": "__module__CapoHelpers__CapoManifestEntry[]",
                    "name": "CapoManifestEntry",
                    "fieldTypes": [
                      {
                        "name": "entryType",
                        "type": {
                          "kind": "enum",
                          "name": "ManifestEntryType",
                          "id": "__module__CapoHelpers__ManifestEntryType[]",
                          "variantTypes": [
                            {
                              "kind": "variant",
                              "tag": 0,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
                              "name": "NamedTokenRef",
                              "fieldTypes": []
                            },
                            {
                              "kind": "variant",
                              "tag": 1,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
                              "name": "DgDataPolicy",
                              "fieldTypes": [
                                {
                                  "name": "policyLink",
                                  "type": {
                                    "kind": "struct",
                                    "format": "list",
                                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                    "name": "RelativeDelegateLink",
                                    "fieldTypes": [
                                      {
                                        "name": "uutName",
                                        "type": {
                                          "kind": "internal",
                                          "name": "String"
                                        }
                                      },
                                      {
                                        "name": "delegateValidatorHash",
                                        "type": {
                                          "kind": "option",
                                          "someType": {
                                            "kind": "internal",
                                            "name": "ValidatorHash"
                                          }
                                        }
                                      },
                                      {
                                        "name": "config",
                                        "type": {
                                          "kind": "internal",
                                          "name": "ByteArray"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "idPrefix",
                                  "type": {
                                    "kind": "internal",
                                    "name": "String"
                                  }
                                },
                                {
                                  "name": "refCount",
                                  "type": {
                                    "kind": "internal",
                                    "name": "Int"
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 2,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
                              "name": "DelegateThreads",
                              "fieldTypes": [
                                {
                                  "name": "role",
                                  "type": {
                                    "kind": "enum",
                                    "name": "DelegateRole",
                                    "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                        "name": "MintDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                        "name": "SpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                        "name": "MintInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 3,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                        "name": "SpendInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 4,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                        "name": "DgDataPolicy",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 5,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                        "name": "OtherNamedDgt",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 6,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                        "name": "BothMintAndSpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 7,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                        "name": "HandledByCapoOnly",
                                        "fieldTypes": []
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "refCount",
                                  "type": {
                                    "kind": "internal",
                                    "name": "Int"
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 3,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
                              "name": "MerkleMembership",
                              "fieldTypes": []
                            },
                            {
                              "kind": "variant",
                              "tag": 4,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
                              "name": "MerkleStateRoot",
                              "fieldTypes": []
                            }
                          ]
                        },
                        "key": "tpe"
                      },
                      {
                        "name": "tokenName",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        },
                        "key": "tn"
                      },
                      {
                        "name": "mph",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "MintingPolicyHash"
                          }
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "pendingChanges",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "enum",
                    "name": "PendingCharterChange",
                    "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
                    "variantTypes": [
                      {
                        "kind": "variant",
                        "tag": 0,
                        "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
                        "name": "delegateChange",
                        "fieldTypes": [
                          {
                            "name": "change",
                            "type": {
                              "kind": "struct",
                              "format": "list",
                              "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
                              "name": "PendingDelegateChange",
                              "fieldTypes": [
                                {
                                  "name": "action",
                                  "type": {
                                    "kind": "enum",
                                    "name": "PendingDelegateAction",
                                    "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                                        "name": "Add",
                                        "fieldTypes": [
                                          {
                                            "name": "seed",
                                            "type": {
                                              "kind": "internal",
                                              "name": "TxOutputId"
                                            }
                                          },
                                          {
                                            "name": "purpose",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "idPrefix",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                                        "name": "Remove",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                                        "name": "Replace",
                                        "fieldTypes": [
                                          {
                                            "name": "seed",
                                            "type": {
                                              "kind": "internal",
                                              "name": "TxOutputId"
                                            }
                                          },
                                          {
                                            "name": "purpose",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "idPrefix",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "replacesDgt",
                                            "type": {
                                              "kind": "internal",
                                              "name": "AssetClass"
                                            }
                                          }
                                        ]
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "role",
                                  "type": {
                                    "kind": "enum",
                                    "name": "DelegateRole",
                                    "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                        "name": "MintDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                        "name": "SpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                        "name": "MintInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 3,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                        "name": "SpendInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 4,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                        "name": "DgDataPolicy",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 5,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                        "name": "OtherNamedDgt",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 6,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                        "name": "BothMintAndSpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 7,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                        "name": "HandledByCapoOnly",
                                        "fieldTypes": []
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "dgtLink",
                                  "type": {
                                    "kind": "option",
                                    "someType": {
                                      "kind": "struct",
                                      "format": "list",
                                      "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                      "name": "RelativeDelegateLink",
                                      "fieldTypes": [
                                        {
                                          "name": "uutName",
                                          "type": {
                                            "kind": "internal",
                                            "name": "String"
                                          }
                                        },
                                        {
                                          "name": "delegateValidatorHash",
                                          "type": {
                                            "kind": "option",
                                            "someType": {
                                              "kind": "internal",
                                              "name": "ValidatorHash"
                                            }
                                          }
                                        },
                                        {
                                          "name": "config",
                                          "type": {
                                            "kind": "internal",
                                            "name": "ByteArray"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      },
                      {
                        "kind": "variant",
                        "tag": 1,
                        "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
                        "name": "otherManifestChange",
                        "fieldTypes": []
                      }
                    ]
                  }
                }
              }
            ]
          }
        },
        {
          "name": "utxo",
          "type": {
            "kind": "internal",
            "name": "TxInput"
          }
        }
      ]
    },
    {
      "kind": "variant",
      "tag": 2,
      "id": "__module__CapoHelpers__cctx_CharterInputType[]__Input",
      "name": "Input",
      "fieldTypes": [
        {
          "name": "datum",
          "type": {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoHelpers__CapoDatum[]__CharterData",
            "name": "CharterData",
            "fieldTypes": [
              {
                "name": "spendDelegateLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "spendInvariants",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "otherNamedDelegates",
                "type": {
                  "kind": "map",
                  "keyType": {
                    "kind": "internal",
                    "name": "String"
                  },
                  "valueType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "mintDelegateLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "mintInvariants",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "struct",
                    "format": "list",
                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                    "name": "RelativeDelegateLink",
                    "fieldTypes": [
                      {
                        "name": "uutName",
                        "type": {
                          "kind": "internal",
                          "name": "String"
                        }
                      },
                      {
                        "name": "delegateValidatorHash",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "ValidatorHash"
                          }
                        }
                      },
                      {
                        "name": "config",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "govAuthorityLink",
                "type": {
                  "kind": "struct",
                  "format": "list",
                  "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                  "name": "RelativeDelegateLink",
                  "fieldTypes": [
                    {
                      "name": "uutName",
                      "type": {
                        "kind": "internal",
                        "name": "String"
                      }
                    },
                    {
                      "name": "delegateValidatorHash",
                      "type": {
                        "kind": "option",
                        "someType": {
                          "kind": "internal",
                          "name": "ValidatorHash"
                        }
                      }
                    },
                    {
                      "name": "config",
                      "type": {
                        "kind": "internal",
                        "name": "ByteArray"
                      }
                    }
                  ]
                }
              },
              {
                "name": "manifest",
                "type": {
                  "kind": "map",
                  "keyType": {
                    "kind": "internal",
                    "name": "String"
                  },
                  "valueType": {
                    "kind": "struct",
                    "format": "map",
                    "id": "__module__CapoHelpers__CapoManifestEntry[]",
                    "name": "CapoManifestEntry",
                    "fieldTypes": [
                      {
                        "name": "entryType",
                        "type": {
                          "kind": "enum",
                          "name": "ManifestEntryType",
                          "id": "__module__CapoHelpers__ManifestEntryType[]",
                          "variantTypes": [
                            {
                              "kind": "variant",
                              "tag": 0,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
                              "name": "NamedTokenRef",
                              "fieldTypes": []
                            },
                            {
                              "kind": "variant",
                              "tag": 1,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
                              "name": "DgDataPolicy",
                              "fieldTypes": [
                                {
                                  "name": "policyLink",
                                  "type": {
                                    "kind": "struct",
                                    "format": "list",
                                    "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                    "name": "RelativeDelegateLink",
                                    "fieldTypes": [
                                      {
                                        "name": "uutName",
                                        "type": {
                                          "kind": "internal",
                                          "name": "String"
                                        }
                                      },
                                      {
                                        "name": "delegateValidatorHash",
                                        "type": {
                                          "kind": "option",
                                          "someType": {
                                            "kind": "internal",
                                            "name": "ValidatorHash"
                                          }
                                        }
                                      },
                                      {
                                        "name": "config",
                                        "type": {
                                          "kind": "internal",
                                          "name": "ByteArray"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "idPrefix",
                                  "type": {
                                    "kind": "internal",
                                    "name": "String"
                                  }
                                },
                                {
                                  "name": "refCount",
                                  "type": {
                                    "kind": "internal",
                                    "name": "Int"
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 2,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
                              "name": "DelegateThreads",
                              "fieldTypes": [
                                {
                                  "name": "role",
                                  "type": {
                                    "kind": "enum",
                                    "name": "DelegateRole",
                                    "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                        "name": "MintDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                        "name": "SpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                        "name": "MintInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 3,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                        "name": "SpendInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 4,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                        "name": "DgDataPolicy",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 5,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                        "name": "OtherNamedDgt",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 6,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                        "name": "BothMintAndSpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 7,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                        "name": "HandledByCapoOnly",
                                        "fieldTypes": []
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "refCount",
                                  "type": {
                                    "kind": "internal",
                                    "name": "Int"
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 3,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
                              "name": "MerkleMembership",
                              "fieldTypes": []
                            },
                            {
                              "kind": "variant",
                              "tag": 4,
                              "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
                              "name": "MerkleStateRoot",
                              "fieldTypes": []
                            }
                          ]
                        },
                        "key": "tpe"
                      },
                      {
                        "name": "tokenName",
                        "type": {
                          "kind": "internal",
                          "name": "ByteArray"
                        },
                        "key": "tn"
                      },
                      {
                        "name": "mph",
                        "type": {
                          "kind": "option",
                          "someType": {
                            "kind": "internal",
                            "name": "MintingPolicyHash"
                          }
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "pendingChanges",
                "type": {
                  "kind": "list",
                  "itemType": {
                    "kind": "enum",
                    "name": "PendingCharterChange",
                    "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
                    "variantTypes": [
                      {
                        "kind": "variant",
                        "tag": 0,
                        "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
                        "name": "delegateChange",
                        "fieldTypes": [
                          {
                            "name": "change",
                            "type": {
                              "kind": "struct",
                              "format": "list",
                              "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
                              "name": "PendingDelegateChange",
                              "fieldTypes": [
                                {
                                  "name": "action",
                                  "type": {
                                    "kind": "enum",
                                    "name": "PendingDelegateAction",
                                    "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                                        "name": "Add",
                                        "fieldTypes": [
                                          {
                                            "name": "seed",
                                            "type": {
                                              "kind": "internal",
                                              "name": "TxOutputId"
                                            }
                                          },
                                          {
                                            "name": "purpose",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "idPrefix",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                                        "name": "Remove",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                                        "name": "Replace",
                                        "fieldTypes": [
                                          {
                                            "name": "seed",
                                            "type": {
                                              "kind": "internal",
                                              "name": "TxOutputId"
                                            }
                                          },
                                          {
                                            "name": "purpose",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "idPrefix",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          },
                                          {
                                            "name": "replacesDgt",
                                            "type": {
                                              "kind": "internal",
                                              "name": "AssetClass"
                                            }
                                          }
                                        ]
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "role",
                                  "type": {
                                    "kind": "enum",
                                    "name": "DelegateRole",
                                    "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                    "variantTypes": [
                                      {
                                        "kind": "variant",
                                        "tag": 0,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                        "name": "MintDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 1,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                        "name": "SpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 2,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                        "name": "MintInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 3,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                        "name": "SpendInvariant",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 4,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                        "name": "DgDataPolicy",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 5,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                        "name": "OtherNamedDgt",
                                        "fieldTypes": [
                                          {
                                            "name": "name",
                                            "type": {
                                              "kind": "internal",
                                              "name": "String"
                                            }
                                          }
                                        ]
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 6,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                        "name": "BothMintAndSpendDgt",
                                        "fieldTypes": []
                                      },
                                      {
                                        "kind": "variant",
                                        "tag": 7,
                                        "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                        "name": "HandledByCapoOnly",
                                        "fieldTypes": []
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "dgtLink",
                                  "type": {
                                    "kind": "option",
                                    "someType": {
                                      "kind": "struct",
                                      "format": "list",
                                      "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                      "name": "RelativeDelegateLink",
                                      "fieldTypes": [
                                        {
                                          "name": "uutName",
                                          "type": {
                                            "kind": "internal",
                                            "name": "String"
                                          }
                                        },
                                        {
                                          "name": "delegateValidatorHash",
                                          "type": {
                                            "kind": "option",
                                            "someType": {
                                              "kind": "internal",
                                              "name": "ValidatorHash"
                                            }
                                          }
                                        },
                                        {
                                          "name": "config",
                                          "type": {
                                            "kind": "internal",
                                            "name": "ByteArray"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      },
                      {
                        "kind": "variant",
                        "tag": 1,
                        "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
                        "name": "otherManifestChange",
                        "fieldTypes": []
                      }
                    ]
                  }
                }
              }
            ]
          }
        },
        {
          "name": "utxo",
          "type": {
            "kind": "internal",
            "name": "TxInput"
          }
        }
      ]
    }
  ]
};
const CapoCtxSchema = {
  "kind": "struct",
  "format": "list",
  "id": "__module__CapoHelpers__CapoCtx[]",
  "name": "CapoCtx",
  "fieldTypes": [
    {
      "name": "mph",
      "type": {
        "kind": "internal",
        "name": "MintingPolicyHash"
      }
    },
    {
      "name": "charter",
      "type": {
        "kind": "enum",
        "name": "cctx_CharterInputType",
        "id": "__module__CapoHelpers__cctx_CharterInputType[]",
        "variantTypes": [
          {
            "kind": "variant",
            "tag": 0,
            "id": "__module__CapoHelpers__cctx_CharterInputType[]__Unk",
            "name": "Unk",
            "fieldTypes": []
          },
          {
            "kind": "variant",
            "tag": 1,
            "id": "__module__CapoHelpers__cctx_CharterInputType[]__RefInput",
            "name": "RefInput",
            "fieldTypes": [
              {
                "name": "datum",
                "type": {
                  "kind": "variant",
                  "tag": 0,
                  "id": "__module__CapoHelpers__CapoDatum[]__CharterData",
                  "name": "CharterData",
                  "fieldTypes": [
                    {
                      "name": "spendDelegateLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "spendInvariants",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "otherNamedDelegates",
                      "type": {
                        "kind": "map",
                        "keyType": {
                          "kind": "internal",
                          "name": "String"
                        },
                        "valueType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "mintDelegateLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "mintInvariants",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "govAuthorityLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "manifest",
                      "type": {
                        "kind": "map",
                        "keyType": {
                          "kind": "internal",
                          "name": "String"
                        },
                        "valueType": {
                          "kind": "struct",
                          "format": "map",
                          "id": "__module__CapoHelpers__CapoManifestEntry[]",
                          "name": "CapoManifestEntry",
                          "fieldTypes": [
                            {
                              "name": "entryType",
                              "type": {
                                "kind": "enum",
                                "name": "ManifestEntryType",
                                "id": "__module__CapoHelpers__ManifestEntryType[]",
                                "variantTypes": [
                                  {
                                    "kind": "variant",
                                    "tag": 0,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
                                    "name": "NamedTokenRef",
                                    "fieldTypes": []
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 1,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
                                    "name": "DgDataPolicy",
                                    "fieldTypes": [
                                      {
                                        "name": "policyLink",
                                        "type": {
                                          "kind": "struct",
                                          "format": "list",
                                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                          "name": "RelativeDelegateLink",
                                          "fieldTypes": [
                                            {
                                              "name": "uutName",
                                              "type": {
                                                "kind": "internal",
                                                "name": "String"
                                              }
                                            },
                                            {
                                              "name": "delegateValidatorHash",
                                              "type": {
                                                "kind": "option",
                                                "someType": {
                                                  "kind": "internal",
                                                  "name": "ValidatorHash"
                                                }
                                              }
                                            },
                                            {
                                              "name": "config",
                                              "type": {
                                                "kind": "internal",
                                                "name": "ByteArray"
                                              }
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "idPrefix",
                                        "type": {
                                          "kind": "internal",
                                          "name": "String"
                                        }
                                      },
                                      {
                                        "name": "refCount",
                                        "type": {
                                          "kind": "internal",
                                          "name": "Int"
                                        }
                                      }
                                    ]
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 2,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
                                    "name": "DelegateThreads",
                                    "fieldTypes": [
                                      {
                                        "name": "role",
                                        "type": {
                                          "kind": "enum",
                                          "name": "DelegateRole",
                                          "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                              "name": "MintDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                              "name": "SpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                              "name": "MintInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 3,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                              "name": "SpendInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 4,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                              "name": "DgDataPolicy",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 5,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                              "name": "OtherNamedDgt",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 6,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                              "name": "BothMintAndSpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 7,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                              "name": "HandledByCapoOnly",
                                              "fieldTypes": []
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "refCount",
                                        "type": {
                                          "kind": "internal",
                                          "name": "Int"
                                        }
                                      }
                                    ]
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 3,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
                                    "name": "MerkleMembership",
                                    "fieldTypes": []
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 4,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
                                    "name": "MerkleStateRoot",
                                    "fieldTypes": []
                                  }
                                ]
                              },
                              "key": "tpe"
                            },
                            {
                              "name": "tokenName",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              },
                              "key": "tn"
                            },
                            {
                              "name": "mph",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "MintingPolicyHash"
                                }
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "pendingChanges",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "enum",
                          "name": "PendingCharterChange",
                          "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
                          "variantTypes": [
                            {
                              "kind": "variant",
                              "tag": 0,
                              "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
                              "name": "delegateChange",
                              "fieldTypes": [
                                {
                                  "name": "change",
                                  "type": {
                                    "kind": "struct",
                                    "format": "list",
                                    "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
                                    "name": "PendingDelegateChange",
                                    "fieldTypes": [
                                      {
                                        "name": "action",
                                        "type": {
                                          "kind": "enum",
                                          "name": "PendingDelegateAction",
                                          "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                                              "name": "Add",
                                              "fieldTypes": [
                                                {
                                                  "name": "seed",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "TxOutputId"
                                                  }
                                                },
                                                {
                                                  "name": "purpose",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "idPrefix",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                                              "name": "Remove",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                                              "name": "Replace",
                                              "fieldTypes": [
                                                {
                                                  "name": "seed",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "TxOutputId"
                                                  }
                                                },
                                                {
                                                  "name": "purpose",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "idPrefix",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "replacesDgt",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "AssetClass"
                                                  }
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "role",
                                        "type": {
                                          "kind": "enum",
                                          "name": "DelegateRole",
                                          "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                              "name": "MintDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                              "name": "SpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                              "name": "MintInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 3,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                              "name": "SpendInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 4,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                              "name": "DgDataPolicy",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 5,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                              "name": "OtherNamedDgt",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 6,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                              "name": "BothMintAndSpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 7,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                              "name": "HandledByCapoOnly",
                                              "fieldTypes": []
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "dgtLink",
                                        "type": {
                                          "kind": "option",
                                          "someType": {
                                            "kind": "struct",
                                            "format": "list",
                                            "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                            "name": "RelativeDelegateLink",
                                            "fieldTypes": [
                                              {
                                                "name": "uutName",
                                                "type": {
                                                  "kind": "internal",
                                                  "name": "String"
                                                }
                                              },
                                              {
                                                "name": "delegateValidatorHash",
                                                "type": {
                                                  "kind": "option",
                                                  "someType": {
                                                    "kind": "internal",
                                                    "name": "ValidatorHash"
                                                  }
                                                }
                                              },
                                              {
                                                "name": "config",
                                                "type": {
                                                  "kind": "internal",
                                                  "name": "ByteArray"
                                                }
                                              }
                                            ]
                                          }
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 1,
                              "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
                              "name": "otherManifestChange",
                              "fieldTypes": []
                            }
                          ]
                        }
                      }
                    }
                  ]
                }
              },
              {
                "name": "utxo",
                "type": {
                  "kind": "internal",
                  "name": "TxInput"
                }
              }
            ]
          },
          {
            "kind": "variant",
            "tag": 2,
            "id": "__module__CapoHelpers__cctx_CharterInputType[]__Input",
            "name": "Input",
            "fieldTypes": [
              {
                "name": "datum",
                "type": {
                  "kind": "variant",
                  "tag": 0,
                  "id": "__module__CapoHelpers__CapoDatum[]__CharterData",
                  "name": "CharterData",
                  "fieldTypes": [
                    {
                      "name": "spendDelegateLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "spendInvariants",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "otherNamedDelegates",
                      "type": {
                        "kind": "map",
                        "keyType": {
                          "kind": "internal",
                          "name": "String"
                        },
                        "valueType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "mintDelegateLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "mintInvariants",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "struct",
                          "format": "list",
                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                          "name": "RelativeDelegateLink",
                          "fieldTypes": [
                            {
                              "name": "uutName",
                              "type": {
                                "kind": "internal",
                                "name": "String"
                              }
                            },
                            {
                              "name": "delegateValidatorHash",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "ValidatorHash"
                                }
                              }
                            },
                            {
                              "name": "config",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "govAuthorityLink",
                      "type": {
                        "kind": "struct",
                        "format": "list",
                        "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                        "name": "RelativeDelegateLink",
                        "fieldTypes": [
                          {
                            "name": "uutName",
                            "type": {
                              "kind": "internal",
                              "name": "String"
                            }
                          },
                          {
                            "name": "delegateValidatorHash",
                            "type": {
                              "kind": "option",
                              "someType": {
                                "kind": "internal",
                                "name": "ValidatorHash"
                              }
                            }
                          },
                          {
                            "name": "config",
                            "type": {
                              "kind": "internal",
                              "name": "ByteArray"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "manifest",
                      "type": {
                        "kind": "map",
                        "keyType": {
                          "kind": "internal",
                          "name": "String"
                        },
                        "valueType": {
                          "kind": "struct",
                          "format": "map",
                          "id": "__module__CapoHelpers__CapoManifestEntry[]",
                          "name": "CapoManifestEntry",
                          "fieldTypes": [
                            {
                              "name": "entryType",
                              "type": {
                                "kind": "enum",
                                "name": "ManifestEntryType",
                                "id": "__module__CapoHelpers__ManifestEntryType[]",
                                "variantTypes": [
                                  {
                                    "kind": "variant",
                                    "tag": 0,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__NamedTokenRef",
                                    "name": "NamedTokenRef",
                                    "fieldTypes": []
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 1,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__DgDataPolicy",
                                    "name": "DgDataPolicy",
                                    "fieldTypes": [
                                      {
                                        "name": "policyLink",
                                        "type": {
                                          "kind": "struct",
                                          "format": "list",
                                          "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                          "name": "RelativeDelegateLink",
                                          "fieldTypes": [
                                            {
                                              "name": "uutName",
                                              "type": {
                                                "kind": "internal",
                                                "name": "String"
                                              }
                                            },
                                            {
                                              "name": "delegateValidatorHash",
                                              "type": {
                                                "kind": "option",
                                                "someType": {
                                                  "kind": "internal",
                                                  "name": "ValidatorHash"
                                                }
                                              }
                                            },
                                            {
                                              "name": "config",
                                              "type": {
                                                "kind": "internal",
                                                "name": "ByteArray"
                                              }
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "idPrefix",
                                        "type": {
                                          "kind": "internal",
                                          "name": "String"
                                        }
                                      },
                                      {
                                        "name": "refCount",
                                        "type": {
                                          "kind": "internal",
                                          "name": "Int"
                                        }
                                      }
                                    ]
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 2,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__DelegateThreads",
                                    "name": "DelegateThreads",
                                    "fieldTypes": [
                                      {
                                        "name": "role",
                                        "type": {
                                          "kind": "enum",
                                          "name": "DelegateRole",
                                          "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                              "name": "MintDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                              "name": "SpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                              "name": "MintInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 3,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                              "name": "SpendInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 4,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                              "name": "DgDataPolicy",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 5,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                              "name": "OtherNamedDgt",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 6,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                              "name": "BothMintAndSpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 7,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                              "name": "HandledByCapoOnly",
                                              "fieldTypes": []
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "refCount",
                                        "type": {
                                          "kind": "internal",
                                          "name": "Int"
                                        }
                                      }
                                    ]
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 3,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleMembership",
                                    "name": "MerkleMembership",
                                    "fieldTypes": []
                                  },
                                  {
                                    "kind": "variant",
                                    "tag": 4,
                                    "id": "__module__CapoHelpers__ManifestEntryType[]__MerkleStateRoot",
                                    "name": "MerkleStateRoot",
                                    "fieldTypes": []
                                  }
                                ]
                              },
                              "key": "tpe"
                            },
                            {
                              "name": "tokenName",
                              "type": {
                                "kind": "internal",
                                "name": "ByteArray"
                              },
                              "key": "tn"
                            },
                            {
                              "name": "mph",
                              "type": {
                                "kind": "option",
                                "someType": {
                                  "kind": "internal",
                                  "name": "MintingPolicyHash"
                                }
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "pendingChanges",
                      "type": {
                        "kind": "list",
                        "itemType": {
                          "kind": "enum",
                          "name": "PendingCharterChange",
                          "id": "__module__CapoDelegateHelpers__PendingCharterChange[]",
                          "variantTypes": [
                            {
                              "kind": "variant",
                              "tag": 0,
                              "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__delegateChange",
                              "name": "delegateChange",
                              "fieldTypes": [
                                {
                                  "name": "change",
                                  "type": {
                                    "kind": "struct",
                                    "format": "list",
                                    "id": "__module__CapoDelegateHelpers__PendingDelegateChange[]",
                                    "name": "PendingDelegateChange",
                                    "fieldTypes": [
                                      {
                                        "name": "action",
                                        "type": {
                                          "kind": "enum",
                                          "name": "PendingDelegateAction",
                                          "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Add",
                                              "name": "Add",
                                              "fieldTypes": [
                                                {
                                                  "name": "seed",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "TxOutputId"
                                                  }
                                                },
                                                {
                                                  "name": "purpose",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "idPrefix",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Remove",
                                              "name": "Remove",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__PendingDelegateAction[]__Replace",
                                              "name": "Replace",
                                              "fieldTypes": [
                                                {
                                                  "name": "seed",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "TxOutputId"
                                                  }
                                                },
                                                {
                                                  "name": "purpose",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "idPrefix",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                },
                                                {
                                                  "name": "replacesDgt",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "AssetClass"
                                                  }
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "role",
                                        "type": {
                                          "kind": "enum",
                                          "name": "DelegateRole",
                                          "id": "__module__CapoDelegateHelpers__DelegateRole[]",
                                          "variantTypes": [
                                            {
                                              "kind": "variant",
                                              "tag": 0,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintDgt",
                                              "name": "MintDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 1,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendDgt",
                                              "name": "SpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 2,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__MintInvariant",
                                              "name": "MintInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 3,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__SpendInvariant",
                                              "name": "SpendInvariant",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 4,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__DgDataPolicy",
                                              "name": "DgDataPolicy",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 5,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__OtherNamedDgt",
                                              "name": "OtherNamedDgt",
                                              "fieldTypes": [
                                                {
                                                  "name": "name",
                                                  "type": {
                                                    "kind": "internal",
                                                    "name": "String"
                                                  }
                                                }
                                              ]
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 6,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__BothMintAndSpendDgt",
                                              "name": "BothMintAndSpendDgt",
                                              "fieldTypes": []
                                            },
                                            {
                                              "kind": "variant",
                                              "tag": 7,
                                              "id": "__module__CapoDelegateHelpers__DelegateRole[]__HandledByCapoOnly",
                                              "name": "HandledByCapoOnly",
                                              "fieldTypes": []
                                            }
                                          ]
                                        }
                                      },
                                      {
                                        "name": "dgtLink",
                                        "type": {
                                          "kind": "option",
                                          "someType": {
                                            "kind": "struct",
                                            "format": "list",
                                            "id": "__module__CapoDelegateHelpers__RelativeDelegateLink[]",
                                            "name": "RelativeDelegateLink",
                                            "fieldTypes": [
                                              {
                                                "name": "uutName",
                                                "type": {
                                                  "kind": "internal",
                                                  "name": "String"
                                                }
                                              },
                                              {
                                                "name": "delegateValidatorHash",
                                                "type": {
                                                  "kind": "option",
                                                  "someType": {
                                                    "kind": "internal",
                                                    "name": "ValidatorHash"
                                                  }
                                                }
                                              },
                                              {
                                                "name": "config",
                                                "type": {
                                                  "kind": "internal",
                                                  "name": "ByteArray"
                                                }
                                              }
                                            ]
                                          }
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            },
                            {
                              "kind": "variant",
                              "tag": 1,
                              "id": "__module__CapoDelegateHelpers__PendingCharterChange[]__otherManifestChange",
                              "name": "otherManifestChange",
                              "fieldTypes": []
                            }
                          ]
                        }
                      }
                    }
                  ]
                }
              },
              {
                "name": "utxo",
                "type": {
                  "kind": "internal",
                  "name": "TxInput"
                }
              }
            ]
          }
        ]
      }
    }
  ]
};

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
class ReqtsController extends DelegatedDataContract {
  dataBridgeClass = ReqtsPolicyDataBridge;
  dgDatumHelper = new DelegateDatumHelper();
  get delegateName() {
    return "reqtV1";
  }
  get capo() {
    return this.configIn?.capo;
  }
  get idPrefix() {
    return "reqt";
  }
  get recordTypeName() {
    return "reqt";
  }
  exampleData() {
    return {
      // id: textToBytes("reqt-1234"),
      // type: "reqt",
      category: "SCALE",
      name: "Supports multiple users",
      purpose: "testing & type example data",
      description: "Some descriptive requirement information to clarify the short name field",
      image: "ipfs://...",
      target: encodeUtf8("something-1234"),
      details: ["more info", "more more info"],
      mech: ["how it's designed", "how it's implemented"],
      impl: "some method or class name providing the described functionality",
      mustFreshenBy: 42n,
      requires: [
        /* no deps */
      ]
    };
  }
  // this method is only needed if the app needs a class for
  // implementing app-specific "business logic" on the data,
  // e.g. for presentation in a UI
  // mkDatumAdapter(): DelegatedDatumAdapter<any> {
  //     return new ReqtsAdapter(this);
  // }
  // get specializedDelegateModule() {
  //     return ReqtsPolicyScript;
  // }
  scriptBundle() {
    console.warn("UNCHECKED: does it work as hoped?");
    return new ReqtsConcreteBundle();
  }
  activityCreatingReqt(seedFrom) {
    const seed = this.getSeed(seedFrom);
    return this.mkSeededMintingActivity("CreatingRecord", { seed });
  }
  activityUpdatingReqt(id) {
    return this.mkSpendingActivity("UpdatingRecord", { id });
  }
  activityCreatingRequirement(seedFrom) {
    const seed = this.getSeed(seedFrom);
    return this.mkSeededMintingActivity("CreatingRecord", { seed });
  }
  async txnCreatingReqt(tcx, reqt, initialStake) {
    const tcx2 = await this.txnGrantAuthority(
      tcx,
      this.activityCreatingRequirement(tcx)
    );
    console.log(
      "\u{1F3D2} starting reqt for TODO add `target` id and implement a parent object... "
    );
    console.log("    -- initial stake: ", initialStake);
    const initialStakeValue = makeValue(initialStake);
    const reqtOutput = makeTxOutput(
      this.capo.address,
      this.uh.mkMinTv(this.capo.mph, tcx2.state.uuts.reqt).add(initialStakeValue),
      await this.mkDgDatum(
        {
          ...reqt,
          id: tcx.state.uuts.reqt.toString()
        }
        /* !!!!!!! */
      )
    );
    console.log("reqt: ", dumpAny(reqtOutput));
    const tcx4 = tcx2.addOutput(reqtOutput);
    return tcx4;
  }
  async txnUpdateReqt(tcx, reqtDetails, newDepositIncrement, newDatum) {
    if (newDatum) {
      throw new Error(
        `todo: support for iterating the reqt details here`
      );
    }
    tcx.state.settingsInfo.utxo;
    const id = reqtDetails.data.id;
    const tcx2 = await this.txnGrantAuthority(
      tcx,
      this.activityUpdatingReqt(id)
    );
    reqtDetails.utxo.value.lovelace;
    console.log("    ---- deposit increment: ", newDepositIncrement);
    let newUtxoValue = (
      // todo: change to $DEMU
      reqtDetails.utxo.value.add(makeValue(newDepositIncrement))
    );
    let updates = {};
    console.log("\u{1F3D2} updating reqt vault... ");
    const tcx3 = tcx2.addOutput(
      makeTxOutput(
        this.capo.address,
        newUtxoValue,
        this.mkDgDatum(
          {
            ...reqtDetails.datum,
            ...updates
          }
          /* !!!!!!! */
        )
      )
    );
    return tcx3;
  }
  requirements() {
    return hasReqts({
      "stores requirements connected to any target object": {
        purpose: "to create clear expectations, applicable in a variety of contexts",
        details: [
          "each requirement is a unique object, with a unique identifier",
          "a set of requirements comprises all the core expectations of a target object",
          "the target object must be a valid object in the system",
          "the set of requirements created for any object is captured by cryptographic proof",
          "the lifecycle of a requirement is shared between its internal state and the object referencing it",
          "a requirement can be suggested, iterated and adopted, and is intended to be immutable once adopted",
          "further iteration after a requirement achieving 'adopted' status should be captured in a new requirement",
          "a requirement can be retired, with its history preserved",
          "different target objects can subscribe to a requirement, indicating a mutual expectation"
        ],
        mech: [
          "each requirement is a unique object, with a unique identifier"
        ],
        requires: [
          // "a person can create a requirement on a target object having a reqts relationship",
          // "the target object is consulted during requirement creation",
          // "the target object can verify the reqt relationship using code provided by the reqts module",
          // "the target object can provide additional validation related to the requirement",
          "the target object can gradually adopt further requirements as needed"
        ]
      },
      "the target object can gradually adopt further requirements as needed": {
        purpose: "honoring the lifecycle of the target object",
        details: [
          "every target object supporting requirements gets a data structure for organizing its requirements workflow",
          "the requirements workflow centers on transactional iteration and consensual adoption",
          "the target's reqts structure contains all the details needed for the lifecycle to work"
        ],
        mech: [
          "the target object has a reqts structure",
          "the reqts structure contains a current-reqts list, and a hash of that list",
          "the reqts structure contains a next-reqts list, and a hash of that list",
          "each next-reqts list can have a 'replaces' entry and/or a 'new' entry",
          "a 'replaces' entry with no 'new' entry indicates a requirement that is being retired",
          "a 'new' entry with no 'replaces' entry indicates a new requirement",
          "a 'replaces' entry with a 'new' entry indicates a requirement that is being replaced",
          "adopting the next-reqts list updates the current-reqts list",
          "adopting the next-reqts list requires that all the new requirements are finalized"
        ],
        requires: []
      }
    });
  }
}
__decorateClass([
  Activity.redeemer
], ReqtsController.prototype, "activityCreatingReqt", 1);
__decorateClass([
  Activity.redeemer
], ReqtsController.prototype, "activityUpdatingReqt", 1);
__decorateClass([
  Activity.redeemer
], ReqtsController.prototype, "activityCreatingRequirement", 1);
__decorateClass([
  partialTxn
], ReqtsController.prototype, "txnUpdateReqt", 1);

class CapoWithoutSettings extends Capo {
  // initSettingsAdapter() {
  //     return new NoSettingsAdapter(this);
  // }
  // scriptBundle() {
  //     return new CapoHeliosBundle();
  // }
  initDelegateRoles() {
    return {
      ...this.basicDelegateRoles(),
      reqts: defineRole("dgDataPolicy", ReqtsController, {})
    };
  }
  async reqtsController() {
    return this.getDgDataController("reqts");
  }
}

class DefaultCapoTestHelper extends CapoTestHelper {
  /**
   * Creates a prepared test helper for a given Capo class, with boilerplate built-in
   *
   * @remarks
   *
   * You may wish to provide an overridden setupActors() method, to arrange actor
   * names that fit your project's user-roles / profiles.
   *
   * You may also wish to add methods that satisfy some of your application's key
   * use-cases in simple predefined ways, so that your automated tests can re-use
   * the logic and syntax instead of repeating them in multiple test-cases.
   *
   * @param s - your Capo subclass
   * @typeParam CAPO - no need to specify it; it's inferred from your parameter
   * @public
   **/
  static forCapoClass(s) {
    class specificCapoHelper extends DefaultCapoTestHelper {
      get stellarClass() {
        return s;
      }
    }
    return specificCapoHelper;
  }
  //xx@ts-expect-error
  get stellarClass() {
    return CapoWithoutSettings;
  }
  //!!! todo: create type-safe ActorMap helper hasActors(), on same pattern as hasRequirements
  async setupActors() {
    this.addActor("tina", 11000n * ADA);
    this.addActor("tracy", 13n * ADA);
    this.addActor("tom", 1200n * ADA);
  }
  setDefaultActor() {
    return this.setActor("tina");
  }
  async mkCharterSpendTx() {
    await this.mintCharterToken();
    const treasury = await this.strella;
    const tcx = this.mkTcx();
    const tcx2 = await treasury.txnAttachScriptOrRefScript(
      await treasury.txnAddGovAuthority(tcx),
      treasury.compiledScript
    );
    return treasury.txnMustUseCharterUtxo(
      tcx2,
      treasury.activityUsingAuthority()
    );
  }
  // accesses the delegate roles, iterates the namedDelegate entries,
  // and uses txnCreateConfiguredDelegate() to trigger compilation of the script for each one
  async checkDelegateScripts(args = {}) {
    const { strella: capo } = this;
    const { delegateRoles } = capo;
    const goodArgs = {
      ...this.mkDefaultCharterArgs(),
      ...args
    };
    let helperTxn = await capo.mkTxnMintCharterToken(
      goodArgs,
      void 0,
      "DRY_RUN"
    );
    console.log("  \u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E} ");
    for (const dgtLabel of Object.keys(delegateRoles)) {
      const dgtSetup = delegateRoles[dgtLabel];
      const { config, delegateClass, delegateType, uutPurpose } = dgtSetup;
      console.log(
        `  -- checking delegate script: ${dgtLabel} (${delegateType})`
      );
      helperTxn = await capo.txnWillMintUuts(
        helperTxn,
        [uutPurpose],
        { usingSeedUtxo: helperTxn.state.seedUtxo },
        {
          // namedDelegate: uutPurpose,
          [dgtLabel]: uutPurpose
        }
      );
      const addr = this.wallet.address;
      await capo.txnCreateOffchainDelegateLink(
        helperTxn,
        dgtLabel,
        {
          // strategyName: delegateName,
          uutName: helperTxn.state.uuts[uutPurpose].name,
          config: {
            // rev: 1n,
            addrHint: [addr]
          }
        }
      );
    }
  }
  mkDefaultCharterArgs() {
    const addr = this.wallet.address;
    console.log("test helper charter -> actor addr", addr.toString());
    return {
      govAuthorityLink: {
        config: {
          //this.capo.stringifyDgtConfig({
          addrHint: [addr]
        }
      },
      mintDelegateLink: {
        config: {}
      },
      spendDelegateLink: {
        config: {}
      },
      mintInvariants: [],
      spendInvariants: [],
      otherNamedDelegates: /* @__PURE__ */ new Map(),
      manifest: /* @__PURE__ */ new Map(),
      rev: 1n
    };
  }
  async mintCharterToken(args, submitOptions = {}) {
    this.actors;
    if (this.state.mintedCharterToken) {
      console.warn(
        "reusing minted charter from existing testing-context"
      );
      return this.state.mintedCharterToken;
    }
    if (!this.strella)
      await this.initialize();
    const capo = await this.strella;
    const goodArgs = {
      ...this.mkDefaultCharterArgs(),
      ...args || {}
    };
    const tcx = await capo.mkTxnMintCharterToken(goodArgs);
    const rawConfig = this.state.rawConfig = this.state.config = tcx.state.bootstrappedConfig;
    this.state.parsedConfig = this.stellarClass.parseConfig(rawConfig);
    expect(capo.network).toBe(this.network);
    await tcx.submit(submitOptions);
    console.log(
      `----- charter token minted at slot ${this.network.currentSlot}`
    );
    this.network.tick(1);
    await tcx.submitAddlTxns({
      onSubmitted: ({ txName, description }) => {
        this.network.tick(1);
        console.log(
          `           ------- submitting addl txn ${txName} at slot ${this.network.currentSlot}:`
        );
      }
    });
    this.state.mintedCharterToken = tcx;
    return tcx;
  }
  async updateCharter(args, submitSettings = {}) {
    await this.mintCharterToken();
    const treasury = await this.strella;
    const { signers } = this.state;
    const tcx = await treasury.mkTxnUpdateCharter(args);
    return tcx.submit({
      signers,
      ...submitSettings
    }).then(() => {
      this.network.tick(1);
      return tcx;
    });
  }
  async bootstrapSettings() {
    const { capo } = this;
    if (!capo.delegateRoles.settings) {
      console.warn(
        ` \u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E} ${capo.constructor.name} has no settings policy`
      );
    } else {
      const mkSetPolTxn = await capo.mkTxnInstallingPolicyDelegate(
        "settings",
        "set"
      );
      const commitChanges = () => {
        return capo.mkTxnCommittingPendingChanges();
      };
      mkSetPolTxn.includeAddlTxn(`commitSettings`, {
        description: `commits settingsPolicy`,
        moreInfo: "makes the on-chain Settings policy active",
        optional: false,
        tcx: commitChanges
      });
      mkSetPolTxn.includeAddlTxn(`createSettingsRecord`, {
        description: `creates the initial settings record`,
        moreInfo: "needed to  configure other contract scripts",
        optional: false,
        tcx: async () => {
          const settingsController = await capo.getDgDataController(
            "settings"
          );
          let initialSettings = settingsController.exampleData();
          if (settingsController && !settingsController.initialSettingsData) {
            console.warn(
              "Note: the Settings controller has no `async initialSettingsData()` method defined; using exampleData().\n  Add this method to the settings policy if needed for deployment of the initial settings record.\n  To suppress this warning, add `initiaiSettingsData() { return this.exampleData() }` to the settings policy."
            );
          } else {
            initialSettings = await settingsController.initialSettingsData();
          }
          if (!initialSettings) {
            throw new Error(
              "the settings policy must implement exampleData() and/or async initialSettingsData() and return a valid settings record"
            );
          }
          return settingsController.mkTxnCreateRecord({
            activity: settingsController.activity.MintingActivities.$seeded$CreatingRecord,
            data: initialSettings
          });
        }
      });
      mkSetPolTxn.includeAddlTxn(`addCurrentSettings`, {
        description: `adds the current settings record to the Capo manifest`,
        moreInfo: "provides settings to all the Capo scripts",
        optional: false,
        tcx: async () => {
          await capo.getDgDataController(
            "settings"
          );
          const settingsUtxo = (await capo.findDelegatedDataUtxos({
            type: "settings"
          }))[0];
          if (!settingsUtxo) {
            throw new Error("can't find settings record");
          }
          const initialSettings = settingsUtxo.data;
          if (!initialSettings) {
            throw new Error(
              "can't extract initial settings record data"
            );
          }
          console.log(
            "\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E} hurray  \u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}\u{1F41E}"
          );
          console.log({ initialSettings });
          return capo.mkTxnAddManifestEntry(
            "currentSettings",
            settingsUtxo,
            {
              tokenName: initialSettings.id,
              entryType: { NamedTokenRef: {} },
              mph: void 0
            }
          );
        }
      });
      return mkSetPolTxn.submitAll();
    }
  }
  // async updateSettings(
  //     args: DetectSettingsType<CAPO>,
  //     submitSettings: SubmitOptions = {}
  // ) {
  //     await this.mintCharterToken();
  //     const capo = this.strella!;
  //     const tcx = await capo.mkTxnUpdateOnchainSettings(args);
  //     return tcx.submit(submitSettings).then(() => {
  //         this.network.tick(1);
  //         return tcx;
  //     });
  // }
}

const insufficientInputError = /(need .* lovelace, but only have|transaction doesn't have enough inputs)/;
Error.stackTraceLimit = 100;

export { ADA, CapoTestHelper, DefaultCapoTestHelper, StellarNetworkEmulator, StellarTestHelper, addTestContext, insufficientInputError };
//# sourceMappingURL=testing-node.mjs.map
